[
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/python-api-concepts/",
	"title": "ArcGIS API for Python のコンセプト",
	"tags": [],
	"description": "ArcGIS API for Python のプロダクト コンセプトと動作要件について紹介します。",
	"content": "ArcGIS API for Python のコンセプト ArcGIS API for Python (以下、Python API) は、Web GIS (ArcGIS Online / ArcGIS Enterprise) を活用してマップと地理空間データを扱うための Python ベースの API です。\nPython のベスト プラクティスに基づき、標準的なイディオムやデータ構造を用いた、シンプルで使いやすい設計になっており、GIS データの可視化や解析の実行だけでなく、ユーザー、グループ、アイテムなどを管理するためのシンプルで使いやすいツールを提供します。 さらに、自身が所有しているデータだけでなく、Esri 等が提供するすぐに使えるマップやデータにアクセスすることも可能です。 また、Pandas や Jupyter Notebook といった、他の Python 向けのライブラリやツールとの連携で、より豊富な機能を活用することが可能です。\n\r Python API のアーキテクチャ Python API は、Web GIS プラットフォームを使用する目的で実装されています。 Python API には、ArcGIS プラットフォーム上で利用するデータやユーザの認証情報など、各オブジェクトを管理して作業するためのモジュール、クラス、関数、およびタイプがあります。\nPython API は arcgis パッケージとして配布されています。 このパッケージの中には、最も基本になる gis モジュールを中心に、Web GIS で使用できる機能がさまざまなモジュールとして編成されています。\nPython API のモジュールを表したダイアグラム\n\rgis モジュールは最も重要なモジュールで、Web GIS への入口となり、ユーザー、グループ、およびコンテンツを管理 (作成、読み込み、更新、削除) する機能を提供します。Web GIS の管理者権限をもつユーザーは、自身の組織のメンバー、グループなどの管理にこのモジュールを使用します。\n紫色のモジュールは、さまざまな空間解析に用いる地理情報データセットにアクセスするために使用します。これらのモジュールには、特定のタイプの空間データを操作するための関数、ジオプロセシング処理、ArcGIS で使用できる様々なデータに対応したクラス、およびそれらを補助するようなヘルパー クラスなどが含まれています。\n青色のモジュールは、GIS のワークフローをサポートする追加的な機能を提供します。住所から緯度経度を特定する geocoding モジュール、フィーチャのジオメトリを表す geometry モジュール、そしてサード パーティーのジオプロセシング ツールをインポートして使用するための geoprocessing モジュール等が含まれています。\nオレンジ色のモジュールは、GIS データの分析結果を可視化して共有することを可能にします。 map モジュールには、Jupyter Notebook でマップとレイヤーを可視化する機能を実装しています。 apps モジュールは ArcGIS で構築された Web アプリケーションの作成と管理に役立ちます。\n各モジュールの詳しい内容は、米国Esri ガイドページ (英語)をご覧ください。\n 動作要件 Python API は次の環境と動作要件が必要です。\n  オペレーティング システム\n Windows (64 ビット) /macOS/ Linux    Python バージョン 3.10.x - 3.12.x\n  開発環境\n Jupyter Notebook※ Jpyter Lab※ 他、Python 開発環境/テキスト エディター    ※ Jupyter Notebook および Jupyter Lab はオープンソースとして利用できる開発環境のひとつです。 Python API はこれらの開発ツールでの地図出力をサポートしてます。利用可能なブラウザは次の通りですが、詳細については Jupyter Notebook のシステム要件をご覧ください。\n Google Chrome FireFox Safari  サポートする最新の動作環境につきましては System requirements または、動作環境もご参照ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-js/",
	"title": "ArcGIS Maps SDK for JavaScript",
	"tags": [],
	"description": "ArcGIS Maps SDK for JavaScript を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。",
	"content": "マップを表示する このチュートリアルでは ArcGIS Maps SDK for JavaScript を使用して、マップとベースマップ レイヤーを表示する方法を紹介します。\nマップには、地理データのレイヤーが含まれています。マップには、ベースマップ レイヤーと、オプションで1つ以上のデータレイヤーを追加できます。マップビューを使用し、場所とズームレベルを設定することで、マップの特定の領域を表示できます。\nこのチュートリアルでは、地形ベースマップレイヤーを使用して、富士山付近を表示する地図を作成します。\n前提条件 このチュートリアルを実施するには、以下が必要です。\n API キーにアクセスするための ArcGIS 開発者アカウント  アカウントをお持ちでない場合は、サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。    ステップ 新しい Pen の作成 CodePen にアクセスして、マッピングアプリケーション用の新しい Pen を作成します。\nHTML の作成 HTML ページを定義して、Web ブラウザのウィンドウの幅と高さをフル利用してマップを作成します。\n  CodePen ＞ HTML で、HTML と CSS を追加し、viewDiv 要素を持つページを作成します。viewDiv は地図を表示する要素で、その CSS はブラウザの設定をリセットして、ブラウザの幅と高さをフルに利用できるようにしています。\nCodePenでは、\u0026lt;!DOCTYPE html\u0026gt; タグは必要ありません。他のエディタを使用している場合や、ローカルサーバでページを実行している場合は、必ずこのタグを HTML ページの先頭に追加してください。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;ArcGIS Maps SDK for JavaScript Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   API の参照   \u0026lt;head\u0026gt; タグ内に、CSS ファイルと JS ライブラリへの参照を追加します。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;ArcGIS Maps SDK for JavaScript Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;!-- CSS ファイルと JS ライブラリへの参照を追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.29/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.29/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   モジュールの追加 ArcGIS JS API には AMD モジュールが含まれています。require ステートメントで Map モジュールと MapView モジュールを参照します。\n  \u0026lt;head\u0026gt; タグ内に、\u0026lt;script\u0026gt; タグと AMD の require ステートメントを追加して、Map モジュールと MapView モジュールを読み込みます。\nJavaScript のコードを HTML パネルではなく、CodePen ＞ JS パネルに追加することもできます。その場合は、\u0026lt;script\u0026gt; タグを削除してください。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;ArcGIS Maps SDK for JavaScript Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;!-- CSS ファイルと JS ライブラリへの参照を追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.29/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.29/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;!-- モジュールの追加 --\u0026gt; \u0026lt;script\u0026gt; require([\u0026#34;esri/config\u0026#34;,\u0026#34;esri/Map\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;], function (esriConfig,Map, MapView) { }); \u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   API キーの取得 ロケーション サービスにアクセスするには、API キーが必要です。 API キーの作成手順については「API キーの取得」を参照してください。\n ダッシュボードにアクセスして、Developer credentials から API キーを取得します。 次のステップで使用しますので、API キーをコピーしてください。  マップの作成 Map を使ってベースマップレイヤーを設定し、API キーを適用します。\n  CodePen に戻ります。\n  require 文の中で、新しい Map を作成し、basemap プロパティに arcgis/topographic を参照するベースマップ スタイルの情報を設定します。ベースマップ スタイル サービスへのアクセスを可能にするために、Map の apiKey() プロパティを設定します。\n  マップには、データ レイヤとベースマップ レイヤがあります。ベースマップ スタイル サービスからベースマップ レイヤーにアクセスするためには、API キーが必要です。キーは、Map の作成時に前のステップから設定できます。\n  マップおよびマップ ビューが Map（2D）でどのように機能するかについては、マッピングとロケーションサービス を参照してください。\n  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;ArcGIS Maps SDK for JavaScript Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;!-- CSS ファイルと JS ライブラリへの参照を追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.29/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.29/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;!-- モジュールの追加 --\u0026gt; \u0026lt;script\u0026gt; require([\u0026#34;esri/config\u0026#34;,\u0026#34;esri/Map\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;], function (esriConfig,Map, MapView) { // API キーの追加  esriConfig.apiKey = \u0026#34;YOUR-API-KEY\u0026#34;; // マップの作成  const map = new Map({ basemap:{ style:{ id:\u0026#34;arcgis/topographic\u0026#34;, // 地形図ベースマップ レイヤー  language:\u0026#34;ja\u0026#34; } } }); }); \u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   マップ ビューの作成 MapView クラスを使って、表示する地図の位置を設定します。\n  MapView を作成し、map プロパティを設定します。マップビューを中央に表示するために、center プロパティを 138.727363, 35.360626 に、zoom プロパティを 13 に設定します。マップの内容を表示するために、container のプロパティを viewDiv に設定します。\n  MapView は、地図の内容を表示します。center と zoom のプロパティは、ロード時にマップの位置と表示されるズームレベルを決定する。\n  zoom プロパティは、マップのズームレベルを設定します。値の範囲は通常 0〜20 で、0 が地表から最も遠く、20 が最も近くなります。ベースマップ レイヤーの中には、さらに 23 までのズーム・レベルをサポートするものもあります。\n  MapView は、クリックやダブルクリックなどのいくつかのタッチイベントもサポートしています。これらのイベントを利用して、マップの位置を変更したり、レイヤー内のフィーチャーを探したりすることができます。\n  Maps（2D）でのマップとマップビューの仕組みについては、マッピングとロケーションサービス のガイドを参照してください。\n  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;ArcGIS Maps SDK for JavaScript Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;!-- CSS ファイルと JS ライブラリへの参照を追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.29/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.29/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;!-- モジュールの追加 --\u0026gt; \u0026lt;script\u0026gt; require([\u0026#34;esri/config\u0026#34;,\u0026#34;esri/Map\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;], function (esriConfig, Map, MapView) { // API キーの追加  esriConfig.apiKey = \u0026#34;YOUR-API-KEY\u0026#34;; // マップの作成  const map = new Map({ basemap:{ style:{ id:\u0026#34;arcgis/topographic\u0026#34;, // 地形図ベースマップ レイヤー  language:\u0026#34;ja\u0026#34; } } }); // マップ ビューの作成  const view = new MapView({ map: map, center: [138.727363, 35.360626], // 経度、緯度  zoom: 13, // ズーム レベル  container: \u0026#34;viewDiv\u0026#34; // MapView を表示する HTML 上の Div 要素の ID  }); }); \u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   アプリを実行する CodePen で、作成したコードを実行して地図を表示します。\nマップには、富士山を中心とした地形ベースマップレイヤーが表示されます。\nWeb マップを表示する 「Web マップの作成」のガイドで Web マップを作成している場合は、作成した Web マップも基本的に同じステップで表示できます。\n  require ステートメントにて、WebMap モジュールを追加で読み込みます。\n\u0026lt;!-- モジュールの追加 --\u0026gt; \u0026lt;script\u0026gt; require([\u0026#34;esri/config\u0026#34;,\u0026#34;esri/Map\u0026#34;, \u0026#34;esri/WebMap\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;], function (esriConfig, Map, WebMap, MapView) { // .....  }); \u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt;   Map オブジェクトを下記のように書き換えます。\n// Web マップの参照  const map = new WebMap({ portalItem: { id: \u0026#34;\u0026lt;Web マップ ID\u0026gt;\u0026#34; //id: \u0026#34;d3ffea931f4a455f9c3b6c2102e66eda\u0026#34;  } });   Web マップに置き換えた全体のコードは下記の通りです。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;ArcGIS Maps SDK for JavaScript Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;!-- CSS ファイルと JS ライブラリへの参照を追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.29/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.29/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!--追加終了 --\u0026gt; \u0026lt;!-- モジュールの追加 --\u0026gt; \u0026lt;script\u0026gt; require([\u0026#34;esri/config\u0026#34;, \u0026#34;esri/Map\u0026#34;, \u0026#34;esri/WebMap\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;], function (esriConfig, Map, WebMap, MapView) { // API キーの追加  esriConfig.apiKey = \u0026#34;YOUR-API-KEY\u0026#34;; // マップの作成  /* const map = new Map({ basemap:{ style:{ id:\u0026#34;arcgis/topographic\u0026#34;, // 地形図ベースマップ レイヤー language:\u0026#34;ja\u0026#34; } } }); */ // Web マップの参照  const map = new WebMap({ portalItem: { id: \u0026#34;\u0026lt;Web マップ ID\u0026gt;\u0026#34; //id: \u0026#34;d3ffea931f4a455f9c3b6c2102e66eda\u0026#34;  } }); // マップ ビューの作成  const view = new MapView({ map: map, center: [138.727363, 35.360626], // 経度、緯度  zoom: 13, // ズーム レベル  container: \u0026#34;viewDiv\u0026#34; // MapView を表示する HTML 上の Div 要素の ID  }); }); \u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;    アプリの動作が確認できたら ArcGIS の セキュリティと認証について学びましょう！\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/",
	"title": "ArcGIS Maps SDK for JavaScript",
	"tags": [],
	"description": "ArcGIS Maps SDK for JavaScript の開発に役立つガイド集です。",
	"content": "ArcGIS Maps SDK for JavaScript の開発に役立つガイド集です。\n 開発の手順\nArcGIS Maps SDK for JavaScript の開発におけるインストールとセットアップからの手順について紹介します。\n\r インストール ガイド\nArcGIS Maps SDK for JavaScript ライブラリのインストール方法を紹介します。\n\r コンポーネント\nArcGIS Maps SDK for JavaScript コンポーネントについて紹介します。\n\r カスタム フォント\n独自のフォントを使用する手順を紹介します。\n\r マップ コンポーネントへの移行ガイド\nマップ コンポーネントへの移行ついて紹介します。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/learn/github/",
	"title": "Esri Japan GitHub",
	"tags": [],
	"description": "Esri Japan GitHub",
	"content": "各 API や SDK のサンプルプログラムに加えて、ハンズオンや開発者セミナーで実施内容を GitHub で共有しています。\nワークショップ  workshops  過去のウェビナーやセミナー、ハンズオンで使用した資料をまとめています。    ArcGIS Maps SDK for JavaScript   maps-app-javascript\n このリポジトリでは、ArcGIS API for JavaScript にて構築された地図アプリをすぐに使用できる Maps App というアプリを提供します。 Maps App をそのまま使うことや、ArcGIS API for JavaScript を使用して拡張することができます。    arcgis-samples-4.0-js\n ArcGIS API 4.x for JavaScript のサンプル集です。Esri Community などで紹介したサンプルなどもございます。    arcgis-samples-js\n ArcGIS API for JavaScript のサンプル集です。    webmap-startup-template-js\n Web マップを使用した開発手法を伝えるためのアプリケーション テンプレートのサンプルです。    ArcGIS Maps SDKs for Native Apps   startup-sample-dotnet\n .NET SDK をはじめて使用される方に、開発キットの基本的な使い方や主要な機能を紹介するためのサンプル アプリケーションです。    enc-viewer-dotnet\n ENC (Electronic Navigational Charts: 航海用電子海図) を表示するビューアーです。    arcgis-samples-flutter\n Flutter SDK を使用した、マーカー表示、現在地表示、住所検索、オフラインマップ等のサンプル集です。    nearby-android\n Android SDK で構築された Android デバイス用の Nearby Places というサンプル アプリを提供しています。そのまま使用したり、多少のカスタマイズで、表示する場所の種類を変更することができます。    ArcPy   arcgis-samples-py\n ArcPy サイト パッケージのサンプル集です。ArcMap 用と ArcGIS Pro 用のサンプルがあります。個々のサンプル リポジトリに tbx ファイルがある場合は、ArcMap や ArcGIS Pro でジオプロセシング ツールとしてそのまま利用することが可能です。    ejpyconv-py\n EJPyConv ツールは ArcPy で書かれた ArcGIS Pro 用の複数の便利なツールが含まれている「サンプル ジオプロセシング ツールボックス」です。 ArcGIS Pro へツールボックスを追加することで、各種ジオプロセシング ツールとして利用が可能です。    arcpy-resources\n ArcGIS ユーザーのための Python/ArcPy を用いた基礎的な学習用の資料を公開しています。    gcf2018-arcpy-demo\n これは第14回 GISコミュニティフォーラムのプレフォーラム・セミナー「Python で始める自動化処理」で行ったデモのソースコードです。    gdb-archived-data-copy\n 履歴管理が有効なフィーチャクラスの過去の一時点の状態を、シェープファイルとして出力します。    gcf2015sde-demo\n これは第11回 GISコミュニティフォーラムのプレフォーラム・セミナー「Python でエンタープライズ ジオデータベースを管理しよう！」で行ったデモのソースコードです。    ArcGIS API for Python   arcgis-samples-python-api\n ArcGIS API for Python のサンプル集です。    arcgis-python-api\n Esri が提供している ArcGIS API for Python リポジトリをフォークし、Esri Community で投稿した記事と、guide 下にある一部のノートブックをローカライズしたものを置いてあります。    ArcGIS Pro SDK   arcgis-samples-pro-sdk\n ArcGIS Pro SDK for .NET のサンプル集です。    arcgis-pro-sdk\n ArcGIS Pro SDK for .NET で ArcGIS Pro を拡張します。ArcGIS Pro SDK for .NET は、アドインおよび構成の拡張性パターンに基づいています。タスク非同期プログラミング（TAP）、LINQ、WPF バインディング、MVVM などの最新の .NET 機能およびパターンを活用し、Pro の新しい API を使用して統合された 2D/3D アドインを記述します。    arcgis-pro-sdk-community-samples\n このリポジトリには、ArcGIS Pro 2.7 SDK for Microsoft .NET Framework 用の ArcGIS Pro Add-In Samples が含まれています。    arcgis-pro-sdk-tools\n ArcGIS Pro SDK を使用したツールを公開しています。ArcGIS Pro SDK の様々な API を使用しているので、開発時の参考リソースとしてもご使用ください。    ArcObjects  maps-app-gislight  Maps App GISLight10 は、ArcObjects SDK for .NETとWindows フォームを使用した、スタンドアロン アプリケーションの実装およびセットアップのサンプルを提供しています。    ArcGIS 全般  arcgis-install-batch  ダウンロード形式で提供されている製品本体（exe）を解凍し、フォルダ階層にパッチファイルを含めて再整理後、大量のPCに一括でインストールを行うためのバッチファイルのサンプル、およびインストールしたものをアンインストールを行うためのバッチファイルのサンプルです。    その他   3D-CityModel-ConversionTools-for-ArcGIS\n 「3D 都市モデルデータ変換ツール for ArcGIS」 は、PLATEAU で整備し、G 空間情報センターで公開している 3D 都市モデル（CityGML）のデータを、ArcGIS で利用可能なファイル ジオデータベース へ変換するツールです。    gsi-wmts\n 地理院地図の layers.txt に含まれるレイヤーのうち、WMTS で配信可能なレイヤーのみを取得したメタデータです。「地理院タイル目録」より情報が取得可能なレイヤーには範囲を指定するエクステント情報を付加しています。    developer-support\n ここは、Esri の開発者ライブラリを使用している GIS 開発者を共同でサポートする場所です。    i3s-spec\n この GitHub リポジトリでは、シーンレイヤーの仕様を公開しています。    arcgis-enterprise-sdk-resources\n このリポジトリでは、10.8.1 ArcGIS Enterprise SDK で構築されたサーバ オブジェクト エクステンション（SOE）およびサーバ オブジェクト インターセプター（SOI）のサンプルおよびコード スニペットを提供しています。    arcgis-saml-samples\n ArcGIS Online / ArcGIS Enterprise は、エンタープライズ ログインのアカウント構成に SAML (Security Assertion Markup Language) 2.0 をサポートしています。SAML は、認証サーバーである ID プロバイダーとサービスを提供するアプリケーションであるサービス プロバイダーとの間で認証/認可データを安全に交換するためのオープン規格です。    sdgs-sample\n Esri が提供する SDGs に関連する以下のプロジェクトを日本語にし、集約しました。    tokyochallenge\n リアルタイム列車遅延マップは第1回 東京公共交通オープンデータチャレンジ向けに開発した Web アプリです。このリポジトリでは、開発したソース コードおよび設定用の必要なデータを公開しています。    gcf2018-geoevent-twitter\n GISコミュニティフォーラム2018年 GeoEvent デモ用    gcf2018-webappbuilder-demo\n 本リポジトリでは、第14回 GISコミュニティフォーラムのプレフォーラム・セミナー「プログラミングゼロ！ ～Web GIS アプリ 3 分メイキング～ 」で紹介したアプリの作成手順を公開しています。    data-visualization-lab\n ArcGIS のオープンなプラットフォームを基盤とした様々なデータ ビジュアライゼーションとそれを支えるオープンなテクノロジーを紹介します。    resas2arcgis\n このサービスは RESAS API から取得できるデータを ArcGIS へ簡単に入力できるようにした開発したサービスです。    photospot-finder\n 室蘭市の2016年11月14日に開催された企業・団体対抗 観光ハッカソン向けに作成したアプリです。    esri-leaflet-tips\n Esri Leaflet のサンプルです。    arcgis-d3-components\n ArcGIS API for JavaScript で作成した地図との連携のための D3 コンポーネントです。    flightsim-game-controller-js\n Web Socket を利用した双方向通信によりマルチユーザー プレイを実現したフライト シミュレーター ゲームの操作アプリです。 全機の位置とスコア ランキングを管理するモニター用のネイティブ アプリと連携します。    data-visualization-js\n ArcGIS API for JavaScript を用いてデータ ビジュアライゼーションの手法とそれを実現する機能について紹介していく「JavaScript で始めるデータ ビジュアライゼーション」シリーズにおいて使用しているサンプル コード集です。    esri-react-components-js\n ArcGIS API for JavaScript の Web アプリ開発に利用可能なモジュールとして React で実装したコンポーネントを集約します。    esrijapan.github.io\n ESRIジャパンあるいは Esri が公開しているオープンソース プロジェクトのランディング ページです。    contributing\n ESRIジャパン GitHub アカウントにおけるオープンソースへの貢献について    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/calcite-design-system/get-started/",
	"title": "はじめに",
	"tags": [],
	"description": "次の手順に従って、すぐに Calcite コンポーネントを使い始めることができます。",
	"content": "出典：Calcite Design System - Get Started\nはじめに Calcite コンポーネントは、Web アプリケーションを構築するための、柔軟でフレームワークに依存しない Web コンポーネントの豊富なライブラリです。Web コンセプトのページ では、Calcite Design System の構成要素について説明しています。\n例題、プロパティ、スロット、スタイル、イベント、モードなどの API リファレンスについては、コンポーネント ドキュメントをご覧ください。以下の手順で、Calcite コンポーネントを使い始めることができます。\nまず、Calcite コンポーネントを使用するには、ArcGIS アカウントが必要です。アカウントをお持ちでない場合は、無料で作成することができます。\n作成方法は、開発者アカウントの作成をご覧ください。\n次に、CDN（Content Delivery Network）または NPM（Node Package Manager）ライブラリを使用して、Calcite コンポーネントを読み込みます。\nCDN で利用する Calcite コンポーネントをロードする最も一般的な方法は、ArcGIS CDN にホストされているバージョンを使用することです。コンポーネントは、HTML ドキュメントの head セクションに \u0026lt;script\u0026gt; タグを配置することでロードできます:\n\u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;https://js.arcgis.com/calcite-components/3.2.1/calcite.esm.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; これらのタグを追加すると、他の HTML 要素と同様にコンポーネントを使用することができます。アプリケーションで使用されるコンポーネントのみが読み込まれます。\nNPM パッケージで利用する Calcite コンポーネントは、NPM パッケージとしても提供されています。使い始めるには、まずパッケージをインストールし、以下のステップに従います。また、様々なフレームワークやビルドツールを使用したサンプルはこちらでご覧いただけます。\nnpm install @esri/calcite-components アセットの読み込み 一部のコンポーネント（例：calcite-icon、calcite-date-picker）は静的リソースに依存しています。デフォルトでは、リソースは CDN から自動的に配信されるため、ほとんどのケースで手動でのパス設定が不要になります。\nローカルにアセットをホストしたい場合やオフライン環境をサポートする必要がある場合は、アセットをプロジェクトのディレクトリにコピーできます。互換性を維持するため、ローカルのアセットは「assets」という名前のディレクトリに配置してください。\n例えば、次のコマンドを使用してアセットをコピーできます。\ncp -r node_modules/@esri/calcite-components/dist/calcite/assets/* ./public/assets/ アセットが用意できたら、アプリケーション内でアセットのパスを設定してください\nimport { setAssetPath } from \u0026#34;@esri/calcite-components\u0026#34;; setAssetPath(\u0026#34;/path-to-your-assets/\u0026#34;); スタイルのインポート 最後に、カスケーディング スタイル シート（CSS）を読み込みます。これもフレームワークやビルド ツールに依存しますが、多くの場合、JavaScript で直接読み込むことができます。\nimport \u0026#34;@esri/calcite-components/dist/calcite/calcite.css\u0026#34;; ビルドの選択 Calcite Components は、異なる用途に対応するため、2 つのビルドを提供しています\nカスタム要素 カスタム要素 は、フロントエンド フレームワークを利用する場合に推奨されるビルドです。 必要に応じて個々のコンポーネントをインポートできます。 アセットをローカルでホストする場合またはカスタム CDN を使用する場合のみ、アセットのパスを設定する必要があります。\nimport { setAssetPath } from \u0026#34;@esri/calcite-components/dist/components\u0026#34;; setAssetPath(\u0026#34;/path-to-your-assets/\u0026#34;); 次に、必要なコンポーネントをインポートします。これにより、カスタム要素が自動的に定義されます。\nimport \u0026#34;@esri/calcite-components/components/calcite-button\u0026#34;; import \u0026#34;@esri/calcite-components/components/calcite-icon\u0026#34;; import \u0026#34;@esri/calcite-components/components/calcite-slider\u0026#34;; ディストリビューション ディストリビューション ビルドでは、グローバル ウィンドウ オブジェクトにカスタム要素を定義する必要があります。カスタム要素 ビルドと同様に、ローカルまたは CDN ホストされたアセットを使用するかを選択できます。\nimport { defineCustomElements } from \u0026#34;@esri/calcite-components/loader\u0026#34;; // CDN hosted assets (default) defineCustomElements(); // Or, for local assets: // defineCustomElements({ resourcesUrl: \u0026#34;/path-to-your-assets/\u0026#34; }); このアプローチでは、個々のコンポーネントをインポートする必要はありません。すべてのコンポーネントはグローバルに登録されているためです。\nTypeScript の設定 TypeScript の設定方法については、 TypeScript section of the Framework integration を参照してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/android/install-android-200.x/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for Kotlin のインストールとセットアップ手順を紹介します。",
	"content": "出典：ArcGIS Maps SDK for Kotlin - Guide - Install and set up\nこのインストール ガイドでは、ArcGIS Maps SDK for Kotlin (バージョン 200.x) のインストールとセットアップ手順を紹介します。マップを表示する方法については「アプリの作成」のチュートリアルをご覧ください。\nArcGIS Maps SDK for Kotlin をインストールする前に、開発マシンがシステム要件を満たしていることを確認してください。アプリを実行するすべてのターゲット デバイスには、Android API レベルの最小バージョンが必要です。詳細については、システム要件を参照してください。\nGradle を使用してインストールすることをお勧めします。これにより、Esri の Maven リポジトリーから必要な依存関係と SDK バイナリーがインストールされます。\nGradle で API を取得する Android Studio で [New Project] ウィザードを実行する際、[Phone and Tablet]、[Empty Activity] の順に選択します。Empty Activity オプションは Compose 対応アプリを作成するために必要な Android からの Jetpack Compose 依存関係を提供します。\n\rAndroid Studio の [New Project] ウィザードで作成したプロジェクトで、次のセットアップ手順を実行します。\n  プロジェクト ツール ウィンドウで、ドロップダウン メニューから [Android ビュー]を選択します。[Gradle Scripts] \u0026gt; [build.gradle.kts (Project: Display_a_map)] を開きます。ファイルの内容を以下のコードに置き換えます。\nbuild.gradle.kts (Project: Display_a_map)\n// すべてのサブプロジェクト/モジュールに共通の構成オプションを追加できる最上位のビルド ファイル plugins { alias(libs.plugins.android.application) apply false alias(libs.plugins.kotlin.android) apply false alias(libs.plugins.kotlin.compose) apply false }   Android ビューから、[Gradle Scripts] \u0026gt; [build.gradle.kts (Module: app)] を開きます。ファイルの内容を次のコードに置き換えます。\nbuild.gradle.kts (Module: app)\nplugins { alias(libs.plugins.android.application) alias(libs.plugins.kotlin.android) alias(libs.plugins.kotlin.compose) } android { namespace = \u0026#34;com.example.app\u0026#34; compileSdk = libs.versions.compileSdk.get().toInt() defaultConfig { applicationId = \u0026#34;com.example.app\u0026#34; minSdk = libs.versions.minSdk.get().toInt() targetSdk = libs.versions.targetSdk.get().toInt() versionCode = 1 versionName = \u0026#34;1.0\u0026#34; testInstrumentationRunner = \u0026#34;androidx.test.runner.AndroidJUnitRunner\u0026#34; vectorDrawables { useSupportLibrary = true } } buildTypes { release { isMinifyEnabled = false proguardFiles(getDefaultProguardFile(\u0026#34;proguard-android-optimize.txt\u0026#34;), \u0026#34;proguard-rules.pro\u0026#34;) } } compileOptions { sourceCompatibility = JavaVersion.VERSION_17 targetCompatibility = JavaVersion.VERSION_17 } kotlinOptions { jvmTarget = \u0026#34;17\u0026#34; } buildFeatures { compose = true } packaging { resources { excludes += \u0026#34;/META-INF/{AL2.0,LGPL2.1}\u0026#34; } } } dependencies { implementation(libs.androidx.core.ktx) implementation(libs.androidx.lifecycle.runtime.ktx) implementation(libs.androidx.activity.compose) implementation(platform(libs.androidx.compose.bom)) implementation(libs.androidx.ui) implementation(libs.androidx.ui.graphics) implementation(libs.androidx.ui.tooling.preview) implementation(libs.androidx.material3) testImplementation(libs.junit) androidTestImplementation(libs.androidx.junit) androidTestImplementation(libs.androidx.espresso.core) androidTestImplementation(platform(libs.androidx.compose.bom)) androidTestImplementation(libs.androidx.ui.test.junit4) debugImplementation(libs.androidx.ui.tooling) debugImplementation(libs.androidx.ui.test.manifest) // ArcGIS Maps for Kotlin - SDK dependency  implementation(libs.arcgis.maps.kotlin) // Toolkit dependencies  implementation(platform(libs.arcgis.maps.kotlin.toolkit.bom)) implementation(libs.arcgis.maps.kotlin.toolkit.geoview.compose) implementation(libs.arcgis.maps.kotlin.toolkit.authentication) } Kotlin 2.0+ では、Compose Compiler Gradle プラグインが必要です。このプラグインは、build.gradle.kts(Module :app)の plugins ブロックで alias(libs.plugins.kotlin.compose) として参照され、libs.versions.toml ファイルでは kotlin-compose = { id = \u0026quot;org.jetbrains.kotlin.plugin.compose\u0026quot;, version.ref = \u0026quot;kotlin\u0026quot; } として宣言されています。Compose Compiler Gradle プラグインと Kotlin Android プラグインのバージョンは同じです。\n2.0 より前の Kotlin バージョンを使用している場合は、Compose コンパイラーと Kotlin コンパイラーのバージョンが互換性があることを確認する必要があります。詳細については、Compose to Kotlin Compatibility Map を参照してください。\n  Android ビューから、[Gradle Scripts] \u0026gt; [libs.versions.toml] を開きます。[version] セクションで、ArcGIS Maps SDK for Kotlin のバージョン番号を宣言します。また、[libraries] セクションには、以下のライブラリーの宣言を追加します。\n ArcGIS Maps SDK for Kotlin SDK ArcGIS Maps SDK for Kotlin Toolkit BOM アプリで使用するすべてのツールキット コンポーネント。マップビューまたはシーンビューを表示するには、コンポーザブルな MapView とSceneView を含む geoview-compose モジュールの宣言が必要です。ユーザー認証を実装するには、authentication モジュールが必要です。  Toolkit BOM のバージョンは、宣言したすべての Toolkit コンポーネントに適用されます。\nGradle バージョン カタログは依存関係のバージョンを宣言するための標準的な Android のアプローチです。build.gradle.kts でバージョン番号を指定したり、version.gradle でバージョン番号を列挙するよりも推奨されます。Android Studio の最近のリリースでは、[New Project Wizard] がこの標準をサポートする build.gradle.kts と gradle/libs.version.toml ファイルを生成します。\nGradle バージョン カタログでは、BOM ファイルを使用して、BOM 内のすべての成果物に対して単一のバージョン番号を指定することもできます。詳細については、ArcGIS Maps SDK for Kotlin Toolkit の README の Using the BOM を参照してください。\ngradle/libs.versions.toml\n[versions] arcgisMapsKotlin = \u0026#34;200.8.0\u0026#34; [libraries] arcgis-maps-kotlin = { group = \u0026#34;com.esri\u0026#34;, name = \u0026#34;arcgis-maps-kotlin\u0026#34;, version.ref = \u0026#34;arcgisMapsKotlin\u0026#34; } arcgis-maps-kotlin-toolkit-bom = { group = \u0026#34;com.esri\u0026#34;, name = \u0026#34;arcgis-maps-kotlin-toolkit-bom\u0026#34;, version.ref = \u0026#34;arcgisMapsKotlin\u0026#34; } arcgis-maps-kotlin-toolkit-geoview-compose = { group = \u0026#34;com.esri\u0026#34;, name = \u0026#34;arcgis-maps-kotlin-toolkit-geoview-compose\u0026#34; } arcgis-maps-kotlin-toolkit-authentication = { group = \u0026#34;com.esri\u0026#34;, name = \u0026#34;arcgis-maps-kotlin-toolkit-authentication\u0026#34; } libs.versions.toml を手で編集しないでください。代わりに、以下のコードを展開し、展開した内容をすべてコピーして libs.versions.toml ファイルに貼り付け、新規プロジェクト ウィザードで生成された元の内容を置き換えてください。\n[versions] arcgisMapsKotlin = \u0026#34;200.8.0\u0026#34; # Version numbers added by Android Studio New Project Wizard agp = \u0026#34;8.9.2\u0026#34; kotlin = \u0026#34;2.1.20\u0026#34; coreKtx = \u0026#34;1.16.0\u0026#34; junit = \u0026#34;4.13.2\u0026#34; junitVersion = \u0026#34;1.2.1\u0026#34; espressoCore = \u0026#34;3.6.1\u0026#34; lifecycleRuntimeKtx = \u0026#34;2.8.7\u0026#34; activityCompose = \u0026#34;1.10.1\u0026#34; composeBom = \u0026#34;2025.04.00\u0026#34; # Other version numbers compileSdk = \u0026#34;36\u0026#34; minSdk = \u0026#34;28\u0026#34; targetSdk = \u0026#34;36\u0026#34; [libraries] arcgis-maps-kotlin = { group = \u0026#34;com.esri\u0026#34;, name = \u0026#34;arcgis-maps-kotlin\u0026#34;, version.ref = \u0026#34;arcgisMapsKotlin\u0026#34; } arcgis-maps-kotlin-toolkit-bom = { group = \u0026#34;com.esri\u0026#34;, name = \u0026#34;arcgis-maps-kotlin-toolkit-bom\u0026#34;, version.ref = \u0026#34;arcgisMapsKotlin\u0026#34; } arcgis-maps-kotlin-toolkit-geoview-compose = { group = \u0026#34;com.esri\u0026#34;, name = \u0026#34;arcgis-maps-kotlin-toolkit-geoview-compose\u0026#34; } arcgis-maps-kotlin-toolkit-authentication = { group = \u0026#34;com.esri\u0026#34;, name = \u0026#34;arcgis-maps-kotlin-toolkit-authentication\u0026#34; } androidx-core-ktx = { group = \u0026#34;androidx.core\u0026#34;, name = \u0026#34;core-ktx\u0026#34;, version.ref = \u0026#34;coreKtx\u0026#34; } junit = { group = \u0026#34;junit\u0026#34;, name = \u0026#34;junit\u0026#34;, version.ref = \u0026#34;junit\u0026#34; } androidx-junit = { group = \u0026#34;androidx.test.ext\u0026#34;, name = \u0026#34;junit\u0026#34;, version.ref = \u0026#34;junitVersion\u0026#34; } androidx-espresso-core = { group = \u0026#34;androidx.test.espresso\u0026#34;, name = \u0026#34;espresso-core\u0026#34;, version.ref = \u0026#34;espressoCore\u0026#34; } androidx-lifecycle-runtime-ktx = { group = \u0026#34;androidx.lifecycle\u0026#34;, name = \u0026#34;lifecycle-runtime-ktx\u0026#34;, version.ref = \u0026#34;lifecycleRuntimeKtx\u0026#34; } androidx-activity-compose = { group = \u0026#34;androidx.activity\u0026#34;, name = \u0026#34;activity-compose\u0026#34;, version.ref = \u0026#34;activityCompose\u0026#34; } androidx-compose-bom = { group = \u0026#34;androidx.compose\u0026#34;, name = \u0026#34;compose-bom\u0026#34;, version.ref = \u0026#34;composeBom\u0026#34; } androidx-ui = { group = \u0026#34;androidx.compose.ui\u0026#34;, name = \u0026#34;ui\u0026#34; } androidx-ui-graphics = { group = \u0026#34;androidx.compose.ui\u0026#34;, name = \u0026#34;ui-graphics\u0026#34; } androidx-ui-tooling = { group = \u0026#34;androidx.compose.ui\u0026#34;, name = \u0026#34;ui-tooling\u0026#34; } androidx-ui-tooling-preview = { group = \u0026#34;androidx.compose.ui\u0026#34;, name = \u0026#34;ui-tooling-preview\u0026#34; } androidx-ui-test-manifest = { group = \u0026#34;androidx.compose.ui\u0026#34;, name = \u0026#34;ui-test-manifest\u0026#34; } androidx-ui-test-junit4 = { group = \u0026#34;androidx.compose.ui\u0026#34;, name = \u0026#34;ui-test-junit4\u0026#34; } androidx-material3 = { group = \u0026#34;androidx.compose.material3\u0026#34;, name = \u0026#34;material3\u0026#34; } [plugins] android-application = { id = \u0026#34;com.android.application\u0026#34;, version.ref = \u0026#34;agp\u0026#34; } kotlin-android = { id = \u0026#34;org.jetbrains.kotlin.android\u0026#34;, version.ref = \u0026#34;kotlin\u0026#34; } kotlin-compose = { id = \u0026#34;org.jetbrains.kotlin.plugin.compose\u0026#34;, version.ref = \u0026#34;kotlin\u0026#34; } \r  Android ビューから、[Gradle Scripts] \u0026gt; [settings.gradle.kts] を開きます。ファイルの内容を次のコードに置き換えます。\nsettings.gradle.kts (Display a map)\npluginManagement { repositories { google { content { includeGroupByRegex(\u0026#34;com\\\\.android.*\u0026#34;) includeGroupByRegex(\u0026#34;com\\\\.google.*\u0026#34;) includeGroupByRegex(\u0026#34;androidx.*\u0026#34;) } } mavenCentral() gradlePluginPortal() } } dependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { google() mavenCentral() maven { url = uri(\u0026#34;https://esri.jfrog.io/artifactory/arcgis\u0026#34;) } } } rootProject.name = \u0026#34;Display a map\u0026#34; include(\u0026#34;:app\u0026#34;)   必要な権限と機能 Android は、権限が分離されたオペレーティング システムです。アプリで使用する ArcGIS の機能によっては、マニフェストに権限を追加する必要がある場合があります。アプリに含まれていない機能の権限を含めないようにしてください。\nArcGIS Maps SDK for Kotlin の機能に必要な権限 ArcGIS Maps SDK for Kotlinの機能の中には、アプリで使用する際にAndroidの権限が必要なものがあります。\n インターネットへのアクセス。ほとんどのアプリで必要になります。 詳細な位置情報。デバイスの GPS にアクセスするには、詳細な位置情報の権限が必要です。これは Android 開発において危険な権限とされています。  次のコード例（AndroidManifest.xml ファイルの場合）には、これらの権限が含まれています。\nAndroidManifest.xml\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_COARSE_LOCATION\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_FINE_LOCATION\u0026#34; /\u0026gt; Android のストレージと権限 Android API レベル 30 以降、すべてのアプリは Android デバイスのファイル システムにアクセスするためにスコープ付きストレージを使用します。スコープ付きストレージでは、アプリは (1)自身のファイルと (2)メディア ストア内の共有ファイルにアクセスできます。\u0026lt;uses-permission android:name=\u0026quot;android.permission.WRITE_EXTERNAL_STORAGE\u0026quot;/\u0026gt; 権限の宣言はサポートされなくなりました。\nAndroid のストレージは、API レベル 29 以降、劇的に変化しています。Android のストレージとパーミッションの詳細については、次のリンクを参照してください。\n データ ストレージとファイル ストレージの概要 Android ストレージのユース ケースとおすすめの方法 共有ストレージからメディア ファイルにアクセスする ストレージ デバイスのすべてのファイルを管理する  OpenGL ES バージョンの宣言 Android マニフェストに uses-feature 要素を追加すると、Play ストアでアプリを正しいタイプのデバイスで利用できるようになります。\nMapView（2D）を使用するアプリには、最小でも OpenGL ES 2.x が必要です。\n\u0026lt;uses-feature android:glEsVersion=\u0026#34;0x00020000\u0026#34; android:required=\u0026#34;true\u0026#34; /\u0026gt; SceneView（3D）を使用するアプリには、OpenGL ES 3.x が必要です。\n\u0026lt;uses-feature android:glEsVersion=\u0026#34;0x00030000\u0026#34; android:required=\u0026#34;true\u0026#34; /\u0026gt; 追加のダウンロード 開発プロジェクトを強化するために、サンプル コードとデータの追加リソースを利用できます。このガイドを、スタンドアロンの開発者ドキュメントとしてダウンロードすることもできます。\nサンプル コード ドキュメントでサンプルの包括的なリストを参照するか、GitHub リポジトリからサンプル コードをダウンロードしてください。\nまた、Google Play ストアからサンプル ビューアー アプリをダウンロードし、お使いのデバイスでライブ サンプルをご覧いただくこともできます。\nArcGIS Maps SDK for Kotlin Toolkit ArcGIS Maps SDK for Kotlin Toolkit には、アプリ開発を簡素化する Compose に対応したコンポーネント (コントロールとユーティリティー) が含まれています。MapView と SceneView のコンポーザブル関数を使用するには、モジュール レベルの build.gradle.kts に次の依存関係を含めます。\nimplementation(platform(\u0026#34;com.esri:arcgis-maps-kotlin-toolkit-bom:200.8.0\u0026#34;)) implementation(\u0026#34;com.esri:arcgis-maps-kotlin-toolkit-geoview-compose\u0026#34;) implementation(\u0026#34;com.esri:arcgis-maps-kotlin-toolkit-authentication\u0026#34;) 明示的なバージョン番号の代わりに、libs.versions.toml を使用している場合は以下のように記述します。\nimplementation(platform(libs.arcgis.maps.kotlin.toolkit.bom)) implementation(libs.arcgis.maps.kotlin.toolkit.geoview.compose) implementation(libs.arcgis.maps.kotlin.toolkit.authentication) build.gradle.kts(Module： app) および libs.versions.toml に含めるべきコードの詳細な指示については、上記の Gradle で API を取得する を参照してください。\nツールキットの主要なモジュールには以下が含まれます。\nGeoView-Compose は、MapView および SceneView クラスのコンポーザブルな実装を提供します。\nAuthentication モジュールは、ArcGIS Maps SDK for Kotlin での認証の課題を解決するためのプラグアンドプレイ ソリューションを提供します。\nToolkit には、Compose に対応した他の特別なコンポーネントも含まれています。詳細は Toolkit を参照してください。\nスタンドアロンの開発者向けドキュメント ダウンロード ページ から、開発者向けドキュメントをアーカイブとしてダウンロードできます。アーカイブには、ローカル Web サーバーからドキュメントを提供する手順が含まれているため、インターネットに接続しなくてもドキュメントにアクセスできます。スタンドアロン ドキュメントには、開発者ガイド、API リファレンス、チュートリアル、およびサンプル ドキュメントが含まれています。このドキュメントは、ローカルのスタンドアロン コンピューターまたは内部ネットワーク上で実行するように設計されており、パブリックなインターネット上では実行できません。\nダウンロードしたドキュメントのアーカイブを解凍するには、無料のオープンソース ファイル アーカイブ ユーティリティー 7-Zip をお勧めします。\n\rローカルでドキュメントを公開する方法。\n 使用する SDK のドキュメントをダウンロードします。ダウンロードしたファイルは、.zip アーカイブ形式になっています。 アーカイブをローカル フォルダーに解凍します。解凍されたアーカイブには、public と install という 2 つのサブフォルダーがあります。 install フォルダー内の README.md ファイルを開き、選択した Web サーバーの指示に従います。  ライブ ドキュメント サイトはリリース時及びリリースの間に定期的に更新されますが、スタンドアロン ドキュメントは静的で、最初のリリース後は更新されません。\n\r追加のデータ 投影エンジン データ 測地系変換は、ある空間基準から別の空間基準へジオメトリーを投影する際に、2つの空間基準の基礎となる測地系に違いがある場合に使用されます。測地系変換は、数学的に定義する（方程式ベースの変換）ことも、外部のサポート ファイルに依存する（グリッド ベースの変換）ことも可能です。アプリでグリッド ベースの変換を使用する場合、投影エンジン ファイルが存在する必要があります。API は、必要なファイルがローカルのファイル システムで利用可能かどうかを検出することができます。投影エンジン ファイルが無い状態で変換をしようとすると、エラーが発生します。API は、必要なファイルがローカル ファイル システムで利用可能かどうかを検出できます。\nグリッド ベースの変換を使用している場合は、ダウンロード ページからサポートする Projection Engine ファイルをダウンロードしてください。座標系、投影法、測地系変換の操作の詳細については、Spatial references のトピックを参照してください。\nElectronic Navigational Charts (ENC) 航海用電子海図（ENC）は、水路や海上の情報を可視化し、分析するためのジオリファレンスされたベクター データセットです。SDK は、国際水路機関（IHO）の S-57 規格 に準拠した ENC をサポートしています。\n航海用電子海図 (ENC) を使用する場合は、ダウンロード ページから hydrography データをダウンロードします。ENC データの操作の詳細については、Display electronic navigational charts のトピックを参照してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/dotnet/install-dotnet-200.x/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for .NET のインストールとセットアップ手順を紹介します。",
	"content": "出典：ArcGIS Maps SDK for .NET - Guide - Install and set up\nこのインストール ガイドでは、ArcGIS Maps SDK for .NET (バージョン 200.x) のインストールとセットアップ手順を紹介します。マップを表示する方法については「アプリの作成」のチュートリアルをご覧ください。\nインストールとセットアップ ArcGIS Maps の機能を .NET アプリケーションに組み込むには、1 つ以上の ArcGIS Maps SDK for .NET NuGet パッケージ への参照を Visual Studio プロジェクト内に追加します。ArcGIS Maps SDK for .NET がサポートするアプリケーション プラットフォームおよび UI フレームワークのそれぞれに対応するプロジェクト テンプレート セットは、Visual Studio 拡張機能 として提供されています。\nプロジェクトでの ArcGIS Maps SDK for .NET の参照 ArcGIS Maps SDK for .NET NuGet パッケージは、NuGet.org でホストされています。NuGet を使用して Visual Studio でパッケージを使用するには、Microsoft のドキュメントにある Visual Studio にパッケージをインストールして使用する (Windows) または Visual Studio にパッケージをインストールして使用する (Mac) を参照してください。\nたとえば、Windows の Visual Studio で ArcGIS Maps SDK for.NET への参照を追加するには、次の手順に従います。\n  [Visual Studio Solution Explorer] ウィンドウで、[Project] を右クリックし、[Manage NuGet Packages] を選択します。\n  [Browse] タブを選択し、パッケージソースとして [nuget.org] を選択します。\n  検索 テキスト ボックスに「Esri」と入力します。ArcGIS Maps SDK for .NET がサポートするさまざまなフレームワークが表示されます。\n  インストールする NuGet パッケージを選択し、[インストール] ボタンをクリックします。NuGet パッケージ マネージャーの詳細については、Microsoft ドキュメントの NuGet パッケージ マネージャーを使用して Visual Studio にパッケージをインストールして管理する を参照してください。\n  [変更のプレビュー] ダイアログで内容を確認し、[OK] を選択してインストールを進めてください。\n  インストールが完了すると、NuGet パッケージ マネージャーの [インストール済み] タブに追加したパッケージが表示され、ArcGIS Maps SDK for .NET を使用して開発できるようになります。\n  Toolkit ArcGIS Maps SDK for .NET Toolkit には、ユーザー インターフェイス（UI）コントロールとコンポーネントが含まれており、すぐに使用したり、アプリ用にカスタマイズしたりできます。Toolkit は、NuGet パッケージとしてプロジェクトに含めることも、GitHub リポジトリからソース コードを入手して自分でビルドすることもできます。\nVisual Studio プロジェクト テンプレートのインストール（オプション） Visual Studio（Windows）用の ArcGIS Maps SDK for .NET プロジェクト テンプレート 拡張機能は、Android、iOS、および Windows 用のアプリケーション プロジェクト テンプレートを提供します。プロジェクト テンプレートは、各プラットフォームに適した NuGet パッケージを参照し、Model-View-ViewModel（MVVM）デザイン パターンを使用します\nWPF、WinUI、.NET MAUI プロジェクト テンプレートには、Visual Studio 17.8 以降が必要です。Visual Studio for Mac はサポートされなくなりました。Windows では Visual Studio からテンプレートを使用して ArcGIS Maps SDK for .NET アプリを作成できます。MacOS では、コマンド ライン インターフェイスからテンプレートを使用してアプリを作成します。\n\r拡張機能のインストール Visual Studio（Windows）用の ArcGIS Maps SDK for .NET プロジェクト テンプレート 拡張機能は、Android、iOS、および Windows 用のアプリケーション プロジェクト テンプレートを提供します。プロジェクト テンプレートは、各プラットフォームに適した NuGet パッケージを参照し、Model-View-ViewModel（MVVM）デザイン パターンを使用します。拡張機能の使用方法の詳細については、Microsoft のドキュメントの Visual Studio の機能拡張を管理する のトピックを参照してください。\n.NET Framework プロジェクト テンプレートなど、すぐに使用できる Visual Studio テンプレートの一部は PackageReference をサポートしていますが、現在、プロジェクトによって参照されるパッケージのリストを維持するために packages.config が既定になっています。packages.config を使用すると、バージョンをアップグレードするときに問題が発生する可能性があります。このような状況を軽減するには、Microsoft の推奨に従って、packages.config から PackageReference に移行 することを検討してください。\n\r  Visual Studio で、[拡張機能] メニュー \u0026gt; [拡張機能の管理] を選択して、[拡張機能の管理] ダイアログを表示します。\n  [検索] テキスト ボックスに、「ArcGIS」と入力します。\n  [ArcGIS Maps SDK for .NET Project Templates] 拡張機能を選択し、[ダウンロード] を選択します。この拡張機能のインストールがスケジュールされて、Visual Studio のすべてのインスタンスが終了した後にインストールされます。\n  [拡張機能の管理] ダイアログを閉じます。\n  Visual Studio を閉じ、拡張機能をインストールします。\n  Visual Studio を閉じた時に表示される [VSIX インストーラー] ダイアログで [変更] をクリックします。\n  インストールが完了したら、インストーラー ダイアログで [閉じる] をクリックします。\n  次回、Visual Studio で [新しいプロジェクトの作成] を選択すると、使用可能なすべてのプラットフォームの ArcGIS のプロジェクト テンプレートが表示されます。\n  ArcGIS Maps SDK App, Packaged (WinUI 3 in Desktop) テンプレートでは、Single-project MSIX Packaging Tools for VS 2022 もインストールされている必要があります。\n\rNuget パッケージからインストールする nuget.org で公開されている Esri.ArcGISRuntime.ProjectTemplates NuGet パッケージは .NET MAUI（iOS、Android、WinUI）、WPF、WinUI、および UWP 用のアプリケーション プロジェクト テンプレートを提供します。\n以下の手順に従って、コマンドライン インターフェイスを使用してプロジェクト テンプレートをインストールします。\n  コマンドプロンプトを開きます。\n  以下のコマンドを使用して、新しいテンプレートをインストールします。\ndotnet new --install Esri.ArcGISRuntime.ProjectTemplates   テンプレートがインストールされたら、Visual Studio を開き、ArcGIS Maps SDK .NET MAUI App の新しくインストールした .NET MAUI テンプレートを選択します。または、次のコマンドを使用して、新しい ArcGIS Maps SDK .NET MAUI App を作成します。\ndotnet new mauimap   追加のダウンロード サンプルコード、データ、コンポーネント の追加のリソースを利用できます。また、ガイドを ダウンロード して、オフラインで利用することも可能です。\nサンプル コード アプリケーションに追加できるさまざまな ArcGIS Maps の強力な機能を説明するサンプル コードを入手できます。サンプルを検索し、サンプル ドキュメント で関連するコードを参照するか、サンプル リポジトリ からソース コードをダウンロードして、サンプルをローカルに構築および実行できます。\nコンパイル済みのサンプル ビューアー アプリ (WPF 版) は、Microsoft ストア から入手できます。 アプリを実行する前に、システム要件を参照して、正常に実行できることを確認してください。\nLocal Server ArcGIS Maps SDK for Local Server では、オフラインでジオプロセシング タスクを実行して、アプリケーションで高度な空間解析とデータ操作を行うことができます。これらのタスクは、ArcGIS Enterprise で実行されるジオプロセシング タスクと同じように動作します。 アプリケーションでオフラインでジオプロセシング タスクを実行する場合は、Local Server のトピックの手順に従って Local Server をインストールします。\nArcGIS Maps SDK for Local Server は非推奨です。詳細は サポート終了情報: ArcGIS Maps SDK for Local Server を参照してください。\n\r追加のデータ 投影エンジン データ 測地系変換は、ある空間基準から別の空間基準へジオメトリを投影する際に、2つの空間基準の基礎となる測地系に違いがある場合に使用されます。測地系変換は、数学的に定義する（方程式ベースの変換）ことも、外部のサポート ファイルに依存する（グリッド ベースの変換）ことも可能です。アプリでグリッドベースの変換を使用する場合、投影エンジン ファイルが存在する必要があります。API は、必要なファイルがローカルのファイルシステムで利用可能かどうかを検出することができます。投影エンジン ファイルが無い状態で変換をしようとすると、エラーが発生します。API は、必要なファイルがローカル ファイル システムで利用可能かどうかを検出できます。\nグリッド ベースの変換を使用している場合は、ダウンロード ページからサポートする Projection Engine ファイルをダウンロードしてください。座標系、投影法、測地系変換の操作の詳細については、Spatial references のトピックを参照してください。\nElectronic Navigational Charts (ENC) 航海用電子海図（ENC）は、水路や海上の情報を可視化し、分析するためのジオリファレンスされたベクター データセットです。SDK は、国際水路機関（IHO） の S-57 規格に準拠した ENC をサポートしています。\n航海用電子海図 (ENC) を使用する場合は、Esri.ArcGISRuntime.Hydrography NuGet パッケージをアプリに追加するか、ダウンロード ページから hydrography データをダウンロードします。\nENC データの操作の詳細については、Display electronic navigational charts のトピックを参照してください。\nArcGIS Maps SDK for .NET を使用したオフライン環境での開発 NuGet パッケージとプロジェクト テンプレート オンライン アクセスが制限された環境でアプリを開発している場合は、ローカルの NuGet パッケージ フィードから ArcGIS Maps SDK for .NET を参照することができます。 NuGet.org で公開されている NuGet パッケージのサブセットを含む、追加の Visual Studio (Windows) 拡張機能を利用できます。 この拡張機能をインストールすると、ユーザー プロファイルの %localappdata%\\Esri\\NuGet の下にローカル NuGet パッケージ ソースが構成されます。 詳細については、Microsoft のドキュメントの ローカル NuGet パッケージ フィード を参照してください。\nこのリリースでは、WPF、WinUI、.NET MAUI プロジェクト テンプレートには Visual Studio 17.8 以降が必要です。\n\rVisual Studio 拡張機能をダウンロードしてインストールする プロジェクト テンプレート拡張機能と NuGet パッケージ拡張機能の両方を、ダウンロード ページ からダウンロードできます。\n  開発マシンからアクセスできる場所にファイルを保存します。\n  ダウンロードした Visual Studio 拡張機能をインストールするには、.vsix ファイルをダブルクリックします (またはファイルを選択して Enter キーを押します)。\n  複数のバージョンの Visual Studio がインストールされている場合、VSIX インストーラー ダイアログには、拡張機能をインストールするために使用できる Visual Studio 製品 (Visual Studio Enterprise 2022 など) のリストが表示されます。 ターゲットの Visual Studio インスタンスを選択し、ライセンス条項を確認して [インストール] を選択します。\n  インストールが完了すると、選択した製品の確認が表示されます。 [閉じる] を選択して、インストールを終了します。 インストールしたら、Visual Studio の [拡張機能の管理] ダイアログを使用して、拡張機能を有効化、無効化、またはアンインストールします。 詳細については、Microsoft ドキュメントのトピック [拡張機能の管理] ダイアログ ボックスを使用しないインストール を参照してください。\n  ローカルの Esri パッケージ ソースから NuGet パッケージをインストールする ローカルの Esri パッケージ ソースから NuGet パッケージをインストールするには、次の手順に従います。\n  Visual Studio ソリューション エクスプローラー ウィンドウで、[プロジェクト] を右クリックし、[NuGet パッケージの管理] を選択します。\n  [参照] タブを選択し、パッケージ ソースとして [Esri] を選択します。\n  ArcGIS Maps SDK for .NET でサポートされているさまざまなフレームワーク用の NuGet パッケージがいくつか表示されます。\n  インストールする NuGet パッケージを選択し、[インストール] ボタンをクリックします。 NuGet パッケージ マネージャーの詳細については、Microsoft ドキュメントの NuGet パッケージ マネージャーを使用して Visual Studio にパッケージをインストールして管理する を参照してください。\n  [変更のプレビュー] ダイアログの内容を確認し、[OK] を選択してインストールを続行します。\n  インストールが完了すると、追加されたパッケージが NuGet パッケージ マネージャーの [インストール済み] タブに表示され、ArcGIS Maps SDK for .NET を使用して開発できるようになります。\n  スタンドアロンの開発者向けドキュメント ダウンロード ページ から、開発者向けドキュメントをアーカイブとしてダウンロードできます。アーカイブには、ローカル Web サーバからドキュメントを提供する手順が含まれているため、インターネットに接続しなくてもドキュメントにアクセスできます。スタンドアロン ドキュメントには、開発者ガイド、API リファレンス、チュートリアル、およびサンプル ドキュメントが含まれています。このドキュメントは、パブリックなインターネット上ではなく、ローカルのスタンドアロン コンピューターまたは内部ネットワーク上で実行するように設計されています。\nダウンロードしたドキュメントのアーカイブを解凍するには、無料のオープンソース ファイル アーカイブ ユーティリティ 7-Zip をお勧めします。\n\rローカルでドキュメントを公開する方法\n 使用する SDK のドキュメントをダウンロードします。ダウンロードしたファイルは、.zip アーカイブ形式になっています。 アーカイブをローカル フォルダに解凍します。解凍されたアーカイブには、public と install という 2 つのサブフォルダがあります。 install フォルダ内の README.md ファイルを開き、選択した Web サーバーの指示に従います。  ライブ ドキュメント サイトはリリース時及びリリースの間に定期的に更新されますが、スタンドアロン ドキュメントは静的で、最初のリリース後は更新されません。\n\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/flutter/install-flutter-200.x/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for Flutter のインストールとセットアップ手順を紹介します。",
	"content": "出典：ArcGIS Maps SDK for Flutter - Guide - Install and set up\nこのインストール ガイドでは、ArcGIS Maps SDK for Flutter (バージョン 200.x) のインストールとセットアップ手順を紹介します。マップを表示する方法については「アプリの作成」のチュートリアルをご覧ください。\nArcGIS Maps SDK for Flutter をインストールする前に、開発マシンが 動作環境 を満たしていることを確認してください。\nFlutter パッケージ リポジトリ ArcGIS Maps SDK for Flutter は、Flutter のパッケージ リポジトリである pub.dev を使用して、VS Code で Flutter プロジェクトに統合することができます。\nVS Code   VS Code で Flutter プロジェクトを開きます。\n  View \u0026gt; Terminal を開きます。\n  プロジェクトの依存関係に arcgis_maps パッケージを追加します。\ndart pub add arcgis_maps  dart pub add は、arcgis_maps パッケージを依存関係として pubspec.yaml に追加し、pubspec.yaml を解決するために依存関係を取得します。\n  以下のコマンドを実行して、すべての依存関係を最新の互換性のあるバージョンにアップデートします。\nflutter pub upgrade このコマンドを実行すると、アプリが依存しているパッケージのみがアップデートされます。\n  arcgis_maps_core をダウンロードしてインストールします。\ndart run arcgis_maps install このコマンドを実行すると、ArcGIS Maps のコア機能のバイナリー配布が Flutter プロジェクトにダウンロードされ、セットアップされます。ソース管理にチェックする場合は、.gitignore ファイルに arcgis_maps_core を追加することをお勧めします。\n  この API を使用するには、以下の import 文を dart コード（.dart）ファイルに追加します。\nimport \u0026#39;package:arcgis_maps/arcgis_maps.dart\u0026#39;; プラットフォーム固有の構成 Android、iOS、またはその両方向けに開発するには、Flutter プロジェクトで以下の設定変更も行う必要があります。\nAndroid   以下の最低要件を更新します。\n Android NDK バージョン: 27.0.12077973 Android の最低 SDK バージョン: 26  android/app/build.gradle.kts\nandroid { namespace = \u0026#34;com.esri.flutter_project_template\u0026#34; compileSdk = flutter.compileSdkVersion ndkVersion = \u0026#34;27.0.12077973\u0026#34; // 変更  compileOptions { sourceCompatibility = JavaVersion.VERSION_11 targetCompatibility = JavaVersion.VERSION_11 } kotlinOptions { jvmTarget = JavaVersion.VERSION_11.toString() } defaultConfig { // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).  applicationId = \u0026#34;com.esri.flutter_project_template\u0026#34; // You can update the following values to match your application needs.  // For more information, see: https://flutter.dev/to/review-gradle-config.  //  minSdk = 26 // 変更  targetSdk = flutter.targetSdkVersion versionCode = flutter.versionCode versionName = flutter.versionName } } `\n  Kotlin のバージョンを更新します。\n Kotlin バージョン: 1.9.0  android/settings.gradle\nplugins { id \u0026#34;dev.flutter.flutter-plugin-loader\u0026#34; version \u0026#34;1.0.0\u0026#34; id \u0026#34;com.android.application\u0026#34; version \u0026#34;8.1.0\u0026#34; apply false id \u0026#34;org.jetbrains.kotlin.android\u0026#34; version \u0026#34;1.9.0\u0026#34; apply false //変更 }   パーミッションを必要とする機能 ArcGIS Maps SDK for Flutter に依存するアプリケーションをデプロイするには、以下の権限が必要です。オンライン リソースにアクセスする権限を追加し、デバイスの GPS にアクセスする権限を追加します。位置情報へのアクセス許可を必要とする API をアプリがアクティブに使用している場合のみ、ユーザーは位置情報へのアクセス許可を提供するよう促されることに注意してください。\nandroid/app/src/main/AndroidManifest.xml\n\u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_COARSE_LOCATION\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_FINE_LOCATION\u0026#34; /\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;application android:label=\u0026#34;flutter_project_template\u0026#34; android:name=\u0026#34;${applicationName}\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34;\u0026gt; デバイスのストレージへのアクセスを許可 添付ファイルの追加やエクスポートなど、デバイスのストレージに対する読み取り/書き込み操作が必要な場合は、以下の追加権限を追加する必要があります。\nandroid/app/src/main/AndroidManifest.xml\n\u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.WRITE_EXTERNAL_STORAGE\u0026#34;/\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_INTERNAL_STORAGE\u0026#34;/\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_EXTERNAL_STORAGE\u0026#34;/\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;application android:label=\u0026#34;flutter_project_template\u0026#34; android:name=\u0026#34;${applicationName}\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34;\u0026gt; ユーザー認証の有効化 ユーザー認証にシステム ブラウザーの使用が必要な場合は、以下を追加する必要があります。\nandroid/app/src/main/AndroidManifest.xml\n\u0026lt;/activity\u0026gt; \u0026lt;!-- application タグ内の activity タグ--\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;activity android:name=\u0026#34;com.linusu.flutter_web_auth_2.CallbackActivity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter android:label=\u0026#34;flutter_web_auth_2\u0026#34;\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34; /\u0026gt; \u0026lt;data android:scheme=\u0026#34;YOUR_CALLBACK_URL_SCHEME_HERE\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; YOUR_CALLBACK_URL_SCHEME_HERE を、ポータルで OAuth 認証情報を設定したときに使用したリダイレクト URL のスキームに置き換えてください。 これは、ログイン ワークフローが完了した後、ブラウザーがアプリに通信して戻るために必要です。\niOS   iOS 16.0 以上を設定します。 行のコメントを解除し、バージョン番号を更新します。\nios/Podfile\n# Uncomment this line to define a global platform for your project platform :ios, \u0026#39;16.0\u0026#39; #変更   Runtimecore ポッドと arcgis_maps_ffi ポッドを Runner ターゲット セクションに追加します。\nios/Podfile\ntarget \u0026#39;Runner\u0026#39; do use_frameworks! use_modular_headers! #変更開始 pod \u0026#39;Runtimecore\u0026#39;, :podspec =\u0026gt; \u0026#39;../arcgis_maps_core/ios/Runtimecore.podspec\u0026#39; pod \u0026#39;arcgis_maps_ffi\u0026#39;, :podspec =\u0026gt; \u0026#39;../arcgis_maps_core/ios/arcgis_maps_ffi.podspec\u0026#39; #変更終了 flutter_install_all_ios_pods File.dirname(File.realpath(__FILE__)) target \u0026#39;RunnerTests\u0026#39; do inherit! :search_paths end end   pod update を使用して Pods を設定します。\ncd ios \u0026amp;\u0026amp; pod update \u0026amp;\u0026amp; cd ..   パーミッションを必要とする機能 ArcGIS Maps SDK for Flutter の一部の機能には、追加のパーミッションが必要です。 ArcGIS Maps SDK for Flutter に依存する iOS アプリを App Store にデプロイするには、以下の記述が必要です。 位置情報へのアクセス許可を必要とする API をアプリがアクティブに使用している場合のみ、ユーザーに位置情報へのアクセス許可を求めるプロンプトが表示されることに注意してください。\n ユーザーの位置情報へのアクセスを要求する（NSLocationUsageDescription） 常にユーザーの位置情報へのアクセスを要求する（NSLocationAlwaysAndWhenInUseUsageDescription） アプリがフォアグラウンドで実行されている間、ユーザーの位置情報へのアクセスを要求する（NSLocationWhenInUseUsageDescription）  次のコード例では、情報プロパティー リストにこれらを含めています。\nios/Runner/Info.plist\n\u0026lt;dict\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;key\u0026gt;NSLocationUsageDescription\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Location permission is required to view your position.\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;NSLocationAlwaysAndWhenInUseUsageDescription\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Location permission is required to view your position.\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;NSLocationWhenInUseUsageDescription\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Location permission is required to view your position.\u0026lt;/string\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;key\u0026gt;CFBundleDevelopmentRegion\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;$(DEVELOPMENT_LANGUAGE)\u0026lt;/string\u0026gt; 追加ダウンロード サンプル コードとデータの追加ソースは、あなたの開発プロジェクトを強化するために利用可能です。本ガイドは、スタンドアロンの開発者向けドキュメントとしてダウンロードすることもできます。\nサンプル コード 独自のアプリケーションに追加できるさまざまな強力な機能を説明した、実践的なサンプル コードを入手できます。 サンプルを検索し、サンプル ドキュメントで関連するコードを参照するか、サンプル リポジトリからコードをダウンロードしてローカルで実行します。\nスタンドアロンの開発者向けドキュメント ダウンロード ページ から、開発者向けドキュメントをアーカイブとしてダウンロードできます。アーカイブには、ローカル Web サーバからドキュメントを提供する手順が含まれているため、インターネットに接続しなくてもドキュメントにアクセスできます。スタンドアロン ドキュメントには、開発者ガイド、API リファレンス、チュートリアル、およびサンプル ドキュメントが含まれています。このドキュメントは、パブリックなインターネット上ではなく、ローカルのスタンドアロン コンピューターまたは内部ネットワーク上で実行するように設計されています。\nダウンロードしたドキュメントのアーカイブを解凍するには、無料のオープンソース ファイル アーカイブ ユーティリティー 7-Zip をお勧めします。\n\rローカルでドキュメントを公開する方法\n 使用する SDK のドキュメントをダウンロードします。 ダウンロードしたファイルは .zip アーカイブ形式になっています。 アーカイブをローカル フォルダに解凍します。 解凍されたアーカイブには、public と install の 2 つのサブフォルダがあります。 install フォルダ内の README.md ファイルを開き、選択した Web サーバーの指示に従います。  ライブ ドキュメント サイトはリリースとリリースの間に定期的に更新されますが、スタンドアロン ドキュメントは静的で、最初のリリース後は更新されません。\n\r補足データ 投影 エンジン データ 測地系変換は、ある空間基準から別の空間基準へジオメトリを投影する際に、2つの空間基準の基礎となる測地系に違いがある場合に使用されます。測地系変換は、数学的に定義する（方程式ベースの変換）ことも、外部のサポート ファイルに依存する（グリッド ベースの変換）ことも可能です。アプリでグリッドベースの変換を使用する場合、投影エンジン ファイルが存在する必要があります。投影エンジン ファイルが無い状態で変換をしようとすると、エラーが発生します。API は、必要なファイルがローカル ファイル システムで利用可能かどうかを検出できます。\nグリッド ベースの変換を使用している場合は、ダウンロード ページからサポートする 投影エンジン ファイルをダウンロードしてください。 座標系、投影、測地系変換の操作に関する詳細は、Spatial references トピックを参照してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/ios/install-ios-200.x/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for Swift のインストールとセットアップ手順を紹介します。",
	"content": "出典：ArcGIS Maps SDK for Swift - Guide - Install and set up\nこのインストール ガイドでは、ArcGIS Maps SDK for Swift (バージョン 200.x) のインストールとセットアップ手順を紹介します。マップを表示する方法については「アプリの作成」のチュートリアルをご覧ください。\nSwift Package Manager Swift Package Manager を使用して Xcode プロジェクトに簡単に統合できます。\nXcode 16 での手順\n Xcode プロジェクトを開きます。メニューバーで、[File] \u0026gt; [Add Package Dependencies\u0026hellip;] を選択します。   パッケージ リポジトリの URL として https://github.com/esri/arcgis-maps-sdk-swift を入力します。\n  オプションとして、正確なバージョンまたは使用するバージョンの範囲を指定したい場合は、Dependency Rule オプションを選択します。\n  [Add Package] をクリックします。\n  [Add to Target] リストからアプリを選択します。[Add Package] をクリックします。\n  ターゲットでアプリを選択します。[Frameworks, Libraries, and Embedded Content] で + 記号をクリックし、\u0026ldquo;ArcGIS\u0026rdquo; がまだ存在しない場合は追加します。  ArcGIS の API を使用するには、次のインポートステートメントを任意の Swift コード（.swift）ファイルに追加します。  import ArcGIS ArcGIS をインポートした後、SwiftUI プロトコルと ArcGIS プロトコルを区別する必要があるかもしれません。これを行うには、API 接頭辞を追加します。  var body: some SwiftUI.Scene { WindowGroup { ContentView() } } 追加のダウンロード 開発プロジェクトを強化するために、サンプル コードとデータ、ツール の追加リソースを利用できます。このガイドを、スタンドアロンの開発者ドキュメントとしてダウンロードすることもできます。\nサンプル コード 独自のアプリケーションに追加できるさまざまな強力な機能を紹介する実践的なサンプル コードを入手してください。サンプルを検索し、サンプル ドキュメントで関連するコードを参照するか、サンプル リポジトリからコードをダウンロードしてローカルで実行できます。\nArcGIS Maps SDK for Swift Toolkit ArcGIS Maps SDK for Swift Toolkit は、ArcGIS Maps SDK for Swift チームによって管理されているオープン ソース プロジェクトであり、アプリ開発を簡素化するためのコントロールとユーティリティーが含まれています。 Examples プロジェクトでこれらのコンポーネントの動作を確認するか、ドキュメントを読んで詳細を確認できます。\nスタンドアロンの開発者向けドキュメント ダウンロード ページ から、開発者向けドキュメントをアーカイブとしてダウンロードできます。アーカイブには、ローカル Web サーバーからドキュメントを提供する手順が含まれているため、インターネットに接続しなくてもドキュメントにアクセスできます。スタンドアロン ドキュメントには、開発者ガイド、API リファレンス、チュートリアル、およびサンプル ドキュメントが含まれています。このドキュメントは、ローカルのスタンドアロン コンピューターまたは内部ネットワーク上で実行するように設計されており、パブリックなインターネット上では実行できません。\nダウンロードしたドキュメントのアーカイブを解凍するには、無料のオープンソース ファイル アーカイブ ユーティリティー 7-Zip をお勧めします。\n\rローカルでドキュメントを公開する方法：\n 使用する SDK のドキュメントをダウンロードします。ダウンロードしたファイルは、.zip アーカイブ形式になっています。 アーカイブをローカル フォルダに解凍します。解凍されたアーカイブには、public と install という 2 つのサブフォルダがあります。 install フォルダ内の README.md ファイルを開き、選択した Web サーバーの指示に従います。  ライブ ドキュメント サイトはリリース時及びリリースの間に定期的に更新されますが、スタンドアロン ドキュメントは静的で、最初のリリース後は更新されません。\n\r追加のデータ 投影エンジン データ 測地系変換は、ある空間基準から別の空間基準へジオメトリを投影する際に、2つの空間基準の基礎となる測地系に違いがある場合に使用されます。測地系変換は、数学的に定義する（方程式ベースの変換）ことも、外部のサポート ファイルに依存する（グリッド ベースの変換）ことも可能です。アプリでグリッド ベースの変換を使用する場合、投影エンジン ファイルが存在する必要があります。API は、必要なファイルがローカルのファイル システムで利用可能かどうかを検出することができます。投影エンジン ファイルが無い状態で変換をしようとすると、エラーが発生します。API は、必要なファイルがローカル ファイル システムで利用可能かどうかを検出できます。。\nグリッド ベースの変換を使用している場合は、ダウンロード ページからサポートする Projection Engine ファイルをダウンロードしてください。座標系、投影法、測地系変換の操作の詳細については、Spatial references のトピックを参照してください。\nElectronic Navigational Charts (ENC) 航海用電子海図（ENC）は、水路や海上の情報を可視化し、分析するためのジオリファレンスされたベクター データセットです。SDK は、国際水路機関（IHO）の S-57 規格 に準拠した ENC をサポートしています。\n航海用電子海図 (ENC) を使用する場合は、ダウンロード ページから hydrography データをダウンロードします。ENC データの操作の詳細については、Display electronic navigational charts のトピックを参照してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/unity/install-and-set-up/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for Unity のインストールとセットアップ手順を紹介します。",
	"content": "出典：ArcGIS Maps SDK for Unity - Guide - Install and set up\nこのインストール ガイドでは、ArcGIS Maps SDK for Unity のインストールとセットアップ手順を紹介します。マップを表示する方法については「アプリの作成」のチュートリアルをご覧ください。\nインストールおよびセットアップ方法 ArcGIS Maps SDK for Unity は Unity 用のプラグインです。ArcGIS Maps SDK for Unity を使用して ArcGIS の実世界のマップや 3D コンテンツを使用した 3D GIS アプリケーションを作成するには、Unity プロジェクトを準備する必要があります。作業を開始する前に、必ずプラグインをダウンロードしてください。\nUnity のインストール このプラグインは Unity 2022.3.x と Unity 6 でサポートしています。インストールされていない場合は、Unity をインストールしてください。\nプラグインのインストール ArcGIS Maps SDK for Unity を使用するには、新規プロジェクトまたは既存プロジェクト (英語) のいずれかにプラグインをインストールします。\nシーン設定オプションの選択 プラグインには、シーン内で ArcGIS データやその他の地理空間コンテンツを使用するための 3 つのオプションが用意されています。\n Map Creator UI では、コードを記述せずにシーンを作成できます。 Components では、シーン内のゲーム オブジェクトにアタッチできます。 C# API では、プラグインのソース コードを変更することでカスタマイズ オプションを提供します。  追加のダウンロード ダウンロード ページから、開発者向けドキュメントをアーカイブ形式としてダウンロードできます。ドキュメントには、開発者ガイド、API リファレンス、チュートリアル、サンプル ドキュメントが含まれています。アーカイブには、インターネットに接続しなくてもドキュメントにアクセスできるように、ローカルの Web サーバーからドキュメントにアクセスする手順が記述されています。このドキュメントは、ローカルのコンピューターまたは内部ネットワーク上で実行するように設計されており、公共のインターネット上では実行できません。\n以下の方法で、ローカルでドキュメントを使用します。\n ArcGIS Maps SDK for Unity のドキュメントをダウンロードします。ダウンロードしたファイルは zip アーカイブ形式です。 アーカイブをローカル フォルダーに解凍1します。解凍したアーカイブには、public と install という 2 つのサブ フォルダーがあります。 install フォルダー内の README.md ファイルを開き、選択した Web サーバーの指示に従います。    パスが長いため、そのままだと Windows の標準機能で解凍できません。他のフリー ソフトを用いるかフォルダーやファイルの名前を変更して解凍を行ってください。 \u0026#x21a9;\u0026#xfe0e;\n   "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/unreal-engine/install-and-set-up/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for Unreal Engine のインストールとセットアップ手順を紹介します。",
	"content": "出典：ArcGIS Maps SDK for Unreal Engine - Guide - Install and setup\nこのインストール ガイドでは、ArcGIS Maps SDK for Unreal Engine のインストールとセットアップ手順を紹介します。マップを表示する方法については「アプリの作成」のチュートリアルをご覧ください。\nインストールおよびセットアップ方法 ArcGIS Maps SDK for Unreal Engine は Unreal Engine 用のプラグインです。ArcGIS Maps SDK for Unreal Engine を使用して ArcGIS の実世界のマップや 3D コンテンツを使用した 3D GIS アプリケーションを作成するには、Unreal プロジェクトを準備する必要があります。作業を開始する前に、必ずプラグインをダウンロードしてください。\nUnreal Engine のインストール このプラグインは、Unreal Engine 5.5、5.4、および 5.3 をサポートしています。インストールされていない場合は、Unreal Engine をインストールしてください。Visual Studio for Unreal Engine の設定については、Unreal Engine 5 のドキュメントを参照してください。\nプラグインのインストール ArcGIS Maps SDK for Unreal Engine を使用するには、新規プロジェクトまたは既存プロジェクト (英語) のいずれかにプラグインをインストールします。\nシーン設定オプションを選択する SDK には、シーン内で ArcGIS データやその他の地理空間コンテンツを使用するための 4 つのオプションが用意されています。\n Modes Panel UI は、コードを記述せずにシーンを作成できます。 Components は、Modes Panel UI の背後にあり、コードを記述せずにシーンを作成できます。 BluePrints は、Unreal Engine で提供されているノードベースのビジュアル スクリプト インターフェイスを使用してシーンを作成するオプションを提供します。 C++ API は、プラグインのソース コードを変更することでカスタマイズ オプションを提供します。  追加のダウンロード ダウンロード ページから、開発者向けドキュメントをアーカイブ形式としてダウンロードできます。ドキュメントには、開発者ガイド、API リファレンス、チュートリアル、サンプル ドキュメントが含まれています。アーカイブには、インターネットに接続しなくてもドキュメントにアクセスできるように、ローカルの Web サーバーからドキュメントにアクセスする手順が記述されています。このドキュメントは、ローカルのコンピュータまたは内部ネットワーク上で実行するように設計されており、公共のインターネット上では実行できません。\nローカルでドキュメントを使用するには、\n ArcGIS Maps SDK for Unreal Engine のドキュメントをダウンロードします。ダウンロードしたファイルは zip アーカイブ形式です。 アーカイブをローカル フォルダーに解凍します。解凍したアーカイブには、public と install という 2 つのサブ フォルダーがあります。 install フォルダー内の README.md ファイルを開き、選択した Web サーバーの指示に従います。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/install-guide/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Web AppBuilder (Developer Edition) をインストールする手順を紹介します。",
	"content": "ArcGIS Web AppBuilder は ArcGIS Online あるいは Portal for ArcGIS に組み込まれた機能として提供されており、ウィジェット（機能）やテーマ（デザイン）を組み合わせることにより、GIS やプログラミングなどの専門知識がなくても誰でも簡単に Web アプリケーションを作成できるソフトウェアです。 Developer Edition（開発者向けエディション）はこれらの機能に加え、開発者のためにウィジェットやテーマを独自に開発するためのフレームワークを提供します。また、作成したアプリケーションをダウンロードし、独自のサーバーにホストすることも可能です。\nここでは、ArcGIS Web AppBuilder (Developer Edition) (以下 Web AppBuilder) のインストール手順を説明します。\n インストール Web AppBuilder の起動 ポータル URL の指定 アプリケーション ID の設定 インストールの確認  インストール  Web AppBuilder の ZIP ファイルをローカルにダウンロードし、解凍します。\nサインイン ページが表示される場合は、ArcGIS Developers 開発者アカウント（あるいは ArcGIS Online 組織向けプランのアカウント）のユーザー名およびパスワードを入力しサインインします。 Web AppBuilder は Node.js 上で動作するため、インストールする端末に Node.js が必要です。Web AppBuilder のインストール ファイルには Windows バージョンの Node.js が含まれていますが、Mac や Linux など他の OS をお使いの場合は Web AppBuilder を起動する前に Node.jsをインストールする必要があります。  ArcGIS API for JavaScript の参照先を変更する（オプション） Web AppBuilder はデフォルトでは Esri の CDN で配信されている ArcGIS API for JavaScript を参照します。そのため、インターネットに接続できない環境で Web AppBuilder を使用する場合、ArcGIS API for JavaScript の参照先を変更する必要があります。ここでは Portal for ArcGIS に内蔵されている ArcGIS API for JavaScript へ参照先を変更する手順を説明します。\n \u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\client\\stemapp\\env.js ファイルをテキストエディターで開きます。 //apiUrl を検索します。   API のバージョンは Web AppBuilder のバージョンにより異なります。通常、Web AppBuilder がリリースされた時点の最新バージョンの API が使われています。  apiUrl= \u0026quot;https://\u0026lt;ポータル URL\u0026gt;/jsapi/jsapi/\u0026quot; に書き換え、上書き保存します。   Portal for ArcGIS が内蔵する API を使用する際は、内蔵されている API のバージョンに注意が必要です。Web AppBuilder が使用する API のバージョンと異なるバージョンの API の利用はサポートされません。\nWeb AppBuilder のバージョンと API のバージョンの関係については About release versions を参照ください。  Web AppBuilder の起動  Web AppBuilder を起動します。   Windows 端末\nWindows をお使いの場合、解凍したフォルダーにある startup.bat ファイルをダブルクリックします。このバッチファイルはコマンド プロンプト上で Node.js サーバーを起動します。 その他の端末 Windows 以外のマシンにインストールする場合は、直接 Node.js サーバーを起動するコマンドを実行します。\nコマンド プロンプトを開き、\u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\server のパスを指定します。続けて node server.js と入力します。\nWeb AppBuilder は Web ブラウザーで http://[マシン名]:3344/webappbuilder にアクセスすると起動します。コマンド プロンプト上で Node.js が起動している間はいつでも、どの Web ブラウザーからでも Web AppBuilder を開くことができます。利用するマシンがドメインに参加しているとき、Web AppBuilder へのアクセスにドメインを含める必要がある場合があります。その際は、http://[マシン名].[ドメイン]:3344/webappbuilder のようにドメインを含めてアクセスしてください。  Node.js がデフォルトで使用するポート番号は 3344 です。パラメーターを追加したり、他のポート番号を割り当てたり、Windows サービスとして起動したりしたい場合は、以下の手順を参照してください。    パラメーターを追加し、他のポート番号を割り当てる\n コマンド プロンプトを開き、Web AppBuilder のサーバー ディレクトリ（\u0026lt;Web AppBuilderのインストール ディレクトリ\u0026gt;\\server）へ移動します。割り当てたいポート番号と必要に応じてプロキシの URL を入力します。  64 ビット版 Windows\nnode_x64.exe server.js [-port=value] [-proxy=value] 32 ビット版 Windows\nnode_x32.exe server.js [-port=value] [-proxy=value] その他のマシン\nnode server.js [-port=value] [-proxy=value]   Web ブラウザーを開き、上記で設定したポート番号を指定し、Web AppBuilder を起動します。\nhttp://[マシン名]:[ポート番号]/webappbuilder    Windows サービスとして起動する\nWeb AppBuilder は、startup.bat ファイルをクリックして起動させるほかに、Windows サービスとして起動させることもできます。\n Windows プラットフォームに Node.js をインストールします。 管理者としてコマンドプロンプトを開きます。 Web AppBuilder のサーバー ディレクトリ（\u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\server）へ移動します。 npm install コマンドを実行します。 npm run-script install-windows-service コマンドを実行します。 Windows の [サービス] ウィンドウを開き、ArcGISWebAppBuilder サービスを起動します。 ArcGISWebAppBuilder サービスを削除するには、npm run-script uninstall-windows-service コマンドを実行します。 プロキシを利用したい場合は、/~server/package.json ファイルを開き、\u0026quot;start\u0026quot;: \u0026quot;node server.js\u0026quot; を \u0026quot;start\u0026quot;: \u0026quot;node server.js -proxy=\u0026lt;http://your proxy\u0026gt;\u0026quot; に変更してください。    ポータル URL の指定   Web AppBuilder で使用するアカウントに紐づく ArcGIS Online またはPortal for ArcGIS の URL を指定します。開発者アカウントをご利用の方は、ArcGIS for Developers の [Account Settings] ページにて URL をご確認ください。\n  [続行] をクリックします。Web 層認証を使用している場合、次のセクションはスキップしてください。ログイン後、インストールの確認をしてください。\nArcGIS Online または Portal for ArcGIS で OAuth2 認証を使用する場合は、次のセクションでアプリケーション ID を設定する必要があります。\n  アプリケーション ID の設定 上記で指定した ArcGIS Online または Portal for ArcGIS ではじめて Web AppBuilder を使用する場合、OAuth2 認証を利用できるようにするため、アプリケーション ID を設定する必要があります。\nアプリケーション ID を入手するには ArcGIS Online または Portal for ArcGIS に Web AppBuilder をアイテムとして追加します。\n  指定したポータルへログインします。\n  コンテンツ ページの[マイコンテンツ] を開きます。[新しいアイテム] をクリックし、[アプリケーション] を選択します。\n  ダイアログボックスで、[アプリケーションタイプ] に Web マッピング、[URL] オプションに Web AppBuilder の URL を入力し [次へ] をクリックします。\n   任意のタイトル、保存先のフォルダー、タグとサマリーを設定し、 [保存] をクリックします。これで Web AppBuilder はアイテムとしてポータルに追加されました。\n  アイテムの追加が完了すると、追加したアイテムの詳細情報のページが表示されます。\n ArcIGS Online：[設定] タブをクリックします。[アプリケーションの登録] セクションまでスクロールし、[登録] をクリックします。 Portal for ArcGIS：[アプリケーションの登録] セクションまでスクロールし、[登録] をクリックします。    [登録] ダイアログが表示されます。[リダイレクト URI] オプションに http://[マシン名] または https://[マシン名] を入力して、[追加] をクリックします。HTTP と HTTPS プロトコルは異なる URI として認識されることに注意してください。リダイレクトに関する問題を避けるため、両方のプロトコルを登録することを推奨しています。\n  [登録] をクリックします。これでアプリケーションの登録は完了です。\n  Web AppBuilder の起動画面に戻ります。[アプリケーション ID] オプションに入手したアプリケーション ID を入力し、[続行] をクリックします。\nInvalid redirect_uri エラー ページが表示される場合は、以下の手順に従ってください。\nアプリケーション ID を入手する際に登録したリダイレクト URI に誤りがある場合、アプリケーション ID オプションにアプリケーション ID を入力し、[続行] をクリックすると、エラー ページが表示されることがあります。この場合、登録したアプリケーションの情報を修正する必要があります。\n Web AppBuilder のサーバー ディレクトリ（\u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\server）を開き、signininfo.json ファイルを削除します。 手順 3 に戻り、入力したリダイレクト URI を更新するか、アプリケーションを新しく登録して、新しいアプリケーション ID を入手します。 起動中の Web AppBuilder のページを再読み込みします。 [アプリケーション ID] オプションにアプリケーション ID を入力し、[続行] をクリックします。    [権限のリクエスト] ダイアログが表示されます。表示されたアカウント情報が正しいことを確認し [承認] をクリックします。\n  アプリケーション ID は OAuth2 認証に必要です。詳細は 認証をご参照ください。ログインに関する問題は、FAQs および アプリの追加とアプリの登録をご参照ください。\nWeb AppBuilder は、デフォルトで HTTPS をサポートするために Node.js で自己署名証明書を使用しています。\n独自に用意した証明書を使用したい場合は、Web AppBuilder のサーバー ディレクトリ（\u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\server）にある cakey.pem と cacert.pem を置き換えてください。\nアプリケーション ID の登録手順の説明は以上です。これで 登録先のポータルへ OAuth2 認証を使用してサインインできるようになりました。次回からは Web AppBuilder を起動すると直接 Web AppBuilder のトップページが表示されます。\nこれで Web AppBuilder のインストールは終了です。\nインストールの確認 ここでは Web AppBuilder が正常にインストールされていることを確認するために、アプリケーションの起動確認を行います。\n Web AppBuilder を起動します。 トップページが表示されたら [新規作成] をクリックします。 [デフォルト（2D）] を選択し、[次へ] をクリックします。 新しい Web アプリの作成ページが開きます。任意のタイトルと説明を入力して [OK] をクリックします。 アプリケーションの作成のページが表示されたらインストールの確認は完了です。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/",
	"title": "スタートアップ ガイド",
	"tags": [],
	"description": "開発を始める方のために必要なアカウントの作成、API キーの取得、ロケーション サービスの利用、各 API / SDK を使った開発の基本的な流れからセキュリティ、運用（ライセンス認証）まで手順にそって学べる情報をまとめています。",
	"content": "開発を始める方のために「開発者アカウントの作成、API キーの取得、ロケーション サービスの利用、API / SDK を利用したアプリ開発、セキュリティ、運用（ライセンス認証）」と ArcGIS Location Platform を利用した開発の基本的な流れを紹介しています。\n 開発者アカウントの作成\nArcGIS Location Platform の利用を開始するために新規アカウントを作成する手順を紹介します。\n\r\r\r API キーの取得\nアプリケーションを公開するために必要な API キーを取得する手順について紹介します。\n\r\r\r ロケーションサービスの利用\nArcGIS Location Platform をはじめて使う方向けにロケーション サービスの紹介やフィーチャ サービス、Web マップを作成する方法について紹介します。\n\r\r フィーチャサービスの作成\nデータの検索や編集が可能な地図サービス (REST API) の配信方法を紹介します。\n\r Web マップの作成\nさまざまなフォーマットのデータを 1 つのマップとして集約し、それを可視化する方法を紹介します。\n\r ルートの検索\nマッピング API ＆ロケーション サービス内のルーティング＆ディレクションズについて紹介します\n\r ベースマップ\nマッピングAPI＆ロケーションサービス内のベースマップについて紹介します\n\r\r アプリ開発\nシンプルな地図アプリの作成方法を紹介します。\n\r\r データ ビジュアライゼーション\n地図にデータを可視化する際の Tips を紹介します。\n\r サンプル集\n開発にすぐに使えるサンプル データ/コードを紹介します。\n\r ミートアップ\nミートアップ参加者を支援するリソースをまとめています。\n\r\r セキュリティと認証の紹介\nAPI キー、ユーザー認証、アプリ認証を使用して、サービスやセキュアなリソースに認証済みのリクエストを行う方法について説明します。\n\r\r\r デプロイの紹介\n開発したアプリをデプロイするために必要なライセンスや利用規約などについて紹介します。\n\r\r\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/visualization/workflow-with-arcgis/",
	"title": "データ可視化のワークフロー",
	"tags": [],
	"description": "マップ ビューアーを使用した地図上でのデータ可視化のプロセスを紹介します。",
	"content": "ArcGIS 開発者向けクラウド サービス（ArcGIS for Developers）で提供されているビジュアライゼーション ツール（マップ ビューアー）を使用した地図上でのデータ可視化のプロセスを紹介します。最終的には地図作成にとどまらず、サードパーティのチャートなどのコンポーネントを組み合わせたアプリ開発をゴールとしています。\n本ワークフローで伝える方法はあくまで作成済みのデータに簡単な加工を施して可視化を行うことをクラウド上で実施することを前提としています。よって、デスクトップ GIS ソフトウェアなどを使ったデータ編集は除外しています。\nワークフロー ５ステップをベースに、各ステップで使用するツールやプラットフォームとその簡単な使用方法を以下で紹介していきます。\n データ取得   データ可視化のテーマとなるデータを取得します。  データ加工   取得したデータを地図上にプロットします。必要に応じてデータ変換を行います。  データ処理   必要に応じてテーマとなるデータをもとに解析処理を施します。  グラフィック表現   可視化対象であるデータをテーマに従って表現を加えます。  アプリ作成/ページ埋め込み   ステップ４までに作成した Web マップをページ上に表示し、データ可視化によるテーマを伝えるためにページの編集を行います。  以下は上記５ステップをチャートで表現した図です。必ずしもすべてのステップを踏む必要はなく、また柔軟なアウトプットを行うために開発が担う作業範囲を大きくすることも考えられますが、ここでは、もっとも簡易で効率的な手段として、ステップ４までのプロセスをクラウド上で完了できるようなフローを紹介します。\nデータ取得 ArcGIS のクラウド サービスが提供するビジュアライゼーション ツールではさまざまなデータ形式をサポートしており、異なる形式のデータをインポートし、地図上に可視化することができます。\nサポートするデータ形式は以下の通りです。\n ArcGIS Server サービス（GeoServices） シェープファイル GeoJSON CSV TXT GPX GeoRSS KML OGC  上記の形式で座標情報あるいは住所情報があればお好きなデータ カタログから取得したデータをすぐに地図上に可視化できます。特に ArcGIS Web サービスを使うことで、動的な属性/空間検索が可能な API を経由したデータ可視化が可能なため、より柔軟な可視化に対応できます。\n以下は、ArcGIS Web サービスを配信しているデータ元の参考です。\n ArcGIS Online ArcGIS Open Data Koop  データ加工 ここで紹介するデータ加工はさまざまなデータ形式を１つの地図上に重ねて可視化する作業にあたります。前のステップで取得したデータをデータ ビジュアライゼーション ツールを使って地図上に可視化します。\n  Web サービス（ArcGIS Server サービス、GeoRSS、KML、OGC）の場合\n  静的ファイル（シェープファイル、CSV、TXT、GPX）の場合\n  ArcGIS Online で全世界に配信されているデータの検索および可視化\rデータ処理 可視化したデータをもとに GIS の空間解析を実施することで、より高度な分析結果を２次データとしてそのまま地図上で扱うことができます。\n例：ポイントの集約 たとえば、喫茶店の場所を示すポイント フィーチャと区のエリア フィーチャがあり、喫茶店の売上を区別にまとめるとします。喫茶店に TOTAL_SALES 属性情報があれば、区ごとの TOTAL_SALES の合計値、各区の TOTAL_SALES の最小値または最大値、各区における総売上の標準偏差を取得できます。\nこのプロセスは必須ではないので、必要に応じて行ってください。\nArcGIS の解析サービスの利用については「解析の実行 | ArcGIS Online ヘルプ」を参照してください。\nグラフィック表現 可視化対象であるデータをテーマに従って表現を加えます。データ ビジュアライゼーション ツールには直感的な操作で地図上のデータの表現を操作するための機能が備わっています。主な表現方法は以下の通りです。\n 場所（単一シンボル）   単一シンボルを使用してデータを描画すると、フィーチャの分布状態 (クラスター化されているか分散されているか) を把握し、隠れているパターンを明らかにできます。\n ヒート マップ   ヒート マップはレイヤー内のポイントを使用して、マップ上のポイントの相対的な密度を計算し、寒色 (ポイントの密度が低い) から暖色 (ポイントの密度が高い) まで滑らかに変化する一連の色の配列で表示します。\n 種類（個別値シンボル）   個別値シンボルを使用すると、数値測定の数ではなく、さまざまな種類 (カテゴリ データ) を表示できます。たとえば、さまざまな色を使用して、レストランが提供する料理の種類を表すことができます。レイヤーに表示するカテゴリを 10 種類未満にするのが理想的です。\n 数と量（色）   数値データが存在する場合、色のグラデーションによってフィーチャを区別できます。使用できる色のグラデーションには、さまざまな種類があります。たとえば、薄い色から濃い色に変化する単純な方式は、年齢や収入など、高低を表すデータ値の表示に適しています。\n 数と量（サイズ）   数値データまたはランク付けされたカテゴリを表すために、順序付けできる異なるサイズの並びを使用します。この方法を使用して、ポイント、ライン、およびエリアをすべて描画できます。この比例シンボル マップでは、シンボルが大きいほど大きい数値を表すという直感的な論理を使用します。伝えたい内容を明確に表すようにシンボルのサイズを調整します。たとえば、等級シンボルを使用して、各都市の相対的な人口密度を表示できます。\n 色とサイズ   データ内の 2 つの属性を選択し、マップ上のポイント シンボルの色とサイズを完了します。または、同じ属性を 2 回使用して、強調するデータの部分に基づき、シンボルのサイズを設定し、色を設定できます。これは、一人親の世帯数などの数情報を、貧困率などの比率で陰影処理して表示する場合に適したスタイルです。\n 個別値シンボルとサイズ   学士号を持つ人などの数属性を表示し、郡名など別のフィールドの値ごとに一意の色を使用する場合に使用します。一意の値を持つテキストまたは数値フィールドと、数値フィールドを選択し、必要に応じて、各属性のマップ シンボル設定を調整します。\n A を B と比較   2 つの数値の比率をマッピングして、その関係をパーセンテージまたは単純な比率で表現できます。たとえば、総人口に対する大学の学位を持つ人の比率をマッピングできます。\nスタイリング機能を使った地図データにもとづくグラフィック表現\rアプリ作成/ページ埋め込み 上記ステップまでに作成した Web マップは１つの完結した地図データとして管理が可能です。Web マップには対応する一意の ID が割り当てられており、JavaScript API を使って ID を参照するだけで可視化した地図をそのまま Web ページ上に表示することができます。\nvar webmap = new WebMap({ portalItem: { id: \u0026#34;\u0026lt;Web マップ ID\u0026gt;\u0026#34; } }); var view = new MapView({ map: webmap, container: \u0026#34;viewDiv\u0026#34; }); \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 参照した地図上のデータをスクリプトで取得し、D3.js などのサードパーティのチャート コンポーネントと容易に連携が可能です。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/overview/",
	"title": "概要",
	"tags": [],
	"description": "ArcGIS Maps SDK for JavaScript の概要について紹介します。",
	"content": "出典：ArcGIS Maps SDK for JavaScript-Get started - Overview\nArcGIS Maps SDK for JavaScript を使用してアプリケーションを構築する場合、複数の選択肢があり、それぞれの目的や要件に応じて利点が異なります。小規模なプロジェクトでは、ArcGIS Content Delivery Network (CDN) を利用するのが最適な方法です。最新の JavaScript フレームワークやビルド ツールを使用して構築された大規模または複雑なアプリケーションでは、npm からコンポーネント パッケージをインストールするのが最も良い方法です。\nCDN ArcGIS CDN を使用すると、ローカルにパッケージをインストールしなくても、アプリケーションに SDK の機能を簡単に組み込むことができます。これは、シンプルなアプリケーションや迅速なプロトタイピング、または最適化されたクラウド キャッシングを活用してモジュールのダウンロードを高速化したい場合に最適です。\nnpm より複雑なアプリケーション、特に最新のビルド ツールや React、Vue、Angular のような JavaScript フレームワークでアプリケーションを構築する場合は、JavaScript Maps SDK を npm 経由でインストールすることをお勧めします。これにより、npm のパッケージ管理機能を利用してあらゆるパッケージをプロジェクトの依存関係として管理できるようになり、Webpack や Vite のような最新のビルド ツールとよりシームレスに統合することができます。JavaScript Maps SDK の各コンポーネント パッケージはフレームワークに依存しないように設計されており、ほとんどの JavaScript フレームワークまたはフレームワークなしでも互換性があります。\nCSS SDK をアプリケーションに読み込む方法によっては、追加の CSS リンクを含める必要があります。 CDN からコンポーネントを使用している場合、CSS リンクは自動的に含まれます。 npm を使用している場合は、アプリケーションに CSS ファイルを手動でインポートする必要があります。\nコンポーネント     コンポーネント スタイルシート コア API スタイルシート Calcite スタイルシート     npm マニュアル マニュアル マニュアル   CDN オート マニュアル オート    コア API     コア API スタイルシート Calcite スタイルシート     npm マニュアル オート   CDN マニュアル オート    アクセス トークン 注 : アプリケーションが認証に ArcGIS アイデンティティのみを使用している場合は、このセクションをスキップできます。詳細については、security and authentication documentation を参照してください。\n\rベースマップ、ジオコーディング、ルーティングなどの ArcGIS サービスにアクセスするには、アクセス トークンが必要です。ポータルにアクセスし、特定のニーズに合わせてカスタム権限とリファラを持つアクセス トークンを作成します。チュートリアルやサンプルの説明で必要な場合は、アクセス トークンを含めてください。global API キー だけでなく、特定のクラスでより細かい API キーを使用することもできます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/get-started/",
	"title": "開発の手順",
	"tags": [],
	"description": "ArcGIS Maps SDK for JavaScript の開発におけるインストールとセットアップからの手順について紹介します。",
	"content": "出典：ArcGIS Maps SDK for JavaScript - Get Started\nArcGIS Maps SDK for JavaScript には、コア API と、API の機能をすぐに使用できる UI 要素にカプセル化する Web コンポーネント ライブラリーのセットが含まれています。アプリケーションのニーズに応じて、4 つのコンポーネント ライブラリー（Map、Coding、Charts、Embeddable）のどれからでもコンポーネントを使用することができます。また、SDK は Esri の Calcite Design System と統合され、一貫性のある利用しやすいユーザー エクスペリエンスを提供します。Calcite は、Web コンポーネント、アイコン、配色、デザイン パターンの豊富なライブラリーを含む、完全な UI ツールキットを提供します。\nJavaScript Maps SDK の使い始めは、目的や要件によって異なります。ローカル パッケージをインストールせずにバニラ JavaScript と HTML アプリを構築したい場合は、CDN を利用することができます。より構造化された、またはスケーラブルな Web アプリケーション、特にフロントエンド フレームワークやビルド ツールを使用する場合は、npm で SDK をインストールすることを検討してください。\n コードの例：ArcGIS Maps SDK for JavaScript コア API とマップ コンポーネント テンプレート プロジェクトをチェックして、すぐに始めまられます。\n CDN Vite React Angular Vue   CDN JavaScript Maps SDK は、ArcGIS CDN を使用して、バニラ JavaScript および HTML アプリケーションに簡単に統合できます。このアプローチでは、最適化されたクラウド キャッシングを活用することで、ローカル ビルドの必要性をなくし、SDK の最新バージョンへの更新を容易にします。\nセットアップ はじめに、基本的なHTMLファイルの \u0026lt;head\u0026gt; セクションに、必要なライブラリー スクリプトと CSS リンク タグを以下に示す順番ですべて含めます。\n\u0026lt;!-- Load Calcite Design System --\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;https://js.arcgis.com/calcite-components/3.2.1/calcite.esm.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- Load the JavaScript Maps SDK core API --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.33/esri/themes/light/main.css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.33/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- Load the JavaScript Maps SDK Map components or other component packages --\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;https://js.arcgis.com/4.33/map-components/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; CSS の設定 カスタム CSS を追加して、コンポーネントがアプリケーションで表示されるようにします。これは、CDN から ArcGIS スタイルシートとライブラリーをインポートした後、\u0026lt;head\u0026gt; セクションの最後の項目にする必要があります。\nお好みの CSS スタイルシートと Calcite モードを含めることで、ライトまたはダークのテーマを選択できます。\n\u0026lt;style\u0026gt; html, body { height: 100%; margin: 0; } \u0026lt;/style\u0026gt; レイアウトの作成 2D マップ コンポーネント (または 3D シーン コンポーネント) を HTML の \u0026lt;body\u0026gt; に追加し、ArcGIS Online または ArcGIS Enterprise ポータルの WebMap を使用している場合は、オプションの item-id を割り当てます。\n詳細については、Programming Patterns、チュートリアル Display a web map、およびサンプル Create a 2D map を参照してください。\n\u0026lt;!-- There is no need to programmatically set the basemap, extent or zoom --\u0026gt; \u0026lt;!-- All this information comes from the WebMap --\u0026gt; \u0026lt;arcgis-map item-id=\u0026#34;02b37471d5d84cacbebcccd785460e94\u0026#34;\u0026gt; \u0026lt;arcgis-zoom position=\u0026#34;top-left\u0026#34;\u0026gt;\u0026lt;/arcgis-zoom\u0026gt; \u0026lt;/arcgis-map\u0026gt; 次に、HTML の \u0026lt;body\u0026gt; の下にある \u0026lt;script\u0026gt; タグで、コア API を使用してプロパティを設定や、変更を監視、カスタム JavaScript ロジックを追加することができます。スクリプトが \u0026lt;script type=\u0026quot;module\u0026quot;\u0026gt; としてマークされていることを確認してください。\nコア API からのモジュールは、グローバルな $arcgis.import() メソッドで読み込むことができます。このメソッドは、モジュール パスまたはモジュール パスの配列を受け取り、要求されたモジュールを解決するプロミスを返します。モジュール識別子は、各 API リファレンス ページの上部にあります。 参考までに Graphic をご覧ください。\n$arcgis.import() メソッドは、CDN 経由で使用する場合の ArcGIS Maps SDK for JavaScript 専用であり、標準の ES モジュール システムのネイティブ機能ではありません。\n\r以下のコードは、マップのビューの準備ができるのを待ちます。ビューの準備が整えば、さらに機能を追加することができます。\n\u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; const Graphic = await $arcgis.import(\u0026#34;@arcgis/core/Graphic.js\u0026#34;); const viewElement = document.querySelector(\u0026#34;arcgis-map\u0026#34;); // Wait for the view to be ready before adding additional functionality  await viewElement.viewOnReady(); ... // Create a graphic and add the geometry and symbol to it  const pointGraphic = new Graphic({ geometry: point, // A point geometry  symbol: markerSymbol // A symbol for drawing the point  }) viewElement.graphics.add(pointGraphic); \u0026lt;/script\u0026gt; npm Vite のような最新のビルド ツールや、React、Angular、Vue のような JavaScript フレームワークの場合は、npm のようなパッケージ マネージャー経由で JavaScript Maps SDK をインストールすることをお勧めします。\nセットアップ node.js と npm の最新の長期サポート（LTS）バージョンを使用していることを確認してください。次に、好みのビルド ツールやフレームワークの推奨テンプレートを使ってプロジェクトの大枠を作成します。モジュール バンドラーとローカル Web サーバーを含むクライアント サイド ビルド ツールである Vite には、多くのテンプレート プロジェクトが用意されています。\nプロジェクトでマップ コンポーネントを使用するには、@arcgis/map-components パッケージとその依存関係をインストールします。\nnpm の場合\nnpm install @arcgis/map-components yarn の場合\nyarn add @arcgis/map-components @arcgis/core @esri/calcite-components CSS の設定 CSS スタイルシートは、CDN または /node_modules からローカルに読み込むことができます。CDN を使用すると、ファイルがローカルにバンドルされずに実行時にロードされるため、ディスク上のビルド サイズが最小になります。\nお好みの CSS スタイルシートと Calcite モードを含めることで、ライトまたはダークのテーマを選択できます。SDK はコンポーネントのスタイリングに Calcite を使用しています。 また、Calciteを使って独自のカスタムUIを追加することもできる。\nCDN の場合\n/* Include calcite, core API and SDK component CSS */ @import \u0026#34;https://js.arcgis.com/calcite-components/3.2.1/calcite.css\u0026#34;; @import \u0026#34;https://js.arcgis.com/4.33/@arcgis/core/assets/esri/themes/light/main.css\u0026#34;; @import \u0026#34;https://js.arcgis.com/4.33/map-components/main.css\u0026#34;; #root, html, body { height: 100%; margin: 0; } /node_modules の場合\n/* Include calcite, core API and SDK component CSS */ @import \u0026#34;@esri/calcite-components/dist/calcite/calcite.css\u0026#34;; @import \u0026#34;@arcgis/core/assets/esri/themes/light/main.css\u0026#34;; @import \u0026#34;@arcgis/map-components/dist/cdn/main.css\u0026#34;; #root, html, body { height: 100%; margin: 0; } import の URL パスを指定するパターンは、使用するフレームワークやモジュール バンドラーに依存します。jsapi-resources の GitHub リポジトリーには、様々なフレームワークやモジュール バンドラーの CSS 設定例があります。MDN には、@import を使用する様々なパターンに関する詳細情報も掲載されています。\nレイアウトの作成 Vite + vanilla JavaScript スターター プロジェクトの index.html ファイルに、2D マップ コンポーネント（または 3D シーン コンポーネント）を追加し、main.js ファイルを参照してください。各コンポーネントは、\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; のような他の HTML 要素と同様に、HTML タグを使用してアプリケーションに追加できるカスタム要素です。\n\u0026lt;body\u0026gt; \u0026lt;arcgis-map item-id=\u0026#34;02b37471d5d84cacbebcccd785460e94\u0026#34;\u0026gt; \u0026lt;arcgis-zoom position=\u0026#34;top-left\u0026#34;\u0026gt;\u0026lt;/arcgis-zoom\u0026gt; \u0026lt;/arcgis-map\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;./main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; コンポーネントのインポート 最後に、main.js JavaScript ファイルで、マップ コンポーネントなど、必要な SDK のコンポーネントを個別にインポートします。\nブラウザーの CustomElementRegistry にコンポーネントを登録します。ブラウザーが \u0026lt;arcgis-map\u0026gt;\u0026lt;/arcgis-map\u0026gt; のようなカスタム要素の HTML タグに出会うと、要素のインスタンスを作成し、DOM に追加してその機能を有効にします。\nimport \u0026#34;./index.css\u0026#34;; import \u0026#34;@arcgis/map-components/components/arcgis-map\u0026#34;; import \u0026#34;@arcgis/map-components/components/arcgis-zoom\u0026#34;; import Graphic from \u0026#34;@arcgis/core/Graphic.js\u0026#34;; const viewElement = document.querySelector(\u0026#34;arcgis-map\u0026#34;); // Wait for the view to be ready before adding additional functionality viewElement.addEventListener(\u0026#34;arcgisViewReadyChange\u0026#34;, () =\u0026gt; { ... // Create a graphic and add the geometry and symbol to it  const pointGraphic = new Graphic({ geometry: point, // A point geometry  symbol: markerSymbol // A symbol for drawing the point  }); viewElement.graphics.add(pointGraphic); }); TypeScript TypeScriptは、実行時ではなく開発時にエラーを特定する静的型チェックを提供する強力な言語です。これにより生産性が向上し、トラブルシューティングの時間が短縮されます。TypeScript の定義は、SDK が npm を使ってローカルにインストールされたときに提供される。TypeScript を JavaScript にコンパイルするには、tsconfig.json ファイルを作成して TypeScript コンパイラーを設定する必要がある。プロジェクトのインストール時に tsconfig.json ファイルが自動的に作成された場合は、すべての設定を見直してください。\nコア API の TypeScript デコレーターを使用する場合、例えば Accessor サブクラスを作成するときやベース レイヤーを拡張するときには、後方互換性のために useDefineForClassFields フラグを false に設定する必要があるかもしれません。このフラグの詳細については、TSConfig Referenceを参照してください。\n以下に tsconfig.json の最小例になります。\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json.schemastore.org/tsconfig.json\u0026#34;, // Array of `.ts` files to compile. You can also use glob patterns such as `\u0026#34;src/**/*\u0026#34;`.  \u0026#34;include\u0026#34;: [\u0026#34;src\u0026#34;, \u0026#34;*.ts\u0026#34;], \u0026#34;compilerOptions\u0026#34;: { // When `true`, this allows use of `import` syntax such as `import x from \u0026#39;xyz\u0026#39;`.  \u0026#34;esModuleInterop\u0026#34;: true, // Specify library type definitions to be included in the compilation.  \u0026#34;lib\u0026#34;: [\u0026#34;DOM\u0026#34;, \u0026#34;DOM.Iterable\u0026#34;, \u0026#34;ES2023\u0026#34;], // The module system to use for compilation.  // Here, ES modules are targeted (ESNext) to enable top-level await and dynamic imports.  \u0026#34;module\u0026#34;: \u0026#34;ES2022\u0026#34;, // Respects package.json\u0026#39;s \u0026#34;exports\u0026#34; conditions.  \u0026#34;moduleResolution\u0026#34;: \u0026#34;Bundler\u0026#34;, // Allow importing from JSON files  \u0026#34;resolveJsonModule\u0026#34;: true, // This sets the output at the minimum version of JavaScript features that will be supported.  \u0026#34;target\u0026#34;: \u0026#34;ES2023\u0026#34;, // Improves performance by checking only the .ts files you write  // rather than the .d.ts files from the libraries you are using.  \u0026#34;skipLibCheck\u0026#34;: true, }, } 詳しくは TypeScript の Get Started ガイドをご覧ください。\n\rReact React 19 プロジェクトで JSX を使用して SDK を使用することは、通常の JavaScript と HTML のプロジェクトで SDK を使用することに似ています。主な違いは、JSX の構文と React のプログラミング パターンです。React のようなフレームワークで作業する場合、コンポーネントのライフサイクルとの統合性を高めるために、一般的にはメソッドを直接呼び出すよりもイベントを使用することが推奨されます。\nindex.jsx\nimport { StrictMode } from \u0026#34;react\u0026#34;; import { createRoot } from \u0026#34;react-dom/client\u0026#34;; import \u0026#34;@arcgis/map-components/dist/components/arcgis-map\u0026#34;; import \u0026#34;./index.css\u0026#34;; const root = createRoot(document.getElementById(\u0026#34;root\u0026#34;)); root.render( \u0026lt;StrictMode\u0026gt; \u0026lt;arcgis-map itemId=\u0026#34;45b77c869ba14b6dbc2de43a817304a6\u0026#34; // All events for the SDK\u0026#39;s components in React will start with `onarcgis` onarcgisViewReadyChange={(event) =\u0026gt; { // The view is ready, add additional functionality below  }}\u0026gt; \u0026gt;\u0026lt;/arcgis-map\u0026gt; \u0026lt;/StrictMode\u0026gt;, ); コンポーネントとコア API の両方を使用する方法を示す完全な例については、SDK の React テンプレート プロジェクトを参照してください。\nすでに React 19 プロジェクトで TypeScript を設定しており、TSX で Web コンポーネントを使用したい場合は、メインの .tsx ファイルまたは Vite の vite-env.d.ts ファイルの先頭に1行のコードを書くだけで可能です。\nvite.env.d.ts\n/// \u0026lt;reference types=\u0026#34;@arcgis/map-components/types/react\u0026#34; /\u0026gt; React 18 を使用している場合は、@arcgis/map-components-react パッケージを確認してください。\nAngular SDK の Web コンポーネントは非 Angular 要素です。 これらを Angular コンポーネント内で使用するには、Angular の CUSTOM_ELEMENTS_SCHEMA を設定する必要があります。\napp.ts\nimport { Component, CUSTOM_ELEMENTS_SCHEMA, OnInit } from \u0026#34;@angular/core\u0026#34;; import \u0026#34;@arcgis/map-components/components/arcgis-map\u0026#34;; @Component({ selector: \u0026#34;app-root\u0026#34;, standalone: true, imports: [RouterOutlet], templateUrl: \u0026#34;./app.component.html\u0026#34;, styleUrl: \u0026#34;./app.component.css\u0026#34;, schemas: [CUSTOM_ELEMENTS_SCHEMA], // Set the schema here }) export class AppComponent { arcgisViewReadyChange(event: CustomEvent) { // The view is ready, add additional functionality below  } } app.html の HTML インテリセンスについては、インテリセンスのドキュメントをご覧ください。Angular のようなフレームワークで作業する場合、コンポーネントのライフサイクルとの統合性を高めるために、一般的にはメソッドを直接呼び出すよりもイベントを使用することをお勧めします。\napp.html\n\u0026lt;arcgis-map item-id=\u0026#34;45b77c869ba14b6dbc2de43a817304a6\u0026#34; (arcgisViewReadyChange)=\u0026#34;arcgisViewReadyChange($event)\u0026#34; \u0026gt; \u0026lt;arcgis-zoom position=\u0026#34;top-left\u0026#34;\u0026gt;\u0026lt;/arcgis-zoom\u0026gt; \u0026lt;/arcgis-map\u0026gt; SDK の Angular テンプレート プロジェクトを参照すると、両方のコンポーネントとコア API の操作方法と CSS の設定方法を示す完全なサンプルが得られます。\nアクセス トークン ヒント：アプリケーションで認証に ArcGIS Identities のみを使用している場合は、このセクションをスキップできます。詳しくは、セキュリティと認証のドキュメントを参照してください。\n\rベースマップ、ジオコーディング、ルーティングなどの ArcGIS サービスにアクセスするには、アクセス トークンが必要です。ポータルにアクセスし、特定のニーズに合わせてカスタム権限とリファラーを持つアクセス トークンを作成します。チュートリアルやサンプルの説明で必要な場合は、アクセストークンを含めてください。グローバル API キーだけでなく、特定のクラスでより細かい API キーを使用することもできます。\n追加情報 詳細については、以下のリンクをご参照ください。\n ArcGIS Maps SDK for JavaScript - Tutorials ArcGIS Maps SDK for JavaScript - Programming patterns ArcGIS Maps SDK for JavaScript - Samples ArcGIS Maps SDK for JavaScript - References MDN - JavaScript modules Web Reference - Module Bundlers in JavaScript MDN - Using custom elements MDN - Client-side tooling overview MDN - Package management basics MDN - Introducing a complete toolchain  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/get-dev-account/",
	"title": "開発者アカウントの作成",
	"tags": [],
	"description": "ArcGIS Location Platform の利用を開始するために新規アカウントを作成する手順を紹介します。",
	"content": "開発者アカウントを作成すると、アプリの開発を無償で開始することができます。また、ArcGIS Location Platform が提供するロケーションサービスであるベースマップの利用やジオコーディング サービス (住所⇄緯度経度)、ネットワーク サービス (ルート検索、到達圏解析) などの様々な GIS サービスを利用したり、お手持ちのデータを GIS サービスとして配信したりすることが、無料枠/月の範囲で利用可能です。\nArcGIS Location Platform アカウントの作成 以下の手順で ArcGIS Location Platform の新規アカウントを作成します。アカウントの作成中に問題が発生した場合は、ESRI ジャパンまでお問い合わせください。\n  ArcGIS Location Platform のサイト (英語) にアクセスし、[Sign Up For Free] をクリックします。\n  名前 (※名前には半角英字のみを使用してください)、E メールアドレス、メールの配信に関する設定を入力し [Continue] をクリックします。\n  ユーザー名、パスワード、ポータル URL、組織名、秘密の質問とその答えを入力します。\n  利用規約とプライバシー ポリシーに同意する場合は、同意欄にチェックを入れ、[Next] をクリックします。\n  手順 2 にて入力した、E メールアドレスの受信ボックスに届いた Esri からのメールを開き、メール本文にある [Activeate your account] をクリックします。\n  以上で ArcGIS Location Platform アカウントの作成は完了です。\n従量制プラン ArcGIS Location Platform では、お手持ちのデータを GIS サービスとして配信したりすることが、無料枠/月の範囲で利用可能です。それを超えてサービスを利用する場合に、従量制プラン (Pay as you go) の有効化が必要となります。\n※ 従量制プラン (Pay as you go) を有効化する際には、クレジットカードの情報が必要になります。\n従量制プランの有効化 以下の手順で従量制プランを有効化します。\n ArcGIS Location Platform (https://location.arcgis.com/dashboard/) のサイトでサイン インします。アカウントのメニューから [Billing] をクリックします。  [Payment methods and history] タブの Pay as you go の欄で、[Enable pay as you go] をクリックします。  ポップアップで表示される画面で、クレジットカード情報等の必要な情報を入力し、[Continue] ボタンをクリックします。  table {\rborder-collapse: collapse;\rwidth: 60%;\rmargin-left:auto;\rmargin-right:auto;\r}\rtable, th, td {\rborder: 1px solid black;\r}\r\r   項目 入力内容      Name on Card (カード名義) カード記載の名義人   Credit Card Number (クレジットカード番号) \u0026mdash;- \u0026mdash;- \u0026mdash;- \u0026mdash;- 形式   Expiration Date (有効期限) mm/yy (月/年) 形式   CVV (セキュリティコード：カード裏面の右端３ケタ) \u0026mdash; 形式   Street Address (住所) 例：2-7-1 Hirakawa-Cho   City (市区町村) 例：Chiyoda-Ku   Region (都道府県) 選択形式   Postal Code (郵便番号) 例：1020093   Country (国) 選択形式     表示されている内容を確認し、「I have read and agree to the terms and conditions of this license agreement and agree to pay all fees owed to Esri for use of services based on our publicly available pricing.」のチェックボックスにチェックを入れ、[Enable pay as you go] をクリックします。\n  Pay as you go が有効化されていることを確認します。\n  以上で従量制プランの有効化は完了です。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/get-api-key/",
	"title": "API キーの取得",
	"tags": [],
	"description": "アプリケーションを公開するために必要な API キーを取得する手順について紹介します。",
	"content": "出典：Security and authentication guide - Tutorial: Create an API key\nAPIキーの認証情報を使用してAPIキーを作成し、管理する方法を学びます。\nAPI キーとは API キーは、ArcGIS のセキュアなサービス、コンテンツ、および機能へのアクセスをアプリケーションに許可する、長期間のアクセス トークンです。API キーは、ポータルでホストされているアイテムの一種である API キーの認証情報を使用して生成されます。API キーの認証情報には、API キーを生成し、その権限や有効期限などのプロパティを管理するための設定が含まれています。 API キーの認証情報を作成し、アプリケーションで API キーを使用するプロセスは、API キー認証として知られています。\nこのガイドでは、APIキーの認証情報を作成し、以下のことを行う方法を説明します。\n 長期的な API キーを生成し、アプリケーションに保存 API キーが ArcGIS のサービス、コンテンツ、および機能にアクセスできる権限の設定 API キーの有効期限と参照元 URL の設定 API キーの認証情報のアイテムページを使用した、API キーの管理  API キーの詳細については Introduction to API key authentication (英語) をご参照ください。\n前提条件  ArcGIS Location Platform アカウント、ArcGIS Online アカウント、ArcGIS Enterprise アカウントのいずれかが必要です。ArcGIS Online アカウントおよび ArcGIS Enterprise アカウントの場合は、アカウントに適切なユーザー タイプとロールが設定されている必要があります。詳細については、製品およびアカウントの要件 を参照してください。 API キーに割り当てる権限を把握する必要があります。割り当てられた権限により、アプリケーションは特定の ArcGIS サービスおよびリソースにアクセスできるようになります。詳細は Privileges を参照してください。  API キーの作成手順 ポータルにサイン イン APIキーの認証情報を含むアイテムの作成と管理にはポータルを使用します。\nArcGIS Location Platform  ブラウザで https://location.arcgis.com にアクセスし、ArcGIS Location Platform アカウントでサインインします。ダッシュボードで「My portal」をクリックして、ポータルに移動します。  ArcGIS Online  ArcGIS Online アカウントでポータルにサインインしてください。  ArcGIS Enterprise  ブラウザで、ArcGIS Enterprise ポータルにアクセスし、ArcGIS Enterprise アカウントでポータルにサインインしてください。  API キーの作成  ポータルで、[コンテンツ] \u0026gt; [マイ コンテンツ] \u0026gt; [新しいアイテム] をクリックします。 [開発者の認証情報] \u0026gt; [API キーの認証情報]を選択し、[次へ] をクリックします。  ArcGIS Online アカウントの場合は、アカウントに管理者権限または API キーの生成権限を持つカスタム ロールが設定されている必要があります。詳細については、Limitations を参照してください。\n\r有効期限と参照元 URL の設定 API キーの認証情報は、API キーと呼ばれる長期間のアクセス トークンを生成します。API キーは最大 1 年間有効で、有効期限は生成時に設定されます。また、APIキーに参照元を設定し、許可されたドメインからのみ使用できるように制限することもできます。\n [開発者の認証情報を作成] ウィンドウで、有効期限日をクリックします。アクセス トークンの有効期限を最大 1 年後まで設定できます。  参照元 URL でアクセス トークンを制限したい Web ドメインを設定します。これはセキュリティのために強く推奨されます。参照元の詳細については、API key credentials をご覧ください。  [次へ] をクリックします。  アクセス トークンの有効期限と参照元 URL は、トークンを無効にしない限り変更できません。\n\r権限の選択 API キーの認証情報を設定することで、アクセス トークンの権限を校正できます。アプリケーションでアクセス トークンを正常に機能させるためには、アプリケーションが使用するコンテンツやサービスにアクセスするための適切な権限が必要です。必要な権限を選択して、API キーのアクセス トークンに適用してください。\nトークンに必要な権限は、アプリケーションに必要なコンテンツ、サービス、機能によって異なります。チュートリアルを行う場合は、そのアクセス トークンのセクションで必要な権限のリストを参照してください。\n\r [開発者の認証情報を作成] の [権限] ウィンドウで利用可能な権限を参照します。  開発者の認証情報に権限が表示されない場合は、アカウントに適切な権限が設定されていない可能性があります。前提条件をご確認ください。\n\rアカウントの種類に応じて利用可能なロケーションサービスについては List of privileges をご参照ください。\nアプリケーションに必要な権限を選択し、[次へ] をクリックします。  アイテムの選択 (オプション) アプリケーションが特定のプライベート アイテムへのアクセスを必要とする場合は、開発者の認証情報を設定してアクセスする必要があります。アイテム アクセス メニューでは、ポータルのコンテンツを参照し、API キーに特定のアイテムへのアクセス権限をを付与することができます。\n トークンがアイテムへのアクセス権を必要としない場合は、[スキップ] をクリックします。 そうでない場合は、[アイテムへのアクセス権を付与] ウィンドウで、[アイテムの参照] をクリックします。  アイテムの参照が表示されない場合は、アカウントに適切な権限が設定されていない可能性があります。前提条件をご確認ください。\n\rアクセス権を与えたいアイテムを選択します。このメニューでは最大 100 件まで選択できます。  一般的な権限 \u0026gt; フィーチャ \u0026gt; 編集などの特定の権限は、アカウントに関連するすべてのアイテムへのグローバルアクセスを許可します。このメニューを使用してアイテムへのアクセス権を設定すると、設定した権限が上書きされます。\n\r[アイテムの追加] をクリックします。  アイテムの保存 API キーの認証情報のプロパティを設定した後、API キーを新しいアイテムとして保存できます。\n [開発者の認証情報を作成] ウィンドウで以下のプロパティを設定し、[次へ] をクリックします。  タイトル フォルダー タグ サマリー    [サマリー] ウィンドウで、設定したプロパティ、権限、アイテム アクセス権を確認し、[次へ] をクリックします。  個人範囲の権限は、公開アプリケーションにおいてセキュリティリスクを伴うため、個人用の自動化スクリプトでのみの使用を推奨します。詳細については、Privilege scopes をご参照ください。\n\rAPI キーのコピー  [開発者の認証情報を作成] \u0026gt; [API キーの生成] ウィンドウで、[今すぐ API キーを生成します。 キーをコピーして保存する準備ができました。] を選択します。  [次へ] をクリックします。 表示されたウィンドウから API キーをコピーし、アプリケーションに貼り付けます。  APIキーのアクセス トークンの値にアクセスできるのはこの時だけです。再度アクセスすることはできません。新しいキーを取得するには、API キーのアイテムページを使ってキーを再生成する必要があります。\n\r認証情報の管理 (オプション) API キーのアイテムを作成した後、そのプロパティはアイテム詳細ページに移動していつでも管理できます。設定メニューでは、API キーの以下のプロパティを管理できます。\n セカンダリ API キーの生成 : 同じ認証情報で、同じ権限と新しい有効期限を持つセカンダリ API キーを生成できます。 API キーの再生成 : API キーにアクセスできなくなった場合、新しい有効期限で再生成することができます。 API キーの無効化 : API キーを無効にして、アプリケーションで機能しなくすることができます。 権限の編集 : API キーの認証レベルを調整するために、API キーの認証情報の権限を編集することができます。 アイテムのアクセス権を編集 : API キーの認証情報がアクセス許可されているアイテムを編集することができます。 使用状況の表示 : API キーの使用状況を監視して、サービスの使用状況を追跡し、請求情報を表示することができます。詳しくは、API key credentials をご覧ください。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/python-api-conda/",
	"title": "ArcGIS API for Python のための基礎環境：Conda入門",
	"tags": [],
	"description": "Conda の基本について簡単に紹介します。",
	"content": "出典：ArcGIS API for Python - Understanding Conda\nArcGIS API for Python (以下、Python API) を使用する際、Conda を利用すると Python の環境やパッケージを管理することが容易になります。\n\rConda の基本について説明します。Conda は Python と Python で使用できるライブラリのインストールやバージョンを管理するためのツールです。 Conda を使用する場合、次の 2 つの選択肢があります。\n Anaconda Distribution : Python とデータサイエンス向けの Python パッケージなどを提供するプラットフォームです (以下、Anaconda)。 Miniconda : Anaconda をコンパクトにしたもので、Python、Conda、それらの依存パッケージ、その他の最小限のパッケージをインストールします。ArcGIS Pro をインストールした場合、Miniconda も同時にインストールされます。  Anaconda と Miniconda の詳しい違いは Anaconda or Miniconda (英語) のページをご覧ください。\nConda の基本 Conda を理解する最も簡単な方法は、チュートリアルに取り組むことです。 以下のセクションでは、ArcGIS API for Python を使用するために必要なコマンドの概要について説明します。\nCondaは プラットフォームに依存しないパッケージ マネージャー アプリケーションで、Python パッケージのインストールや更新、削除などを行うことができます。パッケージは、チャネルと呼ばれるさまざまなリポジトリに保存されているソフトウェアとサポートファイルのバンドルです。チャネルは、Anaconda Cloud のようなクラウド ロケーションのデフォルト セットである場合もあれば、個人や組織が作成したプライベート リポジトリである場合もあります。Conda は、パッケージのリストアップやインストールを行う際に、デフォルトのチャネルを検索します。特定のチャネルを検索するように Conda を設定する方法など、詳細については Channels を参照してください。\nEsri は、esri という名前のチャネルに、arcgis パッケージを格納するための Conda リポジトリを作成しています。conda install コマンドのフラグでチャネルにアクセスし、特定の Conda の環境にパッケージをインストールするよう Conda に指示することができます。\n Conda の環境 Conda の環境を作成するとき、特定の Python インタプリターと環境にインストールするパッケージを隔離する物理的なディレクトリを作成します。これにより、Python を含むソフトウェアの異なるバージョンを持つ複数の環境を作ることができます。新しい環境を簡単に作成し、他の環境に影響を与えることなく切り替えることができます。詳細な説明と手順については、Conda のドキュメント Managing environments を参照してください。\nconda をインストールすると、Python のインタープリターと環境にインストールしたパッケージを隔離するディレクトリが作成されます。これにより、Python を含む異なるバージョンのソフトウェアを持つ複数の環境を作成することが可能になります。新しい環境は簡単に作成することができ、他の環境に影響を与えることなくそれらを切り替えて使用することができます。詳細な説明と手順については、環境の管理に関する conda のドキュメント (英語)を参照してください。\n以降では ArcGIS Pro を通じて conda をインストールした場合と、Anaconda でインストールした場合のデフォルトの環境について説明します。\nArcGIS Pro ArcGIS Pro をインストールした後で環境を確認すると、以下の 2 つが作成されています。\n  base\nこの環境には、Miniconda がインストールされています。Miniconda は Anaconda をコンパクトにしたもので、Conda、Python、それらに依存するパッケージ、その他最小限のパッケージのセットを含みます\n  arcgispro-py3\nこの環境には、Python、ArcPy の機能を含む arcgispro パッケージが含まれています。\n  ArcGIS Pro で Conda の環境を管理 ArcGIS Pro の conda の環境は、次の 3 つの方法を使用して管理できます。どの方法でも、それぞれパッケージのインストール、更新、削除などを行うことができます。\n  Python パッケージ マネージャー\nArcGIS Pro プロジェクトタブからアクセス可能な GUI ツール。\n  Python コマンド プロンプト\narcgispro-py3 の環境に直接アクセスしアクティブにするコマンドライン ショートカット。Windows のスタートメニューで Python Command Prompt を検索すると開くことができます。\n  コマンド プロンプト (windows)\n標準の MS-DOS Windows コマンドライン アプリケーション。\n  Anaconda Anaconda をインストールすると Python、conda、その他多数のパッケージが base という 1 つの環境にインストールされます。\nAnaconda で Conda の環境を管理 主に以下の 2 つの方法で conda の環境を管理することができます。\n  ターミナル アプリケーション\n標準的なコマンドライン ターミナル アプリケーション。\n  Anaconda Navigator\nconda の環境を包括的に管理するための GUI アプリケーション。\n   環境のアクティベート Conda には複数の環境があり、環境を利用するためには、対象となる環境をアクティベートする必要があります。以下のコマンドを実行することで対象の環境をアクティベートできます。\n activate \u0026lt;環境名\u0026gt;  詳細については、Activating an environmentを参照してください。\n パッケージの追加 アクティベートした環境に新しいパッケージを追加したい場合は次のコマンドを使用します。\nconda install \u0026lt;パッケージ名\u0026gt;\nまた、--name や --channel オプションを使用して、特定の環境およびチャネルを指定することもできます。\nconda install --name \u0026lt;環境名\u0026gt; --channel \u0026lt;チャネル名\u0026gt; \u0026lt;パッケージ名\u0026gt;\nconda コマンドや他オプションの使用方法の詳細については Managing packages を参照してください。\n IDE の設定 IDE でプロジェクトを始めるには、Python インタプリターへのパスを指定しなければならないことがあります。 Conda 環境を使用する場合、作成する環境ごとに異なる Python インタプリターを使用します。ここでは以下の 2 つのケースが考えられます。\n ArcGis Pro に含まれている Conda 環境を使用する場合\nスタートメニューで Python コマンドプロンプトを検索して開きます。 Anaconda を使用している場合\nスタートメニューで Anaconda プロンプト検索して開きます。  次のように入力すると、マシン上のすべての環境のリストと、その環境で使われている特定の Python インタプリター (python.exe) のディレクトリの場所が表示されます。\n conda info --envs  \rディレクトリ名を入力し、python.exe を追加して、特定の環境の Python インタプリターへの正しいパスを設定します。例えば、上の画像に基づく IDE の arcgispro-py3 環境の正しいインタプリターは次のようになります。\n C:\\Program Files\\ArcGIS\\Pro\\bin\\Python\\envs\\arcgispro-py3\\python.exe  詳細な手順については、Finding your Anaconda Python interpreter path を参照してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/",
	"title": "ArcGIS Experience Builder (Developer Edition)",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) の開発に役立つガイド集です。",
	"content": "ArcGIS Experience Builder (Developer Edition) の開発に役立つガイド集です。\n コア コンセプト\nArcGIS Experience Builder (Developer Edition) のコア コンセプトについて紹介します。\n\r インストール ガイド\nArcGIS Experience Builder (Developer Edition) をインストールする手順を紹介します。\n\r カスタム ウィジェット開発ガイド\nカスタム ウィジェットを開発する手順を紹介します。\n\r デプロイ\nArcGIS Experience Builder (Developer Edition) のデプロイついて説明しています。\n\r チュートリアル\nArcGIS Experience Builder (Developer Edition) のチュートリアルでは、カスタム ウィジェットの作成方法について説明しています。\n\r Web AppBuilder からの移行\nWeb AppBuilder から ArcGIS Experience Builder (Developer Edition) への移行方法について説明しています。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/learn/developer-community/",
	"title": "ArcGIS 開発者コミュニティ",
	"tags": [],
	"description": "ArcGIS 開発者コミュニティ",
	"content": "ESRIジャパンのスタッフが Esri Community 上で開発者、SIer (エスアイヤー)、ポータル管理者向けの技術ブログを発信しています。毎年多くの記事を配信していますので、初めての方は欲しい情報を探す時間が長くなりがちです。年代別にイベント資料やブログ記事を中心に、API/SDK などのカテゴリー別にまとめていますので、参考にしていただければと思います。紹介している内容のレベルの目安として、【基礎】、【応用】 のフラグを付けています。\n2025 年  最新の記事についてはこちらから確認していただけます。  2024 年  マッピング \u0026amp; ロケーション開発 (ArcGIS Developers) 2024 振り返り  2023 年  マッピング \u0026amp; ロケーション開発 (ArcGIS Developers) 2023 振り返り  2022 年  マッピング \u0026amp; ロケーション開発 (ArcGIS Developers) 2022 振り返り  2021 年  マッピング \u0026amp; ロケーション開発 (ArcGIS Developers) 2021 振り返り  2020 年  マッピング \u0026amp; ロケーション開発 (ArcGIS for Developers) 2020 振り返り  2019 年  マッピング \u0026amp; ロケーション開発 (ArcGIS for Developers) 2019 振り返り  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-esrileaflet/",
	"title": "Esri Leaflet",
	"tags": [],
	"description": "Esri leaflet を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。",
	"content": "マップを表示する このチュートリアルでは、Esri Leaflet と ベースマップ レイヤー サービス を使用して、マップを表示する方法を紹介します。\nマップには、ベースマップ レイヤー サービスのベクター タイル ベースマップ レイヤーを使用しています。ベクター タイル ベースマップ レイヤーには、レイヤーをレンダリングするためのスタイル、レイヤー、フォントグリフ(Font Glyphs)、およびアイコンが含まれています。\nこのチュートリアルでは、ベースマップ レイヤー サービスの地形ベースマップ レイヤーを使用して、富士山周辺の地図を作成します。\nマップとレイヤーの詳細については、Mapping and location services のガイドをご覧ください。\n前提条件 このチュートリアルを実施するには、以下が必要です。\n 開発者ダッシュボードにアクセスして API キーを作成するには、開発者アカウントが必要です。アカウントの作成手順については「開発者アカウントの作成」を参照してください。  ステップ 新しい Pen の作成 CodePen にアクセスして、マッピング アプリケーション用の新しい Pen を作成します。\nHTML の作成と各 JS ライブラリへの参照を追加する Leaflet、Esri Leaflet への参照を含む HTML ページを作成します。 これらは、ベクター タイル ベースマップ レイヤーにアクセスして表示するために必要です。\n \u0026lt;head\u0026gt;の中に、ライブラリを参照するための\u0026lt;script\u0026gt;要素を追加します。 \u0026lt;head\u0026gt;に，ページとマップのスタイルを決めるための\u0026lt;style\u0026gt;要素も追加します。 \u0026lt;body\u0026gt;の中に、マップ用の\u0026lt;div\u0026gt;要素を追加します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1,maximum-scale=1,user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Esri Leaflet\u0026lt;/title\u0026gt; \u0026lt;!-- Leaflet の jsライブラリ と css ファイルの参照を追加--\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\u0026#34; crossorigin=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\u0026#34; crossorigin=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- Esri Leaflet の js ライブラリ と ベクタータイル対応の js ライブラリへの参照を追加--\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/esri-leaflet@3.0.12/dist/esri-leaflet.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/esri-leaflet-vector@4.2.3/dist/esri-leaflet-vector.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; body { margin:0; padding:0; } #map { position: absolute; top:0; bottom:0; right:0; left:0; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; マップの表示 \u0026lt;body\u0026gt;要素に、コードを含む\u0026lt;script\u0026gt;要素を追加してマップを作成します。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1,maximum-scale=1,user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Esri Leaflet\u0026lt;/title\u0026gt; \u0026lt;!-- Leaflet の jsライブラリ と css ファイルの参照を追加--\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\u0026#34; crossorigin=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\u0026#34; crossorigin=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- Esri Leaflet の js ライブラリ と ベクタータイル対応の js ライブラリへの参照を追加--\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/esri-leaflet@3.0.12/dist/esri-leaflet.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/esri-leaflet-vector@4.2.3/dist/esri-leaflet-vector.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; body { margin:0; padding:0; } #map { position: absolute; top:0; bottom:0; right:0; left:0; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- Leaflet でのマップの作成 --\u0026gt; \u0026lt;script\u0026gt; const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; const basemapEnum = \u0026#34;arcgis/topographic\u0026#34;; const map = L.map(\u0026#39;map\u0026#39;, { minZoom: 2 }).setView([35.362752, 138.729858], 12); L.esri.Vector.vectorBasemapLayer(basemapEnum, { apiKey: apiKey, language: \u0026#34;ja\u0026#34; }).addTo(map); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; API キーの設定 ロケーションサービスにアクセスするには、API キーまたは OAuth2.0 アクセストークンが必要です。API キーの作成手順については「API キーの取得」を参照してください。\n認証方法とアクセストークンの取得方法の詳細については、「セキュリティと認証」を参照してください。\n  ダッシュボードにアクセスして、Developer credentials から API キーを取得します。このチュートリアルで使用するサービスにアクセスするには API キーを設定する必要があります。\n  CodePen で、キーを使用するため、apiKey を更新します。\n  \u0026lt;script\u0026gt; const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; const basemapEnum = \u0026#34;arcgis/topographic\u0026#34;; const map = L.map(\u0026#39;map\u0026#39;, { minZoom: 2 }).setView([35.362752, 138.729858], 12); L.esri.Vector.vectorBasemapLayer(basemapEnum, { apiKey: apiKey }).addTo(map); \u0026lt;/script\u0026gt; アプリを実行する CodePen で、コードを実行してマップを表示します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/learn/",
	"title": "もっと学ぶ",
	"tags": [],
	"description": "ArcGIS の開発に役立つ情報を配信しています。",
	"content": "　開発に役立つ情報 GitHub   Esri GitHub\n 米国 Esri 社のスタッフが作成したサンプル プログラムを GitHub で共有しています。    Esri Japan GitHub\n 各 API や SDK のサンプルプログラムに加えて、ハンズオンや開発者セミナーで実施内容を GitHub で共有しています。    Esri Community   Esri Community\n 米国 Esri 社が運営する ArcGIS ユーザー コミュニティ サイトです。世界中のユーザーと ArcGIS に関する技術情報を探索・共有することができます。    ArcGIS 開発者コミュニティ\n ESRIジャパンのスタッフが Esri Community 上で開発者、SIer (エスアイヤー)、ポータル管理者向けの技術ブログを発信しています。    Esri Video、Event、Webinar   Esri Video\n 米国 Esri 社のイベント動画サイトもあり、毎年開催されている開発者向けイベント「ESRI Developer Summit」のテクニカルセッションの動画なども公開されています。    GeoDev Events, Webinars, and Meetups\n 米国ESRI の開発者がお届けする Webinar 等も定期的に開催されています。    Learn ArcGIS  Learn ArcGIS  Esri が提供している無償の自習用コンテンツで、実世界の様々な事例をもとにしたレッスンが多数用意されています。    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/android/distribution-android-200.x/",
	"title": "アプリケーション配布ガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for Kotlin を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を紹介します。",
	"content": "ArcGIS Maps SDK for Kotlin (バージョン 200.x) を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を説明します。\nAPI キーの設定 ArcGIS Location Platform のロケーション サービスを使用する場合は、アプリで API キーを設定する必要があります。API キーの詳細はAPI キーの取得を、API キーの設定方法はアプリの作成のAPI キーを設定するをご覧ください。\nライセンス認証のステップ 開発したアプリケーションのライセンス認証のステップは以下の通りです。\n  使用するライセンスの選択\n  ライセンスの認証方法\n Lite ライセンスの認証方法 Basic ライセンスの認証方法 Standard ライセンスの認証方法 Analysis Extension ライセンスの認証方法 Advanced Editing Extension ライセンスの認証方法    ライセンスの認証\n Lite ライセンス キーを使用した認証 配布パックのライセンス キーを使用した認証 指定ユーザー アカウントを使用した認証    使用するライセンスの選択 ArcGIS Maps SDK for Kotlin には Lite、Basic、Standard の 3 つのライセンス レベルと Analysis エクステンションがあります。開発したアプリケーションが使用する機能に応じて、適切なライセンス レベルを選択してください。\n各ライセンスで利用可能な機能の概要は以下の表をご参照ください。\n   ライセンス 利用できる機能     Lite ・地図表示（2D/3D）\n・フィーチャの表示/検索\n・フィーチャのオンライン/オフライン編集（ArcGIS Online/ArcGIS Enterprise のパブリックなフィーチャ サービス、ArcGIS Location Platform のフィーチャサービス）\n・ルート検索/到達圏解析/最寄り施設検索\n・住所検索/リバース ジオコーディング\n・ユーティリティー ネットワークのトレース   Basic ・Lite ライセンスで利用できるすべての機能\n・フィーチャのオンライン/オフライン編集（ArcGIS Online/ArcGIS Enterprise のセキュアなフィーチャ サービス）\n・モバイル ジオデータベースの編集   Standard ・Basic ライセンスで利用できるすべての機能\n・シェープファイルの表示/編集\n・GeoPackage の表示/編集\n・KML（ローカル ファイル）の表示/編集\n・ラスター データの表示/解析\n・航海用電子海図（ENC）の表示\n・3D 解析   Analysis Extension ・Standard ライセンスで利用可能なエクステンション\n・オフラインでの到達圏解析/最寄り施設検索   Advanced Editing Extension ・Basic ライセンス以上で利用可能なエクステンション・ブランチ バージョン ジオデータベースに新しいバージョンの作成・ブランチ バージョン ジオデータベースのバージョンのフィーチャ/テーブルの編集・ユーティリティー ネットワークのネットワーク フィーチャの編集・ユーティリティー ネットワークのトポロジーの検証    ライセンスの詳細はESRIジャパン製品ページをご参照ください。\nライセンスの認証方法 ライセンスの認証は次の2つの方法があります。\n  ライセンス キーを使用した認証\n ライセンスキーを使用した認証は、ArcGIS Runtime の配布パックを購入し、取得したライセンスキーを利用して、アプリケーションを認証します。    指定ユーザーによるアカウント認証\n 指定ユーザーによるアカウント認証とは、ArcGIS Online または ArcGIS Enterprise の組織のメンバーである ArcGIS 組織アカウントを使用してログイン認証を行います。 ログインを行う指定ユーザー アカウントのタイプによって関連付けられたライセンスのレベルが異なります。    指定ユーザーのユーザー タイプとライセンス レベルの対比表    ユーザー タイプ ライセンス レベル     Viewer Lite   Contributor / Mobile Worker Basic   Creator Standard   Professional / Professional Plus Advanced ※1    ※1 ArcGIS Maps SDK for Kotlin には Advanced ライセンスはありません。\nLite ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Lite のライセンスキーを取得する必要があります 認証の方法は、Lite ライセンス キーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Lite ライセンス レベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Basic ライセンスの認証方法   ライセンス キーを使用した認証\n ArcGIS Runtime Basic の配布パックを購入する必要があります 認証の手順は、配布パックのライセンス キーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Basic ライセンス レベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Standard ライセンスの認証方法   ライセンス キーを使用した認証\n ArcGIS Runtime Standard の配布パックを購入する必要があります 認証の手順は、配布パックのライセンス キーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、Portal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Standard ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Analysis Extension ライセンスの認証方法   ライセンス キーを使用した認証\n ArcGIS Runtime Analysis Extension の配布パックを購入する必要があります 認証の手順は、配布パックのライセンス キーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、Portal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Analysis アドオン ライセンスを割り当てられた）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Advanced Editing Extension ライセンスの認証方法   ライセンス キーを使用した認証\n ArcGIS Runtime Advanced Editing Extension の配布パックを購入する必要があります 認証の手順は、配布パックのライセンス キーを使用した認証をご参照ください    Portal for ArcGIS へのログインによる認証\n注意：この認証は、ArcGIS Enterprise 11.1 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに Portal for ArcGIS の指定ユーザー アカウント（Advanced Editing ユーザー タイプ エクステンションを割り当てられた）が必要です アプリケーションが少なくとも 30 日に 1 回は Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    ライセンスの認証 以下の認証に応じた作業を行ってください。\nLite ライセンス キーを使用した認証 ArcGIS Runtime Lite のライセンス キーを Esri Developer のサイトから取得し、取得したライセンス キーを利用して、アプリケーションを Lite ライセンスで認証することができます。 最初に以下の手順で Lite レベルのライセンス キーを取得します。\n  Get a license ページにアクセスします\n ArcGIS Location Platform アカウント、または、ArcGIS Online アカウントにサインインしてない場合は、いずれかのアカウントでサインインします。 いずれかのアカウントもお持ちでない場合は、ArcGIS Location Platform アカウントに サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。    表示されたライセンス キーをコピーします   次に、アプリケーションのコードにおいて SDK の機能が呼び出される前に、以下のコードを使用してアプリケーションにコピーしたライセンス キーを設定します。\n// 取得したライセンス文字列でアプリのライセンスを設定します val licenseKey = LicenseKey.create(\u0026#34;runtimelite,1000,rud#########,day-month-year,####################\u0026#34;) ?: return showError(\u0026#34;Null license key. \u0026#34;) val licenseResult = ArcGISEnvironment.setLicense(licenseKey)   配布パックのライセンス キーを使用した認証 ArcGIS Runtime の配布パックを購入し、取得したライセンス キーを利用して、アプリケーションを認証することができます。\nArcGIS Runtime の配布パックの購入についてはESRIジャパンにお問合せください。ArcGIS Runtime の配布パックをご購入頂いた場合、ESRIジャパンよりライセンス キーをメールにてお送りします。\nアプリケーションのコードにおいて ArcGIS Runtime SDK の機能が呼び出される前に、以下のコードを使用して配布パックのライセンス キーを設定します。\n// 取得したライセンス文字列でアプリのライセンスを設定します val licenseKey = LicenseKey.create(\u0026#34;runtimestandard,1000,rud#########,day-month-year,####################\u0026#34;) ?: return showError(\u0026#34;Null license key. \u0026#34;) val licenseResult = ArcGISEnvironment.setLicense(licenseKey) Extension ライセンスを認証する場合は以下のコードを使用します。\n// 基本ライセンスとエクステンション ライセンスのリストを設定します val licenseKey = LicenseKey.create(\u0026#34;runtimestandard,1000,rud#########,day-month-year,####################\u0026#34;) ?: return showError(\u0026#34;Null license key. \u0026#34;) val licenseExtensions = listOf( LicenseKey.create(\u0026#34;runtimeanalysis,1000,rud#########,day-month-year,####################\u0026#34;) ?: return showError(\u0026#34;Null license key. \u0026#34;) ) val licenseResult = ArcGISEnvironment.setLicense(licenseKey, licenseExtensions) 指定ユーザー アカウントを使用した認証 アプリケーションの実行時に、アプリケーションを利用するユーザーが保有する ArcGIS Online 組織向けプランもしくは Portal for ArcGIS の指定ユーザー アカウントを使用して ArcGIS Online / Portal for ArcGIS にログインすることで、ライセンスを取得することができます。\nアプリケーションのコードにおいて SDK の機能が呼び出される前に、ライセンスを取得・設定します。以下のコードは、ArcGIS Online の指定ユーザーのライセンスを取得する方法を示しています。\n認証方法の詳細については、「How to use user authentication in your app（英語）」や「Security and authentication（英語）」も併せてご覧ください。\n// クレデンシャルを使用してポータル（ArcGIS Online）に接続します。 val portal = Portal.arcGISOnline(Portal.Connection.Authenticated) lifecycleScope.launch { portal.load().getOrElse { error -\u0026gt; return@launch showError(\u0026#34;Error loading portal: ${error.message}\u0026#34;) } // ポータルから LicenseInfo を取得します  val licenseInfo:LicenseInfo = portal.fetchLicenseInfo().getOrElse { error -\u0026gt; return@launch showError(\u0026#34;Error fetching licenseInfo: ${error.message}\u0026#34;) } // ライセンス情報を使用してアプリのライセンスを認証します  val licenseResult = ArcGISEnvironment.setLicense(licenseInfo) showLicenseResult(licenseResult) } ライセンス情報をローカルストレージに保存した場合、保存したライセンス情報を使用して、オフライン環境でアプリを起動してライセンスを取得できます。ストレージからライセンスを取得し、アプリを認証します。\n// LicenseInfo を JSON 形式のテキストとして取得します val licenseJson = licenseInfo.toJson() // ... テキスト文字列をローカルに保存します ...  // (起動時) ... デバイスに保存されているライセンス JSON を取得します ... // 保存した JSON 文字列からライセンス情報を設定します val licenseInfoFromJson = LicenseInfo.fromJsonOrNull(licenseJson) "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/dotnet/distribution-dotnet-200.x/",
	"title": "アプリケーション配布ガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for .NET を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を紹介します。",
	"content": "ArcGIS Maps SDK for .NET (バージョン 200.x) を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を説明します。\nAPI キーの設定 ArcGIS Location Platform のロケーションサービスを使用する場合は、アプリで API キーを設定する必要があります。API キーの詳細はAPI キーの取得を、API キーの設定方法はアプリの作成のAPI キーを設定するをご参照ください。\nライセンス認証のステップ 開発したアプリケーションのライセンス認証のステップは以下の通りです。\n  使用するライセンスの選択\n  ライセンスの認証方法\n Lite ライセンスの認証方法 Basic ライセンスの認証方法 Standard ライセンスの認証方法 Advanced ライセンスの認証方法 Analysis Extension ライセンスの認証方法 Advanced Editing Extension ライセンスの認証方法    ライセンスの認証\n Lite ライセンス キーを使用した認証 配布パックのライセンス キーを使用した認証 指定ユーザー アカウントを使用した認証    使用するライセンスの選択 ArcGIS Maps SDK for .NET には Lite、Basic、Standard、Advanced の 4 つのライセンス レベルと Analysis エクステンションがあります。開発したアプリケーションが使用する機能に応じて、適切なライセンス レベルを選択してください。\n各ライセンスで利用可能な機能の概要は以下の表をご参照ください。\n   ライセンス 利用できる機能     Lite ・地図表示（2D/3D）\n・フィーチャの表示/検索\n・フィーチャのオンライン/オフライン編集（ArcGIS Online/ArcGIS Enterprise のパブリックなフィーチャ サービス、ArcGIS Location Platform のフィーチャ サービス）\n・ルート検索/到達圏解析/最寄り施設検索\n・住所検索/リバース ジオコーディング\n・ユーティリティー ネットワークのトレース   Basic ・Lite ライセンスで利用できるすべての機能\n・フィーチャのオンライン/オフライン編集（ArcGIS Online/ArcGIS Enterprise のセキュアなフィーチャ サービス）\n・モバイル ジオデータベースの編集   Standard ・Basic ライセンスで利用できるすべての機能\n・シェープファイルの表示/編集\n・GeoPackage の表示/編集\n・KML の表示/編集（ローカル ファイル）\n・ラスター データの表示/解析\n・航海用電子海図（ENC）の表示\n・3D 解析\n・ローカル サーバーの標準的な機能   Advanced ・Standard ライセンスで利用できるすべての機能\n・ローカル サーバーの高度な機能   Analysis Extension ・Standard ライセンス以上で利用可能なエクステンション・オフラインでの到達圏解析/最寄り施設検索\n・ローカル サーバーの高度な機能   Advanced Editing Extension ・Basic ライセンス以上で利用可能なエクステンション・ブランチ バージョン ジオデータベースに新しいバージョンの作成・ブランチ バージョン ジオデータベースのバージョンのフィーチャ/テーブルの編集・ユーティリティー ネットワークのネットワーク フィーチャの編集・ユーティリティー ネットワークのトポロジーの検証    ライセンスの詳細はESRIジャパン製品ページをご参照ください。\nライセンスの認証方法 ライセンスの認証は次の2つの方法があります。\n  ライセンス キーを使用した認証\n ライセンス キーを使用した認証は、ArcGIS Runtime の配布パックを購入し、取得したライセンスキーを利用して、アプリケーションを認証します。    指定ユーザーによるアカウント認証\n 指定ユーザーによるアカウント認証とは、ArcGIS Online または ArcGIS Enterprise の組織のメンバーである ArcGIS 組織アカウントを使用してログイン認証を行います。 ログインを行う指定ユーザー アカウントのタイプによって関連付けられたライセンスのレベルが異なり、また認証はアプリにコードを含める必要があります。    指定ユーザーのユーザー タイプとライセンス レベルの対比表    ユーザー タイプ ライセンス レベル     Viewer Lite   Contributor / Mobile Worker Basic   Creator Standard   Professional / Professional Plus Advanced    Lite ライセンスの認証方法   ライセンス キーを使用した認証\n ArcGIS Runtime Lite のライセンスキーを取得する必要があります 認証の方法は、Lite ライセンス キーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Lite ライセンス レベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Basic ライセンスの認証方法   ライセンス キーを使用した認証\n ArcGIS Runtime Basic の配布パックを購入する必要があります 認証の手順は、配布パックのライセンス キーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Basic ライセンス レベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Standard ライセンスの認証方法   ライセンス キーを使用した認証\n ArcGIS Runtime Standard の配布パックを購入する必要があります 認証の手順は、配布パックのライセンス キーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、Portal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Standard ライセンス レベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Advanced ライセンスの認証方法   ライセンス キーを使用した認証\n ArcGIS Runtime Advanced の配布パックを購入する必要があります 認証の手順は、配布パックのライセンス キーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、Portal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Advanced ライセンス レベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Analysis Extension ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Analysis Extension の配布パックを購入する必要があります 認証の手順は、配布パックのライセンス キーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、Portal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Analysis アドオン ライセンスを割り当てられた）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Advanced Editing Extension ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Advanced Editing Extension の配布パックを購入する必要があります 認証の手順は、配布パックのライセンス キーを使用した認証をご参照ください    Portal for ArcGIS へのログインによる認証\n注意：この認証は、ArcGIS Enterprise 11.1 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに Portal for ArcGIS の指定ユーザー アカウント（Advanced Editing ユーザー タイプ エクステンションを割り当てられた）が必要です アプリケーションが少なくとも 30 日に 1 回は Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    ライセンスの認証 以下の認証に応じた作業を行ってください。\nLite ライセンス キーを使用した認証 ArcGIS Runtime Lite のライセンス キーを Esri Developer のサイトから取得し、取得したライセンス キーを利用して、アプリケーションを Lite ライセンスで認証することができます。 最初に以下の手順で Lite レベルのライセンス キーを取得します。\n  Get a license ページにアクセスします\n ArcGIS Location Platform アカウント、または、ArcGIS Online アカウントにサインインしてない場合は、いずれかのアカウントでサインインします。 いずれかのアカウントもお持ちでない場合は、ArcGIS Location Platform アカウントに サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。    表示されたライセンス キーをコピーします   次に、アプリケーションのコードにおいて SDK の機能が呼び出される前に、以下のコードを使用してアプリケーションにコピーしたライセンス キーを設定します。\n// 取得したライセンス文字列でアプリのライセンスを設定します string licenseKey = \u0026#34;runtimelite,1000,rud#########,none,####################\u0026#34;; ArcGISRuntimeEnvironment.SetLicense(licenseKey);   配布パックのライセンス キーを使用した認証 ArcGIS Runtime の配布パックを購入し、取得したライセンス キーを利用して、アプリケーションを認証することができます。\nArcGIS Runtime の配布パックの購入についてはESRIジャパンにお問合せください。ArcGIS Runtime の配布パックをご購入頂いた場合、ESRIジャパンよりライセンス キーをメールにてお送りします。\nアプリケーションのコードにおいて SDK の機能が呼び出される前に、以下のコードを使用して配布パックのライセンスキーを設定します。\n// 取得したライセンス文字列でアプリのライセンスを設定します string licenseKey = \u0026#34;runtimelite,1000,rud#########,day-month-year,####################\u0026#34;; ArcGISRuntimeEnvironment.SetLicense(licenseKey); Analysis Extension ライセンスを認証する場合は以下のコードを使用します。\n// 基本ライセンスとエクステンション ライセンスのリストを設定します string licenseKey = \u0026#34;runtimelite,1000,rud#########,day-month-year,####################\u0026#34;; string[] extensions = { \u0026#34;runtimeanalysis,1000,rud#########,day-month-year,####################\u0026#34; }; Esri.ArcGISRuntime.ArcGISRuntimeEnvironment.SetLicense(licenseKey, extensions); 指定ユーザー アカウントを使用した認証 アプリケーションの実行時に、アプリケーションを利用するユーザーが保有する ArcGIS Online 組織向けプランもしくは Portal for ArcGIS の指定ユーザー アカウントを使用して ArcGIS Online / Portal for ArcGIS にログインすることで、ライセンスを取得することができます。\nアプリケーションのコードにおいて SDK の機能が呼び出される前に、ライセンスを取得・設定します。以下のコードは、ArcGIS Online の指定ユーザーのライセンスを取得する方法を示しています。コードの前半で、ArcGIS Online ポータルを登録し、チャレンジ ハンドラーと OAuth 認証ハンドラーを設定することによって、AuthenticationManager を構成します。（Authentication Manager の使用を参照）\n認証方法の詳細については、「How to use user authentication in your app（英語）」や「Security and authentication（英語）」も併せてご覧ください。\n// ポータルの認証情報をユーザーに要求します (arcgis.com の OAuth 認証情報のリクエスト) CredentialRequestInfo loginInfo = new CredentialRequestInfo(); // OAuth の暗黙的なグラント フローを使用します loginInfo.GenerateTokenOptions = new GenerateTokenOptions { TokenAuthenticationType = TokenAuthenticationType.OAuthImplicit }; // 認証する URL（ポータル）を指定します（ArcGIS Online） loginInfo.ServiceUri = new Uri(\u0026#34;http://www.arcgis.com/sharing/rest\u0026#34;); try { // AuthenticationManager の GetCredentialAsync を呼び出し、チャレンジ ハンドラーを起動します  Credential cred = await AuthenticationManager.Current.GetCredentialAsync(loginInfo, false); AuthenticationManager.Current.AddCredential(cred); // 認証情報を使用してポータル（ArcGIS Online）に接続します  ArcGISPortal arcgisPortal = await ArcGISPortal.CreateAsync(loginInfo.ServiceUri); // ポータルから LicenseInfo を取得します  LicenseInfo licenseInfo = await arcgisPortal.GetLicenseInfoAsync(); // ... アプリをオフラインにするためにライセンス（JSON 文字列）を保存したり、すぐにアプリを認証するためにコードをここに記述します ...  // ライセンス情報を使ってアプリを認証します  ArcGISRuntimeEnvironment.SetLicense(licenseInfo); } catch (Exception ex) { // 例外処理を記述します。  Console.WriteLine(\u0026#34;ライセンス認証中の例外:\u0026#34; + ex); } ライセンス情報をローカル ストレージに保存した場合、保存したライセンス情報を使用して、オフライン環境でアプリを起動してライセンスを取得できます。ストレージからライセンスを取得し、アプリを認証します。\n// LicenseInfo を JSON 形式のテキストとして取得します string licenseJson = licenseInfo.ToJson(); // ... テキスト文字列をローカルに保存します ...  // (起動時) ... デバイスに保存されているライセンス JSON を取得します ... // 保存した JSON 文字列からライセンス情報を設定します LicenseInfo license = LicenseInfo.FromJson(licenseJson); "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/flutter/distribution-flutter-200.x/",
	"title": "アプリケーション配布ガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for Flutter を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を紹介します。",
	"content": "ArcGIS Maps SDK for Flutter (バージョン 200.x) を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を説明します。\nAPI キーの設定 ArcGIS Location Platform のロケーション サービスを使用する場合は、アプリで API キーを設定する必要があります。API キーの詳細はAPI キーの取得を、API キーの設定方法はアプリの作成のAPI キーを設定するをご覧ください。\nライセンス認証のステップ 開発したアプリケーションのライセンス認証のステップは以下の通りです。\n  使用するライセンスの選択\n  ライセンスの認証方法\n Lite ライセンスの認証方法 Basic ライセンスの認証方法 Standard ライセンスの認証方法 Analysis Extension ライセンスの認証方法 Advanced Editing Extension ライセンスの認証方法    ライセンスの認証\n Lite ライセンス キーを使用した認証 配布パックのライセンス キーを使用した認証 指定ユーザー アカウントを使用した認証    使用するライセンスの選択 ArcGIS Maps SDK for Flutter には Lite、Basic、Standard の 3 つのライセンス レベルと Analysis エクステンションがあります。開発したアプリケーションが使用する機能に応じて、適切なライセンス レベルを選択してください。\n各ライセンスで利用可能な機能の概要は以下の表をご参照ください。\n   ライセンス 利用できる機能     Lite ・地図表示（2D/3D）\n・フィーチャの表示/検索\n・フィーチャのオンライン/オフライン編集（ArcGIS Online/ArcGIS Enterprise のパブリックなフィーチャ サービス、ArcGIS Location Platform のフィーチャサービス）\n・ルート検索/到達圏解析/最寄り施設検索\n・住所検索/リバース ジオコーディング\n   Basic ・Lite ライセンスで利用できるすべての機能\n・フィーチャのオンライン/オフライン編集（ArcGIS Online/ArcGIS Enterprise のセキュアなフィーチャ サービス）\n・モバイル ジオデータベースの編集   Standard ・Basic ライセンスで利用できるすべての機能\n・シェープ ファイルの表示/編集\n・GeoPackage の表示/編集\n・ラスター データの表示/解析\n   Analysis Extension ・Standard ライセンスで利用可能なエクステンション\n・オフラインでの到達圏解析/最寄り施設検索   Advanced Editing Extension ・Basic ライセンス以上で利用可能なエクステンション・ブランチ バージョン ジオデータベースに新しいバージョンの作成・ブランチ バージョン ジオデータベースのバージョンのフィーチャ/テーブルの編集    ライセンスの詳細は ESRIジャパン製品ページをご参照ください。\nライセンスの認証方法 ライセンスの認証は次の2つの方法があります。\n  ライセンス キーを使用した認証\n ライセンス キーを使用した認証は、ArcGIS Runtime の配布パックを購入し、取得したライセンス キーを利用して、アプリケーションを認証します。    指定ユーザーによるアカウント認証\n 指定ユーザーによるアカウント認証とは、ArcGIS Online または ArcGIS Enterprise の組織のメンバーである ArcGIS 組織アカウントを使用してログイン認証を行います。 ログインを行う指定ユーザー アカウントのタイプによって関連付けられたライセンスのレベルが異なります。    指定ユーザーのユーザー タイプとライセンス レベルの対比表    ユーザー タイプ ライセンス レベル     Viewer Lite   Contributor / Mobile Worker Basic   Creator Standard   Professional / Professional Plus Advanced ※1    ※1 ArcGIS Maps SDK for Flutter には Advanced ライセンスはありません。\nLite ライセンスの認証方法   ライセンス キーを使用した認証\n ArcGIS Runtime Lite のライセンス キーを取得する必要があります 認証の方法は、Lite ライセンス キーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Lite ライセンス レベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Basic ライセンスの認証方法   ライセンス キーを使用した認証\n ArcGIS Runtime Basic の配布パックを購入する必要があります 認証の手順は、配布パックのライセンス キーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Basic ライセンス レベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Standard ライセンスの認証方法   ライセンス キーを使用した認証\n ArcGIS Runtime Standard の配布パックを購入する必要があります 認証の手順は、配布パックのライセンス キーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、Portal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Standard ライセンス レベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Analysis Extension ライセンスの認証方法   ライセンス キーを使用した認証\n ArcGIS Runtime Analysis Extension の配布パックを購入する必要があります 認証の手順は、配布パックのライセンス キーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、Portal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Analysis アドオン ライセンスを割り当てられた）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Advanced Editing Extension ライセンスの認証方法   ライセンス キーを使用した認証\n ArcGIS Runtime Advanced Editing Extension の配布パックを購入する必要があります 認証の手順は、配布パックのライセンス キーを使用した認証をご参照ください    Portal for ArcGIS へのログインによる認証\n注意：この認証は、ArcGIS Enterprise 11.1 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに Portal for ArcGIS の指定ユーザー アカウント（Advanced Editing ユーザー タイプ エクステンションを割り当てられた）が必要です アプリケーションが少なくとも 30 日に 1 回は Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    ライセンスの認証 以下の認証に応じた作業を行ってください。\nLite ライセンス キーを使用した認証 ArcGIS Runtime Lite のライセンス キーを Esri Developer のサイトから取得し、取得したライセンス キーを利用して、アプリケーションを Lite ライセンスで認証することができます。 最初に以下の手順で Lite レベルのライセンス キーを取得します。\n Get a license ページにアクセスします  ArcGIS Location Platform アカウント、または、ArcGIS Online アカウントにサインインしてない場合は、いずれかのアカウントでサインインします。 いずれかのアカウントもお持ちでない場合は、ArcGIS Location Platform アカウントに サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。   表示されたライセンス キーをコピーします  次に、アプリケーションのコードにおいて SDK の機能が呼び出される前に、以下のコードを使用してアプリケーションにコピーしたライセンス キーを設定します。  // 取得したライセンス文字列でアプリのライセンスを設定します ArcGISEnvironment.setLicenseUsingKey( \u0026#39;runtimelite,1000,rud#########,day-month-year,####################\u0026#39;, ); 配布パックのライセンス キーを使用した認証 ArcGIS Runtime の配布パックを購入し、取得したライセンス キーを利用して、アプリケーションを認証することができます。\nArcGIS Runtime の配布パックの購入についてはESRIジャパンにお問合せください。ArcGIS Runtime の配布パックをご購入頂いた場合、ESRIジャパンよりライセンス キーをメールにてお送りします。\nアプリケーションのコードにおいて ArcGIS Runtime SDK の機能が呼び出される前に、以下のコードを使用して配布パックのライセンス キーを設定します。\n// 取得したライセンス文字列でアプリのライセンスを設定します ArcGISEnvironment.setLicenseUsingKey( \u0026#39;runtimelite,1000,rud#########,day-month-year,####################\u0026#39;, ); Extension ライセンスを認証する場合は以下のコードを使用します。\n// 基本ライセンスとエクステンション ライセンスのリストを設定します ArcGISEnvironment.setLicenseUsingKey( \u0026#39;runtimelite,1000,rud#########,day-month-year,####################\u0026#39;, extensions: [ \u0026#39;runtimeanalysis,1000,rud#########,day-month-year,####################\u0026#39;, \u0026#39;another license extension code\u0026#39;, ], ); 指定ユーザー アカウントを使用した認証 アプリケーションの実行時に、アプリケーションを利用するユーザーが保有する ArcGIS Online 組織向けプランもしくは Portal for ArcGIS の指定ユーザー アカウントを使用して ArcGIS Online / Portal for ArcGIS にログインすることで、ライセンスを取得することができます。\nアプリケーションのコードにおいて SDK の機能が呼び出される前に、ライセンスを取得・設定します。以下のコードは、ArcGIS Online の指定ユーザーのライセンスを取得する方法を示しています。\n認証方法の詳細については、「How to use user authentication in your app（英語）」も併せてご覧ください。\n// クレデンシャルを使用してポータル（ArcGIS Online）に接続します。 const url = \u0026#39;https://myportal.com\u0026#39;; final portal = Portal(Uri.parse(url), connection: PortalConnection.authenticated); // ポータルをロードします。 await portal.load(); // ポータルからメンバーのライセンス情報を取得します。 final licenseInfo = await portal.fetchLicenseInfo(); // メンバーの licenseInfo を使用してライセンスを設定します。 final licenseResult = ArcGISEnvironment.setLicenseUsingInfo(licenseInfo); ライセンス情報をローカル ストレージに保存した場合、保存したライセンス情報を使用して、オフライン環境でアプリを起動してライセンスを取得できます。ストレージからライセンスを取得し、アプリを認証します。\n// LicenseInfo を JSON 形式のテキストで取得します。 final licenseJson = licenseInfo.toJson(); // ... JSONをデバイスに保存します ...  // ... 起動時に、デバイスに保存されているライセンス JSON を取得します ... // 取得した JSON からライセンス情報を設定します。 final licenseInfoFromJson = LicenseInfo.fromJson(licenseJson); "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/ios/distribution-ios-200.x/",
	"title": "アプリケーション配布ガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for Swift を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を紹介します。",
	"content": "ArcGIS Maps SDK for Swift (バージョン 200.x) を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を説明します。\nAPI キーの設定 ArcGIS Location Platform のロケーション サービスを使用する場合は、アプリで API キーを設定する必要があります。API キーの詳細は API キーの取得を、API キーの設定方法はアプリの作成の API キーを設定するをご覧ください。\nライセンス認証のステップ 開発したアプリケーションのライセンス認証のステップは以下の通りです。\n  使用するライセンスの選択\n  ライセンスの認証方法\n Lite ライセンスの認証方法 Basic ライセンスの認証方法 Standard ライセンスの認証方法 Analysis Extension ライセンスの認証方法 Advanced Editing Extension ライセンスの認証方法    ライセンスの認証\n Lite ライセンス キーを使用した認証 配布パックのライセンス キーを使用した認証 指定ユーザー アカウントを使用した認証    使用するライセンスの選択 ArcGIS Maps SDK for Swift には Lite、Basic、Standard の 3 つのライセンス レベルと Analysis エクステンションがあります。開発したアプリケーションが使用する機能に応じて、適切なライセンス レベルを選択してください。\n各ライセンスで利用可能な機能の概要は以下の表をご参照ください。\n   ライセンス 利用できる機能     Lite ・地図表示（2D/3D）\n・フィーチャの表示/検索\n・フィーチャのオンライン/オフライン編集（ArcGIS Online/ArcGIS Enterprise のパブリックなフィーチャ サービス、ArcGIS Location Platform のフィーチャサービス）\n・ルート検索/到達圏解析/最寄り施設検索\n・住所検索/リバース ジオコーディング\n・ユーティリティー ネットワークのトレース   Basic ・Lite ライセンスで利用できるすべての機能\n・フィーチャのオンライン/オフライン編集（ArcGIS Online/ArcGIS Enterprise のセキュアなフィーチャ サービス）\n・モバイル ジオデータベースの編集   Standard ・Basic ライセンスで利用できるすべての機能\n・シェープファイルの表示/編集\n・GeoPackage の表示/編集\n・KML（ローカル ファイル）の表示/編集\n・ラスター データの表示/解析\n・航海用電子海図（ENC）の表示\n・3D 解析   Analysis Extension ・Standard ライセンスで利用可能なエクステンション・オフラインでの到達圏解析/最寄り施設検索   Advanced Editing Extension ・Basic ライセンス以上で利用可能なエクステンション・ブランチ バージョン ジオデータベースに新しいバージョンの作成・ブランチ バージョン ジオデータベースのバージョンのフィーチャ/テーブルの編集・ユーティリティー ネットワークのネットワーク フィーチャの編集・ユーティリティー ネットワークのトポロジーの検証    ライセンスの詳細はESRIジャパン製品ページをご参照ください。\nライセンスの認証方法 ライセンスの認証は次の2つの方法があります。\n  ライセンス キーを使用した認証\n ライセンス キーを使用した認証は、ArcGIS Runtime の配布パックを購入し、取得したライセンス キーを利用して、アプリケーションを認証します。    指定ユーザーによるアカウント認証\n 指定ユーザーによるアカウント認証とは、ArcGIS Online または ArcGIS Enterprise の組織のメンバーである ArcGIS 組織アカウントを使用してログイン認証を行います。 ログインを行う指定ユーザー アカウントのタイプによって関連付けられたライセンスのレベルが異なります。    指定ユーザーのユーザー タイプとライセンス レベルの対比表    ユーザー タイプ ライセンス レベル     Viewer Lite   Contributor / Mobile Worker Basic   Creator Standard   Professional / Professional Plus Advanced ※1    ※1 ArcGIS Maps SDK for Swift には Advanced ライセンスはありません。\nLite ライセンスの認証方法   ライセンス キーを使用した認証\n ArcGIS Runtime Lite のライセンス キーを取得する必要があります 認証の手順は、Lite ライセンス キーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Lite ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Basic ライセンスの認証方法   ライセンス キーを使用した認証\n ArcGIS Runtime Basic の配布パックを購入する必要があります 認証の手順は、配布パックのライセンス キーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Basic ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Standard ライセンスの認証方法   ライセンス キーを使用した認証\n ArcGIS Runtime Standard の配布パックを購入する必要があります 認証の手順は、配布パックのライセンス キーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、Portal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Standard ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Analysis Extension ライセンスの認証方法   ライセンス キーを使用した認証\n ArcGIS Runtime Analysis Extension の配布パックを購入する必要があります 認証の手順は、配布パックのライセンス キーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、Portal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Analysis アドオン ライセンスを割り当てられた）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Advanced Editing Extension ライセンスの認証方法   ライセンス キーを使用した認証\n ArcGIS Runtime Advanced Editing Extension の配布パックを購入する必要があります 認証の手順は、配布パックのライセンス キーを使用した認証をご参照ください    Portal for ArcGIS へのログインによる認証\n注意：この認証は、ArcGIS Enterprise 11.1 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに Portal for ArcGIS の指定ユーザー アカウント（Advanced Editing ユーザー タイプ エクステンションを割り当てられた）が必要です アプリケーションが少なくとも 30 日に 1 回は Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    ライセンスの認証 以下の認証に応じた作業を行ってください。\nLite ライセンス キーを使用した認証 ArcGIS Runtime Lite のライセンスキーを Esri Developer のサイトから取得し、取得したライセンス キーを利用して、アプリケーションを Lite ライセンスで認証することができます。 最初に以下の手順で Lite レベルのライセンス キーを取得します。\n  Get a license ページにアクセスします\n ArcGIS Location Platform アカウント、または、ArcGIS Online アカウントにサインインしてない場合は、いずれかのアカウントでサインインします。 いずれかのアカウントもお持ちでない場合は、ArcGIS Location Platform アカウントに サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。    表示されたライセンス キーをコピーします。   次に、アプリケーションのコードにおいて SDK の機能が呼び出される前に、以下のコードを使用してアプリケーションにコピーしたライセンス キーを設定します。\n// 取得したライセンス文字列でアプリのライセンスを設定します guard let licenseKey = LicenseKey(\u0026#34;runtimelite,1000,rud#########,none,####################\u0026#34;) else { return } do { let result = try ArcGISEnvironment.setLicense(with: licenseKey) print(\u0026#34;License Result : \\(result.licenseStatus)\u0026#34;) } catch { print(error) }   配布パックのライセンス キーを使用した認証 ArcGIS Runtime の配布パックを購入し、取得したライセンス キーを利用して、アプリケーションを認証することができます。\nArcGIS Runtime の配布パックの購入についてはESRIジャパンにお問合せください。ArcGIS Runtime の配布パックをご購入頂いた場合、ESRIジャパンよりライセンス キーをメールにてお送りします。\nアプリケーションのコードにおいて SDK の機能が呼び出される前に、以下のコードを使用して配布パックのライセンス キーを設定します。\n// 取得したライセンス文字列でアプリのライセンスを設定します guard let licenseKey = LicenseKey(\u0026#34;runtimestandard,1000,rud#########,day-month-year,####################\u0026#34;) else { return } do { let result = try ArcGISEnvironment.setLicense(with: licenseKey) print(\u0026#34;License Result : \\(result.licenseStatus)\u0026#34;) } catch { print(error) } Extension ライセンスを認証する場合は以下のコードを使用します。\n// 基本ライセンスとエクステンション ライセンスのリストを設定します let licenseKey = LicenseKey(\u0026#34;runtimestandard,1000,rud#########,day-month-year,####################\u0026#34;)! let extensions = [ LicenseKey(\u0026#34;runtimeanalysis,1000,rud#########,day-month-year,####################\u0026#34;)! ] do { let result = try ArcGISEnvironment.setLicense( with: licenseKey, extensions: extensions ) } catch { print(error) } 指定ユーザー アカウントを使用した認証 アプリケーションの実行時に、アプリケーションを利用するユーザーが保有する ArcGIS Online 組織向けプランもしくは Portal for ArcGIS の指定ユーザー アカウントを使用して ArcGIS Online / Portal for ArcGIS にログインすることで、ライセンスを取得することができます。\nアプリケーションのコードにおいて SDK の機能が呼び出される前に、ライセンスを取得・設定します。以下のコードは、ArcGIS Online の指定ユーザーのライセンスを取得する方法を示しています。\n認証方法の詳細については、「How to use user authentication in your app（英語）」や「Security and authentication（英語）」も併せてご覧ください。\n// Portal クラスを構築し、指定ユーザーが認証情報を提供することを確認します。 let url = URL(string: \u0026#34;https://myportal.com\u0026#34;)! // 指定ユーザーが認証情報でログインすることを要求します。 let portal = Portal(url: url, connection: .authenticated) // ポータルをロードします。 do { try await portal.load() // ポータルからユーザーのライセンス情報を取得します。 let licenseInfo = try await portal.licenseInfo // 指定ユーザーの licenseInfo を使用してライセンスを設定します。 let result = try ArcGISEnvironment.setLicense(from: licenseInfo) // これでアプリはライセンス認証されました。 // キーチェーン アイテムを作成し、ライセンス情報を保存して、アプリをオフラインで起動してライセンスを取得できるようにします。 let licenseInfoData = licenseInfo.toJSON().data(using: .utf8)! let label = \u0026#34;com.your_org.your_app_name\u0026#34;.data(using: .utf8)! let keychainItem: [String: Any] = [kSecClass as String: kSecClassKey, kSecAttrLabel as String: label, kSecValueData as String: licenseInfoData, kSecUseDataProtectionKeychain as String: true] let status = SecItemAdd(keychainItem as CFDictionary, nil) } catch { print(error) } "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/development-guide/",
	"title": "カスタム ウィジェット開発ガイド",
	"tags": [],
	"description": "カスタム ウィジェットを開発する手順を紹介します。",
	"content": "はじめに このガイドについて このガイドは ArcGIS Web AppBuilder (Developer Edition) （以下、Web AppBuilder）で使用するカスタム ウィジェットを作成する方法を説明します。\nWeb AppBuilder のインストール方法に関しては、ArcGIS Web AppBuilder (Developer Edition) インストールガイドをご参照ください。\nまた Esri Japan GitHub では、Web AppBuilder のカスタム ウィジェット/テーマが共有されています。このガイドで作成するウィジェットの完成版も公開されています。\n既成ウィジェットのソースコードの確認 Web AppBuilder で使われる全てのウィジェットは \u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\client\\stemapp\\widgets に格納されていて、ソースコードを確認できます。開発したカスタム ウィジェットも同様にこのディレクトリに配置します。\n上記ディレクトリにある samplewidgets フォルダーには簡易機能のサンプル ウィジェットが用意されています（本ガイドではウィジェット作成の雛形となるコードが記述されたテンプレートである CustomWidgetTemplate を使用します）。\nウィジェットのフォルダー構成 カスタム ウィジェットを作成する際に使用するファイルは以下です。全ファイルが必須ではなく、ウィジェットの UI を設ける、ウィジェットをローカライズする、設定画面を設ける等の目的に応じてファイルを準備します。\nカスタム ウィジェットの開発 1. ウィジェット ボタンを配置する Web AppBuilder のウィジェットは2 種類に分けられます。1 つは「描画」ウィジェットのようなパネルを表示して使用するウィジェットです（Web AppBuilder では In-Panel ウィジェットと呼びます）。もう 1 つは、「現在位置」ウィジェットのように画面上にボタンのみを配置するパネルを表示しないウィジェットです（Off-Panel ウィジェットと呼びます）。\n本ガイドでは簡単なバッファー検索を行う In-Panel ウィジェットを開発していきます。ウィジェットを追加するには \u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\client\\stemapp\\widgets にウィジェットのフォルダーを配置します。\n`\\client\\stemapp\\widgets\\samplewidgets` にある `CustomWidgetTemplate` フォルダーを `\\client\\stemapp\\widgets` にコピーします。\r`CustomWidgetTemplate` フォルダーの名前を `Buffer` に変えます。\nフォルダー名は半角英数字である必要があります。\n\r`Buffer` フォルダー直下にある `manifest.json` ファイルを開きます。\r`name` 属性の値を `Buffer` に変更します。\r文字コードに UTF8 を指定して、`manifest.json` ファイルを保存します。 以降で紹介する手順においてもファイルを保存する際は、文字コードを UTF8 に指定して保存するようにしてください。\r\rmanifest.json ウィジェットの名前やバージョンなどのウィジェットの属性を設定するファイルです。properties 属性でカスタム ウィジェットのプロパティを構成できます。inPanel を false に設定すると Web AppBuilder のウィジェットの追加画面に表示されなくなります。ウィジェットのプロパティについてはWidget manifestをご参照ください。\nWeb AppBuilder のウィジェットの追加画面で表示されるウィジェット名をローカライズします。ウィジェットのローカライズは `Buffer` フォルダーの直下にある `nls` フォルダーで設定します。`Buffer\\nls` フォルダーにある `strings.js` ファイルを開き、以下のコードを入力し保存します。 define({\rroot: ({\r_widgetLabel: \"Buffer\"\r}),\r\"ja\": 1\r});\r\r`nls` フォルダー直下に `ja` フォルダーを作成します。\r`ja` フォルダーに `strings.js` ファイルを作成し、以下のコードを入力し保存します。 define({\r_widgetLabel: \"バッファー検索\"\r});\r\rWeb AppBuilder を起動してアプリケーションを作成すると、ウィジェットの追加画面に「バッファー検索」というウィジェットが新しく表示されます。\n※ 作成する Web アプリに表示するウィジェット名は Web AppBuilder のウィジェット構成画面で変更可能です。\r\r\rnls フォルダー カスタム ウィジェットを多言語化する場合に使用します（アクセスするブラウザーのロケールにより該当する言語が表示されます）。_widgetLabel はウィジェット追加時に表示されるラベルをローカライズするための固有の属性です。\n使用例\n nls\\strings.js：「Widget.html」でローカライズするストリングを指定  define({ root: ({ label1: \u0026#34;Hello\u0026#34; }), \u0026#34;ja\u0026#34;: 1 // 日本語ロケールを使用する場合に 1 と設定 });  nls\\ja\\strings.js：各言語フォルダーにある strings.js ファイルで表示する文字を設定  define({ label1: \u0026#34;こんにちは\u0026#34; });  Widget.html：文字を表示  \u0026lt;label\u0026gt;${nls.label1}\u0026lt;/label\u0026gt; images\\icon.png カスタム ウィジェットのボタンのアイコンを変更したい場合は、このファイルを置き換えます。\n2. ウィジェットの構成画面を作成する Web AppBuilder でウィジェットの構成を行う画面を作成します。ここでは検索に使用するバッファーの距離単位を設定する画面を作成します。\n  Buffer フォルダーに setting フォルダーを作成します。\n  setting フォルダーに Setting.html ファイルを作成し、以下のコードを入力します。\n  \u0026lt;div\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;td\u0026gt;距離単位\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;div\u0026gt; \u0026lt;select data-dojo-attach-point=\u0026#34;selectLengthUnit\u0026#34; data-dojo-type=\u0026#34;dijit/form/Select\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;kilometers\u0026#34; selected=\u0026#34;selected\u0026#34;\u0026gt;キロメートル\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;meters\u0026#34;\u0026gt;メートル\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; setting フォルダーに Setting.js ファイルを作成し、以下のコードを入力します。  define([ \u0026#39;dojo/_base/declare\u0026#39;, \u0026#39;dijit/_WidgetsInTemplateMixin\u0026#39;, \u0026#39;jimu/BaseWidgetSetting\u0026#39;, \u0026#39;esri/units\u0026#39;, \u0026#39;dijit/form/Select\u0026#39; ], function(declare, _WidgetsInTemplateMixin, BaseWidgetSetting, esriUnits) { return declare([BaseWidgetSetting, _WidgetsInTemplateMixin], { baseClass: \u0026#39;jimu-widget-buffer-setting\u0026#39;, startup: function() { this.inherited(arguments); if (!this.config.measurement) { this.config.measurement = {}; } this.setConfig(this.config); }, setConfig: function(config) { this.config = config; if (this.config.measurement.LengthUnit) { this.selectLengthUnit.set(\u0026#39;value\u0026#39;, this.config.measurement.LengthUnit); } else { // デフォルトで表示される単位をキロメートルに設定  this.selectLengthUnit.set(\u0026#39;value\u0026#39;, \u0026#39;kilometers\u0026#39;); this.config.measurement.UnitLabel = \u0026#39;キロメートル\u0026#39;; } }, getConfig: function() { // ユーザーが単位を変更した時に config.json にその値を格納  this.config.measurement.LengthUnit = this.selectLengthUnit.value; // ウィジェットのパネルに表示する単位ラベルに使用  if (this.config.measurement.LengthUnit === \u0026#39;kilometers\u0026#39;) { this.config.measurement.UnitLabel = \u0026#39;キロメートル\u0026#39;; } else { this.config.measurement.UnitLabel = \u0026#39;メートル\u0026#39;; } return this.config; } }); }); Buffer フォルダーの config.json ファイルを開き、以下のコードを入力します。  { \u0026#34;measurement\u0026#34;: {} } Buffer\\manifest.json を開き hasSettingLocale と hasSettingStyle 属性を false にします。\nsetting フォルダーに css や nls フォルダーを作成することで、構成画面用のスタイル定義、ローカライズが可能ですが、ここでは使用しないため false にします。 ブラウザーを更新して、バッファー検索ウィジェットを追加すると、ウィジェットの構成画面が表示されます。\n変更を反映するために Web AppBuilder を再起動（Node.js の再起動およびブラウザーで Web AppBuilder を更新）する必要がある場合があります。   Setting\\Setting.html Web AppBuilder でウィジェットの設定を行う画面を作成します。\nSetting\\Setting.js Web AppBuilder でウィジェットの設定を行う際の処理を実装します。jimu/BaseWidgetSetting の子クラスを作成し、baseClass に jimu-widget-\u0026lt;ウィジェット名\u0026gt;-setting を指定します。以下のイベントが用意されています。\n setConfig：設定画面の初期化時 getConfig：設定変更時（変更内容を config.json のオブジェクトに格納）  config.json JSON 形式のオブジェクト格納ファイルです。Web AppBuilder でウィジェットの設定を行う場合は、config.json に用意した空のオブジェクトに値を格納して、 Widget.html や Widget.js からそのオブジェクトを取得します。 3. ウィジェットの処理を実装する   Buffer フォルダーにある Widget.html ファイルを開き編集します。バッファーの半径（inputNode）とマップ上にあるレイヤーから検索対象のレイヤーを選択（layerSelectNode）する画面を作成します。\n\u0026lt;div\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;半径を入力（${config.measurement.UnitLabel}）\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;input class=\u0026#34;jimu-input\u0026#34; data-dojo-attach-point=\u0026#34;inputNode\u0026#34; value=\u0026#34;1000\u0026#34;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;検索レイヤーを選択\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;div data-dojo-attach-point=\u0026#34;layerSelectNode\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt;   Buffer フォルダーにある Widget.js ファイルを開き編集します。\n  define([ \u0026#39;dojo/_base/declare\u0026#39;, \u0026#39;dojo/_base/lang\u0026#39;, \u0026#39;jimu/BaseWidget\u0026#39;, \u0026#39;jimu/LayerStructure\u0026#39;, \u0026#39;esri/geometry/geometryEngine\u0026#39;, \u0026#39;esri/symbols/SimpleMarkerSymbol\u0026#39;, \u0026#39;esri/symbols/SimpleLineSymbol\u0026#39;, \u0026#39;esri/symbols/SimpleFillSymbol\u0026#39;, \u0026#39;esri/Color\u0026#39;, \u0026#39;esri/graphic\u0026#39;, \u0026#39;esri/tasks/query\u0026#39;, \u0026#39;dijit/form/Select\u0026#39; ], function(declare, lang, BaseWidget, LayerStructure, geometryEngine, SimpleMarkerSymbol, SimpleLineSymbol, SimpleFillSymbol, Color, Graphic, Query, Select) { return declare([BaseWidget], { baseClass: \u0026#39;jimu-widget-buffer\u0026#39;, ckickfunction: null, layerList: null, layerId: null, // スタートアップ時に実行されるメソッド  startup: function() { this.inherited(arguments); // マップ上のレイヤーを取得し、レイヤー一覧を作成  var options = []; var layerStructure = LayerStructure.getInstance(); layerStructure.traversal(function(layerNode) { layerNode.getLayerType() .then(function(type) { if (type === \u0026#39;FeatureLayer\u0026#39;) { var option = { value: layerNode.id, label: layerNode.title }; options.push(option); } }) .catch(function(err) { console.log(err); }); }); this.layerList = new Select({ options: options }, this.layerSelectNode); this.layerList.startup(); // レイヤー一覧を変更したときのイベント  this.layerList.on(\u0026#34;change\u0026#34;, lang.hitch(this, function(val) { this.layerId = val; })); }, // ウィジェットのパネルを開くときに実行されるメソッド  onOpen: function() { this.inherited(arguments); // マップをクリックしたときのイベント ハンドラ  this.ckickfunction = this.map.on(\u0026#34;click\u0026#34;, lang.hitch(this, this._clickHandler)); }, // ウィジェットのパネルを閉じるときに実行されるメソッド  onClose: function() { this.inherited(arguments); // マップに表示されているグラフィックを削除  this.map.graphics.clear(); // マップのクリック イベントを削除  this.ckickfunction.remove(); }, // マップのクリック イベント  _clickHandler: function(evt) { // マップ コンストラクタを取得  var map = this.map; // マップに表示されているグラフィックを削除  map.graphics.clear(); // inputNode に入力された半径の値を取得  var distance = this.inputNode.value; // ウィジェット構成時に設定した半径の単位を config.json から取得  var unit = this.config.measurement.LengthUnit; // クリック地点から指定した半径のバッファーを作成  var bufferGeometry = geometryEngine.buffer(evt.mapPoint, distance, unit); // 作成したバッファーをマップに表示  var sfs = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASHDOT, new Color([255, 0, 0]), 2), new Color([255, 255, 0, 0.25])); var graphic = new Graphic(bufferGeometry, sfs); map.graphics.add(graphic); // バッファー内のフィーチャを検索  var query = new Query(); query.geometry = graphic.geometry; query.spatialRelationship = Query.SPATIAL_REL_CONTAINS; // マップからレイヤー ID を指定してフィーチャ レイヤーを取得  var layer = map.getLayer(this.layerId); // フィーチャ レイヤーに対してクエリを実行  layer.queryFeatures(query) .then(function(featureSet) { // ポイント、ライン、ポリゴンごとにシンボルを設定  var highlightSymbol; if (layer.geometryType == \u0026#34;esriGeometryPoint\u0026#34;) { highlightSymbol = new SimpleMarkerSymbol(); highlightSymbol.setColor(new Color(\u0026#34;#f00\u0026#34;)); highlightSymbol = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE, 16, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([255, 0, 0]), 1), new Color([255, 0, 0, 0.5])); } else if (layer.geometryType == \u0026#34;esriGeometryPolyline\u0026#34;) { highlightSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([255, 0, 0, 0.5]), 6); } else { highlightSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([255, 0, 0]), 3), new Color([125, 125, 125, 0.5])); } // 結果を表示  featureSet.features.forEach(function(feature) { var queryGraphic = new Graphic(feature.geometry, highlightSymbol); map.graphics.add(queryGraphic); }); }); } }); }); Web AppBuilder で新しくアプリケーションを作成します。 Web AppBuilder でフィーチャ サービスをレイヤーとして追加した Web マップを表示します（このウィジェットはフィーチャ レイヤーに対してバッファー検索を行います）。 バッファー検索ウィジェットを追加し、バッファー検索ウィジェットのボタンをクリックして、半径とレイヤーを設定します。\n マップ上をクリックすると、バッファー内にあるフィーチャがハイライト表示されます。\n  Widget.html ウィジェットの画面を作成します。Web AppBuilder には、デフォルトでいくつかの css クラスが含まれており、アプリのデザインを統一させることができます。各クラスの詳細は css ファイル（jimu.js/css/jimu.css）を参照ください。\n使用例：\n\u0026lt;input class=\u0026#34;jimu-input\u0026#34; data-dojo-attach-point=\u0026#34;inputNode\u0026#34; value=\u0026#34;10000\u0026#34;\u0026gt;\u0026lt;/input\u0026gt; css\\style.css Widget.html のスタイル定義ファイルです。\n使用例：\njimu-widget-\u0026lt;ウィジェット名\u0026gt; div:first-child { color: red; } Widget.js ウィジェットの機能を実装するファイルです。jimu/BaseWidget の子クラスを作成し、\u0026quot;baseClass\u0026quot; に jimu-widget-\u0026lt;ウィジェット名\u0026gt; を指定します。\n\u0026quot;baseClass\u0026quot; は、ウィジェットの css クラスとして適用されるためスタイルの競合を避けることができ、スタイルを定義する際に役立ちます。\nウィジェットのプロパティ Web AppBuilder で表示しているマップには map プロパティを使用してアクセスします。\n使用例：\n Widget.js：  this.mapIdNode.innerHTML = \u0026#39;マップのID：\u0026#39; + this.map.id;  Widget.html：  \u0026lt;div data-dojo-attach-point=\u0026#34;mapIdNode\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; その他に利用可能なプロパティは以下です。\n id label icon uri position config（config.json のオブジェクト） appConfig（アプリの構成ファイルのオブジェクト） folderUrl state（ウィジェットの状態：\u0026quot;opened\u0026quot;、\u0026quot;closed\u0026quot; または \u0026quot;active\u0026quot;） windowState（ウィジェット ウィンドウの状態：\u0026quot;normal\u0026quot;、\u0026quot;minimized\u0026quot; または \u0026quot;maximized\u0026quot;） started（ウィジェットの起動状態） name baseClass templateString  ウィジェットのメソッド ウィジェットは、読み込みやウィジェットの開閉などのイベントの発生で実行されるメソッドが定義されています（ウィジェット ライフサイクル）。このメソッド内に処理を追加することで、ウィジェットをカスタマイズしていきます。\n例えば、ウィジェットが開かれた時に処理を実行するには onOpen メソッドを使用します。\n使用例：\nonOpen: function() { var map = this.map; // ... } その他に利用可能なメソッドは以下です。\n onOpen onClose onNormalize onMinimize onMaximize onActive onDeActive onSignIn onSignOut onPositionChange  利用可能な Dojo のウィジェット Web AppBuilder では Dojo Toolkit が提供しているウィジェット（dijit）を使用することができます。\nさらに、Web AppBuilder 独自のウィジェット（jimu.js/dijit）も提供されています。\nヘルプに使用方法は記載されていませんが、Web AppBuilder に含まれている以下のウィジェットも使用できます。\n CheckBox RadioBtn DrawBox ColorPicker Popup ImageChooser TabContainer ExtentChooser Message LayerFieldChooser PopupConfig SymbolChooser  nls ウィジェットで表示されるメニューを多言語化する場合に使用します。ウィジェット名をローカライズした方法と同様の手順でローカライズできます。\nウィジェットの更新 Web AppBuilder に追加する場合 \u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\client\\stemapp\\widgets にフォルダーを配置します。ウィジェットの構成用ファイルを更新した場合は、ブラウザーで Web AppBuilder を更新することで、更新内容が Web AppBuilder に反映されます。\n※ 更新前に作成したアプリケーションには更新内容は反映されません。新たに設置したカスタム ウィジェットを利用したい場合は、新たにアプリケーションを作成する必要があります。\nダウンロードした Webアプリケーションに追加する場合 ダウンロードしたアプリケーションの widgets フォルダーの直下にカスタム ウィジェットのフォルダーを配置し、アプリケーションのルート フォルダーにある config.json の widgetOnScreen（マップ上に表示）または widgetPool（ツールバー上に表示）セクションの widgets 属性にウィジェットの参照先等を設定します。\nwidgetPool にウィジェットを追加する例：\n{ \u0026#34;name\u0026#34;: \u0026#34;\u0026lt;ウィジェット名\u0026gt;\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;\u0026lt;アプリで表示する名前\u0026gt;\u0026#34;, \u0026#34;uri\u0026#34;: \u0026#34;widgets/\u0026lt;ウィジェット名\u0026gt;/Widget\u0026#34; } ウィジェット開発時の Tips Web AppBuilder では新規にアプリケーションを作成するときに、\u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\client\\stemapp\\widgets フォルダーに配置されたウィジェットが読み込まれます。作成済みの既存アプリケーションには、ウィジェットの更新内容は反映されないため、ウィジェットを更新する度に新規にアプリケーションを作成する作業が発生してしまい、非常に面倒です。\n開発段階でウィジェットの更新や動作確認を行うには、以下の手順が便利です。\n Web AppBuilder で新規にアプリケーションを作成します。 \u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\server\\apps フォルダーを開きます。このフォルダーには Web AppBuilder で作成したアプリケーションが配置されています。\nフォルダー名にはアプリケーションの作成順に数字が割り当てられます。\n 手順1で作成したアプリケーションのフォルダーを開き、ウィジェットの構成ファイルを更新します。アプリケーション名は、各アプリケーションのルート フォルダーにある config.json ファイルに記載された JSON の title 属性で確認できます。\n Web AppBuilder で該当するアプリケーションを開きます。既に開いている場合はブラウザーを更新します。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/calcite-design-system/core-concepts/",
	"title": "コア コンセプト",
	"tags": [],
	"description": "Web コンポーネントを活用するための基本的な概念とパターンを学びます。",
	"content": "出典：Calcite Design System - core concepts\nCalcite コンポーネントは、最小限のコードで Web アプリケーションを構築するための、再利用可能な Web コンポーネントのライブラリーです。Calcite コンポーネントを使用すると、ブランドに沿った、軽量でアクセスしやすい Web アプリケーションを素早く構築できます。\nWeb コンポーネントはブラウザーのネイティブ規格であり、Calcite コンポーネントで開発するために必要な技術的概念の多くは、このライブラリー特有のものではありません。このページでは、効果的なに必要な、主要な Web コンセプトを紹介します。さらに詳しい情報について、このページで紹介されるすべての概念は、MDN Web Docs やその他の Web 標準ドキュメントで確認できます。\nカスタム要素 カスタム要素は、Web コンポーネント標準の一部であり、HTML と任意の JavaScript ライブラリーや Web フレームワークを使用して、モダンなブラウザーで動作します。カスタム要素は機能をカプセル化するため、他のコードとの競合を防ぐことができます。\nCalcite Components はカスタム要素であり、ネイティブの HTML 要素と同様に使用することができます。例えば以下のように記述します。\n\u0026lt;calcite-action-bar layout=\u0026#34;horizontal\u0026#34;\u0026gt;\u0026lt;/calcite-action-bar\u0026gt; スロット スロットは、スロット名を参照することで独自のコンテンツを追加できるプレースホルダー要素です。スロットは Web コンポーネントの一般的な概念であり、すでに使用している可能性があります。例えば、次の HTML を見てみましょう。\n\u0026lt;select\u0026gt; \u0026lt;option value=\u0026#34;platypus\u0026#34;\u0026gt;Platypus\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;sloth\u0026#34;\u0026gt;Sloth\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;armadillo\u0026#34;\u0026gt;Nine-banded armadillo\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; Web コンポーネントの用語では、option 要素は select のデフォルト スロットに配置されます。さらに、「Platypus」、「Sloth」、「Nine-banded armadillo」のテキストは、それぞれの option 要素のデフォルト スロットに配置されます。\nCalcite コンポーネントの多くもデフォルト スロットを利用しています。例えば、以下の calcite-action-bar では、calcite-action 要素がデフォルト スロットに追加されています。\n\u0026lt;calcite-action-bar layout=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;calcite-action text=\u0026#34;Add\u0026#34; icon=\u0026#34;plus\u0026#34; text-enabled\u0026gt;\u0026lt;/calcite-action\u0026gt; \u0026lt;calcite-action text=\u0026#34;Save\u0026#34; icon=\u0026#34;save\u0026#34; text-enabled\u0026gt;\u0026lt;/calcite-action\u0026gt; \u0026lt;calcite-tooltip slot=\u0026#34;expand-tooltip\u0026#34;\u0026gt;Toggle Action Bar\u0026lt;/calcite-tooltip\u0026gt; \u0026lt;/calcite-action-bar\u0026gt; 多くの場合、デフォルト スロットだけで十分です。しかし、コンポーネントが複雑になるにつれて、子要素の配置やスタイルを個別に調整する必要が出てきます。そこで登場するのが「名前付きスロット」です。上の例では、calcite-tooltip が calcite-action-bar の expand-tooltip スロットに配置されています。これにより、ツールチップがデフォルト スロット内の要素とは異なる方法で処理されるべきであることがコンポーネントに伝えられます。\nコンポーネントにスロットがある場合、calcite-card のスロットのようにドキュメントに記載されています。スロットの詳細については MDN を参照してください。\nShadow DOM カスタム要素はカプセル化されており、マークアップ構造、スタイル、動作がページ上の他のコードから隠され、分離されます。Shadow DOM はカスタム要素をカプセル化する仕組みです。その結果、Shadow DOM は Web コンポーネントの DOM 要素を隠して分離するため、ブラウザー上にレンダリングされますが、他のコードと衝突することはありません。\nShadow DOM によるカプセル化はアプリケーション全体で一貫したスタイルと機能を維持し、ユーザーに統一されたユーザー体験を提供します。\nCSS 変数 Calcite コンポーネントでは、スタイルを上書きするための CSS 変数が提供されています。Web コンポーネントの Shadow DOM により、CSS 変数なしでは簡単にスタイルを変更することができません。色やタイポグラフィーなど、デザイン システム全体で使用されるトークンには CSS 変数が用意されています。\nさらに、一部の Calcite コンポーネントにはコンポーネント固有のスタイルを変更ための CSS 変数も用意されています。これらの CSS 変数は calcite-loader の CSS 変数のようにコンポーネントのドキュメントから確認できます。\n使用例としては、calcite-notice において、CSS 変数を使って表面色とテキスト色を入れ替えることが挙げられます。\ncalcite-notice { --calcite-ui-foreground-1: #151515; --calcite-ui-text-1: #ffffff; } CSS カスタムプロパティ（変数）の使用 に、機能の詳細が説明されています。\nコンポーネントのロード Web コンポーネントは、最初はシンプルな HTML 要素として始まり、その実装がブラウザーで定義されるとすぐにアップグレードされます。Calcite コンポーネントは、アプリケーションにインポートされ、使用すると自動的に定義されます。しかし、特定のコードを実行する前に、コンポーネントが定義されるのを待つ必要がある場合もあります。\nハイドレーション Calcite コンポーネントには、コンポーネントおよびそのすべての子コンポーネントのハイドレーションが完了した際にフラグを追加するオプションが提供されています。これは、様々なコンポーネントが非同期に読み込まれ、レンダリングされる際に、スタイルの適用前に一瞬表示されてしまうフラッシュ（FOUC）を防ぐことができます。\nCalcite コンポーネントでは、ハイドレーションが完了すると calcite-hydrated 属性がコンポーネントに追加されます。この属性はアプリケーションをデバッグする際に便利です。\n定義された際の挙動 (whenDefined) フレームワークを使っている場合や、\u0026lt;script type=\u0026ldquo;module\u0026rdquo;\u0026gt; を読み込んでいる場合は、whenDefined() メソッドを使用する必要はありません。\n\rcustomElementRegistry インターフェイスの whenDefined() メソッドは、指定された要素が定義された際に解決される Promise を返します。\nこの Promise が解決された後に、そのコンポーネントの定義を必要とするコードを実行することができます。例えば、次のように記述します。\ncustomElements.whenDefined(\u0026#34;calcite-button\u0026#34;).then(() =\u0026gt; document.querySelector(\u0026#34;calcite-button\u0026#34;).setFocus()); コンポーネントの準備 コンポーネントがレンダリングされたタイミングを判断するには、componentOnReady() メソッドを使用できます。このメソッドは、コンポーネントがレンダリングされた後に解決される Promise を返します。コンポーネントのメソッドを使用する前や、あるコンポーネントが別のコンポーネントに依存している場合には、対象のコンポーネントが読み込まれていることを確認することが推奨されます。\n例えば、他のコンポーネントのレンダリングが完了するまで calcite-loader を表示しておきたい場合などです。\nawait document.querySelector(\u0026#34;calcite-alert\u0026#34;).componentOnReady(); document.querySelector(\u0026#34;calcite-loader\u0026#34;).hidden = true; フレームワークを使用している場合や \u0026lt;script type=\u0026ldquo;module\u0026rdquo;\u0026gt; を読み込んでいる場合は、whenDefined() メソッドを使用する必要はありません。しかし、\u0026lt;script type=\u0026ldquo;module\u0026rdquo;\u0026gt; を追加できない状況では、非同期関数と whenDefined() を組み合わせて使用する必要があります。\n(async () =\u0026gt; { await customElements.whenDefined(\u0026#34;calcite-alert\u0026#34;); await document.querySelector(\u0026#34;calcite-alert\u0026#34;).componentOnReady(); document.querySelector(\u0026#34;calcite-loader\u0026#34;).hidden = true; })(); requestAnimationFrame() のコールバックとしてコンポーネントのメソッドを呼び出すことで、ユーザー インターフェイスがコンポーネントの状態に応じて更新されることが保証されます。例えば、ユーザーの閲覧履歴に基づいて calcite-stepper の現在のステップを設定したい場合は、goToStep() メソッドを使用することができます。\n(async () =\u0026gt; { await customElements.whenDefined(\u0026#34;calcite-stepper\u0026#34;); const el = await document.querySelector(\u0026#34;calcite-stepper\u0026#34;).componentOnReady(); requestAnimationFrame(() =\u0026gt; el.goToStep(3)); })(); イベント Calcite コンポーネントは、CustomEvent() コンストラクターを使用してイベントを作成し、トリガーします。\nCustomEvent は、ボタンのクリックなどで HTML 要素から発火される Event と同様に動作します。例えば、イベント ペイロード内の target プロパティを通じて発火元の要素にアクセスすることができます。\n各コンポーネントのドキュメント ページでは、calcite-pagination のイベントなど、どのようなイベントを持っているかを確認できます。例えば以下のようにイベントを利用できます。\ndocument.addEventListener(\u0026#34;calcitePaginationChange\u0026#34;, event =\u0026gt; { console.log(`Starting item number on the page: ${event.target.startItem}`); }); open / close イベントの動作 一部のコンポーネントは、open Boolean 型プロパティを切り替えることで表示位置や表示状態を制御できます。open プロパティの値がユーザー操作やプログラムによって変更されると、コンポーネントは対応するイベントを発火させ、その変更を通知します。\n例えば、Dialog が開かれたり、閉じられたりすると、calciteDialogOpen および、calciteDialogClose イベントが発火されます。\nBlock コンポーネントのように、open の代わりに expanded プロパティを使用するものもありますが、イベントの発火パターンは同様です。\nこの設計により、遷移を伴うアニメーションやタイミングの一貫性が保たれますが、ユーザー操作のみがイベントに反映されると期待している場合は混乱する可能性があります。\nなお、open または close イベントがボタンのクリックなどのユーザー操作によるものか、element.open = false を設定するなどのプログラムによるものかを区別する方法は組み込まれていません。しかし、フラグを使ってプログラムによる変更を追跡することは可能です。\n例えば、以下のような方法です。\nlet isProgrammaticClose = false; const dialog = document.querySelector(\u0026#34;calcite-dialog\u0026#34;); const cancelButton = document.getElementById(\u0026#34;dialog-cancel-button\u0026#34;); // close イベントのハンドリング dialog.addEventListener(\u0026#34;calciteDialogClose\u0026#34;, () =\u0026gt; { if (isProgrammaticClose) { console.log(\u0026#34;Dialog closed programmatically\u0026#34;); } else { console.log(\u0026#34;Dialog closed by user interaction\u0026#34;); } // イベントの処理後、フラグをリセット  isProgrammaticClose = false; }); // プログラムからダイアグラムを閉じる function closeDialog() { isProgrammaticClose = true; dialog.open = false; } cancelButton.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { closeDialog(); }); グローバル設定 バージョン バージョン 2.10 以降、開発者は calciteConfig グローバル変数を使用して、実行時に Calcite のバージョンを検出することができます。\nwindow.addEventListener(\u0026#34;load\u0026#34;, () =\u0026gt; console.log(window.calciteConfig.version)); ログ メッセージ バージョン 2.11 以降、コンポーネントの非推奨化の通知などの重要なメッセージがコンソールに出力されるようになりました。開発者は calciteConfig を使用することで、これらのメッセージを本番環境やビルドしたアプリから除外することができます。\nvar calciteConfig = { logLevel: \u0026#34;off\u0026#34; }; フォーム フォーム内の各コンポーネントには、フォーム送信時に値を適切に渡すために、name 属性を設定する必要があります。例えば、Input Date Picker と Text Area に name 属性を追加することが挙げられます。\n\u0026lt;form\u0026gt; \u0026lt;calcite-label\u0026gt; Observation date: \u0026lt;calcite-input-date-picker name=\u0026#34;observation-date\u0026#34;\u0026gt;\u0026lt;/calcite-input-date-picker\u0026gt; \u0026lt;/calcite-label\u0026gt; \u0026lt;calcite-label\u0026gt; Observation notes: \u0026lt;calcite-text-area name=\u0026#34;observation-notes\u0026#34; placeholder=\u0026#34;Observation notes\u0026#34; max-length=\u0026#34;250\u0026#34;\u0026gt;\u0026lt;/calcite-text-area\u0026gt; \u0026lt;/calcite-label\u0026gt; \u0026lt;calcite-button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/calcite-button\u0026gt; \u0026lt;/form\u0026gt; フォームに関するその他の考慮事項については、フォームのアクセシビリティーを参照してください。\nフォームの検証 フォームの検証には、status、validationMessage、validationIcon プロパティの使用が含まれます。これらのプロパティは、コンポーネントの status プロパティが \u0026quot;invalid\u0026quot; である場合に、デフォルトおよびカスタムのメッセージとアイコンをサポートします。\n検証時の制約 カスタムの制約を設定するには、以下の手順を行います。\n id を使用して、特定のフィールドのカスタム制約、メッセージ、アイコンを定義する検証用の制約配列を作成します。 setCustomValidity のような関数を使用して、対象のフィールドに validationMessage、validationIcon、および status を設定します。 イベント リスナーを使用してユーザー入力が事前に定義された制約に合致しているかを確認します。ユーザー入力が指定された制約を満たしていない場合、setCustomValidity 関数を使ってカスタムの検証メッセージを設定します。  パターン pattern 属性を使用することで、フォーム検証における制約をサポートできます。この属性を使用すると、入力が一致しなければならない正規表現を定義できます。これにより、フォームが有効と見なされるための条件を指定できます。例えば、pattern の特定の部分に一致した場合に表示される validationMessage や validationIcon を定義することができます。\n\u0026lt;!-- HTML --\u0026gt; \u0026lt;calcite-label\u0026gt; Full Name: \u0026lt;calcite-input-text pattern=\u0026#34;[a-zA-Z]{1,15}\\s[a-zA-Z]{1,15}\u0026#34; placeholder=\u0026#34;John Doe\u0026#34; name=\u0026#34;fullName\u0026#34; id=\u0026#34;fullName\u0026#34; validation-message=\u0026#34;Full name is a required field.\u0026#34; validation-icon=\u0026#34;exclamation-mark-triangle\u0026#34; status=\u0026#34;invalid\u0026#34; required\u0026gt;\u0026lt;/calcite-input-text\u0026gt; \u0026lt;/calcite-label\u0026gt; // JavaScript // フィールドの制約の検証、アイコン、メッセージを持つオブジェクトの配列を定義 const validationConstraints = [ { id: \u0026#34;fullName\u0026#34;, patterns: [ { value: /^\\w{16,}/, message: \u0026#34;First name must not be longer than 15 letters.\u0026#34;, icon: \u0026#34;exclamation-mark-triangle-f\u0026#34; }, { value: /^\\w+\\s\\w{16,}$/, message: \u0026#34;Last name must not be longer than 15 letters.\u0026#34;, icon: \u0026#34;exclamation-mark-triangle-f\u0026#34; }, { value: /^\\w*[^\\s]\\w*$/, message: \u0026#34;First and last name are required.\u0026#34;, icon: \u0026#34;exclamation-mark-triangle-f\u0026#34; }, { value: /^[a-zA-Z]*$/, message: \u0026#34;First and last name are required.\u0026#34;, icon: \u0026#34;exclamation-mark-triangle-f\u0026#34; }, ] } ]; // ユーザーがコンポーネントを操作する際のカスタムの validationMessage、validationIcon、status を設定 function setCustomValidity(el, message, icon) { if (message) { el.validationMessage = message; el.validationIcon = icon; el.status = \u0026#34;invalid\u0026#34;; } else { el.validationMessage = \u0026#34;\u0026#34;; el.validationIcon = false; el.status = \u0026#34;idle\u0026#34;; } } window.onload = () =\u0026gt; { // フォーム要素にイベント リスナーを追加し、validationMessage、validationIcon、blur 時のステータスを更新  validationConstraints.forEach(constraint =\u0026gt; { document.querySelector(`#${constraint.id}`)?.addEventListener(\u0026#34;blur\u0026#34;, ({ target }) =\u0026gt; { // pattern 制約にカスタム validationMessage を設定  if (typeof constraint?.patterns === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; constraint?.patterns?.length \u0026gt; 0) { for (const pattern of constraint?.patterns) { if (target.value?.match(pattern?.value)) { setCustomValidity(target, pattern?.message, pattern?.icon ?? true); return; } } } // すべての制約が満たされたら、カスタム検証メッセージを削除  setCustomValidity(target, \u0026#34;\u0026#34;); }); }); }; モード Calcite コンポーネントは、明色 (light)、暗色 (dark) モードがあり、それぞれの CSS クラスである calcite-mode-light と calcite-mode-dark を使用して切り替えることができます。また、calcite-mode-auto クラスを使用すると、ブラウザーの prefers-color-scheme CSS メディア クエリーに従って、明色、暗色モードが自動的に決定されます。\nモードのクラスをある要素に設定すると、そのすべての子ノードにも適用されます。したがって、アプリケーション全体を明色モードから暗色モードに切り替えるには次のようにします。\n\u0026lt;body class=\u0026#34;calcite-mode-dark\u0026#34;\u0026gt; \u0026lt;!-- アプリケーション要素 --\u0026gt; \u0026lt;/body\u0026gt; "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/",
	"title": "コア コンセプト",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) のコア コンセプトについて紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Core concepts\nArcGIS Experience Builder Developer Edition は、開発者がノー コード/ロー コード アプローチでカスタム Web アプリケーションを作成できる Web アプリケーション フレームワークです。 ArcGIS のサービスやデータと統合できる、インタラクティブで応答性の高いアプリケーションを構築するためのツールやコンポーネントのセットを提供します。\n開発者は、カスタム ウィジェット、テーマ、およびアクションを作成して、ArcGIS Experience Builder を拡張できます。Jimu と呼ばれるこの拡張性フレームワークにより、開発ニーズに合ったアプリケーションを構築することができる。\nJimu とは Jimu は ArcGIS Experience Builder の拡張性フレームワークで、開発者はカスタム ウィジェット、テーマ、およびアクションを作成できます。Experience Builder アプリケーションの機能を拡張するための API とツールのセットを提供します。\nExperience Builder は、カスタム ウィジェットの作成、カスタム テーマの作成、カスタム データソース、メッセージ/アクションの作成を通じて拡張することが可能です。これらはすべて、以下のコンポーネントで構成されているjimu と呼ばれる Experience Builder の拡張フレームワークを使用することで可能になります。\nJimu フレームワークは、以下を含むいくつかの技術の上に構築されています。\n ArcGIS Maps SDK for JavaScript 4.x は、地図と地理空間データを統合します。 ユーザーインターフェースの構築とアプリケーションの状態管理のための React と Redux フレームワーク ユーザー インターフェース コンポーネントの Emotion Web 標準に準拠した HTML5 と CSS3  開発 TypeScript は JavaScript のスーパーセットで、言語に静的な型付けを追加しています。ArcGIS Experience Builder でウィジェット、テーマ、その他のコンポーネントを開発するには、TypeScript を使用します。TypeScript には、次のような多くの利点があります。\n 型宣言によるエラー検出 よりよい IDE エクスペリエンス セルフ-ドキュメント コード より読みやすく、わかりやすい  コア コンセプト Experience Builder のエクスペリエンスは、Web アプリケーションを作成するために連携するさまざまなコンポーネントで構成されます。これらのコア コンセプトを理解することで、Experience Builder のフレームワークを効果的にナビゲートし、開発することができます。\n ページ（Page） \n ウィンドウ（Window） \n セクションとビュー（Section and view） \n スクリーン グループ（Screen groups） \n レイアウト（Layout） \n テーマ（Theme） \n ウィジェット（Widget） \n Jimu \n データ ソース（Data source） \n データ アクション（Data action） \n メッセージとアクション（Message and action） \n マップ/シーン ビュー（Map/Scene View） \n 拡張ポイント（Extension points） \n AppConfig \n\r高速モード（Express mode） （外部サイトに移動します） 高度な書式設定 （外部サイトに移動します） "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/visualization/data-visualization-procedure/",
	"title": "データ可視化の手順",
	"tags": [],
	"description": "ArcGIS Online 上のデータを可視化するための方法を紹介します。",
	"content": "ArcGIS Online 上のデータを可視化するための方法  マップを作成したい シンボルを変更したい ラベルを変更したい  マップを作成したい マップ ビューアー → [追加] → [保存]\n緯度経度の情報を持ったCSV ファイルなどを、レイヤーとしてマップに追加し、様々なレイヤーを組み合わせてマップを作成することができます。マップの保存には、コンテンツを作成する権限が必要です（権限を持っていない場合でもマップは作成できますが、保存することはできません）。\n  マップ ビューアーを開きます。マップ ビューアーを開いた時点でベースとなる背景地図(ベースマップ)は自動的に表示されます。\n  [追加] をクリックします。\n  [レイヤーの検索]、[Living Atlas レイヤーの参照]、[Web からレイヤーを追加]、[ファイルからレイヤーを追加]、[マップ メモの追加] いずれかのレイヤーの追加方法を選択します。\n  それぞれのレイヤー追加方法は、以下の通りです。\nレイヤーの検索   [検索] ボックスにキーワードを入力し、[検索] をクリックします。 [検索先] ドロップダウン リストでは、検索する場所を限定することができ、また、[マップ エリア内] のチェックボックスをオンにすると、マップ ビューアーの表示範囲にあるレイヤーを検索することができます。\n  検索結果は下部のボックス内に表示され、レイヤー名の右にある [追加] をクリックするか❶、レイヤー名をクリックしたのちに❷、[マップに追加] ❸をクリックします。\n  [レイヤーの追加を完了] をクリックし、レイヤーの追加を終了します。\n  Living Atlas レイヤーの参照 米国 Esri 社やほかのユーザーが提供する高品質マップ レイヤーをマップに追加します。レイヤーの詳細は、アイテム説明で確認できます。レイヤーによっては、組織向けアカウントでのサイン インが必要であったり、クレジットを消費するものがあります。\nWeb からレイヤーの追加 URL を指定して、ArcGIS Server Web サービス、OGC WMS Web サービス、OGC WMTS Web サービス、Web サーバー上にあるタイル レイヤー、KML ファイル、GeoRSS ファイル、および CSV ファイルのレイヤーを追加することができます。\nファイルからレイヤーを追加  [ファイルを選択] をクリックして、コンピューター上のファイル（区切りテキスト ファイル（.csv または .txt）、GPS Exchange Format（.gpx）ファイル、またはシェープファイル（.zip に圧縮済み））を選択します。  この方法で追加できるレイヤーのフィーチャ数の上限は、1,000フィーチャです。\r1,000フィーチャ以上のデータを持つファイルを追加する場合、[マイ コンテンツ] ページの [アイテムの追加] で行う方法があります。\r[レイヤーのインポート] をクリックします。 [CSV レイヤーの追加] ダイアログが表示された場合は、緯度/経度あるいは住所の情報を含んでいるフィールドを選択します。[レイヤーの追加] をクリックして、レイヤーの追加を終了します。  マップ メモの追加   [マップ メモの追加] ダイアログで、[名前] フィールドでレイヤー名を、[テンプレート] ドロップダウン リストから任意のマップ メモのテンプレートを選択します。\n  [マップ メモの追加] ダイアログで、名前を入力し、テンプレートをドロップダウン リストから選択して、[作成] をクリックします。\n  フィーチャの追加パネルが表示されるので、マップに追加するシンボルを選択します。\n  マップの任意の位置をクリックすると、その位置にシンボルが表示されると同時にポップアップが開き、タイトルや説明などを入力することができます。\n  コンテンツ パネルでレイヤーが追加されたことを確認し、追加されたレイヤー名にマウス オンするかレイヤー名をクリックし、から [レイヤーの保存] をクリックします。\n  [アイテムの作成] ダイアログでレイヤーのタイトル、タグ、サマリー（説明）を入力し、保存するフォルダーを選択して [アイテムの作成] をクリックします。\n~~~~\rタグを入力して、Enter キーを押すと、入力文字を確定できます。\r~~~~\r  マップを保存するために、[保存] → [保存] をクリックします。\nマップの保存では、マップ ビューアー上で参照しているレイヤーやその表示設定などが保存されます。\rマップ上で設定したレイヤーのシンボルなどは、レイヤー自体には保存されないため、他のマップでそのレイヤーを追加したときには、\r再度、シンボルの設定等を行う必要があります。\r  タイトル、タグ、サマリー（説明）を入力し、保存するフォルダーを選択し、[マップの保存] をクリックします。\n  [マイ コンテンツ] ページに移動し、マップが のような地図のアイコンで保存されていることを確認できます。\n緯度経度、または住所情報を含むテキスト ファイル（ *.txt、 *.csv）であれば、マップ表示エリアにファイルをドラッグ \u0026amp; ドロップすることで、ポイント フィーチャ レイヤーとしてマップに追加できます。フィールドはカンマ、セミコロン、またはタブで区切る必要があり、その他の区切り文字はサポートされていません。また、緯度経度は、10進度である必要があります。Google Chrome、Mozilla Firefox、Internet Explorer 10以降で利用可能です。\n 日本語を含むテキストファイルを使用するためには、Windows の「メモ帳」でファイルを開き、[ファイル] メニュー → [名前を付けて保存] をクリックし、[名前を付けて保存] ダイアログの下部に表示される [文字コード] ドロップダウン リストから [UTF-8] を指定して [保存] ボタンをクリックします。  保存したファイルを、マップ ビューアー上にドラッグ \u0026amp; ドロップします。  [CSV レイヤーの追加] 画面が表示されます。住所が入力されている場合は、[使用しているフィーチャの特定] では [住所] を指定し、[国] ドロップダウン リストから 「日本」 を選択します。 住所が入力されているフィールド名をクリックし、[場所フィールド] で [住所/大字町丁目以降] を選択します。 [レイヤーの追加] ボタンをクリックします。    シンボルを変更したい マップ ビューアー → [詳細] → [コンテンツ] → レイヤー名にマウス オン / クリック → [スタイルの変更]\nシンボルの色や形を変更します。コンテンツを作成する権限を持っている場合に可能です。\n  マップ ビューアーの [詳細] が選択されていることを確認し、[コンテンツ] をクリックします。\n  シンボルを変更したいレイヤー名にマウス オン / クリックし、[スタイルの変更] のアイコンをクリックします。\n  [スタイルの変更] パネルが表示されます。\n  [①表示する属性を選択] ドロップダウン リストから、シンボルの設定をする属性フィールドを選択します。 属性値でシンボル設定をしない場合は、[場所のみ表示] を選択します。\n  [②描画スタイルの選択] で、変更したい描画方法の [選択] をクリックします。既に選択されている描画スタイルは [オプション] と表示されます。\n一種類の属性フィールドによるシンボル設定 場所（単一シンボル） すべてのフィーチャを同じシンボルで表現します。\n種類 (個別値シンボル) 樹木の種類、道路クラス、都道府県名など、属性のカテゴリごとにシンボルを割り当てて描画します。\n数と量（サイズ） 数値またはランク付けされたデータをシンボルの大きさで表現します。データの数値が大きいほど、シンボルの大きさも大きく表示されます。\n数と量（色） 数値またはランク付けされたデータを色の濃淡で表現します。データの数値が大きいほど濃い色で、小さいほど淡い色で表示することなどができます。\nヒート マップ ポイントが集中しているエリアを一目で確認できるような表現ができます。\n日付データによるシンボル設定 属性フィールドに日付データを含むフィールドを選択すると、時系列データのスタイルの変更が提示されます。\n連続タイムライン（サイズ） 日付データをシンボルの大きさで表現します。新しい日付から古い日付をシンボルの大きさで表示することができます。\n連続タイムライン（色） 日付データを色の濃淡で表現します。新しい日付から古い日付を濃い色から薄い色で表示することなどができます。また、特定の日付の前後で色を変えることもできます。\n期間（サイズ） 設定した開始と終了日の期間の長さをシンボルの大きさで表現します。期間が長いほどシンボルの大きさも大きく表示されます。\n期間（色） 設定した開始と終了日の期間の長さを色の濃淡で表現します。期間の長さを濃淡で表現したり、所定日の前後で色を変える設定ができます。\n※レイヤーが持つ属性フィールドのタイプに応じて選択できる種類が異なります。例えば、文字列型のフィールドのみで構成されるレイヤーでは、[種類] ドロップダウン リストでサイズや色の指定はできません。\n  [オプション] をクリックすると、シンボルの詳細な設定をすることができます。\n  場所（単一シンボル）の場合 [シンボル] をクリックし、形状や大きさ、塗りつぶし色、アウトラインの設定などを行います。\n種類（個別値シンボル）の場合  ❶ 各シンボルの形状や大きさ、塗りつぶし色、アウトラインの設定などを行うことができます。 ❷ 凡例で表示するラベル名を直接入力して変更することができます。 ❸ ドラッグし、目的の位置でドロップすることで、各シンボルの順序を変更できます。 ❹ チェックボックスをオンにすると、シンボルが設定されている値以外の図形（例えば、属性値が入力されていない図形）が「その他」として表示されます。\n※個別値が11種類以上ある場合は、一部のデータが「その他」にグループ化されます。ラベル欄の「その他」の右にある をクリックすると、一括してグループ化を解除できます。また、「その他」の中にはグループ化された個別値が表示され、各個別値の をクリックすることで、個々にグループから除外することもできます。  数と量（サイズ）の場合 - ❺ スライダーの上部、下部のバーを動かして、最大 / 最小クラスの閾値を変更できます。また、数値をクリックして、直接入力することもできます。 - ❻ ポイントのシンボルを変更できます。 - ❼ 最小/最大クラスのポイントのサイズを変更できます。 - ❽ チェックボックスをオンにすると、クラスの分類数や分類方法、各クラスの閾値を設定することができます。各クラスの閾値は、スライダーを動かして変更するか、クラスの閾値の数値をクリックして、直接、入力することもできます❾。\r数と量（色）の場合  ❿ スライダーの上部、下部のバーを動かして、最小/ 最大クラスの閾値を変更できます。また、数値をクリックして、直接入力することもできます。 ⓫ ここをクリックすることで、色のパターンなどを変更できます。 ⓬ チェックボックスをオンにすると、クラスの分類数や分類方法、各クラスの閾値を設定することができます。設定方法は「数と量（サイズ）（16ページ）」をご参照ください。  ヒートマップの場合  ⓭ スライダーの上部、下部のバーを動かして、密集度の高いエリアや低いエリアを変更できます。 ⓮ 色のパターンを選択できます。 ⓯ スライダーを左右に動かして、影響範囲を変更できます。  二種類の属性フィールドによるシンボル設定 各パネルにおいて [OK] をクリックし、[完了] をクリックします。 一つ目の属性フィールドを選択すると表示される、[属性の追加] をクリックします。\n※数値型および文字列型のフィールド タイプを持つレイヤーに対してのみ、 [属性の追加] が表示されます。ここで、二つ目の属性フィールドを選択します。（一つ目に選択する属性フィールドを A、二つ目に選択する属性フィールドは B とします。）  [②描画スタイルの選択] で、変更したい描画方法の [選択] をクリックします。既に選択されている描画スタイルは [オプション] と表示されます。  色とサイズ Ａの属性は、色の濃淡で数値を表現し、Bの属性に対してはシンボルのサイズで数値を表現します。 選択した属性フィールドが日付型の場合は、時系列表示のシンボル設定がおこなえます。\n色 (期間) とサイズ A の属性は、期間を色の濃淡で表現し、B の属性に対しては日付の新旧をシンボルのサイズで表現します。\n色とサイズ (期間) A の属性は、日付の新旧をシンボルのサイズで表現し、B の属性に対しては期間を色の濃淡で表現します。\nA を B と比較 Bの属性に対し、Ａの属性の比率や割合を表現します。また、二つの属性の合計に対するAの属性の割合を表示します。\nタイプとサイズ 一意のシンボル（個別値）をサイズで表現します。A、B どちらかが文字列型の属性である場合は、文字列型の属性の方に個別値シンボルが自動的に適用され、他方の属性にサイズが適用されます。 選択した属性フィールドが日付型の場合は、時系列表示のシンボル設定がおこなえます。\nタイプとサイズ (期間) 一意のシンボル（個別値）ごとに期間の長さをシンボルの大きさで表現します。 A、B どちらかが文字列型の属性である場合は、その属性の方に個別値シンボルが自動的に適用され、日付型の属性にサイズが適用されます。\n主要カテゴリ 複数の属性フィールドの値を比較して、一番高い値を持つ属性フィールドに設定した色を表示します。同時に、他の値と比べてどれほど優位かを透過で表現します。\n主要カテゴリおよびサイズ 上記の「主要カテゴリ」に加え、複数の属性値の合計を円の大きさで表します。 10.\t[オプション] をクリックすると、シンボルの詳細な設定をすることができます。 11.\t設定後、各パネルにおいて [OK] をクリックし、[完了] をクリックします。\n※独自のシンボルを表示したい場合は、シンボルとして表示させたい画像をあらかじめWeb 上にアップロードしておき、[スタイルの変更] パネル → [場所（単一シンボル）] あるいは [種類（個別値シンボル）] → [選択] → [オプション] で、シンボルをクリックし、[画像の使用] をクリックします。参照する URL をボックス内に入力し、プラスマークをクリックすると、独自のシンボルとして利用することができます。 ラベルを変更したい マップ ビューアー → [詳細] → [コンテンツ] → レイヤー名にマウス オン / クリック → [その他のオプション] → [ラベルの作成]\nマップ上のフィーチャに簡単にテキストを追加することができます。ラベルのテキスト文字列はフィーチャの属性情報を利用して設定することができます。コンテンツを作成する権限を持っている必要があります。\n  マップ ビューアーの [詳細] が選択されていることを確認し、[コンテンツ] をクリックします。\n  ラベルを変更したいレイヤー名にマウス オン / クリックし、[その他のオプション] から [ラベルの作成] を選択します。\n  [ラベル フィーチャ] パネルが表示されます。[ラベル フィーチャ] チェックボックスをオンにして、ラベルを表示します❶。\n  [テキスト] フィールドに、ラベルとして表示したい属性を持つフィールドを入力します。複数の属性を表示したい場合は、右の ボタンで任意のフィールドを追加することができます❷。｛｝(中かっこ)でフィールド名を囲むと各フィーチャの属性が表示されます。\n  テキストのサイズ、太字、斜体、アンダーライン、色を変更することができます❸。\n  [整列] で、ラベル配置を指定します❹。\n  [OK] をクリックし、ラベルの設定を終了します。\n  ラベルの設定をした状態でレイヤーを保存することで、他のマップでもラベルが設定された状態でレイヤーを利用することができます。そのためには、レイヤー名にマウス オン / クリックし、[その他のオプション] から [レイヤーの保存] を選択します。\n  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/services/create-feature-service/",
	"title": "フィーチャサービスの作成",
	"tags": [],
	"description": "データの検索や編集が可能な地図サービス (REST API) の配信方法を紹介します。",
	"content": "配信可能な地図サービス ArcGIS Location Platform では、お手持ちの地図データや、住所・緯度経度を含む CSV などのテキスト データをもとに地図 (GIS) サービスを配信することが可能です。ArcGIS の地図サービスはさまざまな機能ごとに種類が分かれています。配信可能な基本的な地図サービスは以下の 2 種類です。\n  フィーチャ サービス (レイヤー)\n  緯度経度および属性情報をフィーチャ (文字列) として配信 (クライアントでベクター データのグラフィックとして描画されます)\n  クライアント側でクエリを実行してデータを取得したり、編集したりする場合に利用\n機能 : 表示 (地図と属性) / 検索 / 作成 / 更新 / 削除\n    タイル サービス (レイヤー)\n あらかじめ作成しておいたタイル状に分割された地図を配信 描画速度が速く、背景地図などの広範囲のデータを利用したい場合に最適 機能 : 表示 (地図のみ)    Esri は無償で利用できるタイル サービスとして、全世界の背景地図サービス (道路地図、地形図、衛星画像 など) を配信しています。 なお、自分でタイル サービスを生成する場合は、10,000 タイルにつき 1 クレジットを消費して生成できます。 生成したタイル サービスを公開する方法は ArcGIS Online ヘルプのホスト タイル レイヤーの公開をご覧ください。\n以下では、主題データとして利用頻度のもっとも高いフィーチャ サービスの公開および配信方法をご紹介します。\nフィーチャ サービスの作成・公開 フィーチャ サービスの公開には以下の 2 つの方法があります。\n 空のフィーチャ サービスを公開  データがない状態のフィーチャ サービスを公開し、マップ ビューアーを使って手動でデータを追加していきます。    地図データおよび住所データを使ってフィーチャ サービスを公開   地図データが持つ座標情報や住所情報をもとにフィーチャ サービスを公開します。公開可能なデータ例の一部を以下にあげます。\n CSV Excel (*.xlsx または *.xls) Google Sheets GeoJSON シェープ ファイル (Zip 形式に圧縮) ファイル ジオデータベース (Zip 形式に圧縮)  詳細は ArcGIS Online ヘルプのホスト フィーチャ レイヤーの公開をご覧ください。\n    地図データや住所データを使ってフィーチャ サービスを公開する方法は「Import data as a feature layer」をお読みください。\n以下は空のフィーチャ サービスを公開するまでのステップを紹介します。\n1. フィーチャ サービスの作成を開始する ArcGIS Location Platform から空のフィーチャ サービスを公開する方法として、ArcGIS Location Platform のアカウントで ArcGIS ポータルにアクセスし、ポータル上で作成できます。\n ArcGIS Location Platform のサイト上から My dashboard をクリックし、ご自身のアカウントのダッシュボードを開きます。  ダッシュボードを開きましたら Layers and data services をクリックし、Create new feature service をクリックします。  そのあとに出るモーダルウィンドウ上の Go to your portal を押し、ポータル上で空のフィーチャ サービスを作成します。  ポータル上での空のフィーチャ サービスの作成はこちらを参照に作成してみてください。\n2. フィーチャ サービスの利用状況の確認方法 ArcGIS Location Platform のダッシュボートでは、フィーチャ サービスの利用状況を確認することができます。\n ArcGIS Location Platform のダッシュボードから Layers and data services をクリックします。  ポータル上にあるレイヤーの一覧から利用状況を確認したいレイヤーの View usage をクリックします。  レイヤーの利用状況について月ごとの合計と利用された日付とその日の使用量を確認することができます。また、その結果を CSV ファイルでダウンロードすることもできます。  3. フィーチャ サービスの詳細情報の確認と設定方法 フィーチャ サービスの詳細情報の確認はポータル上で行うことができます。 また、編集の可否についてもポータル上で設定が可能です。\n ArcGIS Location Platform のダッシュボードから Layers and data services をクリックします。  ポータル上にあるレイヤーの一覧から詳細情報の確認もしくは、設定を編集したいレイヤーの Manage layer and service をクリックします。 遷移先は、ポータル上のレイヤーの詳細画面になっています。  ポータル上でのレイヤーの管理方法についてはこちらを参照してください。\nここまで作成してきたフィーチャ サービスは「Web マップの作成」で 1 レイヤーとして扱うことができます。自身が複数のデータをお持ちで、複数のレイヤーとして地図に表示したい場合でも、自由に追加して独自の地図をデザインすることが可能です。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/page/",
	"title": "ページ（Page）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - page\nページとは ArcGIS Experience Builder では、ページはレイアウトの表現であり、物理的な HTML の Web ページではありませんが、そのように動作します。ページは、エクスペリエンス内でコンテンツを整理するための基盤です。\nエクスペリエンスには最低 1 ページが必要で、複数ページも可能です。ページは 2 つのレイアウト タイプでデザインできます。\n フルスクリーン アプリ： アプリケーション インターフェースに似ています。 スクロール ページ：従来の Web ページに似ています。  ウィジェット、セクション、スクリーンなどのページ コンテンツは、固定レイアウトやフロー レイアウトなどのレイアウト ルールに基づいて配置されます。さまざまな画面サイズに対応できるよう、レイアウトは3つのサイズ モード大画面、中画面、小画面）に設定できます。この構成により、さまざまな機器に対応したカスタマイズ設計が可能になります。\nアプリの設定では、ページは pages プロパティで定義され、その構造は pageStructure プロパティで概説されます。\nページの使用方法 ArcGIS Experience Builder でページを使用する一般的な手順は次のとおりです。\n  ページの追加 エクスペリエンスにページを追加してください。\n  ページにコンテンツを追加 ページにウィジェット、セクション、またはスクリーンを追加します。\n  ページ レイアウトの設定 ページのレイアウト タイプとサイズ モードを設定します。\n  1. ページの追加 エクスペリエンスにページを追加するには、以下の手順に従ってください。\n ArcGIS Experience Builder のページ パネルに移動します。 ページの追加ボタンをクリックしてください。 ページのレイアウト タイプを選択します。  フルスクリーン アプリ：このレイアウトはアプリケーションのインターフェイスに似ており、固定レイアウトやグリッド レイアウトをサポートしています。 スクロール ページ：このレイアウトは従来の Web ページに似ており、縦スクロールが可能です。    2. ページにコンテンツを追加 ページにコンテンツを追加するには、以下の手順に従ってください。\n ページ パネルで、コンテンツを追加したいページを選択します。 ウィジェット パネルからウィジェット、セクション、スクリーンをページにドラッグ＆ドロップします。 エクスペリエンス ビルダーで利用可能なレイアウト オプションを使用して、必要に応じてコンテンツを配置します。  3. ページ レイアウトの設定 ページ レイアウトを設定するには、以下の手順に従ってください。\n ページ パネルで、設定したいページを選択します。 ページのサイズ モードを設定します。  大画面：デスクトップやラップトップなどの大画面用に設計されています。 中画面：タブレットなどの中型スクリーン用に設計されています。 小画面：スマートフォンなどの小さな画面用に設計されています。    ページ レイアウト タイプ Experience Builder には、それぞれ異なるユーザー エクスペリエンスを提供するように設計された、ページ用の 2 つの主要なレイアウト タイプ（フルスクリーン アプリとスクロール ページ）があります。\nフルスクリーン アプリ フルスクリーン アプリのページレイアウトは、アプリケーションのインターフェイスに似せてデザインされています。より没入感のあるエクスペリエンスを提供し、ユーザーは気が散ることなくコンテンツに接することができます。レイアウトは、さまざまな画面サイズや向きに合わせてカスタマイズできます。\nフルスクリーン アプリのページ レイアウトは、2つのレイアウト タイプをサポートしています。\n   レイアウト タイプ 説明     固定 幅と高さが固定されているため、さまざまなデバイスでコンテンツの一貫性が保たれます。特定のデザインとレイアウトを必要とするアプリケーションに適しています。   グリッド コンテンツをより柔軟に配置することができます。さまざまな画面サイズや向きに対応できるため、レスポンシブ デザインを必要とするアプリケーションに適しています。グリッド レイアウトは、さまざまなコンテンツ タイプや配置に合わせてカスタマイズできます。    スクロール ページ スクロールページ レイアウトは、従来の Web ページに似せてデザインされています。標準的な Web サイトと同じように、ユーザーがコンテンツを縦にスクロールできるようになっています。このレイアウトは、ストーリーテ リングやステップ バイ ステップのガイド、長編コンテンツなど、より直線的な情報の流れを必要とするエクスペリエンスに適しています。\nページ サイズ モード ArcGIS Experience Builder では、ページの 3 つのサイズ モードがサポートされているため、開発者はさまざまな画面サイズや向きに適応するレスポンシブ デザインを作成できます。3 つのサイズ モードは次のとおりです。\n   モード 説明     大画面 このモードは、デスクトップやラップトップなどの大画面用に設計されています。より多くのコンテンツやウィジェットを収容できるレイアウトを提供します。   中画面 このモードは、タブレットなどの中型スクリーン向けにデザインされています。タッチ インタラクションにコンテンツを最適化するレイアウトを提供します。   小画面 このモードは、スマートフォンなどの小さな画面向けに設計されています。コンパクトなレイアウトで、モバイル端末でもコンテンツにアクセスしやすく、ナビゲートしやすくなっています。    Experience Builderは、選択したサイズ モードに基づいてレイアウトとコンテンツを自動的に調整します。開発者は、各モードのデザインと動作をカスタマイズして、すべてのデバイスで一貫したユーザー エクスペリエンスを実現できます。\nヘッダーとフッター Experience Builder では、ヘッダーとフッターは、追加のコンテキストまたはナビゲーション オプションを提供するためにページに追加できるオプションのコンポーネントです。ロゴ、タイトル、ナビゲーションリンク、その他の関連情報などの要素を含めることができます。\nヘッダーとフッターはページ設定でオン/オフでき、内容はすべてのページで同じになります。ヘッダーとフッターは、すべてのページに表示されるように設定することも、エクスペリエンス内の特定のページにのみ表示されるように設定することもできます。また、エクスペリエンスの全体的なデザインに合わせてスタイルやカスタマイズも可能です。ヘッダーとフッターは、ページ設定でオンまたはオフにできます。\nページ構成とその設定方法については、ページの追加と管理のドキュメントをご覧ください。\n\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/unity/add-the-plugin-to-a-new-project/",
	"title": "新規プロジェクトにプラグインを追加",
	"tags": [],
	"description": "ArcGIS Maps SDK for Unity を新規プロジェクトに導入する手順を紹介します 。",
	"content": "出典：ArcGIS Maps SDK for Unity - Guide - Add the plugin to a new project\nArcGIS Maps SDK for Unity は、ソース コードとサンプル アセットを含む Unity プラグインです。このページを始める前に、必ずプラグインをダウンロードしてください。\n新規プロジェクトの作成   新しいプロジェクトを作成するには、Unity Hub を開いて [プロジェクト (Projects)] タブを選択し、[新しいプロジェクト (New project)] ボタンをクリックします。\n  ポップアップ ウィンドウで、以下を定義します。\n エディター バージョン：ArcGIS Maps SDK for Unity は Unity 2022.3.x LTS および Unity 6 をサポートしています。複数の Unity エディター バージョンがインストールされている場合は、ポップアップ ウィンドウの上部でサポートされているエディター バージョンを選択してください。 テンプレート：プラグインは High Definition Render Pipeline (12.x) と Universal Render Pipeline (12.x) の両方をサポートしています。初めて使用する場合は、[Download template] ボタンをクリックして、これらのテンプレートをダウンロードする必要があります。HDRP または URP テンプレート以外のテンプレートを選択した場合は、レンダー パイプライン パッケージを手動でインストールします。(レガシー ビルトイン レンダー パイプラインはサポートされていません。) プロジェクト名：プロジェクトに関連するアセット、シーン、その他のファイルを保存するメイン プロジェクト フォルダーの名前を設定します。 場所：プロジェクトの保存場所を設定します。デフォルトのプロジェクトの場所は、コンピューターのホーム フォルダーに設定されています。    プラグインのインストール Unity パッケージ マネージャー (Package Manager) を使用してプラグインをインストールします。Unity パッケージ マネージャー (Package Manager) の詳細については、Unity ドキュメントのトピック Unity の Package Manager を参照してください。\nマイ アセット (My Asset) からプラグインをインストール  エディターでプロジェクトを開きます。 トップ メニューで、[ウィンドウ(Window)] \u0026gt; [パッケージ マネージャー(Package Manager)]を展開し、[パッケージ マネージャー (Package Manager)] ウィンドウを開きます。  Unity ドキュメントのトピック Asset Store パッケージのインポートに従います。  プラグインがプロジェクトにインポートされると、[パッケージ (Package)] メニューから [プロジェクト内 (In Project)] を選択したときに、プロジェクト ウィンドウの [パッケージ (Packages)] セクションに [ArcGIS Maps SDK for Unity] フォルダーが表示されます。\nローカルの .tgz(tarball) ファイルからプラグインをインストール  パッケージをインポートするプロジェクトをエディターで開きます。 トップ メニューで、[ウィンドウ(Window)] \u0026gt; [パッケージ マネージャー(Package Manager)]を展開し、[パッケージ マネージャー (Package Manager)] ウィンドウを開きます。  [パッケージ マネージャー (Package Manager)] ウィンドウの [+] アイコンをクリックします。 リストから [.tgz ファイルからパッケージを加える… (Add package from tarball)] を選択し、ファイル ブラウザーを表示します。  .tgz(tarball) ファイルを保存したフォルダーに移動します。  プラグインがプロジェクトにインポートされると、[パッケージ (Package)] メニューから [プロジェクト内 (In Project)] を選択したときに、プロジェクト ウィンドウの [パッケージ (Packages)] セクションに [ArcGIS Maps SDK for Unity] フォルダーが表示されます。\nサンプル アセットのインポート ArcGIS Maps SDK for Unity には、シーンに機能とビジュアル フィデリティーを追加するために使用できる追加のサンプルとツールが付属しています。\n以下の方法で、プラグインに付属しているサンプルアセットをインポートします。\nパッケージ マネージャー (Window  Package Manager)** を展開し、**パッケージ マネージャー (Package Manager)** ウィンドウを開きます。\r2. 左側のリストから **ArcGIS Maps SDK for Unity** を選択します。\r3. 右側のパネルで **サンプル (Samples)** をクリックし、セクションを展開します。\r4. **Sample Content** の隣にある **インポート (Import)** ボタンをクリックします。\r--\r トップ メニューで、[ウィンドウ(Window)] \u0026gt; [パッケージ マネージャー(Package Manager)]** を展開し、[パッケージ マネージャー (Package Manager)] ウィンドウを開きます。 左側のリストから [ArcGIS Maps SDK for Unity] を選択します。 右側のパネルで [サンプル (Samples)] タブをクリックします。 [Sample Content] の隣にある [インポート (Import)] ボタンをクリックします。   サンプル アセットがプロジェクトにインポートされると、[プロジェクト (Project)] ウィンドウの [Assets] \u0026gt; [Samples] の下にフォルダーとそのコンテンツが表示されます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/unreal-engine/add-the-plugin-to-a-new-project/",
	"title": "新規プロジェクトにプラグインを追加",
	"tags": [],
	"description": "ArcGIS Maps SDK for Unreal Engine を新規プロジェクトに導入する手順を紹介します。",
	"content": "出典：ArcGIS Maps SDK for Unreal Engine - Guide - Add the plugin to a new project\nArcGIS Maps SDK for Unreal Engine は、ソース コードとサンプル アセットを含む Unreal Engine プラグインです。このページを始める前に、必ずプラグインをダウンロードしてください。\n新規プロジェクトの作成 Unreal Engine には、お客様の業種に合ったさまざまな開発テンプレート (Developer Template)が用意されています。 どのテンプレートを選べばよいかわからない場合は、ゲーム テンプレート (Games Template) とシミュレーション テンプレート (Simulation Template) をお勧めします。これらのテンプレートの詳細については、Unreal Engine テンプレート リファレンスを参照してください。\n  Unreal Engine を起動するには、Epic Games ランチャー を開き、[ライブラリ (Library)] をクリックします。サポートされているバージョンを選択し、[起動 (Launch)] をクリックします。Unreal Engine を起動すると、[Unreal プロジェクトブラウザ (Project Browser)] が自動的に開きます。\n  [最近利用したプロジェクト (Recent Project)] の下で、[開発テンプレート (Developer Template)] の[ゲーム テンプレート (Games Template)]を選択してください。\n  リストからプロジェクトのテンプレートを選択します。プラグインを初期化するには、[ブランク (Blank)]のテンプレートを使用することをお勧めします。\n  プロジェクトを [C++] プロジェクトに設定します。これにより、Visual Studio プロジェクトが作成され、ソース コード フォルダーに空の C++ クラスが 1 つ以上あるという条件が満たされます。品質 / パフォーマンス レベル、ターゲット プラットフォーム、スターター コンテンツを含めるかどうかなどを選択できます。詳細については、Deployment のページを参照してください。\n  ウィンドウの下部で、プロジェクトを保存する場所を選択し、プロジェクト名を付けます。[作成 (Create)]をクリックして終了します。\n  プロジェクト設定の詳細については、Unreal Engine ドキュメント の 新規プロジェクトを作成する を参照してください。\nシミュレーション テンプレートのシミュレーション ブランク テンプレート Unreal Engine バージョン 5.1 以降には、さまざまなシミュレーション アプリケーション用の シミュレーション テンプレート が含まれています。 空、照明、体積雲、地理座標などの設定済みのシミュレーション ブランク テンプレートを活用して、プロジェクトを開始できます。\n  Unreal Engine を起動するには、Epic Games ランチャー を開き、[ライブラリ (Library)]をクリックします。サポートされているバージョンを選択し、[起動 (Launch)]をクリックします。Unreal Engine を起動すると、[Unreal プロジェクト ブラウザー (Project Browser)]が自動的に開きます。\n  [最近利用したプロジェクト (Recent Project)]の下で、[シミュレーション テンプレート (Simulation Template)]を選択してください。\n  [シミュレーション ブランク (Simulation Blank)]テンプレートを使用してください。\n  プロジェクトを [C++] プロジェクトに設定します。これにより、Visual Studio プロジェクトが作成され、ソース コード フォルダーに空の C++ クラスが 1 つ以上あるという条件が満たされます。品質 / パフォーマンス レベル、ターゲット プラットフォーム、スターター コンテンツを含めるかどうかなどを選択できます。詳細については、Deployment のページを参照してください。\n  ウィンドウの下部で、プロジェクトを保存する場所を選択し、プロジェクト名を付けます。[作成 (Create)] をクリックして終了します。   プロジェクト設定の詳細については、Unreal Engine 5 ドキュメント の 新規プロジェクトを作成する を参照してください。\nプラグインのインストール ArcGIS Maps SDK for Unreal Engine をプロジェクトディレクトリにインストールする必要があります。\n  Unreal Engine を終了し、Visual Studio を終了します。次に、メインのプロジェクト ディレクトリに Plugins フォルダーを作成します。\n作成したフォルダーの名前は必ず Plugins にしてください。\n\r  .zip ファイルから ArcGISMapsSDK フォルダーを解凍し、新しい Plugins フォルダーにコピーします。 プロジェクトの再構築に関する警告メッセージが表示された場合は、[Yes] をクリックして続行できます。\n\r  プロジェクトを開いたら、メニュー バーの [編集(Edit)] -\u0026gt; [プラグイン(Plugins)] に移動し、ArcGIS Maps SDK for Unreal Engine プラグインが正しくインストールされていることを確認します。\nmacOS をお使いの場合は、プライバシーとセキュリティでプラグインを許可する必要があるかもしれません。\n\r  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/get-started-cdn/",
	"title": "開発の手順 (CDN)",
	"tags": [],
	"description": "cdn を使用した ArcGIS Maps SDK for JavaScript の開発の手順について紹介します。",
	"content": "出典 : ArcGIS Maps SDK for JavaScript - Get started with CDN\nコード : Map コンポーネントを表示するチュートリアル、または マップ コンポーネントの導入-2D マップの作成 サンプルから始めましょう。\n\rセットアップ ArcGIS Maps SDK for JavaScript をアプリに組み込む方法はいくつかあります。最も一般的な方法は、ArcGIS CDN を使用することです。ファイルは最適化されたクラウドキャッシュを介してダウンロードされるため、アプリケーションをローカルでビルドする必要がありません。また、SDK の新しいバージョンに更新するのも簡単で、その都度アプリケーションを再ビルドする必要がありません。\nコンポーネント ArcGIS Maps SDK for JavaScript のコンポーネントは、Calcite Design System と SDK のコア API に依存しています。まず Calcite とコア API を読み込む必要があります。\nCalcite を読み込むには、スタイルシート リンクとスクリプト タグを含めて Calcite コンポーネントをインポートします。\nArcGIS Maps SDK for JavaScript のバージョン 4.32 より前のバージョンでは、Calcite CSS リンク タグを含める必要がありました。 バージョン 4.32 では、Calcite CSS リンク タグは必要なくなりました。\n\u0026lt;!-- Load Calcite --\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;https://js.arcgis.com/calcite-components/3.0.3/calcite.esm.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 次に、SDK のコア API を読み込むには、スタイルシート リンクとスクリプト タグを含めます。\n\u0026lt;!-- Load the ArcGIS Maps SDK for JavaScript core API --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.32/esri/themes/dark/main.css\u0026#34;/\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.32/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 次に、Map コンポーネント パッケージやその他のコンポーネント パッケージを読み込むには、スクリプト タグ（必要に応じて関連する CSS も）を含めます。\n\u0026lt;!-- Load map components --\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;https://js.arcgis.com/map-components/4.32/arcgis-map-components.esm.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; カスタム CSS を追加して、コンポーネントがアプリケーション内で表示されるようにします。これは、ArcGIS のスタイルシートとライブラリを CDN からインポートした後、アプリケーションの \u0026lt;head\u0026gt; セクションの最後に配置する必要があります。\n\u0026lt;style\u0026gt; html, body { margin: 0; } arcgis-map { display: block; height: 100vh; } \u0026lt;/style\u0026gt; 次に、HTML に arcgis-map コンポーネントを追加し、ArcGIS Online または ArcGIS Enterprise ポータルから WebMap を使用する場合はオプションの item-id を割り当てます。item-id が追加されない場合、デフォルトのベースマップは topo-vector になります。詳細な手順については、チュートリアルを参照してください。\n\u0026lt;arcgis-map item-id=\u0026#34;05e015c5f0314db9a487a9b46cb37eca\u0026#34;\u0026gt;\u0026lt;/arcgis-map\u0026gt; それが完了したら、次のことができます：\n プロパティを設定する（例：ベースマップ、中心、ズーム） 変更を監視する（例：arcgisViewReadyChange イベントを使用してビューが準備完了になったときや、ビューのマップまたはシーンが置き換えられたときに監視） コア API を使用してカスタム JavaScript ロジックを追加する。詳細な手順については、チュートリアルを参照してください。  const mapElem = document.querySelector(\u0026#34;arcgis-map\u0026#34;); mapElem.addEventListener(\u0026#34;arcgisViewReadyChange\u0026#34;, (event) =\u0026gt; { console.log(\u0026#39;Map component is ready\u0026#39;, event); // Set the zoom property mapElem.zoom = 10; }); API API の AMD モジュールには、以下のスクリプトタグを使用します :\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.32/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.32/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; HTML に div を追加し、id を割り当てます：\n\u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; それが完了したら、マップを初期化し、カスタム機能を追加し始めることができます :\nconst map = new Map({ basemap: \u0026#34;topo-vector\u0026#34; }); const view = new MapView({ container: \u0026#34;viewDiv\u0026#34;, // reference to the div id  map: map, zoom: 4, center: [15, 65] }); "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/",
	"title": "ArcGIS Web AppBuilder (Developer Edition)",
	"tags": [],
	"description": "ArcGIS Web AppBuilder (Developer Edition) の開発に役立つガイド集です。",
	"content": "ArcGIS Web AppBuilder (Developer Edition) の開発に役立つガイド集です。\nArcGIS Web AppBuilder (Developer Edition) は、ArcGIS API for JavaScript バージョン 3.x のサポート終了と同時に 2024 年 7 月にサポートが終了しました。現在 Web AppBuilder でアプリを開発している方は、ArcGIS Experience Builder に移行することを検討してください。\r開発者は、Experience Builder で新しいアプリ プロジェクトを開始することを強くお勧めします。詳細および移行については、ArcGIS Web AppBuilder のサポート終了についてを参照してください。\n\r インストール ガイド\nArcGIS Web AppBuilder (Developer Edition) をインストールする手順を紹介します。\n\r カスタム ウィジェット開発ガイド\nカスタム ウィジェットを開発する手順を紹介します。\n\r デプロイ パターン\nArcGIS Web AppBuilder (Developer Edition) で作成したアプリやウィジェットのデプロイ パターンを紹介します。\n\r Web アプリケーションのデプロイ\nArcGIS Web AppBuilder (Developer Edition) で作成したアプリケーションをダウンロードし、独自のサーバーにホストする手順を紹介します。\n\r ウィジェット一覧表\nArcGIS Web AppBuilder で提供されているウィジェットの一覧表です。\n\r\rカスタム ウィジェットのサンプル集（外部サイト）  ArcGIS Web AppBuilder (Developer Edition) を使用して開発されたカスタム ウィジェットのサンプルを確認できるサイトです。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-maplibre/",
	"title": "MapLibre GL JS",
	"tags": [],
	"description": "MapLibre GL JS を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。",
	"content": "マップを表示する このチュートリアルでは、MapLibre GL JS と ベースマップ レイヤー サービスを使用して、マップを表示する方法を紹介します。\nベースマップ レイヤー サービスのベクター タイル ベースマップ レイヤーを使用して、MapLibre GL JS にマップを表示できます。ベクター タイル ベースマップレイヤーは、ソース、レイヤー、フォントグリフ(Font Glyphs)、およびレイヤーをレンダリングするためのアイコンを含む MapLibre GL スタイルです。\nこのチュートリアルでは、ベースマップ レイヤー サービスの地形ベースマップ レイヤーを使用して、富士山周辺の地図を表示します。\nマップとレイヤーの詳細については、Mapping APIs and services のガイドの Mapping にアクセスしてください。\n前提条件 この機能を使うには、開発者アカウントが必要です。アカウントの作成手順については「開発者アカウントの作成」を参照してください。\n手順 新しい Pen の作成 CodePen にアクセスして、マッピング アプリケーション用の新しい Pen を作成します。\nHTML の作成 HTML ページを定義して、Web ブラウザの幅と高さにあわせたマップを作成します。\n CodePen \u0026gt; HTML で、HTML と CSS を追加して、map という id 属性を持つ div 要素のあるページを作成します。 map id は、マップを表示するために使用される id 属性です。CSS はブラウザの設定をリセットして、マップがブラウザの幅と高さ全体に表示されるようにします。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;MapLibre GL JS Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; API の参照  \u0026lt;head\u0026gt;タグで、MapLibre GL JS CSS および JS ライブラリへの参照を追加します。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;MapLibre GL JS Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- maplibre gl js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=https://unpkg.com/maplibre-gl@4.0.0/dist/maplibre-gl.js\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=https://unpkg.com/maplibre-gl@4.0.0/dist/maplibre-gl.css rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; APIキーの設定 ロケーションサービスにアクセスするには、API キーまたは OAuth2.0 アクセストークンが必要です。API キーの作成手順については「API キーの取得」を参照してください。\n認証方法とアクセストークンの取得方法の詳細については、「セキュリティと認証」を参照してください。\n ダッシュボードにアクセスして、Developer credentials から API キーを取得します。これは、次の手順で使います。  マップの作成 Map クラスを使用して、指定したベースマップを使用してマップを追加します。 Map クラスは、map の HTML 要素 を使用して、マップのコンテンツを表示し、対話するためのユーザーインターフェイスを提供します。地図のクリック、ズーム、パン、回転、視点の変更をサポートします。また、マウスがクリックされた場所のフィーチャの検索など、マップデータに関する情報を操作および検出することもできます。また、新しいソースを追加したり、レイヤープロパティを変更したりして、表示されるデータを変更することもできます。 詳細については、MapLibre GL JS のドキュメントを参照してください。\n \u0026lt;body\u0026gt;タグ内に\u0026lt;script\u0026gt;タグを追加します。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;MapLibre GL JS Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- maplibre gl js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=https://unpkg.com/maplibre-gl@4.0.0/dist/maplibre-gl.js\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=https://unpkg.com/maplibre-gl@4.0.0/dist/maplibre-gl.css rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script のタグを追加--\u0026gt; \u0026lt;script\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; API キーを格納するための apiKey 変数を作成します。YOUR_API_KEY を、API キーの設定で開発者ダッシュボードからコピーした API キーに置き換えます。アクセスする各 ArcGIS サービスの URL にこれを含める必要があります。なお、ここでは maplibre.accessToken を設定する必要はありません。使用するベースマップ arcgis/topographic を格納する basemapEnum 変数を作成します。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;MapLibre GL JS Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- maplibre gl js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=https://unpkg.com/maplibre-gl@4.0.0/dist/maplibre-gl.js\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=https://unpkg.com/maplibre-gl@4.0.0/dist/maplibre-gl.css rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script のタグを追加--\u0026gt; \u0026lt;script\u0026gt; // API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ベースマップの指定  const basemapEnum = \u0026#34;arcgis/topographic\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 表示と動作を制御するオプションを使用して Map を作成します。container プロパティを、作成した div の id に設定します。style プロパティは、ベースマップレイヤーサービスの場所を参照し、ベースマップ識別子と API キーを含みます。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;MapLibre GL JS Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- maplibre gl js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=https://unpkg.com/maplibre-gl@4.0.0/dist/maplibre-gl.js\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=https://unpkg.com/maplibre-gl@4.0.0/dist/maplibre-gl.css rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script 要素を追加--\u0026gt; \u0026lt;script\u0026gt; // API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ベースマップの指定  const basemapEnum = \u0026#34;arcgis/topographic\u0026#34;; const map = new maplibregl.Map({ container: \u0026#34;map\u0026#34;, // div 要素内の id を指定  style: `https://basemapstyles-api.arcgis.com/arcgis/rest/services/styles/v2/styles/${basemapEnum}?token=${apiKey}\u0026amp;language=${language}`, zoom: 12, // マップ初期表示時点でのズームレベル  center: [138.729858, 35.362752] // マップ初期表示時の位置  }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; アプリの実行 CodePen で、作成したコードを実行して地図を表示します。\n地図には、日本の富士山のエリアの地形ベースマップ レイヤーが表示されています。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/services/create-webmap/",
	"title": "Web マップの作成",
	"tags": [],
	"description": "さまざまなフォーマットのデータを 1 つのマップとして集約し、それを可視化する方法を紹介します。",
	"content": "Web マップとは Web マップとは背景地図や主題となる地図データを追加し、表示方法などを設定してクラウド上に JSON 形式で保存される Web 上の地図です。Web マップの作成には ArcGIS クラウド サービスが提供する地図作成ツール（マップ ビューアー）を使用します。クラウド上に保存された Web マップを使えば、地図上に何をどのように表示するかを一つ一つコーディングする必要がなく、非常にローコストで地図アプリを作成することができます。\nWeb マップに含まれる情報は以下の JSON 仕様で確認できます。\n Web マップ仕様 (Web Map JSON)  Web マップの作成 1. Web マップの作成とレイヤーの追加 マップ ビューアーで Web マップを作成していきましょう。\n  マップ ビューアーを開きます。\n  開発者アカウントでサインインします（サインインをしないと地図作成機能を利用できません）。\n  ArcGIS Living Atlasで共有中のレイヤーを追加します。[追加] をクリック後、[マイコンテンツ]を [Living Atlas] に変更し [レイヤーの検索] を選択します。\n  レイヤーの検索を行います。検索先を変えるなどしてもよいので、検索フォームにお好きなキーワードを入力して検索してみましょう。\n  検索結果が表示されたら、追加したいレイヤーの[+]ボタンをクリックするとレイヤーが追加されます。\n   今回は、東京都 避難所と南海トラフ巨大地震の被害想定（震度/最大クラス）のレイヤーを追加しています。  2. レイヤーの表示方法の設定   レイヤーの表示設定を変えてみましょう。 レイヤー リストから表現を変更したいレイヤーを選び、[\u0026hellip;] アイコンをクリックして、[プロパティの表示] をクリックします。\n  画面右側に表示される[プロパティ]内の[レイヤースタイルの編集]をクリックします。\n  レイヤースタイルの個別値シンボルの場合は、属性値ごとに表示したいシンボルを設定することができます。シンボルを設定してみましょう。\n  [スタイルの選択]内の[場所(単一シンボル)]の[スタイルオプション]をクリックします。ペンアイコンをクリックして、シンボルをお好きなシンボルに変更します。また、見ずらいという方はサイズの変更を行うこともできます。\n  レイヤー リスト上の透過率を設定したいレイヤー下にある [\u0026hellip;] アイコンをクリックして、画面右側に表示される[プロパティ]内の[透過表示] にカーソルを合わせると、スライダ－で透過率を設定できます。 これで背景地図が見えるように設定できるので場所の特定はできるようになりましたが、地震の被害想定は見たい人だけに見てほしい。そんな場合には、初期状態で非表示にしておくことができます。   非表示にしたいレイヤー名の右にある目のマークをクリックして[／]で消すと、レイヤーは非表示になります。\n  3. Web マップの保存 最後にここまで設定を行ってきた Web マップの保存を行います。保存すると Web マップには ID が割り当てられます。開発の際に、この ID を参照することで、設定を行った状態の地図をそのまま表示することができます。\n  画面左側のメニューから[保存と開く] →[名前をつけて保存]の順にクリックし、マップの情報を入力します。入力し終わったら、[保存] をクリックして、保存は完了です。必須項目はマップのタイトルです。\n  保存が完了すると、URL が自動的に変更されます。URL 末尾の ?webmap=\u0026lt;Web マップ ID\u0026gt; が Web マップの ID です。メモしておきましょう。\n   アプリの作成を始めましょう！お使いの開発環境からお選びください。\n JavaScript Android iOS .NET  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/install-guide/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) をインストールする手順を紹介します。",
	"content": "ArcGIS Experience Builder は、モダンな Web アプリ構築のための新しいビルダーで、コードを記述することなく Web アプリケーションを作成することができます。豊富なウィジェット セットから必要なツールを選択したり、独自のテンプレートをデザインしたり、2D コンテンツや 3D コンテンツを操作したりすることができます。Developer Edition (開発者向けエディション)は、これらの機能に加え、ウィジェットやテーマを独自に開発するなどのアプリをカスタマイズするためのフレームワークを提供します。また、作成したアプリケーションをダウンロードして、Web サーバーなどの独自のサーバーにホストすることが可能です。\nArcGIS Experience Builder (Developer Edition) で使用されている技術は、ArcGIS Maps SDK for JavaScript 4.x に加えて、React + Redux といったフレームワークや Bootstrap 4 などのコンポーネントライブラリ等を使用しています。開発に必要な情報は ArcGIS Experience Builder (Developer Edition) のコア コンセプト (Core concepts) を参照してください。\nインストール ArcGIS Experience Builder (Developer Edition) は、ArcGIS Online および ArcGIS Enterprise 10.6 以降をサポートしています。 Experience Builder (Developer Edition) は server と client の 2 つのサービスを使用しています。\n server サービス  Experience Builder (Developer Edition) の本体を起動します。   client サービス  独自のウィジェットやテーマを開発するためには client サービスを使用する必要があります。通常、server サービスを起動することで、Experience Builder (Developer Edition) を動作させることはできますが、開発したウィジェットなどを配置したり、デバッグするには、client サービスを起動しておく必要があります。    両方のサービスを実行しておくことで、Experience Builder での更新を自動的に反映することができます。 ここでは、Experience Builder (Developer Edition) の server と client のインストール手順について説明します。また、インターネットに接続していない環境で Experience Builder をインストールする必要がある場合は、offlineでのインストール手順を参照してください。\nServer インストール 1. クライアント ID の作成 はじめに クライアント ID を作成する必要があります。クライアント ID は、このあとの server サービスを起動して立ち上がるアプリケーションで指定します。 クライアント ID の作成は、ArcGIS Online/ArcGIS Enterprise を使用して作成します。ご使用の環境に応じて作成を行ってください。\nArcGIS Developerアカウントは現在、ArcGIS Location Platform アカウントとなっています。以前、開発者ダッシュボードで OAuth 2.0 アプリケーションを管理するためのツールは、利用できなくなりました。また、ArcGIS Experience Builder へのアクセスもサポートしていません。ArcGIS Online または ArcGIS Enterprise アカウントをご利用ください。\n\rArcGIS Online/ArcGIS Enterprise にて クライアント ID を作成 ※ インストール手順については Esri が公開しているインストール動画 (英語)でも確認することができます。\n\r ArcGIS Online または ArcGIS Enterprise ポータルにログインし、コンテンツ ページの マイ コンテンツ タブに移動して、新しいアイテム をクリックし、アプリケーション を選択します。 アプリケーション タイプ で 他のアプリケーション を選択します。 ダイアログボックスで、以下のパラメータを入力し、保存 をクリックします。  タイトル - 例えば、Experience Builder credentials などの任意のタイトルをを入力します。 フォルダー - アイテムを保存する任意のフォルダーを選択します。 タグ - Experience Builder のような内容を入力します。 必要に応じてカテゴリとサマリーを入力してください。    設定 タブをクリックします。Application までスクロールします。 URL に任意の URL を入力します。 認証情報までスクロールし、次のように、リダイレクト URL に https://localhost:3001/ と入力し、追加をクリックして、更新 をクリックします。クライアント ID は、このあとの手順で使用するため、コピーなどをして控えておきます。   ArcGIS Enterprise 11.1 以前のバージョンでは、画面構成や表現が異なります。クライアント ID は ArcGIS Enterprise 11.1 以前では アプリケーション ID となっています。\n\r2. server サービスのインストール クライアント ID の作成が完了したら以下の手順で server サービスのインストールを行います。\nExperience Builder は、Node.js を使用します。長期サポート (LTS) バージョン v12 以上がサポートされています。お使いの OS に対応した最新の Node.js LTS バージョンをダウンロードしてインストールを行ってください。\n Experience Builder (Developer Edition) の ZIP ファイルをローカルにダウンロードして、解凍します。  コマンド プロンプト、またはターミナル ウィンドウを開き、Experience Builder の /server ディレクトリに cd コマンドで移動して npm ci と入力し、Enter キーを押して、必要なモジュールをインストールします。 ※ npm ci でのインストールは初回のみになります。次回以降は Experience Builder (Devloper Edition) の起動のみになりますので、npm start で実行します。 npm start と入力して server を起動します。  カスタムポートを使用するには、次のようにオプションとしてポートを指定します。： npm start -- --port 81 --https_port 443 .\nサブディレクトリ（例：https://localhost:3001/subfolder）でサーバーを実行するには、次のように path オプションを指定します： npm start -- --path /subfolder .\n\r次の URL https://localhost:3001/ を指定して Experience Builder をブラウザで開きます。  Experience Builder は、Node.js の自己署名証明書を使用して HTTPS をサポートしています。この証明書を信頼して Experience Builder を実行することもできますし、独自の証明書を使用することもできます。独自の証明書を使用するには、server/cert ディレクトリのこれら 2 つのファイル server.key と server.cert を置き換えます。また、次のように証明書ファイル (server.cert および server.key) が存在するフォルダへのカスタムパスを指定することもできます。：npm start \u0026ndash; \u0026ndash;cert_folder \u0026lt;フォルダパス\u0026gt;\n\rポータルの URL には ArcGIS Online または ArcGIS Enterprise の組織サイトの URL を指定し、クライアント ID には「1. クライアント ID の作成」で作成したクライアント ID を指定します。 すべてを指定したらサイン インをクリックします。  Safari で、PKI、Kerberos、IWA、または LDAP 認証タイプを使用して Experience Builder Developer Edition にサインインするには、Safari の開発メニューにある「Cross-Origin Restrictions を無効にする」を選択する必要があります。\n\rサイン インをクリックすると、以下のように「権限のリクエスト画面」、もしくは、「ArcGIS ログイン画面」が表示されます。 ● 権限のリクエスト画面 権限のリクエスト画面は、使用しているブラウザですでに ArcGIS Online などにログインしているため、ログインした組織のアカウントが表示されます。許可をクリックすることで、Experience Builder の初期画面が表示されます。もし、他のアカウントでサイン インする場合は、別のアカウントでサイン インをクリックしてください。以下の ArcGIS ログイン画面が起動しますので、目的のユーザー名、パスワードを入力してサイン インします。 ● ArcGIS ログイン画面 使用しているブラウザで ArcGIS Online などにログインしていない場合は、ArcGIS ログイン画面が表示されます。目的のユーザー名、パスワードを入力してサイン インをクリックしてください。認証に成功すると、Experience Builder の初期画面が表示されます。  6. 次のステップで client インストールを行います。\nClient インストール Experience Builder の開発では、ローカルの Experience Builder で使用しているカスタム ウィジェットやテーマをバンドルしてロードするため webpack を起動する必要があります。webpack を起動するために client サービスをインストールする必要があります。\n コマンド プロンプト、またはターミナル ウィンドウを開き、Experience Builder の /client ディレクトリに cd コマンドで移動して npm ci と入力し、Enter キーを押して、必要なモジュールをインストールします。 ※ npm ci でのインストールは初回のみになります。次回以降は Experience Builder (Devloper Edition) の起動のみになりますので、npm start で実行します。 ※ npm ci でのインストール時は Visual Studio C++ Build Tools と Python が端末上にある必要があります。 npm start と入力して client を起動します。 ※ client のサービスを起動することで、カスタム ウィジェットやテーマは https://localhost:3001 で表示した Experience Builder 上で使用することが可能となります。  /client/your-extensions ディレクトリに新しいファイルやフォルダを作成した場合は、client サービスの再起動が必要になります。\n\r同じマシンで複数のバージョンの Developer edition を持つことができます。お使いのマシンがシステム要件を満たしていることを確認してください。\nマシン上で Node.js のバージョンを変更またはアップグレードする際には、Experience Builder (Developer Edition) の server および client フォルダーで再度 npm ci コマンドを実行することをお勧めします。これにより、新しくインストールされた Node.js のバージョンからのすべての変更が反映されます。\n\rOffline インストール   インターネットに繋がらない環境では、ArcGIS Maps SDK for JavaScript (JSSDK) CDN にアクセスすることはできません。このシナリオでは、JSSDK をダウンロードしてローカルにインストールする必要があります。\n  Experience Builder は、Node.js 12+.x 以上のバージョンで動作します。 Experience Builder のインストール環境に Node.js (v12+.x) をダウンロードしてインストールを行います。\n  Experience Builder の機能強化や新機能をサポートするために、最新版の ArcGIS Maps SDK for JavaScript をインストールすることが推奨されています。Esri が公開しているオフライン インストール動画（英語） を参照してください。ホストされた JSSDK のために、サーバーで CORS サポートを設定することが推奨されます。例えば、Windows OS の場合、HTTPSレスポンスヘッダーにAccess-Control-Allow-Original アクションを追加することができます。\n\r Experience Builder (Developer Edition) の ZIP ファイルをローカルにダウンロードして、解凍します。 Experience Builder (Developer Edition) 用の npm-cache zip をローカルにダウンロードして、解凍します。 コマンド プロンプト(例えば、Windows OS c:\\Users\\exbuser)、またはターミナル(例えば、macOS /Users/installExB)で、ユーザーフォルダを開き、npm config get cache と入力します。 npm config get cache の実行で表示された npm-cache のフォルダのパスをコピーして、そのディレクトリを Windows のエクスプローラーか Mac の場合は Finder で開きます。 ダウンロードした Experience Builder (Developer Edition) 用 の npm-cache ディレクトリをコピーして、4 で参照しているディレクトリに貼り付けます。 コマンド プロンプト、またはターミナル ウィンドウを開き、Experience Builder インストールの client ディレクトリに cd コマンドで移動して、npm install --offline と入力して Enter キーを押します。 別のコマンド プロンプト、またはターミナル ウィンドウを開き、Experience Builder インストールの server ディレクトリに cd コマンドで移動して、npm install -- offline と入力して Enter キーを押します。 Experience Builder の client ディレクトリを以下のパス \u0026lt;install folder\u0026gt;/client/dist で開きます。 変数 ARCGIS_JS_API_URL をローカルで JSAPI を参照している URL に更新する必要が4箇所あります。例えば、以下の各ファイルで var ARCGIS_JS_API_URL = 'https://js.arcgis.com/4.xx/' を var ARCGIS_JS_API_URL = 'https://exb.esri.com/4.xx/' に置き換えてください。  \u0026lt;install folder\u0026gt;/client/dist/index.html \u0026lt;install folder\u0026gt;/client/dist/experience/index.html \u0026lt;install folder\u0026gt;/client/dist/template/index.html \u0026lt;install folder\u0026gt;/client/dist/builder/index.html   コマンド プロンプト、またはターミナル ウィンドウを開き、Experience Builder のインストール先の client ディレクトリに cd コマンドで移動して、npm start と入力して client サービスを起動します。 コマンド プロンプト、またはターミナル ウィンドウを開き、Experience Builder のインストール先の server ディレクトリに cd コマンドで移動して、npm start と入力して server サービスを起動します。  Experience Builder (Developer Edition) を使用するために クライアント ID が必要になります。クライアント ID を作成するために ArcGIS Online または ArcGIS Enterprise に接続します。\n\rここでは、ArcGIS Online または ArcGIS Enterprise を使用した クライアント ID の作成手順について示します。\n  ArcGIS Online または ArcGIS Enterprise ポータルにログインし、コンテンツ ページの マイ コンテンツ タブに移動して、新しいアイテム をクリックし、アプリケーション を選択します。\n  アプリケーション タイプ で 他のアプリケーション を選択します。\n  ダイアログボックスで、以下のパラメータを入力し、保存 をクリックします。\n タイトル - 例えば、Experience Builder credentials などの任意のタイトルをを入力します。 フォルダー - アイテムを保存する任意のフォルダーを選択します。 タグ - Experience Builder のような内容を入力します。 必要に応じてカテゴリとサマリーを入力してください。     設定 タブをクリックします。Application までスクロールします。\n  URL に任意の URL を入力します。\n  認証情報までスクロールし、次のように、リダイレクト URL に https://localhost:3001/ と入力し、追加をクリックして、更新 をクリックします。クライアント ID は、このあとの手順で使用するため、コピーなどをして控えておきます。   次の URL https://localhost:3001/ を指定して Experience Builder をブラウザで開きます。\n  ポータルの URL には、ArcGIS Online または ArcGIS Enterprise の組織サイトの URL を指定し、5. で作成した アプリケーション ID を指定します。すべてを指定したらサイン インをクリックします。\n  サイン イン後の流れについては、2. server サービスのインストールのステップ5 以降を参照してください。\n  Windows サービスとしてインストール   お使いの OS に対応した最新の Node.js LTSバージョンをダウンロードし、インストールしてください。\n  Windows のコマンドプロンプトを管理者権限で開きます。\n  Experience Builder の /server ディレクトリにディレクトリを変更 (cd) します。\n  npm ci  コマンドを実行し、依存関係をインストールします。\n  npm run install-windows-service のコマンドを実行します。\n  Windows サービスアプリを開き、Experience Builder サービス（デフォルト名：exb-server）を起動します。\n  Experience Builder サービスを削除するには、 npm run uninstall-windows-service  というコマンドを実行します。\n  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/python-api-install/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS API for Python の環境構築方法を紹介します。",
	"content": "Python には、ArcGIS Pro で使用できるパッケージが豊富に用意されています。Python パッケージの使用を簡素化するために、ArcGIS Pro には conda と呼ばれるパッケージ管理システムが含まれています。 conda は、パッケージとその依存関係のインストールや更新の手間を省きます。 個のガイドでは ArcGIS Pro を使用したインストールの流れについてご紹介します。\nSTEP 1: Python API のインストール  ArcGIS Pro でインストール Python コマンド プロンプトでインストール  STEP 2: arcgis パッケージのアップグレード STEP 3: ArcGIS API for Python の実行  Jupyter Notebook の起動 Jupyter Notebook で地図表示  参考  オフライン時のインストール方法 特定の Python 環境のカーネルの追加  Python API のインストール ArcGIS Pro でインストール ArcGIS Pro では、2.5 以降のリリースから conda と arcgis パッケージが最初からインストールされています。 conda の機能は、パッケージ マネージャー を通じて ArcGIS Pro に統合されています。ArcGIS Pro 2.5 以降では、任意の conda パッケージをダウンロードしてインストールするための パッケージ マネージャーの GUI が提供されています。ArcGIS Pro の設定画面からアクセスすることができます。\nArcGIS API for Python 2.4.0 は ArcGIS Pro 3.4 以降でのみサポートされます。ArcGIS Pro 3.3 以前の環境では、2.4.0 の arcgis および arcgis-mapping パッケージはサポートされません。ArcGIS Pro 3.3.x 環境でのインストールについては、ArcGIS API for Python 2.3.x のドキュメントをご参照ください。\n\r ArcGIS Pro を開き [設定] ＞ [パッケージ マネージャー] を選択します。プロジェクトを開いている場合は、[プロジェクト] タブ ＞ [パッケージ マネージャー] を選択します。 デフォルトの arcgispro-py3 環境にインストールされているパッケージのリストが表示されます。さらにパッケージの追加や更新を行うには、以下の操作を行います。 パッケージ マネージャーで [環境マネージャー] ボタンをクリックし、[arcgispro-py3 のクローン作成] ボタンを選択します。  (ArcGIS Pro 3.x)①[環境マネージャー]ボタンと環境の②[デフォルトのクローン]ボタン\n\r 必要に応じてパスと名前を変更し、[OK] をクリックします。 すべてのパッケージのインストールが完了すると、クローンされた環境が格納されているディレクトリ名が表示されます。\n※ 完了前に操作をすると、作成した環境が正常に動作しない可能性があります。 環境マネージャー ウィンドウで作成した環境の右側にある [・・・] から [アクティブ化] を選択し、完了したら [OK] をクリックします。  (ArcGIS Pro 3.x)環境をアクティベート\n\rアクティブ化した環境でインストールされているパッケージを確認したり、更新やパッケージの追加オプションを使用して、クローン環境をニーズに合わせて変更することができます。\nパッケージ マネージャー を使用して arcgis パッケージをアップグレードすることはできません。arcgis パッケージのアップグレード手順については、「パッケージのアップグレード」のセクションを参照してください。\n\r Python コマンド プロンプトでインストール ArcGIS Pro には、任意の conda パッケージをダウンロードしてインストールするための Python コマンド プロンプトが提供されています。\n Windows のスタートメニュー ＞ すべてのアプリ ＞ ArcGIS ＞ Python コマンド プロンプトを選択します。  デフォルトでは、Python コマンド プロンプトは ArcGIS Pro のデフォルトの arcgispro-py3 環境ディレクトリ(通常は C:\\Program Files\\ArcGIS\\Pro\\bin\\Python\\envs\\arcgispro-py3\\ ) で開き、デフォルトの conda 環境がアクティブになります。\n\rさらにパッケージを追加するには、デフォルトの arcgispro-py3 環境のクローンを作成する必要があります。Python コマンド プロンプトでクローン環境を作成する手順についての詳細は、Clone a Python environment with the Python Command Prompt を参照してください。クローン環境を既に作成している場合は、以下のコマンドを使用してクローン環境をデフォルトの環境に変更することができます。\nproswap \u0026lt;環境名\u0026gt;\r Python コマンドプロンプトで以下のコマンドを使用してパッケージをインストールします。\n※ バージョン番号を指定しない場合はその時点の最新版がインストールされます。  conda install -c esri arcgis arcgis-mapping\rarcgis 2.4.0 および arcgis-mapping パッケージは、ArcGIS Pro 3.4 以降の環境でサポートされています。ArcGIS Pro 3.3.x インストールのパッケージのアップグレードについては、バージョン 2.3.x のドキュメントを参照してください。\n\rPython コマンド プロンプト\n\rarcgis パッケージのアップグレード デフォルトの arcgispro-py3 環境は変更できません。パッケージをアップデートする場合は、クローン環境を作成してください。また、パッケージ マネージャーでは arcgis パッケージを更新することはできません。以下のようにPython コマンド プロンプトを使用します。\n\r Python コマンドプロンプトを開きます。\nWindows のスタートメニュー ＞ すべてのアプリ ＞ ArcGIS ＞ Python コマンド プロンプトで開くことができます。 以下のコマンドでアップグレードする arcgis パッケージを含む環境をアクティブ化します。  activate \u0026lt;環境名\u0026gt;\r esri チャネルからバージョン番号なしでインストールして、arcgis パッケージを最新版にアップグレードします。以下のコマンドを入力します。  conda install -c esri arcgis arcgis-mapping\rコマンドの入力\n\r インストール、アップグレードするパッケージの名前とバージョン番号が表示されるので、問題がなければ y を入力し、実行します。 ArcGIS Pro のバージョンによっては、最新の Python API のバージョンが表示されない場合があります。その場合、一度 n を入力・実行し、以下のコマンドを再入力してください。  conda install -c esri arcgis --no-pin\rArcGIS Pro のバージョンによってはデフォルトの設定で、アップグレードできる Python API のバージョンの上限が指定がされています。 conda install -c esri arcgis --no-pin のうち、--no-pin がバージョンの指定を外して最新版までアップグレードするためのオプションです。 ただし、デフォルトの設定が変更されるわけではないため、アップグレード後に他のパッケージをインストールしようとすると、設定された上限のバージョンにダウングレードするように conda で計画されます。 その場合、そのパッケージをインストールした後に再度上記のコマンドを入力し arcgis パッケージをアップグレードしてください。\n\r アップグレードしたバージョンを確認するには、次のコマンドを入力します。  conda list arcgis\r Python API を含む ArcGIS 関連のパッケージとそのバージョン番号が表示されます。  \n\r ArcGIS API for Python の実行 Jupyter Notebook の起動  Pythonコマンドプロンプトを起動します。 cd コマンドを使用して、ノートブックがあるディレクトリ、またはノートブックを作成したいディレクトリに移動します。 次のように入力して Jupyter Notebook を起動します。  jupyter notebook\r 起動しなかった場合は、以下を試してください。  jupyter-notebook\rまたは、スタートメニュー ＞ すべてのプログラム ＞ ArcGIS ＞ Jupyter Notebook を選択しても起動することができます。\nJupyter Notebook の詳しい操作は Jupyter Notebook を使ってみようもご覧ください。 Python API バージョン 1.5.0 以降からは、Jupyter Lab からも操作が可能です。Jupyter Lab を使ってみようも是非ご覧ください。\nJupyter Notebook で地図表示 次の手順で、地図を表示するための新しいノートブックを作成します。\n Click New \u0026gt; Python 3  \r次のコードを入力します。\nfrom arcgis.gis import GIS my_gis = GIS() my_gis.map() \rJupyter Notebook から使用している Python API のバージョンを確認する場合、次のコードを実行することで、現在お使いのバージョンを確認することができます。\nimport arcgis arcgis.__version__ もしくは、先頭に ! を付けて以下のようにコマンドを実行して確認することも可能です。\n!conda list arcgis\r\r 参考 オフライン時のインストール方法 インターネットに接続していない環境の場合、次の手順で Python API のインストールが可能です。\nただし、この場合、すべての依存パッケージがインストールされるわけではないため、Jupyter Notebook の利用など、一部の機能が制限される可能性があります (※ 組織やコンテンツの管理など特定のタスクは以下手順でインストールする six パッケージのみで可能です。)\n依存パッケージについては米国Esri 社のガイドページ：System requirements を参照ください。\nインターネットに接続できる環境で以下の必要なソフトウェアをダウンロードします。\n 最新の Python 3.x 用の Anaconda 適切なバージョンの Python API のファイル  Anaconda クラウドの Esri のチャネルからダウンロード可能です。 ファイル名は以下のパターンに従います  OS/arcgis-x.x.x-pyZZyyyyyyy-y.tar.bz2.  OS: 使用するマシンの OS x.x.x: API のバージョン ZZ: 使用する Python のバージョン yyyyyyy-y: チャネルにアップロードされた conda のパッケージに付与されるハッシュ ナンバー     例えば、Windows 64 bit のマシンで、Python API 1.6.0 の Python 3.7 版をダウンロードする場合は、\u0026quot;win-64/arcgis-1.6.0-py37h62639d4_1.tar.bz2\u0026quot; をクリックしてダウンロードします。    \rオフライン環境で Anaconda を設定\n Anaconda をインストールします。 次のコマンドでオフライン モードに設定します。  conda config --set offline True\r 次のコマンドで新しい環境を作成します。  conda create -n \u0026lt;環境名\u0026gt; python six\r 環境をアクティベートします。  conda activate \u0026lt;環境名\u0026gt;\r ArcGIS API for Python をインストールします。  conda install \u0026lt;事前にダウンロードしたファイルのパス\u0026gt;\r\u0026ldquo;done\u0026quot;が表示されればインストール完了です。\nより詳しい情報は Esri ガイド ページ Install-Offline をご覧ください。\n特定の Python 環境のカーネルの追加 異なる Python 環境ごとに Jupyter Notebook のインスタンスを実行する代わりに、特定の Python 環境を持つカーネルを Jupyter Notebook にインストールすることができます。\nJupyter Notebook に特定の Python 環境でカーネルを追加するには、以下で説明する手順に従います。\n Python コマンド プロンプトを管理者として実行します Python コマンド プロンプト ウィンドウで、次のコマンドを挿入します  python -m ipykernel install --user --name \u0026lt;環境名\u0026gt; --display-name \u0026quot;\u0026lt;Jupyter Notebook 上の表示名\u0026gt;\u0026quot;\r2 のコマンドを実行すると、カーネルが作成され、次の応答が返されます  Installed kernelspec \u0026lt;カーネル名\u0026gt; in C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Roaming\\jupyter\\kernels\\\u0026lt;カーネル名\u0026gt;\r次に、別の Python 環境でカーネルを作成するために別の環境をアクティベートします  activate \u0026lt;環境名\u0026gt;\r手順 2 と同様の方法でカーネルを作成します Python コマンド プロンプトで下記のコマンドを入力し、Jupyter Notebook を起動します  Jupyter Notebook\rカーネルのリストに作成したカーネルが存在することが確認できます  \rこのような方法で特定の異なる環境のカーネルを作成し、Jupyter Notebook 上で切り替えられるようになります。\n特定の Python 環境を持つ新しいカーネルは手動で作成することでも可能です。詳細は Install a new kernel in Jupyter Notebook using a specific Python environment をご参照ください。\nまた、特定の環境のパスを指定してカーネルを作成する方法については Kernels for different environments もご参照ください。\nインストールに関しての詳細は Esri ガイド ページ Install and set up もご参照ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/window/",
	"title": "ウィンドウ（Window）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Window\nウィンドウとは ArcGIS Experience Builder では、ウィンドウはエクスペリエンスの上にコンテンツまたはウィジェットを表示できるパネルです。ウィンドウズでは、ユーザーはメインのエクスペリエンスから離れることなく、集中してコンテンツに触れることができます。ウィンドウは固定モーダルまたはアンカー付きポップアップとして表示するように設定できます。\nウィンドウにコンテンツを表示するには、主に2つの設定があります。\n   ウィンドウ タイプ 説明     固定ウィンドウ 閉じるまでメイン ウィンドウとのインタラクションを無効にするモーダル オーバーレイ。スプラッシュ画面や重要なメッセージによく使われます。   アンカー ウィンドウ ボタンやテキストなどのウィジェットに固定されたポップアップで、通常、コンテキスト情報やアクションに使用されます。    アプリの設定では、ウィンドウはダイアログ プロパティで定義されます。\nなぜウィンドウを使うのか ArcGIS Experience Builder のウィンドウでは、メインのエクスペリエンスからナビゲートすることなく、追加のコンテンツや機能を表示できます。フォーム、メディア、その他のウィジェットを集中的に表示し、ユーザーとのインタラクションやエンゲージメントを高めることができる。\nウィンドウを使用して、次を提供します。\n メインコンテンツから離れることなく、重要な情報や行動を提示します。 追加の詳細、フォーム、またはメディアを専用のオーバーレイで表示します。 ユーザーが別のスペースでウィジェットやコンテンツとやりとりできるようにします。 特定のウィジェットからウィンドウをトリガーして、関連情報やオプションを提供します。  ウィンドウの使用方法 ArcGIS Experience Builder でウィンドウを使用する一般的な手順は次のとおりです。\n ウィンドウの追加 エクスペリエンスにウィンドウを追加します。 ウィンドウの設定 ウィンドウのモード、サイズ、位置を設定します。 ウィンドウのトリガーを設定 ウィンドウの表示タイミングと表示方法を設定します。  1. ウィンドウの追加 エクスペリエンスにウィンドウを追加するには、以下の手順に従ってください。\n ページ パネルに移動し、ウィンドウ タブを選択し、ウィンドウの追加をクリックします。 ウィンドウのテンプレートを選択します。 ウィンドウ タイプを決定します。  固定：画面上の固定位置に表示されます。 アンカー：リンクされたウィジェットに隣接して表示されます。 ウィンドウがエクスペリエンスに追加され、プロパティの設定を開始できます。    2. ウィンドウの設定 ウィンドウのプロパティを設定するには、以下の設定を考慮する必要があります。\n  位置とサイズ\n 固定ウィンドウの場合は、ページ上の9つのアンカー ポイントから1つを選択します。 幅と高さをピクセルまたはパーセントで指定します。 ウィンドウの位置を調整するには、オフセット X/Yを使用します。 ウィンドウの周囲にスペースを設定するためにマージンを定義します。    動作設定\n ブロック ページ：ウィンドウがアクティブな間、基礎となるアプリとのインタラクションを防ぎます。 マスク色：ウィンドウがアクティブなときに、アプリの残りの部分をオーバーレイする色を選択します。 終了オプション  ユーザーがウィンドウの外側をクリックしてウィンドウを閉じられるようにします。 ウィンドウ内に閉じるボタンを追加します。      3. ウィンドウのトリガーを設定 アプリのロード、ページのロード、ウィジェットとのユーザーインタラクションなどのトリガーを設定することで、ウィンドウがいつ、どのように表示されるかを制御できます。\nウィンドウのトリガーを設定するには、以下の方法を使用できます。\n  アプリまたはページのロード時\n アプリのロード時に表示されるスプラッシュとしてウィンドウを設定します。 ウィンドウを特定のページにリンクするには、「ウィンドウで開く」設定を使用します。    ウィジェット インタラクション\n ウィジェットの設定でリンクを設定オプションを使用して、ユーザー インタラクションでウィンドウを開きます。 このトリガーでは、スプラッシュ ウィンドウを除いて、アンカー ウィンドウか固定ウィンドウのいずれかを選択します。    ウィンドウ テンプレート 使用するケースに合わせて、さまざまなウィンドウ テンプレートから選択することができます。以下の表は、一般的なテンプレートとその目的をまとめたものです。\n   テンプレート 説明     固定ブロッカー 閉じるまで操作をブロックします。   固定パススルー メイン ウィンドウとのインタラクションを許可します。   アンカー ウィジェットにウィンドウをリンクする場合に適切です。    ウィンドウ テンプレートの詳細については、ウィンドウの追加 -\u0026gt; テンプレートを参照してください。\n\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/calcite-design-system/tutorials/",
	"title": "チュートリアル",
	"tags": [],
	"description": "Calcite の開発パターンを学び、ワークフローやアプリケーションを構築します。",
	"content": "出典：Calcite Design System - Tutorials\n段階的な手順に従って、ArcGIS Maps の機能と Calcite Design System のコンポーネントやパターンを組み込んだアプリケーションを構築します。\nコンセプト コア コンセプトを適用し、Calcite Design System の機能を確認します。\n マッピング アプリの作成\nCalcite コンポーネントとArcGIS Maps SDK for JavaScript Mapコンポーネントを使用して、シンプルなマッピング アプリケーションのUIを作成する方法について学びます。\n\r 暗色 (dark) モード スイッチの構築\nCalcite コンポーネントと ArcGIS Maps SDK for JavaScript の明色 (light) モードと暗色 (dark) モードを切り替えるコンポーネントの作成方法について学びます。\n\r Web コンポーネントでマッピング アプリを構築\nCalcite コンポーネントと Map コンポーネントを使用して、インタラクティブなマッピング アプリケーションを構築する方法を学びます。\n\r\rアプリケーションパターン 基本的な概念とパターンに基づいて構築し、それらをエクスペリエンスとワークフローに適用します。\n  コア コンセプトの適用\nインタラクティブなアプリケーションを作りながら、Calcite Components の基本的な概念を学びます。\n  最近の地震をフィルタリング\nCalcite Design System でユーザー インターフェース(UI)を作成します。\n  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/deploy-pattern/",
	"title": "デプロイ パターン",
	"tags": [],
	"description": "ArcGIS Web AppBuilder (Developer Edition) で作成したアプリやウィジェットのデプロイ パターンを紹介します。",
	"content": "トピック  概要 Web アプリケーションをデプロイ ウィジェットをデプロイ テンプレートをデプロイ  概要 ArcGIS Web AppBuilder (Developer Edition) (以下 Developer Edition) では ArcGIS Web AppBuilder を拡張して、独自の Web アプリケーションやウィジェット、テンプレートを作成することが可能です。エンド ユーザーの利用形態や要件により最適なデプロイは異なりますが、このページでは以下の 3 つの主要なデプロイ パターンと、それぞれのデプロイ方法についてご紹介します。\n Web アプリケーションをデプロイ 全体像  Web アプリケーションを作成し、独自のサーバーでホストすることができます。特定の業務で継続的に利用されるアプリ等、ユーザーによる設定変更が不要な場合や、ユーザーに設定変更をさせたくない場合等に活用できます。   必要なコンポーネント  開発時  Node.js Developer Edition   運用時  ArcGIS Enterprise または ArcGIS Online Web サーバー (ArcGIS Enterprise の Web サーバーと併用も可)    手順概要 以下は Web アプリケーション作成から、デプロイ、実際の運用までの流れの概要です。\n カスタム ウィジェットを含む web アプリケーションを作成  Developer Edition を用いたウィジェットの開発や web アプリケーションの作成には Node.jsが必要です。 詳しくはインストールガイドをご覧下さい。 カスタム ウィジェットを開発する際は、カスタム ウィジェット開発ガイドをご覧ください。   作成した web アプリケーションを自身で用意した Web サーバーに配置  ArcGIS Enterprise で使用している Web サーバーと併用することも可能です。 ※ ArcGIS Online を使用してホストすることはできません。 詳しくは、アプリケーションのデプロイをご覧ください。   ユーザーが作成された web アプリケーションを利用  ユーザーが web アプリケーションにアクセスして利用します。 ArcGIS Enterprise や ArcGIS Online のポータルにアイテムとして表示させたい場合はアプリの URL をアイテムに登録する必要があります。  詳細は「アプリの追加」及びその後の「アプリの登録」をご覧ください。   内部的には、アプリは ArcGIS Online もしくは ArcGIS Enterprise の Web マップを参照してアプリ上に地図を表示します。     ウィジェットをデプロイ  WebApp Builder で使用できるウィジェットのみを開発し、独自のサーバーでホストすることも可能です。ユーザーが ArcGIS Online や ArcGIS Enterprise を使用して独自に web アプリケーションを作成することを想定しているものの、デフォルトの ArcGIS Web AppBuilder のウィジェットには無い機能を拡張したい場合に活用できます。   必要なコンポーネント  開発時  Node.js Developer Edition   運用時  ArcGIS Enterprise Web サーバー (ArcGIS Enterprise の Web サーバーと併用も可)    手順概要 以下はカスタムウィジェットの作成から、デプロイ、実際の運用までの流れの概要です。\n カスタムウィジェットを作成  Developer Edition を用いたウィジェットの作成には Node.jsが必要です。 詳しくはインストールガイドをご覧下さい。 カスタムウィジェット開発の詳細については、カスタム ウィジェット開発ガイドをご覧下さい。   作成したカスタムウィジェットを自身で用意した Web サーバーに配置  ArcGIS Enterprise で使用している Web サーバーと併用することも可能です。 ※ ウィジェットを配置するサーバーが自己署名証明書を使用している場合、Portal for ArcGIS に証明書をインポートする必要があります。詳しい方法はポータルへの証明書のインポートをご覧ください。 Web サーバーに配置後、ArcGIS Enterprise に組み込まれている ArcGIS Web AppBuilder にカスタムウィジェットを追加します。  詳しくは、カスタム ウィジェットの追加をご覧ください。 ※ ArcGIS Online に追加することはできません。     ウィジェットを使った web アプリケーションの作成・利用  ユーザーが ArcGIS Enterprise に組み込まれている ArcGIS Web AppBuilder を利用してカスタムウィジェットを使用した web アプリケーションを作成・利用します。 内部的には、アプリは Web サーバーでホストされているカスタムウィジェットを参照して動作します。     テンプレートをデプロイ  Esri が用意している web アプリケーションのテンプレートとは別に、Developer Edition で作成した web アプリケーションをベースに独自のテンプレートを作成できます。テンプレートを用いることで、ユーザー自身がマップや簡易な設定の変更のみで web アプリケーションを作成することができるようになります。テンプレートを作成しておくと、必要な機能が共通している複数の業務に対して、異なるマップや設定を適用するだけですぐ各業務向けのアプリを作成できます。 ここでご紹介する方法では開発環境と運用環境が同じである点にご注意ください。   必要なコンポーネント  開発時  Node.js Developer Edition   運用時  Node.js Developer Edition ArcGIS Online または ArcGIS Enterprise    手順概要 以下はテンプレートの作成から、デプロイ、実際の運用までの流れの概要です。\n カスタムウィジェットを含む web アプリケーションを作成  Developer Edition を用いたウィジェットの作成には Node.jsが必要です。 詳しくはインストールガイドをご覧下さい。 カスタム ウィジェットを開発する際は、カスタム ウィジェット開発ガイドをご覧ください。   web アプリケーションをテンプレートとして保存 (登録)  Developer Edition で作成した web アプリケーションを組織にエクスポートします。  Developer Edition でアプリを作成し、[保存] ボタンをクリックした後 [テンプレートとしてエクスポート] をクリックします。  構成可能にするパラメーターを設定した後、組織にエクスポートをクリックします。  ※ テンプレートは、組織が設定するテンプレート グループに共有される必要があります。管理権限を持っていない場合、権限が無いことと別途マニュアルで追加する必要がある旨がダイアログで表示されます。 組織の管理者権限がある場合、以下の手順でテンプレート グループを設定できます。  [組織] → [設定] → [マップ] の順にクリック  [テンプレート] の中でテンプレートを共有するグループを指定  [Esri のデフォルトの構成可能なアプリをグループで共有します] をクリックすると、Esri がデフォルトで用意しているテンプレートも通常どおり使用できます。         テンプレートを使った web アプリケーションの作成・利用  ユーザーが ArcGIS Online もしくは ArcGIS Enterprise のテンプレートから web アプリケーションを作成・利用します。 内部的には、アプリは Developer Edition のテンプレートを参照して動作します。 ※ 上記理由から、運用時においてもユーザーが Developer Edition にアクセスできる必要があります。    3つのデプロイ パターンの総括表    パターン 開発時に必要なコンポーネント 運用時に必要なコンポーネント ArcGIS Online での利用可否 ArcGIS Enterprise での利用可否     Web アプリケーションをデプロイ Node.js、Developer Edition Web サーバー、ArcGIS Online もしくは ArcGIS Enterprise 〇 〇   ウィジェットをデプロイ Node.js、Developer Edition Web サーバー、 ArcGIS Enterprise × 〇   テンプレートをデプロイ Node.js、Developer Edition Developer Edition、ArcGIS Online もしくは ArcGIS Enterprise 〇 〇    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/android/migration-android-100.x/",
	"title": "バージョン 10.2.x から 100.x への移行",
	"tags": [],
	"description": "今まで ArcGIS Runtime SDK for Android バージョン 10.2.x を使用してアプリケーションを開発されていた開発者向けのガイドです。",
	"content": "ArcGIS Runtime SDK バージョン 100.x は新しいアーキテクチャを使用してゼロから開発された次世代の ArcGIS Runtime です。このバージョンアップに伴い API の再設計が行なわれています。このドキュメントでは、バージョン 100.x の変更点について説明します。\nArcGIS Runtime SDK for Android に関しては、ESRIジャパン 製品ページをご参照ください。\n以下は、バージョン 100.x の主な変更点です。\n Gradle 参照プロジェクトの変更 マップ ビュー レイヤー クラス名の変更 フィーチャ レイヤーの表示 フィーチャの操作 個別属性表示 グラフィックス オーバーレイ ジオメトリとジオメトリ ビルダー ローダブル パターン 新しい同期パターン 既知の制限事項  Gradle 参照プロジェクトの変更 Android Studio のビルド ツールは Gradle を使用し、maven リポジトリとライブラリの参照を変更します。\nrepositories {\rjcenter()\rmaven {\rurl 'https://esri.jfrog.io/artifactory/arcgis'\r}\r}\rdependencies {\rimplementation 'com.esri.arcgisruntime:arcgis-android:100.10.0'\r}\rArcGIS Runtime SDK for Android がサポートする最新の動作環境は、ESRIジャパン 製品ページ（動作環境）をご参照ください。\nマップ 100.x では、ArcGISMap オブジェクトを API のコアとして、ArcGIS プラットフォームの Web GIS 機能を迅速に利用できるようになりました。\nArcGISMap オブジェクトは 、それを表示する View と分離されています。ArcGISMap オブジェクトには 、操作レイヤー、ベースマップ、ブックマーク等の ArcGIS 固有のデータを設定でき、アプリケーションで利用することができます。\nビュー MapView（2D表示用）と SceneView（3D表示用）は、UI コンポーネントです。MapView クラスの map プロパティに、ArcGISMap オブジェクトを設定します。\n100.x では、以下のようにマップを表示します。\n// ベースマップを指定してマップを初期化 ArcGISMap mArcGISMap = new ArcGISMap(); mArcGISMap.setBasemap(Basemap.createTopographic()); // マップビューにマップを設定 MapView mMapView = findViewById(R.id.MapView); mMapView.setMap(mArcGISMap); レイヤー クラス名の変更 各レイヤーのクラス名が以下のように変更されています。\n   レイヤー 10.2.x のクラス名 100.x のクラス名     ArcGIS Server ダイナミック マップ サービス レイヤー ArcGISDynamicMapServiceLayer ArcGISMapImageLayer   タイル マップ サービス レイヤー ArcGISTiledMapServiceLayer ArcGISTiledLayer   タイル パッケージ レイヤー ArcGISLocalTiledLayer ArcGISTiledLayer    100.x でサポートされているレイヤーの種類については、ArcGIS Runtime SDK for Android: レイヤー（英語）をご参照ください。\n作成した各レイヤーは、以下の方法でマップに追加します。\n// 操作レイヤーとしてマップに追加する mArcGISMap.getOperationalLayers().add(arcgis_map_image_layer) // ベースマップとしてマップに追加する Basemap mBasemap = new Basemap(); mBasemap.getBaseLayers().add(arcgis_tiled_layer); フィーチャ レイヤーの表示 フィーチャ サービスや端末のローカルに格納されたジオデータベースのデータをマップに表示するにはフィーチャ レイヤーを使用します。 フィーチャ レイヤーを表示するには、はじめにフィーチャ テーブルを作成します（フィーチャ サービスのデータをフィーチャ レイヤーで表示する場合は ArcGISFeatureTable オブジェクト、ジオデータベースのデータを表示する場合は GeodatabaseFeatureTable オブジェクトを使用します）。次に作成したフィーチャ テーブルを引数として FeatureLayer オブジェクトを作成し、ArcGISMap オブジェクトの OperationalLayers に追加します。\n次のコードは、フィーチャ サービスのデータを FeatureLayer としてマップに追加する方法を示しています。\n// フィーチャ サービスの URL からフィーチャ テーブルを作成 ServiceFeatureTable serviceFeatureTable = new ServiceFeatureTable(\u0026#34;https://services.arcgis.com/wlVTGRSYTzAbjjiC/arcgis/rest/services/all_Japan_shikuchoson/FeatureServer/0\u0026#34;); // フィーチャ テーブルからフィーチャ レイヤーを作成 FeatureLayer featureLayer = new FeatureLayer(serviceFeatureTable); // フィーチャ レイヤーをマップの操作レイヤーに追加 mArcGISMap.getOperationalLayers().add(featureLayer); フィーチャの操作 フィーチャの検索や編集はフィーチャ テーブル （ServiceFeatureTable または GeodatabaseFeatureTable）に対して行います。\nフィーチャ サービスから作成したフィーチャ テーブル（ServiceFeatureTable）の場合、フィーチャ テーブルのフィーチャは、マップ上にレンダリングするために必要最小限の情報だけを含むように最適化されています。これにより、フィーチャを表示するための待機時間と帯域幅の消費が削減されます。フィーチャの編集やすべての属性情報を表示するような場合は完全な情報を取得するために、ローダブル パターン等を使用して、フィーチャを明示的にロードしておく必要があります。\nフィーチャのリクエスト モード フィーチャ サービスからフィーチャを取得する場合は、 リクエスト モードの設定によってフィーチャの取得頻度とや端末上でのデータのキャッシュ方法を制御します。リクエスト モードには、ON_INTERACTION_CACHE、 ON_INTERACTION_NO_CACHE、MANUAL_CACHE  があります。リクエスト モードはフィーチャ テーブルが初期化される前に、ServiceFeatureTable の setFeatureRequestMode メソッドを使用して設定できます。\n ON_INTERACTION_CACHE : ユーザーの操作によりマップの表示領域が変更されると、フィーチャが自動的にリクエストされます。リクエストされたすべてのデータはローカルにキャッシュされます。データがキャッシュされルため、既に表示された領域にマップが移動しても、再度フィーチャはリクエストされません。サーバー上のデータが変更される可能性が少ない静的なデータに適したモードです。 ON_INTERACTION_NO_CACHE : ユーザーの操作によりマップの表示領域が変更されると、フィーチャが自動的にリクエストされますが、キャッシュはされません。既に表示された領域にマップが移動すると、再度フィーチャがリクエストされます。サーバー上のデータが継続的に更新される可能性がある場合に適したモードです。 MANUAL_CACHE : ユーザーによるマップ操作では、フィーチャは自動的にリクエストされません。このモードを使用する場合は、ServiceFeatureTable の populateFromServiceAsync メソッドを使用して明示的にデータをリクエストする必要があります。  以下のコードは populateFromServiceAsync メソッドを使用して、サーバー上のすべてのフィーチャを取得する方法の例です。\n// フィーチャの検索パラメーターを設定 QueryParameters queryParameters = new QueryParameters(); // すべてのフィーチャを取得するように条件を設定 queryParameters.setWhereClause(\u0026#34;1=1\u0026#34;); // 検索結果にフィーチャのすべての属性情報（outFields の配列に \u0026#34;*\u0026#34; を指定）を含める ArrayList\u0026lt;String\u0026gt; outFields = new ArrayList\u0026lt;\u0026gt;(); outFields.add(\u0026#34;*\u0026#34;); serviceFeatureTable.populateFromServiceAsync(queryParameters,true,outFields); フィーチャの編集 フィーチャの編集はフィーチャ テーブルに対して行います。フィーチャ サービスまたはジオデータベースのデータから作成したフィーチャ テーブルのどちらを編集する場合も実装方法に違いはありません。\nフィーチャの編集方法は、 ArcGIS Runtime SDK for Android: フィーチャの編集（英語）をご参照ください。\nフィーチャの検索 フィーチャの検索はフィーチャ テーブルに対して行います。フィーチャ サービスまたはジオデータベースのデータから作成したフィーチャ テーブルのどちらを編集する場合も実装方法に違いはありません。検索を行うには ServiceFeatureTable または GeodatabaseFeatureTable クラスの queryFeaturesAsync メソッドを使用します。\n次のコードは、フィーチャ サービスから作成したフィーチャ テーブルからフィーチャを検索する方法を示しています。\nfinal ListenableFuture\u0026lt;FeatureQueryResult\u0026gt; queryResult = serviceFeatureTable.queryFeaturesAsync(queryParameters); queryResult.addDoneListener(()-\u0026gt;{ // call get on the future to get the result  try { FeatureQueryResult result = queryResult.get(); for (Iterator\u0026lt;Feature\u0026gt; features = result.iterator(); features.hasNext();) { // 検索結果のフィーチャを取得  Feature feature = features.next(); ・・・ } } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } }); 個別属性表示 マップ上で特定の場所をタップして、その位置にあるフィーチャをすべてのレイヤーから検索して取得することができます。この操作はビューに対して行います。次のコードは、MapView クラスの identifyLayersAsync メソッドを使用してフィーチャを取得する方法を示しています。\nfinal ListenableFuture\u0026lt;List\u0026lt;IdentifyLayerResult\u0026gt;\u0026gt; identifyLayersResult = mapView.identifyLayersAsync(screenPoint,10,true); identifyLayersResult.addDoneListener(()-\u0026gt;{ try { List\u0026lt;IdentifyLayerResult\u0026gt; identifyResult = identifyLayersResult.get(); for(IdentifyLayerResult identifyLayerResult : identifyResult){ // GeoElement オブジェクトの取得  List\u0026lt;GeoElement\u0026gt; geoElement = identifyLayerResult.getElements(); ・・・ } } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } }); グラフィックス オーバーレイ グラフィックは、マップ上に一時的なデータを表示するために使用されます。MapView オブジェクトにはグラフィックを表示するためのグラフィックス オーバーレイ（GraphicsOverlay）が含まれています。 グラフィックス オーバーレイを使用することで、マップ上のレイヤーの順序が変更されても、グラフィックが常に最上位に表示されます。\n次のコードは、MapView オブジェクトに、グラフィックス オーバーレイを使用してグラフィックを追加する方法を示しています。\n// ジオメトリとシンボルを設定してグラフィックを作成 Graphic graphic = new Graphic(geometry,symbol); // グラフィックス オーバーレイに作成したグラフィックを追加 GraphicsOverlay graphicsOverlay = new GraphicsOverlay(); graphicsOverlay.getGraphics().add(graphic); // MapView の GraphicsOverlays に作成したグラフィックス オーバーレイを追加 mapView.getGraphicsOverlays().add(graphicsOverlay); ジオメトリとジオメトリ ビルダー Geometry オブジェクトのコンストラクタを使用すると、既知の座標を使用してジオメトリを作成できますが、作成後にそのジオメトリを変更することはできません。\nジオメトリ ビルダー（GeometryBuilder）を使用すると、ゼロから新しいジオメトリを作成したり、既存のジオメトリを基に、ジオメトリを変更することができます。\nローダブル パターン データを非同期でロードして状態を初期化するマップやレイヤー等のリソースは、ローダブル パターンが採用されています。各リソースのプロパティにアクセスするには、ローダブル パターンを使用して、リソースがロードされた後にアクセスすることが推奨されます。ローダブル パターンは、ロード状態の振る舞いをより均一にして且つ一貫性を持たせることで、非同期性をより明示的にします。ローダブル パターンでは、各リソースは自動的にリソースの状態をロードしません。それらは、開発者が明示的に実行したときに、遅延ロードします。 各リソースの状態は、NotLoaded（ロードが開始していない、Loading（ロード中）、Loaded（ロードに成功）、FailedToLoad（ロードに失敗） のいずれかで監視することもできます。\n詳細は、ArcGIS Runtime SDK for Android: ローダブル パターン（英語）をご参照ください。\n次のコードは、ローダブル パターンの基本的な使用方法の例を示しています。\nFeatureLayer featureLayer = new FeatureLayer(serviceFeatureTable); if(featureLayer.getLoadStatus().equals(LoadStatus.FAILED_TO_LOAD)){ Log.e(\u0026#34;eTag\u0026#34;,\u0026#34;error\u0026#34;); }else{ // フィーチャ レイヤーのロードに成功 } 新しい同期パターン Java 言語で ListenableFuture というインターフェースで馴染みのある Future パターンが拡張されました。この新しい API は、メソッドの完了時に必要な数のリスナーを追加できます。\n既知の制限事項 本バージョンでの既知の制限事項が、ArcGIS Runtime SDK for Android: リリース ノート（英語）に記載されていますので、ご参照ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/ios/migration-ios-100.x/",
	"title": "バージョン 10.2.x から 100.x への移行",
	"tags": [],
	"description": "今まで ArcGIS Runtime SDK for iOS バージョン 10.2.x を使用してアプリケーションを開発されていた開発者向けのガイドです。",
	"content": "ArcGIS Runtime SDK バージョン 100.x は新しいアーキテクチャを使用してゼロから開発された次世代の ArcGIS Runtime です。このバージョンアップに伴い API の再設計が行なわれています。このドキュメントでは、バージョン 100.x の変更点について説明します。\nArcGIS Runtime SDK for iOS に関しては、ESRIジャパン 製品ページをご参照ください。\n以下は、バージョン 100.x の主な変更点です。\n マップとシーン ビュー レイヤー クラス名の変更 フィーチャ レイヤーの表示 フィーチャの操作 個別属性表示 グラフィックス オーバーレイ ジオメトリとジオメトリ ビルダー スケッチ エディター ローダブル パターン ブロックを使用した非同期プログラミング 既知の制限事項  マップとシーン 100.x では、AGSMap オブジェクト（2D表示用）と AGSScene オブジェクト（3D表示用）を API のコアとして、ArcGIS プラットフォームの Web GIS 機能を迅速に利用できるようになりました。\nAGSMap オブジェクトと AGSScene オブジェクトは 、それらを表示する View と分離されています。AGSMap オブジェクトと AGSScene オブジェクトには 、操作レイヤー、ベースマップ、ブックマーク等の ArcGIS 固有のデータを設定でき、アプリケーションで利用することができます。\nビュー AGSMapView（2D表示用）と AGSSceneView（3D表示用）は、UI コンポーネントです。AGSMapView クラスの map プロパティに、AGSMap オブジェクトを、AGSMapSceneView クラスの scene プロパティには AGSScene オブジェクトを設定します。\n100.x では、以下のようにマップを表示します。\n// ベースマップを指定してマップを初期化 let map = AGSMap(basemap:AGSBasemap.imagery()) // マップビューにマップを設定 self.mapView.map = map レイヤー クラス名の変更 各レイヤーのクラス名が以下のように変更されています。\n   レイヤー 10.2.x のクラス名 100.x のクラス名     ArcGIS Server ダイナミック マップ サービス レイヤー AGSDynamicMapServiceLayer AGSArcGISMapImageLayer   タイル マップ サービス レイヤー AGSTiledMapServiceLayer AGSArcGISTiledLayer   タイル パッケージ レイヤー AGSLocalTiledLayer AGSArcGISTiledLayer    作成した各レイヤーは、以下の方法でマップに追加します。\n// 操作レイヤーとしてマップに追加する self.map.operationalLayers.add(arcgis_map_image_layer) // ベースマップとしてマップに追加する self.map.basemap = AGSBasemap(baseLayer: arcgis_tiled_layer) フィーチャ レイヤーの表示 フィーチャ サービスや端末のローカルに格納されたジオデータベースのデータをマップに表示するにはフィーチャ レイヤーを使用します。 フィーチャ レイヤーを表示するには、はじめにフィーチャ テーブルを作成します（フィーチャ サービスのデータをフィーチャ レイヤーで表示する場合は AGSArcGISFeatureTable オブジェクト、ジオデータベースのデータを表示する場合は AGSGeodatabaseFeatureTable オブジェクトを使用します）。次に作成したフィーチャ テーブルを引数として AGSFeatureLayer オブジェクトを作成し、AGSMap オブジェクトの OperationalLayers に追加します。\n次のコードは、フィーチャ サービスのデータを AGSFeatureLayer としてマップに追加する方法を示しています。\n// フィーチャ サービスの URL からフィーチャ テーブルを作成 let featureTable = AGSServiceFeatureTable(url: URL(string: \u0026#34;https://services.arcgis.com/wlVTGRSYTzAbjjiC/arcgis/rest/services/all_Japan_shikuchoson/FeatureServer/0\u0026#34;)!) // フィーチャ テーブルからフィーチャ レイヤーを作成 let featureLayer = AGSFeatureLayer(featureTable: featureTable) // フィーチャ レイヤーをマップの操作レイヤーに追加 self.map.operationalLayers.add(featureLayer) フィーチャの操作 フィーチャの検索や編集はフィーチャ テーブル （AGSArcGISFeatureTable または AGSGeodatabaseFeatureTable）に対して行います。\nフィーチャ サービスから作成したフィーチャ テーブル（AGSArcGISFeatureTable）の場合、フィーチャ テーブルのフィーチャは、マップ上にレンダリングするために必要最小限の情報だけを含むように最適化されています。これにより、フィーチャを表示するための待機時間と帯域幅の消費が削減されます。フィーチャの編集やすべての属性情報を表示するような場合は完全な情報を取得するために、ローダブル パターン等を使用して、フィーチャを明示的にロードしておく必要があります。\nフィーチャのリクエスト モード フィーチャ サービスからフィーチャを取得する場合は、 リクエスト モードの設定によってフィーチャの取得頻度とや端末上でのデータのキャッシュ方法を制御します。リクエスト モードには、OnInteractionCache、 OnInteractionNoCache、ManualCache があります。リクエスト モードはフィーチャ テーブルが初期化される前に、AGSServiceFeatureTable の featureRequestMode プロパティを使用して設定できます。\n  OnInteractionCache: ユーザーの操作によりマップの表示領域が変更されると、フィーチャが自動的にリクエストされます。リクエストされたすべてのデータはローカルにキャッシュされます。データがキャッシュされルため、既に表示された領域にマップが移動しても、再度フィーチャはリクエストされません。サーバー上のデータが変更される可能性が少ない静的なデータに適したモードです。\n  OnInteractionNoCache: ユーザーの操作によりマップの表示領域が変更されると、フィーチャが自動的にリクエストされますが、キャッシュはされません。既に表示された領域にマップが移動すると、再度フィーチャがリクエストされます。サーバー上のデータが継続的に更新される可能性がある場合に適したモードです。\n  ManualCache: ユーザーによるマップ操作では、フィーチャは自動的にリクエストされません。このモードを使用する場合は、AGSServiceFeatureTable の populateFromService メソッドを使用して明示的にデータをリクエストする必要があります。\n以下のコードは populateFromService メソッドを使用して、サーバー上のすべてのフィーチャを取得する方法の例です。\n// フィーチャの検索パラメーターを設定 let params = AGSQueryParameters() // すべてのフィーチャを取得するように条件を設定 params.whereClause = \u0026#34;1 = 1\u0026#34; // 検索結果にフィーチャのすべての属性情報（outFields の配列に \u0026#34;*\u0026#34; を指定）を含める self.featureTable.populateFromService(with: params, clearCache: true, outFields: [\u0026#34;*\u0026#34;]) {(result, error) -\u0026gt; Void in if let error = error { // フィーチャの取得に失敗  print(\u0026#34;Error:\\(error.localizedDescription)\u0026#34;) } else { // フィーチャの取得に成功（フィーチャ数を表示）  print(result?.featureEnumerator().allObjects.count ?? \u0026#34;0\u0026#34;) } }   フィーチャの編集 フィーチャの編集はフィーチャ テーブルに対して行います。フィーチャ サービスまたはジオデータベースのデータから作成したフィーチャ テーブルのどちらを編集する場合も実装方法に違いはありません。\nフィーチャの編集方法は、 ArcGIS Runtime SDK for iOS: フィーチャの編集（英語）をご参照ください。\nフィーチャの検索 フィーチャの検索はフィーチャ テーブルに対して行います。フィーチャ サービスまたはジオデータベースのデータから作成したフィーチャ テーブルのどちらを編集する場合も実装方法に違いはありません。検索を行うには AGSServiceFeatureTable または AGSGeodatabaseFeatureTable クラスの queryFeaturesWithParameters メソッドを使用します。\n次のコードは、フィーチャ サービスから作成したフィーチャ テーブルからフィーチャを検索する方法を示しています。\nfeatureTable.queryFeatures(with: queryParameters, queryFeatureFields: .loadAll, completion:{ (result, error) -\u0026gt; Void in if let error = error { print(\u0026#34;Error:\\(error.localizedDescription)\u0026#34;) } else { let enumr = result?.featureEnumerator() for feature in enumr! { // 検索結果のフィーチャを取得  let feature = feature as! AGSArcGISFeature } } }) 個別属性表示 マップ上で特定の場所をタップして、その位置にあるフィーチャをすべてのレイヤーから検索して取得することができます。この操作はビューに対して行います。次のコードは、AGSMapView クラスの identifyLayers メソッドを使用してフィーチャを取得する方法を示しています。\nself.mapView.identifyLayers(atScreenPoint: screenPoint, tolerance: 10, returnPopupsOnly: true, completion: { (results, error) -\u0026gt; Void in if let error = error { print(error) } else { for identifyLayerResult in results! { for geoElement in identifyLayerResult.geoElements { // AGSGeoElement オブジェクトの取得  } } } }) グラフィックス オーバーレイ グラフィックは、マップ上に一時的なデータを表示するために使用されます。AGSMapView と AGSSceneView オブジェクトにはグラフィックを表示するためのグラフィックス オーバーレイ（AGSGraphicsOverlay）が含まれています。 グラフィックス オーバーレイを使用することで、マップ上のレイヤーの順序が変更されても、グラフィックが常に最上位に表示されます。\n次のコードは、AGSMapView オブジェクトに、グラフィックス オーバーレイを使用してグラフィックを追加する方法を示しています。\n// ジオメトリとシンボルを設定してグラフィックを作成 let pointGraphic = AGSGraphic(geometry: pointGeometry, symbol: poitnSymbol, attributes: nil) // グラフィックス オーバーレイに作成したグラフィックを追加 let graphicsOverlay = AGSGraphicsOverlay() graphicsOverlay.graphics.add(pointGraphic) // AGSMapView の GraphicsOverlays に作成したグラフィックス オーバーレイを追加 self.mapView.graphicsOverlays.add(graphicsOverlay) ジオメトリとジオメトリ ビルダー AGSGeometry オブジェクトのコンストラクタを使用すると、既知の座標を使用してジオメトリを作成できますが、作成後にそのジオメトリを変更することはできません。\nジオメトリ ビルダー（AGSGeometryBuilder）を使用すると、ゼロから新しいジオメトリを作成したり、既存のジオメトリを基に、ジオメトリを変更することができます。\nスケッチ エディター スケッチ エディター（AGSSketchEditor）を使用すると、ユーザーがマップ上で対話的にジオメトリをスケッチすることができます。\n次のコードは、AGSSketchEditor の使用方法の例を示しています。\n// マップ ビューにスケッチ エディターを設定 self.sketchEditor = AGSSketchEditor() self.mapView.sketchEditor = self.sketchEditor // ジオメトリの種類を設定してスケッチを開始 self.sketchEditor.start(with: AGSGeometryType.polygon) // スケッチ中のジオメトリの更新を監視 NotificationCenter.default.addObserver(self, selector: #selector(ViewController.respondToGeometryChanged), name: NSNotification.Name.AGSSketchEditorGeometryDidChange, object: nil) ・・・・・・ @objc func respondToGeometryChanged() { // ジオメトリが更新された際の処理 } ローダブル パターン データを非同期でロードして状態を初期化するマップやレイヤー等のリソースは、ローダブル パターンが採用されています。各リソースのプロパティにアクセスするには、ローダブル パターンを使用して、リソースがロードされた後にアクセスすることが推奨されます。ローダブル パターンは、ロード状態の振る舞いをより均一にして且つ一貫性を持たせることで、非同期性をより明示的にします。ローダブル パターンでは、各リソースは自動的にリソースの状態をロードしません。それらは、開発者が明示的に実行したときに、遅延ロードします。 各リソースの状態は、NotLoaded（ロードが開始していない、Loading（ロード中）、Loaded（ロードに成功）、FailedToLoad（ロードに失敗） のいずれかで監視することもできます。\n詳細は、ArcGIS Runtime SDK for iOS: ローダブル パターン（英語）をご参照ください。\n次のコードは、ローダブル パターンの基本的な使用方法の例を示しています。\nself.featureLayer.load(completion: {(error) -\u0026gt; Void in if let error = error { print(error) }else { // フィーチャ レイヤーのロードに成功  } }) ブロックを使用した非同期プログラミング 非同期操作を実行するメソッドは、完了ブロックを引数として受け取ります。ブロックは操作が正常に完了したとき、または、エラーが発生したときに呼び出されます。操作が成功すると、その操作の結果がブロックに渡されます。それ以外の場合はエラーが渡されます。 これは、デリゲートを使用して各非同期操作の結果とエラーをハンドリングしていた 10.2.x のプログラミング方法を置き換えます。\n次のコードは、例として端末の GPS の位置情報の取得開始の操作結果をハンドリングする方法を示しています。\nself.mapView.locationDisplay.start(completion: { (error) -\u0026gt; Void in if let error = error { // GPS の位置情報の取得に失敗  print(\u0026#34;Error:\\(error.localizedDescription)\u0026#34;) } else { // GPS の位置情報の取得に成功  } }) 既知の制限事項 現バージョンでの既知の制限事項が、ArcGIS Runtime SDK for iOS: リリース ノート（英語）に記載されていますので、ご参照ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/android/migration-android-200.x/",
	"title": "バージョン 100.x から 200.x への移行",
	"tags": [],
	"description": "今まで ArcGIS Runtime SDK for Android バージョン 100.x を使用してアプリケーションを開発されていた開発者向けのガイドです。",
	"content": "出典：ArcGIS Maps SDK for Kotlin - Guide - Migrate from 100.x to 200.x\nArcGIS Runtime SDK バージョン 100.15 は、不具合修正とマイナー アップデートのみに焦点を当てた長期サポート リリースです。ArcGIS Maps SDKs for Native Apps バージョン 200.x は、100.15 の実績あるアーキテクチャをベースに、最新の開発者フレームワークのイノベーションを活用するように設計されています。このトピックでは、変更された API の領域について概説し、200.x アプリ用に 100.x コードをリファクタリングするための手順を説明します。\n200.0 リリースでは、Android 向けの新しい Kotlin ベースの API「ArcGIS Maps SDK for Kotlin」が導入されました。\nこのリリースは、ArcGIS Runtime SDK for Android を Kotlin ファーストの SDK として完全に再構築したもので、コルーチン、フロー、null 安全などの機能をすぐにサポートすることができます。Java ベースの ArcGIS Runtime SDK for Android は、長期サポート（LTS）となり、不具合修正は継続されますが、それ以上の機能アップデートはありません。\n新機能を利用するには、Java ベースの ArcGIS Runtime SDK for Android を置き換える ArcGIS Maps SDK for Kotlin に移行してください。詳細については、ブログ「ArcGIS Runtime SDK の今後のバージョンアップの計画についてのお知らせ」をご確認ください。\nJetpack Compose のサポート ArcGIS Maps SDK for Kotlin 200.2 以降では、Jetpack Compose を完全にサポートしています。このページのコード スニペットは、ほかのコンポーザブルとともに、ArcGIS Maps SDK for Kotlin Toolkit で定義されているコンポーザブル関数 MapView の使用を紹介しています。詳細については Toolkit を参照してください。\nJetpack Compose を使用しない場合は、代わりに XML レイアウトと MapView および SceneView クラスを使用し続けることができます。\nLifeCycleObserver GeoView クラスは MapView や SceneView のベースクラスで、DefaultLifecycleObserver を実装しています。したがって、onResume、onPause、onDestroy のようなライフサイクルイベントを GeoView に転送することは、もはや必要ではありません。\nArcGIS Maps SDK for Kotlin v200.x\noverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // API キーを設定する  ArcGISEnvironment.apiKey = ApiKey.create(BuildConfig.API_KEY) // アクティビティにデータバインディングを設定する  val activityMainBinding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main) mapView = activityMainBinding.mapView // アクティビティのライフサイクルに MapView を追加する  lifecycle.addObserver(mapView) } ArcGIS Runtime API for Android v100.x\noverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val activityMainBinding = ActivityMainBinding.inflate(layoutInflater) setContentView(activityMainBinding.root) // API キーを設定する  ArcGISRuntimeEnvironment.setApiKey(BuildConfig.API_KEY) // MapView と値のビューバインディング  mapView = activityMainBinding.mapView } override fun onPause() { mapView.pause() super.onPause() } override fun onResume() { super.onResume() mapView.resume() } override fun onDestroy() { mapView.dispose() super.onDestroy() } コルーチンとコルーチンのスコープ Kotlin のサスペンド関数は、より安全で、非同期操作のエラーが発生しにくくなっています。すべてのサスペンド関数は Result を返すため、try/catch ブロックは不要になりました。さらに、ライフサイクルを認識するコルーチン スコープを使用してコルーチンを起動できます。これは、ライフサイクルが破棄されると自動的にキャンセルされます。\nArcGIS Maps SDK for Kotlin v200.x\nlifecyleScope.launch { // サスペンド関数を実行してジオデータベースを取得する  val geodatabaseResult = Geodatabase.create(filePath) // サスペンドが完了したら結果を取得する  geodatabaseResult.onSuccess { geodatabase -\u0026gt; // サスペンド関数を実行してジオデータベース フィーチャテーブルを作成する  val featureTableResult = geodatabase.createTable(tableDescription) // サスペンドが完了したら結果を取得する  featureTableResult.onSuccess { geodatabaseFeatureTable -\u0026gt; setupMapFromGeodatabase(geodatabaseFeatureTable) }.onFailure { throwable -\u0026gt; showMessage(throwable.message) } }.onFailure { throwable -\u0026gt; showMessage(throwable.message) } } ArcGIS Runtime API for Android v100.x\nval geodatabaseFuture = Geodatabase.createAsync(filePath) // ジオデータベースを非同期で作成する geodatabaseFuture.addDoneListener { try { // モバイル ジオデータベースのインスタンスを取得する  val geodatabase = geodatabaseFuture.get() // テーブルの説明を使用してテーブルを作成する  val featureTableFuture = geodatabase.createTableAsync(tableDescription) featureTableFuture.addDoneListener { try { // 作成されたフィーチャテーブルを取得する  val featureTable = featureTableFuture.get() setupMapFromGeodatabase(featureTable) } catch (e: Exception) { showMessage(e.message) } } } catch (e: Exception) { showMessage(e.message) } } イベント処理 すべてのイベントが SharedFlow を使用して表現されるようになったため、コールバックは不要になりました。\nArcGIS Maps SDK for Kotlin v200.x\nval simulatedLocationDataSource = SimulatedLocationDataSource(polyline) simulatedLocationDataSource.start() simulatedLocationDataSource.locationChanged.collect { location -\u0026gt; val locationPoint = location.position } ArcGIS Runtime API for Android v100.x\nval simulatedLocationDataSource = SimulatedLocationDataSource().apply { setLocations(polyline) } simulatedLocationDataSource.startAsync() simulatedLocationDataSource.addLocationChangedListener { locationChangedEvent -\u0026gt; val locationPoint = locationChangedEvent.location.position } ローダブル ローダブルの状態 (LoadStatus) は StateFlow を使用して表されますが、load() はロード処理完了の Result\u0026lt;Unit\u0026gt; を返すサスペンド関数です。ロード エラーは、失敗した場合に Result から取得できます。\nArcGIS Maps SDK for Kotlin v200.x\nprivate suspend fun loadPortalItem() { val portalItem = PortalItem(Portal(\u0026#34;https://www.arcgis.com\u0026#34;), itemID) portalItem.load().onSuccess { val featureLayer = FeatureLayer(portalItem) setFeatureLayer(featureLayer, viewpoint) }.onFailure { throwable -\u0026gt; showError(throwable.message) } } ArcGIS Runtime API for Android v100.x\nprivate fun loadPortalItem() { val portal = Portal(\u0026#34;https://www.arcgis.com\u0026#34;, false) val portalItem = PortalItem(portal, itemID) portalItem.addDoneLoadingListener { if(portalItem.loadStatus == LoadStatus.LOADED){ val featureLayer = FeatureLayer(portalItem) setFeatureLayer(featureLayer) }else if(portalItem.loadStatus == LoadStatus.FAILED_TO_LOAD){ showError(portalItem.loadError.message) } } portalItem.loadAsync() } Loadable.loadStatus プロパティが現在 StateFlow であるため、LoadStatus の更新を非同期で監視する方法があります。この方法では、途中の LoadStatus の値も取得できます。\nArcGIS Maps SDK for Kotlin v200.x\nlifecycleScope.launch { portalItem.load() } lifecycleScope.launch { portalItem.loadStatus.collect { loadStatus -\u0026gt; when (loadStatus) { LoadStatus.Loaded -\u0026gt; { val featureLayer = FeatureLayer(portalItem) setFeatureLayer(featureLayer) } is LoadStatus.FailedToLoad -\u0026gt; { showError(\u0026#34;Error loading portal item: ${loadStatus.error.message}\u0026#34;) } LoadStatus.Loading -\u0026gt; { ... } LoadStatus.NotLoaded -\u0026gt; { ... } } } } タスクとジョブ ArcGIS Maps SDK for Kotlin では、ジョブ またはタスクのワークフローが大幅に変更されました。ジョブは、進行状況または完了の流れを制御する CoroutineScope で実行する必要があります。コルーチン フローを使用して複数のジョブとタスクを実行できるため、ネストされたコールバックの操作を回避できます。\nArcGIS Maps SDK for Kotlin v200.x\n// 新しいオフライン マップ タスクを作成する val offlineMapTask = OfflineMapTask(mapView.map) // タスクのパラメーターを設定する val generateOfflineMapParameters = GenerateOfflineMapParameters( geometry, minScale, maxScale ) // オフライン マップ パラメーターを使用してジョブを作成する val offlineMapJob = offlineMapTask.generateOfflineMap( generateOfflineMapParameters, offlineMapPath ) // ジョブを開始する offlineMapJob.start() with (lifecycleScope) { // ジョブの進捗を取得する  launch { offlineMapJob.progress.collect { val progressPercentage = offlineMapJob.progress.value } } // ジョブが成功した場合にマップを表示する  launch { offlineMapJob.result().onSuccess { offlineMapResult -\u0026gt; mapView.map = offlineMapResult.offlineMap }.onFailure { throwable -\u0026gt; showMessage(throwable.message.toString()) } } } ArcGIS Runtime API for Android v100.x\n// 新しいオフライン マップ タスクを作成する val offlineMapTask = OfflineMapTask(mapView.map) // タスクのパラメーターを設定する val generateOfflineMapParameters = GenerateOfflineMapParameters( geometry, minScale, maxScale ) // オフライン マップ パラメーターを使用してジョブを作成する val offlineMapJob = offlineMapTask.generateOfflineMap( generateOfflineMapParameters, offlineMapPath ) // ジョブを開始する offlineMapJob.start() // ジョブの進捗を取得する offlineMapJob.addProgressChangedListener { val progress = offlineMapJob.progress } // ジョブが成功した場合にマップを表示する offlineMapJob.addJobDoneListener { if (offlineMapJob.status == Job.Status.SUCCEEDED) { mapView.map = offlineMapJob.result.offlineMap } else if (offlineMapJob.status == Job.Status.FAILED) { showMessage(offlineMapJob.error.message) } } ArcGIS Maps SDK for Kotlin バージョン 200.x のコードで示されている map 変数は、MapView コンポーザブルに渡すものと同じ変数です。\nArcGIS Maps SDK for Kotlin v200.x\nMapView( modifier = Modifier.fillMaxSize(), arcGISMap = map ) \rジオメトリーとジオメトリー ビルダー 読みやすさと使いやすさを向上させるために、ジオメトリーとジオメトリー ビルダーの使用法にいくつかの変更があります。\n  PolylineBuilder や PolygonBuilder などのジオメトリー ビルダーは、レシーバー タイプとしてビルダーを使用して関数パラメーターを受け取るようになり、Kotlin の慣用的な方法でビルダーにジオメトリーを追加できるようになりました。\n  MutablePart.createWithSegments() を使用して、セグメントでパーツを作成できます。\n  可変および不変のジオメトリー コレクション タイプの名前は、Kotlin のイディオムに合わせて調整されています。以下は、ArcGIS Runtime API for Android に類似した ArcGIS Maps SDK for Kotlin で定義されているジオメトリー タイプのリストです。\n     ArcGIS Maps SDK for Kotlin 200.x ArcGIS Runtime API for Android v100.x     MutablePart Part   Part ImmutablePart   MutablePartCollection PartCollection   PartCollection ImmutablePartCollection      points プロパティにアクセスすることにより、Part および MutablePart をポイントのコレクションとして表示できます。\n  GeometryEngine メソッドはジェネリックであり、より優れたタイプ セーフを提供するため、以下に示すように同一のジオメトリーが返されます。\n  ArcGIS Maps SDK for Kotlin v200.x\nfun \u0026lt;T : Geometry\u0026gt; project(geometry: T, outputSpatialReference: SpatialReference, datumTransformation: DatumTransformation?): T fun \u0026lt;T : Geometry\u0026gt; project(geometry: T, spatialReference: SpatialReference): T fun \u0026lt;T : Geometry\u0026gt; simplify(geometry: T): T fun \u0026lt;T : Geometry\u0026gt; setM(geometry: T, m: Double?): T fun \u0026lt;T : Geometry\u0026gt; setZ(geometry: T, z: Double?): T fun \u0026lt;T : Geometry\u0026gt; setZAndM(geometry: T, z: Double?, m: Double?): T ArcGIS Maps SDK for Kotlin v200.x\n// ポリライン ジオメトリーを作成する val polylineGeometry = PolylineBuilder(spatialReference) { addPoint(-10e5, 40e5) addPoint(20e5, 50e5) }.toGeometry() // セグメントを使用してパーツ ジオメトリーを作成する val partGeometry = MutablePart.createWithSegments( segments = listOf(leftCurve, leftArc, rightArc, rightCurve), spatialReference = spatialReference ) val polygon = Polygon(listOf(partGeometry)) ArcGIS Runtime API for Android v100.x\n// ポリライン ジオメトリーを作成する val polylineGeometry = PolylineBuilder(spatialReference).apply { addPoint(-10e5, 40e5) addPoint(20e5, 50e5) }.toGeometry() // セグメントを使用してパーツ ジオメトリーを作成する val partGeometry = Part(spatialReference).apply { addAll(listOf(leftCurve,leftArc,rightArc,rightCurve)) } val polyon = Polygon(partGeometry, spatialReference) ジェスチャー MapView と SceneView には、DefaultMapViewOnTouchListener をオーバーライドする代わりに、ジェスチャー イベントがあります。 イベントは SharedFlow として表され、コルーチンで取得できます。\nArcGIS Maps SDK for Kotlin v200.x\nMapView( modifier = Modifier.fillMaxSize(), arcGISMap = map, onSingleTapConfirmed = { singleTapConfirmedEvent -\u0026gt; val mapPoint = singleTapConfirmedEvent.mapPoint val screenCoordinate = singleTapConfirmedEvent.screenCoordinate // . . .  } ) ArcGIS Runtime API for Android v100.x\nmapView.onTouchListener = object : DefaultMapViewOnTouchListener(applicationContext, mapView) { override fun onSingleTapConfirmed(motionEvent: MotionEvent): Boolean { val screenPoint = android.graphics.Point( motionEvent.x.roundToInt(), motionEvent.y.roundToInt() ) val mapPoint = mapView.screenToLocation(screenPoint) return super.onSingleTapConfirmed(motionEvent) } } 認証 ArcGIS Maps SDK for Kotlin には、セキュリティで保護された ArcGIS サービスを操作するための異なるアプローチがあります。SDK は、ArcGIS 認証情報を作成し、特定の保護されたリソースの読み込みとは関係なくトークンを生成するための一連の非同期 API を提供します。認証チャレンジの処理中に作成された資格情報は保存され、後続のリクエストの送信中に再利用されます。\nArcGIS Maps SDK for Kotlin v200.x\nArcGISEnvironment.authenticationManager.arcGISAuthenticationChallengeHandler = ArcGISAuthenticationChallengeHandler { challenge -\u0026gt; val result: Result\u0026lt;TokenCredential\u0026gt; = TokenCredential.create( challenge.requestUrl, \u0026#34;username\u0026#34;, \u0026#34;password\u0026#34;, tokenExpirationInterval ) val credential = result.getOrElse { throwable -\u0026gt; Log.e(\u0026#34;TokenCredential Creation\u0026#34;, \u0026#34;Failed\u0026#34;) return@ArcGISAuthenticationChallengeHandler ArcGISAuthenticationChallengeResponse .ContinueAndFailWithError(throwable) } Log.d(\u0026#34;TokenCredential Creation\u0026#34;, \u0026#34;Succeeded\u0026#34;) return@ArcGISAuthenticationChallengeHandler ArcGISAuthenticationChallengeResponse .ContinueWithCredential(credential) } lifecycleScope.launch { // authenticationManager は認証を処理して PortalItem を取得します  val portal = Portal(portalURL, Portal.Connection.Authenticated) val portalItem = PortalItem(portal, itemID) val map = ArcGISMap(portalItem) mapView.map = map map.loadStatus.collect { loadStatus -\u0026gt; when (loadStatus) { LoadStatus.NotLoaded -\u0026gt; { ... } LoadStatus.Loading -\u0026gt; Log.e(\u0026#34;LoadStatus\u0026#34;, \u0026#34;About to load map\u0026#34;) LoadStatus.Loaded -\u0026gt; Log.e(\u0026#34;LoadStatus\u0026#34;, \u0026#34;Map loaded successfully\u0026#34;) is LoadStatus.FailedToLoad -\u0026gt; Log.e(\u0026#34;LoadStatus\u0026#34;, loadStatus.error.message.toString()) } } } Output\nLoadStatus: About to load map TokenCredential Creation: Succeeded LoadStatus: Map loaded successfully アプリで認証コードを移行する手順については、Migrate authentication from 100.x to 200.x トピックを参照してください。\nカスタム Location DataSource ArcGIS Maps SDK for Kotlin には、ユーザー定義のロケーション データ プロバイダーによって駆動できる CustomLocationDataSource が導入されています。これは、カスタム ソースからのロケーション データがあり、そのデータを LocationDataSource の形式にして、API の他の部分と連携できるようにする場合に役立ちます。\nArcGIS Maps SDK for Kotlin v200.x\n{ // ... MapView を設定する  // カスタム ロケーション エミッタを作成する  val customLocationProvider = { SingleLocationEmitter() } // ロケーション プロバイダーをデータソースに追加する  val customLocationDataSource = CustomLocationDataSource(customLocationProvider) lifecycleScope.launch { customLocationDataSource.start().onSuccess { // カスタム ロケーション データソースが正常に開始される  }.onFailure { throwable -\u0026gt; // ロケーション データソースの開始エラー  } customLocationDataSource.locationChanged.collect { // ロケーションの変更を取得する  } } // データソースを MapView に追加する  mapView.locationDisplay.dataSource = customLocationDataSource } // ... 外部クラスで、カスタム ロケーション プロバイダーを作成する class SingleLocationEmitter() : CustomLocationDataSource.LocationProvider { override val locations: Flow\u0026lt;Location\u0026gt; = flow { emit( Location( Clock.System.now(), point, horizontalAccurary, verticalAccuracy, speed, course, lastKnown ) ) } override val headings: Flow\u0026lt;Double\u0026gt; = flow { emit(0.0) } } カスタムの位置情報データ ソースはロケーション ディスプレイの dataSource プロパティに割り当てられます。ロケーション ディスプレイを作成し、それを MapView コンポーザブルに渡す方法の一例は以下のとおりです。\nArcGIS Maps SDK for Kotlin v200.x\nimport com.arcgismaps.toolkit.geoviewcompose.rememberLocationDisplay val locationDisplay = rememberLocationDisplay { dataSource = createCustomLocationDataSource() } MapView( modifier = Modifier.fillMaxSize(), arcGISMap = map, locationDisplay = locationDisplay ) ApplicationContext の要件 ArcGIS Runtime SDK for Android から ArcGIS Maps SDK for Kotlin へのアップデートでは、API のいくつかの部分で ArcGISEnvironment.applicationContext プロパティを設定することが必要です。LocationDataSource、CustomLocationDataSource、SystemLocationDataSource、IndoorsLocationDataSource、RouteTask、ServiceAreaTask、ClosestFacilityTask または AuthenticationManager でコンテキストが必要です。このプロパティは、以下のようにアクティビティーの開始時に設定することができます。\nArcGIS Maps SDK for Kotlin v200.x\nArcGISEnvironment.applicationContext = this.applicationContext ライブラリー固有のデータ型 Color: このアップデートにより、android.graphics.color が com.arcgismaps.Color に置き換えられます。この Color ライブラリーには、すぐに使用できるデフォルトのカラーが付属しており、カスタム RGB カラーを作成したり、アプリのリソースの色を使用したりできます。\nArcGIS Maps SDK for Kotlin v200.x - Color\nimport com.arcgismaps.Color var accentColor = Color.green // var accentColor = Color.fromRgba(r = 0, g = 255, b = 0, a = 255) // var accentColor = 0xFF00FF00.toInt() // val accentColor = Color(colorResource(id = R.color.colorAccent).toArgb())  val selectionProperties = remember { SelectionProperties().apply { color = accentColor } } MapView( modifier = Modifier.fillMaxSize(), arcGISMap = map, selectionProperties = selectionProperties ) ArcGIS Maps GUID: ArcGIS Maps SDK for Kotlin は独自のデータ型 GUID を導入します。これは、128 ビットのグローバルに一意の識別子を表し、ArcGIS サービスおよびジオデータベースからの GlobalID および GUID フィールドを表します。\nArcGIS Maps SDK for Kotlin v200.x - Guid\nval utilityElement = utilityNetwork.createElementOrNull( assetType = utilityAssetType, globalId = Guid(\u0026#34;\u0026lt;Unique-Identifier-Here\u0026gt;\u0026#34;), terminal = utilityTerminal ) 既知の制限事項 現バージョンでの既知の制限事項が、ArcGIS Maps SDK for Kotlin: リリース ノート に記載されていますので、ご参照ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/dotnet/migration-dotnet-200.x/",
	"title": "バージョン 100.x から 200.x への移行",
	"tags": [],
	"description": "今まで ArcGIS Runtime SDK for .NET バージョン 100.x を使用してアプリケーションを開発されていた開発者向けのガイドです。",
	"content": "出典：ArcGIS Maps SDK for .NET - Guide - Migrate from 100.x to 200.x\nArcGIS Runtime SDK バージョン 100.15 は、バグ修正とマイナー アップデートのみに特化した長期サポート リリースです。ArcGIS Maps SDKs for Native Apps バージョン 200.x は、100.15 の実績あるアーキテクチャをベースに、最新の開発者向けフレームワークの技術を活用するよう設計されています。このトピックでは、変更された API の領域の概要と、200.x アプリ用に 100.x コードをリファクタリングするためのガイダンスを提供します。\n基本的な移行手順 ArcGIS Runtime SDK for .NET バージョン 100.0 から 100.15 で構築した既存のアプリを ArcGIS Maps SDK for .NET バージョン 200.0 に移行するには、以下の一般的な手順に従います。\n 以下の システム要件の変更 のセクションを確認し、推奨される変更または更新を行います。 アプリケーションのソース コードを開きます。 すべての Esri.ArcGISRuntime.* NuGet リファレンスをバージョン 200.0 に更新します。 API の破壊的変更に対処します。v100.x で非推奨とマークされた API は 200.0 で削除され、これらの API を使用するとコンパイル エラーが発生します。 アップグレードされたアプリをビルドして実行し、正しく機能することを確認します。  Xamarin アプリケーションの移行 バージョン 100.15 は、Xamarin.Forms、Xamarin.Android、Xamarin.iOS をサポートする ArcGIS Runtime SDK for .NET の最後のリリースとなりました。バージョン 200.0 は、.NET MAUI、.NET for Android、.NET for iOS をサポートしています。既存の Xamarin Forms アプリケーションは .NET MAUI（Multi-platform App UI）へ、Xamarin.Android と Xamarin.iOS はそれぞれ .NET for Android と .NET for iOS へ移行する必要があります。\n.NET MAUI 用の ArcGIS Maps SDK パッケージの初期化 ArcGIS Maps SDK for .NET を .NET MAUI アプリで使用するには、アプリの初期化時に MauiAppBuilder クラスで UseArcGISRuntime() を呼び出します。下記の例は、その方法を示しています。\nMauiProgram.cs\npublic static class MauiProgram { // このクラスは、標準的な MAUI テンプレートの一部です  // MAUI アプリは、CreateMauiApp を使用してアプリを準備します  public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); builder.UseMauiApp\u0026lt;App\u0026gt;(); // この行は、ArcGIS Runtime を使用する場合に必要です  builder.UseArcGISRuntime(); return builder.Build(); } } Xamarin Forms アプリの .NET MAUI への移行については、以下のドキュメントを参照してください。\n Xamarin.Forms からアプリを移行する (Microsoft ドキュメント) Migrating from Xamarin.Forms (Preview) - Wiki  API の変更 バージョン 100.x で非推奨だった API は、バージョン 200.0 ですべて削除されました。非推奨の API を使用すると、コンパイルエラーが発生するため、バージョン 200.0.0 を使用してアプリケーションを正常にビルドするには、このエラーに対処する必要があります。\nシステム要件の変更 ArcGIS Runtime SDK for .NET を使用するアプリを開発およびデプロイするためのシステム要件がバージョン 200.x で以下のように変更されました。詳細については、System requirements のトピックを参照してください。\nよくある質問 (FAQ) 移行に関するよくある質問と回答は、以下のとおりです。\n  質問: ArcGIS Runtime SDK for .NET バージョン 100.x から ArcGIS Maps SDK for .NET バージョン 200.x にアプリをすぐに移行する必要がありますか？\n回答: いいえ。ArcGIS Runtime SDK for .NET バージョン 100.15 は、長期サポート リリースです。バージョン 200.0（または将来のバージョンの 200.x リリース）で提供される新機能を必要としないアプリの場合、アプリは正常に動作します。詳細については、製品ライフサイクルのドキュメント を参照してください。\nただし、ArcGIS Maps SDK for .NET が提供する最新の機能を使用するためには、アプリを移行する必要があります。\n  質問: ArcGIS Runtime SDK for .NET バージョン 100.x で利用可能な機能で、ArcGIS Maps SDK for .NET バージョン 200.x で利用できない機能はありますか？\n回答: いいえ。ArcGIS Runtime SDK for .NET 100.15 に含まれるすべての機能は、ArcGIS Maps SDK for .NET 200.0 で利用可能です。さらに、バージョン 200.0 では、100.15 では利用できなかった新しい機能が提供されています。詳細については、リリース ノート を参照してください。\n  質問: ArcGIS Runtime SDK for .NET バージョン 100.x で作成したアプリを ArcGIS Maps SDK for .NET バージョン 200.x で使用するには、アプリを書き換える必要がありますか？\n回答: いいえ。ArcGIS Runtime SDK for .NET バージョン 100.15 を使用するアプリを ArcGIS Maps SDK for .NET バージョン 200.0 に更新することは、通常のバージョンアップ通りで簡単です。Xamarin.Forms アプリを .NET MAUI に移行するには、ArcGIS Maps SDK for .NET の機能とは関係なく Xamarin から MAUI アプリへ移行するための一般的な追加作業が必要です。\n  質問: ArcGIS Maps SDK for .NET はまったく新しい製品ですか？\n回答: いいえ。ArcGIS Runtime SDK として知られていた製品群は、現在 ArcGIS Maps SDK for Native Apps として提供されています。これらの SDK のバージョン 200.x は、ArcGIS Runtime 100.15 の実績あるアーキテクチャを基盤としており、最新の開発者用フレームワークの技術を活用するように設計されています。\n  既知の制限事項 現バージョンでの既知の制限事項が、ArcGIS Maps SDK for .NET: リリース ノートに記載されていますので、ご参照ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/ios/migration-ios-200.x/",
	"title": "バージョン 100.x から 200.x への移行",
	"tags": [],
	"description": "今まで ArcGIS Runtime SDK for iOS バージョン 100.x を使用してアプリケーションを開発されていた開発者向けのガイドです。",
	"content": "出典：ArcGIS Maps SDK for Swift - Guide - Migrate from 100.x to 200.x\nイントロダクション ArcGIS Maps SDK for Swift v200.x は、Swift 開発者向けに設計された次世代マッピング API を提供します。これは、ArcGIS Runtime SDK for iOS v100.x の後継であり、同じ基盤、アーキテクチャー、および機能を継承しています。API の概念の多くは変更されていませんが、SwiftUI、構造化された同時並行処理、値型、Measurement、デフォルト パラメーターなどの Swift の規則、フレームワーク、および機能に合わせて記述されています。\n既存のアプリを移行するには、大幅な変更が必要です。具体的には、SwiftUI を使用してユーザー インターフェイスを再構築し、async/await を使用して非同期コードを実装する必要があります。 これらのテクノロジーをしっかりと理解することは、移行を容易にし、強固な基盤を提供するのに役立ちます。\nAPI 名の変更 型名変更 型 (クラス、プロトコル、構造体、および列挙型) は ArcGIS モジュールにカプセル化され、名前に AGS プレフィックスが含まれなくなりました。その結果として生じる名前の変更の例を次に示します。\n   v100.x v200.x     AGSMap Map   AGSMapView MapView   AGSLoadable Loadable   AGSViewpoint Viewpoint   AGSPoint Point   AGSFeatureLayer FeatureLayer   AGSArcGISFeatureTable ArcGISFeatureTable    ArcGIS Maps SDK への製品名変更の一環として、Runtime という単語がタイプ名から削除されました。\n   v100.x v200.x     ArcGISRuntimeEnvironment ArcGISEnvironment    メソッドおよびプロパティー名の変更 Swift API Design Guidelines に従うように、さまざまなメソッドとプロパティーが調整されています。\n  メソッド引数のラベルが読みやすくなりました。\n100.x:\nAGSGeometryEngine.bufferGeometry(geometry, byDistance:5000) 200.x:\nGeometryEngine.buffer(around:geometry, distance: 5000)   メソッドの引数の順序が変更されました。\n100.x:\nfeatureLayer.setFeature(feature, visible: true) 200.x:\nfeatureLayer.setVisible(true, for:feature)   Boolean プロパティーはアサーションとして読み取られます。\n100.x:\ntrackingStatus.calculatingRoute 200.x:\ntrackingStatus.isCalculatingRoute   ファクトリー メソッドは、make プレフィックスを使用します。\n100.x:\nfeatureTable.createFeature() 200.x:\nfeatureTable.makeFeature()   コレクションを含むクラスは、それらを変更するための変更メソッドを提供します。\n100.x:\ngraphicsOverlay.graphics.add(graphic) 200.x:\ngraphicsOverlay.addGraphic(graphic)   Swift 構造化された同時並行処理関連の変更 非同期メソッドの呼び出しで、完了を処理するためにクロージャー コールバックを渡す必要がなくなりました。 非同期メソッドを待機して、結果を直接使用するか、エラーを処理できます。\n100.x:\nrouteTask.solveRoute(with: routeParameters) { (routeResult: AGSRouteResult?, error: Error?) in if let error { // エラー処理 } else if let routeResult { // 結果の使用 } } 200.x:\ndo { let routeResult = try await routeTask.solveRoute(using: routeParameters) // 結果の使用 } catch { // エラー処理 } ジョブを開始するために、ステータスを監視したり完了を処理したりするためにクロージャー コールバックを渡す必要がなくなりました。代わりに、ジョブを開始し、その出力を待って結果を取得し、そのメッセージを非同期的に反復してステータスを監視できます。\n100.x:\nlet job = offlineMapTask.generateOfflineMapJob( with: parameters, downloadDirectory: downloadDirectoryURL ) job.start(statusHandler: { status in print(status) }, completion: { [weak self] (result, error) in guard let self = self else { return } if let result { self.offlineMapGenerationDidSucceed(with: result) } else if let error { self.offlineMapGenerationDidFail(with: error) } }) 200.x:\nlet job = offlineMapTask.makeGenerateOfflineMapJob( parameters: parameters, downloadDirectory: downloadDirectoryURL ) job.start() Task { for await status in job.$status { print(status) } } do { let output = try await job.output } catch { self.error = error } イベントは、コールバック ハンドラー、デリゲート、または通知センターではなく、非同期シーケンスを通じて提供されます。\n100.x:\nlocationDisplay.dataSourceStatusChangedHandler = { [weak self] isStarted in // 開始したかどうかを確認 } 200.x:\nfor await isStarted in locationDisplay.statusChanged { // 開始したかどうかを確認 } 具体的には、AGSRouteTrackerDelegate によって提供されるルート トラッカーなどのデリゲート メソッドの場合、新しい一致パターンは非同期ストリームを使用します。\n100.x:\nextension NavigateRouteViewController: AGSRouteTrackerDelegate { func routeTracker(_ routeTracker: AGSRouteTracker, didUpdate trackingStatus: AGSTrackingStatus) { routeRemainingGraphic.geometry = trackingStatus.routeProgress.remainingGeometry routeTraversedGraphic.geometry = trackingStatus.routeProgress.traversedGeometry } } 200.x:\nfor try await newStatus in routeTracker.$trackingStatus { routeRemainingGraphic.geometry = newStatus?.routeProgress.remainingGeometry routeTraversedGraphic.geometry = newStatus?.routeProgress.traversedGeometry } SwiftUI 関連の変更 マップ ビューを作成する SwiftUI は宣言型 UI フレームワークです。これは、View を作成するときに、特定の状態で何を表示するかについての説明も作成することを意味します。これは、フレームが定義されたビューを作成する UIKit の UIView からの変更です。SwiftUI では、ビューは親ビューの body に含まれています。ただし、UIKit ビューは、プログラムまたは Storyboard を使用してビュー コントローラーのルート ビューに追加されていました。次のコードは、v200.x と比較して、v100.15 でマップ ビューを作成する方法を示しています。\n100.x:\n@IBOutlet private var mapView: AGSMapView! { didSet { mapView.map = AGSMap(basemapStyle: .arcGISOceans) mapView.setViewpoint(AGSViewpoint(latitude: -117, longitude: 34, scale: 1e5)) } } 200.x:\n// Geo ビューに必要なさまざまなモデル オブジェクトを格納するモデル private class Model: ObservableObject { let map = Map(basemapStyle: .arcGISOceans) } // ビューの状態が変化したときに再作成されないように、StateObject として保持される @StateObject private var model = Model() // マップ ビューの現在の視点 @State private var viewpoint = Viewpoint( center: Point(x: -117, y: 34, spatialReference: .wgs84), scale: 1e5 ) var body: some View { MapView( map: model.map, viewpoint: viewpoint ) } 修飾子を表示 ビュー修飾子をビューに適用して、ビューの外観と動作をカスタマイズします。 新しい MapView と SceneView には、対応する UIKit と同じ機能を実現するためのさまざまなビュー修飾子があります。\n  Viewpoint: ビューポイント状態変数をマップ ビューの現在のビュー ポイントで更新します。\n.onViewpointChanged(kind: .centerAndScale) { viewpoint = $0 }   DrawStatus: マップ ビューの描画ステータスが変化したときにアクションを実行します。\n.onDrawStatusChanged { if $0 == .completed { print(\u0026#34;Map view draw completed.\u0026#34;) } }   LocationDisplay: マップ ビューの位置情報表示をオンにして設定します。\n.locationDisplay(model.locationDisplay)   Callout: マップ ビューでタップされたポイントの座標を含むコールアウトを表示します。\nAGSGeoViewTouchDelegate のジェスチャー デリゲート メソッドは、さまざまなビュー修飾子に置き換えられました。\n.onSingleTapGesture { screenPoint, mapPoint in if calloutPlacement == nil { // タップした位置にコールアウトを WGS84 で表示する calloutPlacement = LocationCalloutPlacement(location: mapPoint) } else { // コールアウトを非表示にする calloutPlacement = nil } } .callout(placement: $calloutPlacement.animation(.default.speed(4))) { callout in Text( CoordinateFormatter.toLatitudeLongitude( point: callout.location, format: .decimalDegrees, decimalPlaces: 2 ) ) .font(.callout) }   ジオエレメントを識別する UIKit と SwiftUI の違いにより、Identify(識別)の操作をマップ ビューで直接実行することはできません。 v200.x では、SwiftUI の reader-proxy デザイン パターンに従い、MapViewProxy を導入して、Identify などの操作を実行できるようにします。\n次のコードは、v100.15 での AGSGeoView.identifyLayers を使用した Identify と、v200.x での MapViewProxy.identify を使用した Identify の違いを示しています。\n100.x:\n// Completion ブロック mapView.identifyLayer( featureLayer, screenPoint: screenPoint, tolerance: 12, returnPopupsOnly: false, maximumResults: 10 ) { (results: [AGSIdentifyLayerResult]?, error: Error?) in if let error { self.presentAlert(error: error) } else if let results { self.handleIdentifyResults(results) } } 200.x:\nMapViewReader { mapViewProxy in MapView(map: map) .onSingleTapGesture { screenPoint, tapLocation in identifyScreenPoint = screenPoint identifyTapLocation = tapLocation } .task(id: identifyScreenPoint) { guard let screenPoint = identifyScreenPoint else { return } // Async/Await do { let results = try await mapViewProxy.identify( on: featureLayer, screenPoint: screenPoint, tolerance: 12, maximumResults: 10 ) } catch { self.error = error } // 以下で識別結果を処理 } } @State および @StateObject SwiftUI でのビューの更新は、状態の変化によって駆動されます。 次のコードは、マップ ビューの最新の表示領域の取得方法を、v200.x と v100.15 で比較しています。\n100.x:\n@IBOutlet private var mapView: AGSMapView! { didSet { mapView.map = AGSMap(basemapStyle: .arcGISOceans) } } // 表示領域の取得 private var visibleArea: AGSPolygon? { mapView.visibleArea } 200.x:\nprivate class Model: ObservableObject { let map = Map(basemapStyle: .arcGISOceans) } @StateObject private var model = Model() /// 現在のマップ ビューの表示領域 /// 概観図で使用できる @State private var visibleArea: Polygon? var body: some View { MapView(map: model.map) .onVisibleAreaChanged { visibleArea = $0 } } 認証 アプリで認証コードを移行する手順については、Migrate authentication from 100.x to 200.x トピックを参照してください。\nスケッチ マップ ビューでジオメトリーをインタラクティブに描画するには、AGSSketchEditor の代わりに GeometryEditor を使用します。\nその他のリソース その他の例については、新しいサンプルまたはツールキットを確認できます。\n既知の制限事項 現バージョンでの既知の制限事項が、ArcGIS Maps SDK for Swift: リリース ノート に記載されていますので、ご参照ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/migrating-from-3.x-to-4.0/",
	"title": "バージョン 3.x から 4.x への移行",
	"tags": [],
	"description": "バージョン 3.x の API で作成した既存のアプリケーションを 4.x に移行するために必要な情報を紹介します。",
	"content": "出典：ArcGIS Maps SDK for JavaScript - Migrating from 3.x to 4.28\nバージョン 4.x では ArcGIS Maps SDK for JavaScript の構成要素が大きく見直され、機能拡張が行われています。バージョン 3.x で開発したアプリケーションをアップデートすることも可能ですが、アプリケーションを書き換えることを検討してください。\n本トピックでは 3.x の API で作成した既存のアプリケーションを 4.x に移行するために必要な情報を解説します。API で更新された仕様はいくつかありますが、その中でも重要な項目について紹介します。\n プロパティのハンドリング View の利用 Map と Layer の仕様 モジュールとパッケージの更新 Web マップのサポート ローカライズ モジュール 廃止項目  バージョン 4.0 では、大幅な変更が行われました。これらの変更は、開発者がどのようなアプリケーションを作成する場合でも、より効率的かつ効果的に作業できるようにするために行われました。この変更は、コンストラクタ、プロパティ、イベントの処理方法に見られます。\nプロパティ 4.0 より前のバージョンでは、getMethodName や setMethodName を呼び出すことで、一部のプロパティを get (読み込み）または set（書き込み）することができました。API では、すべてのプロパティを取得・設定するためのシンプルで一貫した方法がサポートされているため、これらのタイプのメソッドは不要になりました。\n 例えば map.basemap = \u0026quot;oceans\u0026quot; のようにオブジェクトに直接プロパティを設定します。 例えば map.basemap.title. のようにオブジェクトから直接プロパティを取得します。  例えば、3.x ではフィーチャーレイヤーの definitionExpression 設定は、以下のようになります。\nmyFeatureLayer.setDefinitionExpression(expression); 次の行は、4.0 でフィーチャーレイヤーの definitionExpression 設定する方法を示しています。\nmyFeatureLayer.definitionExpression = expression; 4.0 では、以下のように .get() を使用して深い階層のプロパティにアクセスすることができます。\nvar basemapTitle = map.get(\u0026#34;basemap.title\u0026#34;); プロパティの変更の監視 4.0 より前のバージョンでは、プロパティの変更はイベントでハンドリングされていました。4.0 では、プロパティの変更を監視することが非常に簡単になりました。これは、.watch(property, callback) メソッドで処理されます。このコールバックは、プロパティが変更されるたびに呼び出され、プロパティの新しい値、古い値、名前を監視対象のオブジェクトと一緒に操作することができます。\n// ベースマップ \u0026#39;streets-vector\u0026#39; を定義し、新しい map オブジェクトを作成 var map = new Map({ basemap: \u0026#39;streets-vector\u0026#39; }); // map オブジェクトで定義したベースマップのタイトルが変更されるとコールバックが発生します。 var handle = map.watch(\u0026#39;basemap.title\u0026#39;, function(newValue, oldValue, property, object) { console.log(\u0026#34;新しい値: \u0026#34;, newValue, // プロパティの新しい値  \u0026#34;\u0026lt;br\u0026gt;古い値: \u0026#34;, oldValue, // プロパティの前の値（変更される前の値）  \u0026#34;\u0026lt;br\u0026gt;監視しているプロパティ: \u0026#34;, property, // この例では、この値は常に \u0026#34;basemap.title\u0026#34; になります。  \u0026#34;\u0026lt;br\u0026gt;監視しているオブジェクト: \u0026#34;, object); // この例では、この値は常に map オブジェクトになります。 }); View の利用 4.0 では、Map を 2D または 3D で表示できるようになりました。それに併い、マップの描画ロジックが変更されました。描画ロジックは、マップとレイヤーではなく、View によって制御されるようになりました。\nView は 4.0 で導入されたコンセプトです。View は 2 つのタイプがあります。\n 2D で表示する場合: MapView 3D で表示する場合: SceneView  View は、Map や Scene 内のデータを可視化するために使用されます。Map には実際に表示するデータやレイヤーが含まれていますが、View はそのデータの表示を行います。データの可視化（表示）方法は、2D か 3D かによって異なります。View は、view.map のように、Map への参照を持っています。しかし、Map は View への参照を持っていません。注意すべき点は、1 つの Map が複数の View によって消費されることがあるということです。\nこれを別の言い方をすると、Map は世界のベースマップや機能を表し、View はその地図を見るための窓ということになります。\n以下の構文は、2D View (MapView) と 3D View (SceneView) の両方を作成し、操作する方法を示しています。\n次のスニペットは、MapView を使った 2D マッピングを示しています。\nfunction (Map, MapView){ map = new Map({ basemap: \u0026#34;topo-vector\u0026#34; }); view = new MapView({ container: \u0026#34;viewDiv\u0026#34;, map: map, scale: 2400000 }); } このスニペットは、SceneView を使った 3D マッピングです。\nfunction (Map, SceneView){ map = new Map({ basemap: \u0026#34;topo-vector\u0026#34; }); view = new SceneView({ container: \u0026#34;viewDiv\u0026#34;, map: map, scale: 2400000 }); } Map と Layer の仕様 Map と Layer にはいくつかの重要なアップデートが行われましたが、その一部を以下にご紹介します。\n 4.0 からは、basemap と地図上の operational layers を分離しました。 2D または 3D の View を回転させることができるようになりました。 グラフィック レイヤーは、マップのレイヤー コレクションの中のどこにでも追加することができます。4.0 以前では、グラフィック レイヤーは他の形式のレイヤーよりも上に追加する必要がありました。 GroupLayer クラスが追加されました。  モジュールとパッケージの更新 詳細は3.x/4.x 機能比較表（英語）を確認してください。以下に挙げた項目は、その中でも重要な更新です。\n パッケージ名の変更（例: esri/dijit が esri/widgets に変更） モジュール名の短縮（例: ArcGISTiledMapServiceLayer が TileLayer に変更） モジュール名の大文字・小文字を統一し、「Map」「Graphic」「Query」など、すべてのモジュールが大文字で始まるようになりました。 サポート クラスは、API リファレンスをより組織化するために support フォルダに 移動しました(例: esri/layers/support, esri/tasks/support)。 esri/config の構成が変更され、 esriConfig.defaults のプロパティは esriConfig に移動しました。以下は、デフォルトで使用されるジオメトリ サービスの設定方法の例です。  // 3.x esriConfig.defaults.geometryService = new GeometryService(\u0026#34;\u0026lt;ジオメトリ サービスのURL\u0026gt;\u0026#34;); // 4.x esriConfig.geometryService = new GeometryService(\u0026#34;\u0026lt;ジオメトリ サービスのURL\u0026gt;\u0026#34;);  defaults.io オブジェクトは esriConfig.request に移動しました。  // 3.x esriConfig.defaults.io.timeout = 30000; // 4.x esriConfig.request.timeout = 30000;  3 つの *-all レガシー モジュールが削除されました。これは、ビルドや Website Optimizer を使用してより適切に処理されます。 各コンストラクタは JSON をサポートしなくなったため、代わりに、fromJSON() メソッド（例: Graphic.fromJSON() ）を使用してください。(注: ベータ3では、まだ 3.x のスタイルを使用したコンストラクタがいくつか含まれています。) FeatureLayer はグラフィックを保持しません。代わりに LayerView が FeatureLayer のフィーチャを表すグラフィックを描画します。  Web マップのサポート バージョン 2.x の Web マップ を読み込むことができます。WebMap の操作は部分的にサポートされています。これは、API ですでに利用可能な機能に依存していることを意味します。例えば、まだ実装されていないレイヤータイプが含まれている場合でも WebMap を読み取ることができます。このような場合、API でサポートされているレイヤータイプのみが表示されます。WebMap の保存は、バージョン 4.14 からサポートされています。\nローカライズ 4.x では、ロケールを \u0026ldquo;ar \u0026ldquo;や \u0026ldquo;he \u0026ldquo;に設定しても、right-to-left (RTL) は行われなくなりました。\n どのロケールでも RTL をオプトインできるようになりました。RTL サポートを参照してください。 \u0026lt;html\u0026gt; または \u0026lt;body\u0026gt; タグで方向を指定します。RTL サポートを参照してください。  モジュール 4.x の API は、AMD モジュールと ES モジュールとして提供されます。4.0 以前は、AMD と dojo.require のレガシー モジュールの両方を使用することができました。4.0 以降は、AMD モデルのみのサポートとなり、4.18でESモジュールが導入されました。4.xの異なるモジュールタイプの概要については、Introduction to tooling を参照してください。\n廃止項目 Geocoder ウィジェットはバージョン 3.13 で非推奨となり、4.x では提供されません。代わりに Search ウィジェットを使用してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/services/create-routing/",
	"title": "ルートの検索",
	"tags": [],
	"description": "マッピング API ＆ロケーション サービス内のルーティング＆ディレクションズについて紹介します",
	"content": "出典：Mapping and location services guide - Route and directions\nルーティングとは？ ルーティングとはシンプル ルーティングとも呼ばれ、人や車両を出発地点地から目的地点地までの最適経路を導き出す手段の一つです。ルーティングは、制限速度や車線の数、時間帯といった道路網における様々なデータ パラメータを考慮しています。その他にも道路状況や事故、障害物といったリアルタイム データを考慮したルーティングも可能となります。\nルーティングを利用して以下のアプリケーションを構築することができます。\n・出発地点から目的地点までの最短経路を検索\n・複数の目的地点への最短経路を検索\n・多言語での経路案内を実現\nルーティングの仕組み 経路作成における典型的なワークフロー\n  出発地点と経由地点および目的地点を明確にする\n  経路における移動手段を明確にする\n  サービスから経路や道案内を呼び出す際に、経路の特徴や道順を確認することが可能\n  ルーティング サービスを用い、シンプルな経路や最適化された経路を作成することができます。\n・シンプルな経路とは地点間の最短経路のことをいいます。\n・最適化された経路とは、地点間の最も効率的な経路のことをいいます。\n最適化された経路を作成するためには、findBestSequence パラメータを使用する必要があります。このパラメータを使用すると、地点間の最も効率的な経路を返すように順序が変更されます。\n開発者アカウントをお持ちの場合、シンプルな経路の作成は位置情報サービスへのアクセスの無料枠に含まれています。最適化された経路の作成を利用するには、従量課金となります。\n\r経路のナビゲーションの方法 経路が決定したら、現在の端末位置情報を使用して進行状況を把握することや、経路を縦断する際にナビゲーション指示(音声案内)を呼び出したい場合、ArcGIS Maps SDKs for Native Apps で実行するのが効果的です。\n経路案内についてより詳しく知りたい方は、以下に記載のガイド「Navigate a route」をご参照ください。\n・ArcGIS Maps SDK for Kotlin\n・ArcGIS Maps SDK for Swift\n・ArcGIS Maps SDK for .NET\n・ArcGIS Maps SDK for Qt\n\rURLリクエスト ルーティング サービスに https リクエストを行うか、クライアント API を使用することで経路と道順を検索できます。出発地点、目的地点、そしてオプションで追加のパラメータを指定すると経路検索結果を絞り込むことができます。ここで最も一般的なパラメータの一部を以下に説明します。\nリクエスト制限    リミット ダイレクト ジョブ     最大ストップ数 150 10,000   最大トランザクション時間 5分 60分   最大バリア地点 250 250   ポリライン バリアと交差する道路ストリート フィーチャの最大数 500 500   ポリゴン バリアと交差するストリート フィーチャの最大数 2,000 2,000   徒歩移動モードにおける最長距離（いずれかのストップ間の直線距離がこの制限を超える場合に歩行制限を使用すると解析が失敗します） 27 マイル (43.45km)\n 27 マイル (43.45km)\n   直線距離が以下の距離を超えると階層化を強制します(いずれかの停止位置間の直線距離がここに示す限界値より大きい場合、\ntravel_modeで階層化を使用しないと、定義されていても解析では階層化を使用します)\n 50 マイル\n(80.46km)\n 50 マイル (80.46km)\n   最大スナップ許容範囲：(入力地点と最寄りのトラバース可能な道路との距離がここで指定した距離より大きい場合、その地点は解析から除外されます) 12.42 マイル (20km)\n 12.42 マイル\n(20km)\n   返すことができる方向性のフィーチャ特徴の最大数( travel_mode で階層を使用しないと、定義されていても各地点間の直線距離がここに示した制限値を超える場合、解析では階層を使用します) 制限なし 1,000,000\n\n   返すことができる路肩の最大数 利用不可\n\n 1,000,000    必要なパラメータ    パラメータ名 説明 例     f 返されるデータ形式 f=json f=pjson f=geojson f=html   token API キーまたは Oauth 2.0 のアクセス トークン アクセス トークンの取得方法については、セキュリティと認証をご覧ください。 token=\u0026lt;YOUR_API_KEY\u0026gt;\ntoken=\u0026lt;ACCESS_TOKEN\u0026gt;\n   Stops 経路上で訪問する必要のある 2 か所以上の場所 Stops=139.767176,35.681260;139.796337,35.710982   findBestSequence 複数の目的地点を訪れる際に、サービスが最適な順序を発見するサービスを行うかどうかを指定します。\n注意：最適化された経路を生成する場合は、このパラメータを true に設定します。 findBestSequence=true    ダイレクト 5分以内で経由地点が150未満の短い処理のものに使用します\nエンドポイント https://route-api.arcgis.com/arcgis/rest/services/World/Route/NAServer/Route_World/solve?\u0026lt;parameters\u0026gt;\rhttps://route.arcgis.com/arcgis/rest/services/World/Route/NAServer/Route_World/solve?\u0026lt;parameters\u0026gt;\r上記のエンドポイントは、いずれも機能は基本的に同じものです。エンドポイントの詳細については、サービス エンドポイントをご覧ください。\n\rキー パラメータ    パラメータ名 説明 例     travelMode 車やトラックの運転、徒歩などの移動手段 travelMode=JSONObject   startTime 入力した地点から移動を開始する時刻です。now を指定すると出発時刻を現在時刻に設定することもできます。 startTime=now   returnDirections 各経路のドライブ ガイドを生成する returnDirections=true   directionsLanguage 経路案内目的地の生成時に使用する言語 directionsLanguage=ja    追加パラメータ polygon_barriers は一時的な減速など経路を追加設定する場合、\nroute_shyape はサービスで作成するルート フィーチャの種類を指定する場合、\nreturn_to_start は経路の開始位置と終了位置が同じ場合に設定します。\nリクエストやパラメータ、有効な入力値の詳細については、Routing service REST API ドキュメントを参照してください。\n\rジョブ 60 分以内で経由地点が最大 10000 までの長時間の処理のものに利用します。\nエンドポイント https://logistics.arcgis.com/arcgis/rest/services/World/Route/GPServer/FindRoutes/submitJob?\u0026lt;parameters\u0026gt;\rエンドポイントについての詳細は、サービス エンドポイントをご覧ください。\n\r必要パラメータ    パラメータ名 説明 例     f 返されるデータ形式 f=json f=pjson f=geojson f=html   token API キーまたは OAuth 2.0 のアクセス トークン アクセス トークンの取得方法については、セキュリティと認証をご覧ください。 Token=\u0026lt;YOUR_API_KEY\u0026gt;   stops 経路上で2か所以上の経由する地点 Stops=139.767176,35.681260; 139.796337,35.710982   reorder_stops_to_\nfind_optimal_routes\n 複数の目的地点地を訪問する際に、最適な順序を見つけるかどうかを指定します。 Reoder_stops_to_find_\noptimal_routes=true\n    キー パラメータ    パラメータ名 説明 例     travel_mode 車やトラックの運転、徒歩などの移動手段 travel_mode=JSON Object   time_of_day 入力した終点から移動を開始する時間 time_of_day=1608022800000   populate_directions 各経路のドライブ ガイドを生成 populate_directions=true   directions_language 経路案内目的地の生成時に用いる言語 directions_language=ja    追加パラメータ polygon_barriers は一時減速を設定する場合、\nroute_shape はサービスで作成するルート フィーチャの種類を指定する場合、return_to_start は経路の開始位置と終了位置が同じ場合に設定します。\nリクエストやパラメータ、有効な入力値の詳細については、ルーティング サービス REST API ドキュメントを参照してください。\n\rサンプル コード ダイレクト:経路や道順の検索 この例ではルーティング サービスを使用して、現在の交通状況を考慮した停留所間の経路ルートを検索し、日本語のドライブ ガイドを生成します。\n経路を見つけるには、訪れる地点を少なくとも２つ定義する必要があります。デフォルトの travelMode では自動車の走行時間ですが、徒歩やトラック輸送の走行モードでも使用可能です。最適な結果を得るためには常に startTime を指定するのがよいでしょう。この例では、startingTime を now と指定し、経路ルートの出発時刻を現在の時刻に設定するとともに、経路が現在の交通状況を使用することをサービスに表設定しています。また、directorsLanguage を設定して選択した言語で道案内を生成しています。\n応答には目的地点地やルート セグメント、ターン バイ ターンのテキスト道案内が含まれています。\nセキュリティと認証 :アクセス トークンを取得するには、Security and Authentication \u0026gt; Get started に進みます。\n\rAPIs ArcGIS Maps SDK for JavaScript \rクリックでコードを表示\r\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34;\u0026gt; \u0026lt;title\u0026gt;ArcGIS JavaScript Tutorials: Find a route and directions (Auth)\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.26/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.26\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; require([ \u0026#34;esri/Map\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;, \u0026#34;esri/Graphic\u0026#34;, \u0026#34;esri/geometry/Point\u0026#34;, \u0026#34;esri/rest/route\u0026#34;, \u0026#34;esri/rest/support/RouteParameters\u0026#34;, \u0026#34;esri/rest/support/FeatureSet\u0026#34;, \u0026#34;esri/config\u0026#34;, \u0026#34;esri/widgets/Expand\u0026#34; ],(Map, MapView, Graphic, Point, route, RouteParameters, FeatureSet, esriConfig,Expand)=\u0026gt; { const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; esriConfig.apiKey = apiKey; const map = new Map({ basemap: \u0026#39;osm-standard\u0026#39; }); const center = new Point ([139.78679,35.71374]); const origin = new Point([139.77770,35.71159]); const stop = new Point([139.79016,35.711]); const destination = new Point([139.79637,35.71108]); const view = new MapView({ container: \u0026#34;viewDiv\u0026#34;, map: map, center: center, zoom: 12, constraints: { snapToZoom: false } }); view.when(()=\u0026gt;{ addGraphic(\u0026#34;start\u0026#34;, origin); addGraphic(\u0026#34;stop\u0026#34;, stop); addGraphic(\u0026#34;finish\u0026#34;, destination); getRoute(); }); view.on(\u0026#34;click\u0026#34;, (event)=\u0026gt;{ if (view.graphics.length === 0) { addGraphic(\u0026#34;start\u0026#34;, event.mapPoint); } else if (view.graphics.length === 1) { addGraphic(\u0026#34;stop\u0026#34;, event.mapPoint); } else if (view.graphics.length === 2) { addGraphic(\u0026#34;finish\u0026#34;, event.mapPoint); getRoute(); } else { view.graphics.removeAll(); view.ui.empty(\u0026#34;top-right\u0026#34;); addGraphic(\u0026#34;start\u0026#34;,event.mapPoint); } }); function addGraphic(type, point) { let color = \u0026#34;#ffffff\u0026#34;; let outlineColor = \u0026#34;#000000\u0026#34; let size = \u0026#34;12px\u0026#34;; if (type == \u0026#34;start\u0026#34;) { color = \u0026#34;#ffffff\u0026#34;; } else if (type == \u0026#34;stop\u0026#34;) { color = \u0026#34;#000000\u0026#34;; outlineColor = \u0026#34;#ffffff\u0026#34;; size = \u0026#34;8px\u0026#34;; } else { color = \u0026#34;#000000\u0026#34;; outlineColor = \u0026#34;#ffffff\u0026#34;; } const graphic = new Graphic({ symbol: { type: \u0026#34;simple-marker\u0026#34;, color: color, size: size, outline: { color: outlineColor, width: \u0026#34;1px\u0026#34; } }, geometry: point }); view.graphics.add(graphic); } function getRoute() { const routeUrl = \u0026#34;https://route-api.arcgis.com/arcgis/rest/services/World/Route/NAServer/Route_World\u0026#34;; const routeParams = new RouteParameters({ stops: new FeatureSet({ features: view.graphics.toArray() }), returnDirections: true, directionsLanguage: \u0026#34;ja\u0026#34; }); route.solve(routeUrl, routeParams) .then((data)=\u0026gt; { if (data.routeResults.length \u0026gt; 0) { showRoute(data.routeResults[0].route); showDirections(data.routeResults[0].directions.features); } }) .catch((error)=\u0026gt;{ console.log(error); }) } function showRoute(routeResult) { routeResult.symbol = { type: \u0026#34;simple-line\u0026#34;, color: [5, 150, 255], width: 3 }; view.graphics.add(routeResult,0); } function showDirections(directions) { function showRouteDirections(directions) { const directionsList = document.createElement(\u0026#34;ol\u0026#34;); directions.forEach(function(result,i){ const direction = document.createElement(\u0026#34;li\u0026#34;); direction.innerHTML = result.attributes.text + ((result.attributes.length \u0026gt; 0) ? \u0026#34; (\u0026#34; + result.attributes.length.toFixed(2) + \u0026#34; miles)\u0026#34; : \u0026#34;\u0026#34;); directionsList.appendChild(direction); }); directionsElement.appendChild(directionsList); } const directionsElement = document.createElement(\u0026#34;div\u0026#34;); directionsElement.innerHTML = \u0026#34;\u0026lt;h3\u0026gt;Directions\u0026lt;/h3\u0026gt;\u0026#34;; directionsElement.classList = \u0026#34;esri-widget esri-widget--panel esri-directions__scroller directions\u0026#34;; directionsElement.style.marginTop = \u0026#34;0\u0026#34;; directionsElement.style.padding = \u0026#34;0 15px\u0026#34;; directionsElement.style.minHeight = \u0026#34;365px\u0026#34;; showRouteDirections(directions); view.ui.empty(\u0026#34;top-right\u0026#34;); view.ui.add(new Expand({ view:view, content:directionsElement, expanded:true, mode:\u0026#34;floating\u0026#34;}), \u0026#34;top-right\u0026#34;); } }); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \rREST API curl https://route-api.arcgis.com/arcgis/rest/services/World/Route/NAServer/Route_World/solve? \\-d \u0026#34;f=json\u0026#34;-d \u0026#34;token=\u0026lt;ACCESS_TOKEN\u0026gt;\u0026#34;-d \u0026#34;stops=-139.77770,35.71159; 139.79016,35.711; 139.79637,35.71108\u0026#34;-d \u0026#34;startTime=now\u0026#34;-d \u0026#34;returnDirections=tr-d \u0026#34;directionsLanguage=ja"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/services/",
	"title": "ロケーションサービスの利用",
	"tags": [],
	"description": "ArcGIS Location Platform をはじめて使う方向けにロケーション サービスの紹介やフィーチャ サービス、Web マップを作成する方法について紹介します。",
	"content": "ArcGIS Location Platform をはじめて使う方向けにロケーション サービスの紹介やフィーチャ サービス、Web マップを作成する方法について紹介します。\nロケーションサービス ArcGIS Location Platform で提供されているロケーション サービスは、背景地図サービス（ベース マップ レイヤー）、ジオコーディング サービス、ルーティング サービス、空間分析 サービス、人口統計などのサービスがあります。ロケーション サービスを利用したアプリケーションは、Web アプリやネイティブアプリなどのクライアント APIs を使用して開発することができます。また、ロケーション サービスへ直接アクセスするには REST API を使用できます。そのため、地図アプリケーションの開発や自社のソリューション、サービス、製品などにこれらのサービスを組み込んで利用することもできます。\nチュートリアル ArcGIS Location Platform のチュートリアルでは、ロケーション サービスを利用したアプリケーションの構築方法を学ぶことができます。\nフィーチャ サービス、Web マップの作成   フィーチャ サービスの作成\nデータの検索や編集が可能な地図サービス (REST API) の配信方法を紹介します。\n  Web マップの作成\nさまざまなフォーマットのデータを 1 つのマップとして集約し、それを可視化する方法を紹介します。\n  ルートの検索\nマッピングAPI＆ロケーション サービス内のルーティング＆ディレクションズについて紹介します。\n  ベースマップ\nマッピングAPI＆ロケーション サービス内のベースマップについて紹介します。\n  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/visualization/6ways-to-improve-your-maps/",
	"title": "地図上に賢くデータを可視化するための 6 つの方法",
	"tags": [],
	"description": "マップ ビューアーを使って地図データを賢く可視化するために おさえておくべき６つの方法を紹介します。",
	"content": "ArcGIS のデータ ビジュアライゼーション ツール（マップ ビューアー）を使って地図データを賢く可視化するために おさえておくべき６つの方法を紹介します。\n 色について考える パターンを発見する アウトラインを調整する 透過率を調整してパターンをハイライトする ２つの属性データをサイズと色で表現する もっとも大きい値を発見する  色について考える 主題となるデータに色を加える場合に考えるべき事項は以下の 3 つです。\n 背景地図 ストーリー カラーランプ  地図を使ったデータ可視化ではほとんどの場合、__背景地図__の上に主題となるデータが重なります。 そのため、色は背景地図の配色に応じて見やすい適切な色を選択するべきです。 ただし、データ可視化においてはむしろ背景地図を使わないという選択肢も１つのテクニックになり得ます。\nデータ可視化には必ず伝えたい__ストーリー__があります。 そのストーリーを説明するような説得力のある色を選びましょう。\n最後に__カラーランプ__ですが、数値データに対してその値の範囲をカラーランプ（色の変化）で表現します。 上記のストーリーとデータのもつ意味を照らし合わせて、どの色からどの色へ変化すべきなのか考えてみましょう。\nパターンを発見する データ可視化の主題となるデータからパターンを導き出すことは重要です。 パターンを浮かび上がらせるためにはいくつかの方法があります。 たとえば、数値データに対しての表現として以下がまず前提となる２つの項目です。\n 色を使うか？サイズを使うか？ クラスで分類するか？しないか？  たとえば、公園の面積で大中小のような３段階の規模でカテゴライズして可視化したい場合、 色よりもサイズで規模を表現したほうが意図を伝えやすいと思います。 そして、面積に比例してシンボルが変化するより、３段階でクラス分類すべきでしょう。\nArcGIS のビジュアライゼーション ツールにはヒストグラムを掛け合わせたスライダーを操作することによって、 動的に見栄えを確認しながら変化させることができます。 ストーリーとの関連から、基点となる数字に意味を持たせるのもよいと思いますが、 このスライダーを使ってあくまで地図上で可視化されたグラフィックの集合から、 あるパターンを浮かび上がらせるには便利なツールです。\n変化前（左）と変化後（右）\nアウトラインを調整する ポイントとポリゴンのシンボルはアウトライン（枠線）があります。 アウトラインはデータをそれぞれ視認するのには役立ちますが、 適切に調整をしないで使用すると視覚的には邪魔な要素となり、 地図上の主題データが伝えるストーリーを理解するための焦点を逸らしてしまいかねません。\n色と透過率を用いて、強調しないようなアウトラインの表現に調整してみてください。 場合によっては、完全にアウトラインをなくしてしまうことも選択肢として考えられます。\n調整前（左）と調整後（右）\n透過率を調整してパターンをハイライトする パターンを発見/可視化するためのシンボル表現として色あるいはサイズを選択することを伝えましたが、 もう１つ値の変化を表現する方法として透過率を利用する方法があります。 パターンや基点となるような重要な値をハイライトする際に採用することをお薦めします。\n透過率もスライダーで動的にレンジを調整することが可能です。\n２つの属性データをサイズと色で表現する 従来、地図上で属性データを可視化する場合は単一の属性値に基づいて色やサイズで表現することが基本でした。 マップ ビューアーのビジュアライゼーション機能では、 ２つのデータを色とサイズでそれぞれ表現することで１つのシンボルに対して２つの意味を含めることが可能です。\nたとえば、エリアごとの家賃相場を色、居住者の平均年収をサイズで表現することで、 家賃相場と居住者の収入の関連を単一の主題図で可視化することができます。\nもっとも大きい値を発見する ビジュアライゼーション機能のなかでもっともユニークなものとして、 複数の属性値を比較してもっとも大きい値を占める属性を可視化する機能があります。\nたとえば、選挙マップを作って各選挙区でどの政党がもっとも優勢かを表したいときに有効な表現です。 選挙区の属性値として政党ごとの得票数が A 党 100、B 党 150、C 党 50 といったように格納されている場合に、 A 党は赤、B 党は青、C 党は黄と色を割り振って、 値の割合に応じて色をブレンドして１つの色で表現します。\nB 党がもっとも優勢なので、色味としては青が強い色になり、 各政党が拮抗している場合には色彩の弱い色になります。\n以上、６つの方法を紹介してきましたが、 まずはそれぞれの機能を実際に使ってみて表現を確かめてコツをつかんでみてください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/",
	"title": "技術 Tips 集",
	"tags": [],
	"description": "開発に役立つ技術 Tips 集です。",
	"content": "　開発ドキュメント 各 API/SDK の開発をサポートするドキュメントです。\n ArcGIS Maps SDK for JavaScript ArcGIS Experience Builder (Developer Edition) ArcGIS Web AppBuilder (Developer Edition) Calcite Design System ArcGIS Maps SDK for .NET ArcGIS Maps SDK for Kotlin ArcGIS Maps SDK for Swift ArcGIS Maps SDK for Flutter ArcGIS Maps SDK for Unity ArcGIS Maps SDK for Unreal Engine ArcGIS Pro SDK ArcGIS API for Python ArcGIS AppStudio  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/get-started-npm/",
	"title": "開発の手順（npm）",
	"tags": [],
	"description": "npm を使用した ArcGIS Maps SDK for JavaScript の開発におけるインストールとセットアップからの手順について紹介します。",
	"content": "出典：ArcGIS Maps SDK for JavaScript - Get started with npm\n@arcgis/map-components Vite および @arcgis/core Vite のサンプルを使用して始めることができます。\n\rArcGIS Maps SDK for JavaScript の @arcgis/map-components と @arcgis/core パッケージは、npm コマンドライン インターフェイスを使用してローカルにインストールできます。\n始めるには、npm と Node.js の両方をインストールします。さらに、モジュールバンドラーとローカル Web サーバーを含むクライアントサイドのビルドツール（例：Vite.js）が、アプリケーションの開発とテストに必要です。\nフレームワークやトランスパイラーの使用は任意であり、特定の要件に依存します。これらのツールの基本的な動作を理解しておくことが重要です。これらの概念の紹介については、以下の追加情報セクションを参照してください。\n依存関係の管理 npm を使用する場合、package.json ファイルはアプリケーションの実行とビルドに必要なパッケージの初期セットを指定します。これらの npm パッケージがインストールされると、それぞれ固有の依存関係も指定されます。\nローカル ビルド ツールを使うのが初めての場合、package.json が依存関係、devDependencies、peerDependencies とどのように連動するかを理解することが重要です。\nコンポーネント インストール Map コンポーネントを使用する場合、@arcgis/map-components パッケージをプロジェクトにインストールします。\nnpm の場合\nnpm install @arcgis/map-components yarn の場合\nyarn add @arcgis/map-components @arcgis/core @esri/calcite-components レイアウトの作成 index.html ファイルに arcgis-map コンポーネントを追加し、main.js ファイルを参照します。各コンポーネントはカスタム要素であり、HTML タグを使用してアプリケーションに追加します。これらは \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; などの他の HTML 要素と同様に機能します。\nindex.html\n\u0026lt;body\u0026gt; \u0026lt;arcgis-map item-id=\u0026#34;e691172598f04ea8881cd2a4adaa45ba\u0026#34;\u0026gt; \u0026lt;arcgis-legend position=\u0026#34;top-right\u0026#34;\u0026gt;\u0026lt;/arcgis-legend\u0026gt; \u0026lt;/arcgis-map\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; CSS の設定 CSS を設定し、main.js ファイルにインポートします。さまざまなフレームワークやモジュールバンドラーの具体例は、jsapi-resources の GitHub リポジトリで確認できます。以下は、arcgis-map コンポーネントの Vite の例です。\nindex.css\n/* Include calcite, core API and SDK component CSS */ @import \u0026#34;https://js.arcgis.com/calcite-components/3.0.3/calcite.css\u0026#34;; @import \u0026#34;https://js.arcgis.com/4.32/@arcgis/core/assets/esri/themes/dark/main.css\u0026#34;; @import \u0026#34;https://js.arcgis.com/map-components/4.32/arcgis-map-components.css\u0026#34;; html, body { margin: 0; } arcgis-map { display: block; height: 100vh; } main.js\nimport \u0026#34;./index.css\u0026#34;; コンポーネントのインポート 最後に、必要な SDK のコンポーネントを @arcgis/map-components パッケージから個別にインポートします。（例：arcgis-map や arcgis-legend）\nこれにより、コンポーネントがブラウザーの CustomElementRegistry に登録されます。ブラウザーが \u0026lt;arcgis-map\u0026gt;\u0026lt;/arcgis-map\u0026gt; などのカスタム要素の HTML タグに遭遇すると、その要素のインスタンスを作成し、DOM に追加して機能を有効にします。\nmain.js\nimport \u0026#34;./index.css\u0026#34;; import \u0026#34;@arcgis/map-components/components/arcgis-map\u0026#34;; import \u0026#34;@arcgis/map-components/components/arcgis-legend\u0026#34;; ここまでで、以下のことが可能になっています。\n プロパティの設定 イベントのハンドリング カスタム JavaScript ロジックの追加 チャート（ベータ版）など、他のコンポーネントの追加 最終的なアプリケーションのビルド  以下のコードスニペットでは、document.querySelector() を使用して arcgis-map コンポーネントへの参照を取得し、機能を追加しています。その後、arcgis-map コンポーネントの arcgisViewReadyChange イベントのイベントリスナーを追加します。\nmain.js\ndocument .querySelector(\u0026#34;arcgis-map\u0026#34;) .addEventListener(\u0026#34;arcgisViewReadyChange\u0026#34;, (event) =\u0026gt; { /** * Get a reference to the `WebMap` * from the `event.detail` object. */ const { map } = event.detail; // Add more functionality here.  }); コンポーネントで View を使用する方法については、チュートリアルを参照してください。\nコア API インストール コア API の ES モジュールを使用するには、@arcgis/core パッケージをプロジェクトにインストールします。\nnpm install @arcgis/core レイアウトの作成 HTML に div 要素を追加し、id を割り当てます。ここにマップが挿入されます。\nindex.html\n\u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; CSS の設定 CSS を設定し、main.js ファイルにインポートします。height, width, margin、padding のプロパティを設定します。さまざまなフレームワークやモジュール バンドラーの具体例は、jsapi-resources の GitHub リポジトリで確認できます。以下は、@arcgis/core を使用した Vite の例です。\nindex.css\n#viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } main.js\nimport \u0026#34;./index.css\u0026#34;; モジュール のインポート 最後に、必要な SDK のモジュールを個別にインポートします。（例：@arcgis/core パッケージの @arcgis/core/Map）\nmain.js\nimport \u0026#34;./index.css\u0026#34;; import Map from \u0026#34;@arcgis/core/Map\u0026#34;; import MapView from \u0026#34;@arcgis/core/views/MapView\u0026#34;; const map = new Map({ basemap: \u0026#34;topo-vector\u0026#34; }); const view = new MapView({ container: \u0026#34;viewDiv\u0026#34;, // reference the div id  map: map, zoom: 4, center: [15, 65] }); 詳細は Using ESM import statements ガイドのトピックを参照してください。\nCSS のインポート コア API およびコンポーネント パッケージに light または dark テーマを選択し、対応する CSS ファイルをアプリケーションに組み込みます。 SDK は、コンポーネントとウィジェットに Calcite を使用しています。 UI キット、アイコン、カラー スキーム、およびボタン、パネルなどの UI 要素を含む Web コンポーネント ライブラリーを含む Calcite Design Systemを使用して、独自のカスタム機能を追加できます。 コア API のみを使用する場合、Calcite を含めることはオプションです。\nスタイルシートは CDN からローカルビルドで使用できます。\nindex.css\n@import \u0026#34;https://js.arcgis.com/calcite-components/3.0.3/calcite.css\u0026#34;; @import \u0026#34;https://js.arcgis.com/4.32/@arcgis/core/assets/esri/themes/dark/main.css\u0026#34;; @import \u0026#34;https://js.arcgis.com/map-components/4.32/arcgis-map-components.css\u0026#34;; または、スタイルシートのローカル コピーをプロジェクトで使用することもできます。 index.css\n@import \u0026#34;@esri/calcite-components/calcite/calcite.css\u0026#34;; @import \u0026#34;@arcgis/core/assets/esri/themes/dark/main.css\u0026#34;; @import \u0026#34;@arcgis/map-components/arcgis-map-components/arcgis-map-components.css\u0026#34;; この @import url パスを指定する方法は使用するフレーム ワークやモジュール バンドラーに依存します。MDN では @import を使うための様々な方法について詳しく説明しています。\nアセットの利用 SDK のアセットには、スタイル、画像、Web ワーカー、WASM、およびローカライズ ファイルが含まれています。\nデフォルト アセット ローカル ビルドを行うほとんどのユースケースでは、ArcGIS CDN から SDK のアセットを使用することをお勧めします。これらは以下の URL からデフォルトで読み込まれ、追加の設定は不要です。\n @arcgis/core: https://js.arcgis.com/4.32/@arcgis/core/assets/ @arcgis/map-components: https://js.arcgis.com/map-components/4.32/assets @esri/calcite-components: https://js.arcgis.com/calcite-components/3.0.3/assets  ArcGIS CDN を使用することで、これらのアセットをローカル ビルドにバンドルする必要がなくなります。これにより、ディスク上のビルド サイズが削減され、ビルド時間が短縮される可能性があります。\nローカル アセット インターネットにアクセスできない環境で作業する場合など、アセットをローカルで管理する必要があるシナリオもあります。その場合、以下のディレクトリからアセットをプロジェクトにコピーする必要があります。\n @arcgis/core: /node_modules/@arcgis/core/assets @arcgis/map-components: /node_modules/@arcgis/map-components/dist/arcgis-map-components/assets/ @esri/calcite-components: /node_modules/@esri/calcite-components/dist/calcite/assets/  アセットのローカル コピーで作業すると、ビルドのディスク上のサイズが大きくなります。\n\rこれを実現する簡単な方法は、ビルド プロセス中に実行される npm スクリプトを構成することです。以下に、cpx2 を使用してアセットを正しいプロジェクト フォルダーにコピーする Vite の例を示します。パッケージのインストールについては cpx2 のドキュメントを参照してください。その後、コンポーネント、Core API、および Calcite の package.json スクリプトにコピー コマンドを追加します。ファイルをコピーするための npm スクリプトやプラグインの使用に関するベスト プラクティスについては、フレームワークやバンドラーのドキュメントを確認してください。\npackage.json\n{ \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;npm run copy:all \u0026amp;\u0026amp; vite\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;npm run copy:all \u0026amp;\u0026amp; vite build\u0026#34;, \u0026#34;copy:all\u0026#34;: \u0026#34;npm run copy:components \u0026amp;\u0026amp; npm run copy:core\u0026#34;, \u0026#34;copy:components\u0026#34;: \u0026#34;cpx ./node_modules/@arcgis/map-components/dist/arcgis-map-components/assets/**/*.* /path-to-your-assets/\u0026#34;, \u0026#34;copy:core\u0026#34;: \u0026#34;cpx ./node_modules/@arcgis/core/assets/**/*.* /path-to-your-assets/\u0026#34;, \u0026#34;copy:calcite\u0026#34;: \u0026#34;cpx ./node_modules/@esri/calcite-components/dist/calcite/assets/**/*.* /path-to-your-assets/\u0026#34;, \u0026#34;postinstall\u0026#34;: \u0026#34;npm run copy:all\u0026#34; } } コピー後の次のステップは、SDK がこれらのリソースを正しく見つけて読み込めるように、コード内のアセット パスを構成することです。ローカルビルド環境では、デフォルトのアセットパスがプロジェクトの構造と一致しない可能性があるため、このステップは非常に重要です。\nindex.js\n// Configure the asset path to your desired directory for components and core import esriConfig from \u0026#34;@arcgis/core/config.js\u0026#34;; import { setAssetPath as setMapAssetPath } from \u0026#34;@arcgis/map-components\u0026#34;; // @arcgis/core assets esriConfig.assetsPath = \u0026#34;/path-to-your-assets/\u0026#34;; // map-components assets setMapAssetPath(\u0026#34;/path-to-your-assets/\u0026#34;); Calcite コンポーネントやローカル アセットの使用に関する詳細については、Calcite\u0026rsquo;s Get started および SDK in a disconnected environment のガイド トピックを参照してください。\nESM インポート文の使用 ES モジュールのインポート文は、個々の API モジュールを読み込むために使用されます。インポート宣言には、デフォルト、ネームスペース、および名前付きの3つの形式があります。\n// Default import import WebMap from \u0026#34;@arcgis/core/WebMap.js\u0026#34;; // Namespace import import * as projection from \u0026#34;@arcgis/core/geometry/projection.js\u0026#34;; 各モジュールのコア API リファレンス ページの上部には、デフォルトとネームスペースの どちらのインポート構文を使用するかについてのガイダンスがあります。 ほとんどのモジュールは、上記の import WebMap クラスの例に示されているように、デフォルトの import 構文を使用します。 ヘルパー関数を提供するモジュールなど、他のモジュールは、import * as projection の例のようなネームスペース インポートを使用します。 スタイルの好みに応じて、ネームスペースインポートの代わりに、必要なメソッドを正確に参照する名前付きインポートを使用することもできます。\n// Named import import { load, project } from \u0026#34;@arcgis/core/geometry/projection.js\u0026#34;; 変数名の競合が発生する可能性がある場合は、エイリアスを使用することもできます。例えば、いくつかのクラスが load() メソッドを使用している場合などです。\n// Named import using an alias import { load as projectionLoad, project } from \u0026#34;@arcgis/core/geometry/projection.js\u0026#34;; デフォルト、ネームスペース、名前付きのいずれのインポートを使用しても、esbuild、rollup.js、Webpack などのモジュール バンドラーは、ツリーシェイキング（未使用のコードを削除して最小かつ最も効率的なビルドを作成するプロセス）に関して同じように扱います。\nESM CDNの使用 ES モジュール CDN はテストとプロトタイピングのためのものであり、パフォーマンスの最適化はされていません。プロダクション アプリケーションで最高のパフォーマンスを得るには、@arcgis/core モジュールをローカルでビルドしてください。サンプルはjsapi-resources の GitHub リポジトリーにあります。以下は HTML と JavaScript のコード スニペットです。\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.32/@arcgis/core/assets/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import Map from \u0026#39;https://js.arcgis.com/4.32/@arcgis/core/Map.js\u0026#39;; const map = new Map({ basemap: \u0026#34;topo-vector\u0026#34; }); \u0026lt;/script\u0026gt; 追加情報 追加の情報として、以下のリンクを参照してください。\n MDN - JavaScript modules Web Reference - Module Bundlers in JavaScript MDN - Using custom elements MDN - Client-side tooling overview MDN - Package management basics MDN - Introducing a complete toolchain  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/calcite-design-system/",
	"title": "Calcite Design System",
	"tags": [],
	"description": "Calcite Design System の開発に役立つガイド集です。",
	"content": "Calcite Design System の開発に役立つガイド集です。\nCalcite Design System は、最小限の労力で、アプリ間で美しく、使いやすく、まとまりのある体験を生み出すためのデザインおよび開発リソースを集めたものです。UI キット、アイコン、カラー スキーム、そしてボタン、パネル、アコーディオン、アラートなどの UI 要素を含む Web コンポーネントライブラリが含まれています。\nどこから始めるか Calcite Design System* で、一貫性のある考慮された体験を構築します。\n はじめに\n次の手順に従って、すぐに Calcite コンポーネントを使い始めることができます。\n\r コア コンセプト\nWeb コンポーネントを活用するための基本的な概念とパターンを学びます。\n\r チュートリアル\nCalcite の開発パターンを学び、ワークフローやアプリケーションを構築します。\n\r\rDesign System Calcite Design System の基礎、包括的なコンポーネント ライブラリ、およびガイド リソースをご覧いただけます。\n  基礎編（英語）  アクセシブルなアプリケーションを構築し、テーマやアイコンを使って製品をカスタマイズすることができます。\n  コンポーネント（英語）  一貫したユーザビリティを実現するためのインタラクティブな Web コンポーネント群です。\n  リソース（英語）  UI キット、フレームワークの統合、ローカライゼーションのガイダンス、コミュニティとサポートにアクセスできます。\n  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/python-api-jnsetup/",
	"title": "Jupyter Notebook を使ってみよう",
	"tags": [],
	"description": "ArcGIS API for Python の実行に便利な JupyterLab の初期設定方法と使用方法を簡単に紹介します。",
	"content": "ここでは、対話的に Python コードを実行し、出力を地図やグラフとして視覚化することができる Jupyter Notebook をご紹介します。Jupyter Notebook はオープンソ－スとして公開されている開発ツールのひとつで、ArcGIS API for Python (以下、Python API)はこのツール上でマップ等を表示することができます。 Jupyter Notebook の詳細については、Jupyter の公式マニュアルおよびクイックスタートガイドを参照してください。 また、サポートされているブラウザについてもご確認ください。Jupyter Notebook がサポートしていないブラウザ（Internet Explorer 等）ではマップ等が表示されないことがあります。\nJupyter Notebook の起動 conda と Python API がインストールされたら、Python コマンドプロンプト (ArcGIS Pro 経由でインストールした場合) または、Anaconda Prompt (Anaconda でインストールした場合) 等のターミナル アプリケーションに次のコマンドを入力して Jupyter Notebook を起動します。\njupyter notebook\rもし起動できなかった場合は次のコマンドをお試しください (参考: Jupyter fails to start)。\njupyter-notebook\r他、Windows OS を実行している場合はコマンド プロンプトまたは PowerShell ウィンドウでも代用できます。以下は、Windows のコマンドプロンプトからコマンドを実行した場合の画面のスクリーンショットです。\nWindows のコマンドプロンプトからコマンドを実行した場合\n\rPython API を root 以外の仮想環境を作成しインストールした場合、Jupyter Notebook を起動する前にその仮想環境をアクティベートする必要があります。root 以外の仮想環境を使用するメリットと仮想環境の作成および管理する方法の詳細については、公式のマニュアルページを参照してください。\nEsri では GitHub 上でサンプルのノートブック (*.ipynb) を公開していますが、こうしたノートブックをダウンロードしてを実行したい場合は、Jupyter Notebook を起動する前に、ノートブックを格納したディレクトリに移動 (cd) する必要があります。 上の例では、ノートブックが C:\\code ディレクトリに配置されています。\nJupyter Notebook 起動のコマンドを実行すると Jupyter Notebook は以下のように端末のデフォルトに設定されている Web ブラウザで開きます。\nJupyert Notebook 起動画面 (Google Chrome)\n\rこのページは、ノートブック ダッシュボードと呼ばれています。\nノートブックを実行する Jupyter Notebookでは、ディレクトリを移動してノートブックをクリックすることでそのノートブックを新しいブラウザのタブまたはウィンドウで開くことができます。各セルを選択し、[セルを実行]ボタン(または shift + Enter)をクリックすることで、各セルを実行できます。以下の画像では、実行までの一通りの手順を示しています。\nノートブックを開いて実行するまで\n\rセルを実行すると、そのセルのコードを実行している間、左わきにアスタリスク (*) が表示されます。実行が完了するとセル実行番号に変わります。\n新しいノートブックの作成 Esri が提供するサンプルのノートブックを実行するだけでなく、プロジェクト用の新しいノートブックを作成することもできます。 これを行うには、ノートブックダッシュボードから、「New」ボタンをクリックし、以下の画像のように Python のカーネルを選択します。\n新しいノートブックを作成する\n\r実行中のノートブックの「ファイル」メニューから新しいノートブックを作成することもできます。 上の画像では、現在実行中のノートブックのアイコンが緑色で表示されています。\rJupyter Notebook ヘルプとキーボードショートカット その他、Jupyter Notebook の各機能や使い方は、任意のノートブックを開いて、[Help \u0026gt; User Interface Tour] から体験することができます。 また、便利なキーボード ショートカットも設定されています。ショートカット キーの一覧は、[Help \u0026gt; Keyboard Shortcuts] で表示できます。\nショートカットキー一覧\n\rショートカットの中でも、[Ctrl + Shift + P] はコマンド パレットを表示できるため、特に便利です。コマンド パレットでは、実行したい機能を入力して実行することができます。Jupyter Notebook の使い方については Five Tips To Get You Started With Jupyter Notebook（英語） のブログ記事も参考にしてください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-openlayers/",
	"title": "OpenLayers",
	"tags": [],
	"description": "OpenLayers を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。",
	"content": "マップを表示する このチュートリアルでは、OpenLayers と ベースマップ レイヤー サービス を使用して、マップを表示する方法を紹介します。\nマップには、地理データのレイヤーが含まれています。マップには、ベースマップ レイヤーと、オプションで1つ以上のデータ レイヤーが含まれます。マップ ビューを使用し、場所とズームレベルを設定することで、マップの特定の領域を表示できます。\nこのチュートリアルでは、地形 ベースマップ レイヤーを使用して、 OpenLayers で富士山周辺の地図を表示します。\n前提条件 このチュートリアルを実施するには、以下が必要です。\n 開発者ダッシュボードにアクセスして API キーを作成するには、開発者アカウントが必要です。アカウントの作成手順については「開発者アカウントの作成」を参照してください。  ステップ 新しい Pen の作成 CodePen にアクセスして、マッピング アプリケーション用の新しい Pen を作成します。\nHTML の作成 HTML ページを定義して、Web ブラウザの幅と高さにあわせたマップを作成します。\n  CodePen ＞ HTML で、HTML と CSS を追加して、map という id 属性をもつ div 要素のあるページを作成します。\nHTML を使って、マップを表示する Web ページを作成します。この時マップは map div 内に表示します。CSS を使って、マップを全幅・全高で表示されるようにします。\nCodePenでは、\u0026lt;!DOCTYPE html\u0026gt;タグは必要ありません。他のエディタを使用している場合や、ローカルサーバでページを実行している場合は、必ずこのタグを HTML ページの先頭に追加してください。\n  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ライブラリの読み込み OpenLayers と ol-mapbox-style の JavaScript と CSS ファイルを参照するために、\u0026lt;script\u0026gt;と\u0026lt;link\u0026gt;タグを追加します。\n \u0026lt;head\u0026gt;要素の中に、OpenLayers の CSS と JavaScript ライブラリへの参照を追加します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ol-mapbox-style ライブラリへの参照を追加します。これは、OpenLayers でベク​​タータイル スタイルを使用してベクタータイル レイヤーをロードおよびスタイル設定するために必要です。\nolms.js は、OpenLayers の開発者によって提供されています。\u0026ldquo;olms\u0026rdquo; は OpenLayers Mapbox Style の略です。詳しくは、ol-mapbox-style のドキュメントをご覧ください。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@10.6.0/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Map と View の作成 OpenLayers マップを作成するには、Map クラスと View クラスを使用します。\nOpenLayers の Map クラスは、マップのコンテンツを表示し、それを操作するためのユーザーインターフェースを提供します。マップのクリック、ズーム、パン、回転、視点の変更をサポートしています。また、マップデータの可視コンテンツを操作することもでき、例えば、マウスカーソルでフィーチャを見つけることができます。また、新しいソースを追加したり、レイヤーのプロパティを変更したりして、表示されるデータを修正することもできます。OpenLayers は、レイヤーの変更に応じて、必要に応じて自動的に再レンダリングを行います。\n詳細については、OpenLayers のドキュメントを参照してください。\n \u0026lt;body\u0026gt;要素の中に\u0026lt;script\u0026gt;要素を追加します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@10.6.0/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Map クラスを使用して、表示や動作を制御するオプション付きのマップを作成します。target プロパティには、div 要素の id として \u0026ldquo;map\u0026rdquo; を設定します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@10.6.0/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 地図を表示するタグの id 属性を指定  const map = new ol.Map({ target: \u0026#34;map\u0026#34; }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; View を作成し、setView を使ってマップに適用します。マップビューを中央に配置するために、center プロパティを [138.729858,35.362752] に、zoom プロパティを12に設定します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@10.6.0/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 地図を表示するタグの id 属性を指定  const map = new ol.Map({ target: \u0026#34;map\u0026#34; }); // 地図を表示する位置と初期のズームレベルの指定  map.setView( new ol.View({ center: ol.proj.fromLonLat([138.729858, 35.362752]), zoom: 12 }) ); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; APIキーの設定 ロケーションサービスにアクセスするには、API キーまたは OAuth2.0 アクセストークンが必要です。API キーの作成手順については「API キーの取得」を参照してください。\n認証方法とアクセストークンの取得方法の詳細については、「セキュリティと認証」を参照してください。\n  ダッシュボードにアクセスして、Developer credentials から API キーを取得します。\n  次の手順に使うため API キーをコピーします。\n  ベースマップ レイヤーの追加 OpenLayers はベクター ベースマップやベクター スタイル ファイルを直接サポートしていないので、openlayers-mapbox-style (olms) JavaScript ライブラリを使用して、ベースマップ レイヤー サービスから Mapbox スタイルをロードし、OpenLayers でレンダリングします。\nMapbox スタイルは、スタイルで使用されるベクター タイル レイヤーへの参照と、それらのタイル内の1つまたは複数のデータ レイヤーに適用される表示スタイル ルールを含む JSON ファイルです。\n API キーを変数として保存します。ArcGIS サービスを呼び出す際には、必ずこの API キーを含める必要があります。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@10.6.0/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 地図を表示するタグの id 属性を指定  const map = new ol.Map({ target: \u0026#34;map\u0026#34; }); // 地図を表示する位置と初期のズームレベルの指定  map.setView( new ol.View({ center: ol.proj.fromLonLat([138.729858, 35.362752]), zoom: 12 }) ); // API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; basemapId 変数を作成し、それを arcgis/topographic に設定します。また、ベースマップを日本語で表示するため、language 変数を作成し、ja を設定します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@10.6.0/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 地図を表示するタグの id 属性を指定  const map = new ol.Map({ target: \u0026#34;map\u0026#34; }); // 地図を表示する位置と初期のズームレベルの指定  map.setView( new ol.View({ center: ol.proj.fromLonLat([138.729858, 35.362752]), zoom: 12 }) ); // API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ベースマップの設定  const basemapId = \u0026#34;arcgis/topographic\u0026#34;; // ベースマップの言語設定  const language = \u0026#34;ja\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; basemapId と API キーに基づいてベースマップの URL を作成します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@10.6.0/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 地図を表示するタグの id 属性を指定  const map = new ol.Map({ target: \u0026#34;map\u0026#34; }); // 地図を表示する位置と初期のズームレベルの指定  map.setView( new ol.View({ center: ol.proj.fromLonLat([138.729858, 35.362752]), zoom: 12 }) ); // API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ベースマップの設定  const basemapId = \u0026#34;arcgis/topographic\u0026#34;; // ベースマップの言語設定  const language = \u0026#34;ja\u0026#34;; // ベースマップの URL を設定  const basemapURL = \u0026#34;https://basemapstyles-api.arcgis.com/arcgis/rest/services/styles/v2/styles/\u0026#34; + basemapId + \u0026#34;?type=style\u0026amp;token=\u0026#34; + apiKey + \u0026#34;\u0026amp;language=\u0026#34; + language; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; olms を使用して、ベースマップ スタイルをマップに適用します。olms 関数は、マップ要素と Mapbox ベースマップ スタイル ファイルの URL の2 つの入力を受け取ります  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@10.6.0/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 地図を表示する要素の id 属性を指定  const map = new ol.Map({ target: \u0026#34;map\u0026#34; }); // 地図を表示する位置と初期のズームレベルの指定  map.setView( new ol.View({ center: ol.proj.fromLonLat([138.729858, 35.362752]), zoom: 12 }) ); // API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ベースマップの設定  const basemapId = \u0026#34;arcgis/topographic\u0026#34;; // ベースマップの言語設定  const language = \u0026#34;ja\u0026#34;; // ベースマップの URL を設定  const basemapURL = \u0026#34;https://basemapstyles-api.arcgis.com/arcgis/rest/services/styles/v2/styles/\u0026#34; + basemapId + \u0026#34;?type=style\u0026amp;token=\u0026#34; + apiKey + \u0026#34;\u0026amp;language=\u0026#34; + language; // olms 関数でベクター タイル レイヤー をベースマップに適用  olms(map, basemapURL); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; アプリを実行する CodePen で、作成したコードを実行して地図を表示します。\n地図には、日本の富士山のエリアの地形ベースマップ レイヤーが表示されているはずです。パンとズームで地図を探索してみましょう。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/deploy-your-app/",
	"title": "Web アプリケーションのデプロイ",
	"tags": [],
	"description": "ArcGIS Web AppBuilder (Developer Edition) で作成したアプリケーションをダウンロードし、独自のサーバーにホストする手順を紹介します。",
	"content": "トピック  アプリのダウンロード アプリのデプロイ グループ アクセスの設定 動作環境  ArcGIS Web AppBuilder (Developer Edition)（以下 Web AppBuilder）で作成したWeb アプリケーション (以下、アプリ) はダウンロードして、独自の Web サーバーにホストすることができます。もしアプリが未共有のアイテムを参照しているとき、ダウンロードしたアプリは ArcGIS Online または Portal for ArcGIS に登録する必要があります。 アプリをデプロイする場所にかかわらず、Web マップへのアクセスは必須です。\nその他のデプロイ パターンについてはデプロイ パターンのページをご覧下さい。\nアプリのダウンロード  Web AppBuilder を起動し、トップページを開いたら、アプリのダウンロードボタンをクリックします。 アプリケーションは ZIP ファイルでダウンロードされます。保存ダイアログが表示されたら、任意のフォルダーを指定し、[保存] をクリックします。これで、アプリケーションはローカル ドライブに保存されます。  アプリのデプロイ  ダウンロードしたアプリを解凍します。 解凍したアプリを Web サーバーへ配置します。 アプリのルート ディレクトリにある config.json ファイルを開き、以下の項目を編集します。 プロキシ\n必要に応じて、使用するプロキシを proxy プロパティに追加します。プロキシの詳細は Use proxy をご参照ください。 アプリケーション ID\nアプリケーション ID を appId プロパティへ設定します。アプリケーション ID を入手するには、アプリの追加、登録が必要です。詳細はアプリの追加およびアプリの登録をご参照ください。 OAuth と SAML を用いたプラットフォーム認証を活用するために、アプリケーション ID を使用することを推奨しています。  アプリをカスタマイズするには、以下のドキュメントを参照してください。\n アプリとウィジェットの設定：App configuration ArcGIS API for JavaScript の変更：ArcGIS API for JavaScript の参照先を変更する（オプション）  グループ アクセスの設定 もしアプリがグループや異なる組織間のメンバーで共有している、パブリックではない Web マップを使用しているとき、すべてのグループのメンバーがWeb マップにアクセスできるように設定します。\n アプリの config.json ファイルを開きます。 portalUrl プロパティの値を www.arcgis.com に変更します。 map プロパティに portalUrl プロパティが含まれている場合は、値を www.arcgis.com に変更します。  動作環境 アプリがサポートしているブラウザーは以下の通りです。\n 2D  Google Chrome Firefox Safari（Mac） Edge Internet Explorer 11\nIE11 または Edge で OAuth 認証を使用してアプリを開くとき、ポップアップが表示されることがあります。はいをクリックすると、ポップアップは消えますが、アプリは読み込まれません。この場合は、ブラウザーの設定から .arcgis.com を信頼済みサイトとして追加してください。 Safari（iOS） Google Chrome（Android）   3D  Google Chrome Firefox Safari（Mac） Edge Internet Explorer 11\n3D アプリには WebGL をサポートしているデスクトップの Web ブラウザーが必要です。ほとんどの最新バージョンのデスクトップ Web ブラウザーは WebGL を内蔵しています。ご利用の Web ブラウザーが WebGL を利用可能かどうかは get.webgl.org で確認できます。WebGL に関するトラブルシューティングは WebGL Troubleshooting をご参照ください。また、シーン ビューアーについての詳細は シーン ビューアーの要件 をご参照ください。    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/",
	"title": "その他",
	"tags": [],
	"description": "開発に役立つ技術です。",
	"content": "　テーマ別ページ   データ ビジュアライゼーション\n 地図にデータを可視化する際の tips を紹介します。    サンプル集\n 開発にすぐに使えるサンプル データ/コードを紹介します。    ミートアップ\n 開発者向けのイベント用に提供したページのリンクです。    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/",
	"title": "アプリ開発",
	"tags": [],
	"description": "シンプルな地図アプリの作成方法を紹介します。",
	"content": "マップとベースマップ レイヤーを表示するシンプルな地図アプリの作成方法を紹介します。お使いの開発環境からお選びください。\nWeb APIs \r\rArcGIS Maps SDK for JavaScript\rEsri Leaflet\rMapLibre GL JS\rOpenLayers\rCesiumJS\r\r\rNative APIs \r\r.NET\rAndroid\riOS\rFlutter\rUnity\rUnreal Engine\r\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/install-and-setup/",
	"title": "インストールおよびセットアップ方法",
	"tags": [],
	"description": "インストールおよびセットアップの方法を紹介します。",
	"content": "インストールおよびセットアップ API へのアクセス ArcGIS Maps SDK for JavaScript をアプリに導入するには、複数のオプションがあります。AMD および ES モジュールの詳細については、Introduction to Tooling を参照してください。\nArcGIS CDN による AMD モジュール API にアクセスする最も一般的な方法は、ホスト型のバージョンを使用することです。Esri の CDN から API と CSS を参照して、アプリでの API の使用を開始してください。\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.32/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.32/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; NPM による ES モジュール JavaScript API は、npm（JavaScriptのパッケージマネージャー）を使っても利用できます。ローカルに API をインストールして、React や Angular などの JavaScript フレームワークや、webpack や rollup.js などのモジュールバンドラーで利用することができます。\nインストール方法：\nnpm install @arcgis/core モジュールのインポート：\nimport Map from \u0026#34;@arcgis/core/Map.js\u0026#34;; CSS のインポート：\n/* URL 文字列を使用した CSS */ @import \u0026#34;https://js.arcgis.com/4.32/@arcgis/core/assets/esri/themes/light/main.css\u0026#34;; 詳細については、以下のガイドを参照してください。\n ツールの紹介 ES モジュールの構築  CDN による ES モジュール ※ この方法は、現在のところ、開発やプロトタイピングにのみ推奨されています。\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.32/@arcgis/core/assets/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import Map from \u0026#34;https://js.arcgis.com/4.32/@arcgis/core/Map.js\u0026#34;; // Use the Map class \u0026lt;/script\u0026gt; ローカルにホストされる AMD モジュール 場合によっては、ArcGIS CDN を介して AMD モジュールのローカルにホストされたバージョンを使用する必要があります。この例は、インターネットにアクセスできない制限されたネットワーク環境で作業している場合です。また、API リファレンス、チュートリアル、およびサンプルを含むドキュメントをダウンロードしてインストールすることもできます。ダウンロード可能なドキュメントは、バージョン 4.30 のリリース日からのスナップショットであり、最新のサンプル アップデートやドキュメントの修正などは含まれていません。\nArcGIS Maps SDK for JavaScript およびそのドキュメントをダウンロードするには、ArcGIS Maps SDK for JavaScript のダウンロード ページに移動し、Esri グローバル アカウントでログインします。\nWeb サーバーのホスティング設定 ArcGIS Maps SDK for JavaScript をホストする Web サーバのホスティング構成では、以下の MIME/type 登録が必要です。\n   エクステンション MIME/type 説明     .ttf application/octet-stream True Type フォント   .wasm application/wasm WebAssembly   .woff application/font-woff Web Open Font Format   .woff2 application/font-woff2 WOFF File Format 2.0   .wsv application/octet-stream Scene View の星の可視化に対応   .pbf application/x-protobuf 一部のレイヤーの MapView ラベル用のフォント    なお、HTTPS をサポートする Web サーバーでは、SSL Web サーバー証明書を使用する必要があります。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/custom-widget/",
	"title": "ウィジェット開発",
	"tags": [],
	"description": "ウィジェットと呼ばれる、再利用可能な UX コンポーネント作成の基礎を紹介します。",
	"content": "出典：ArcGIS Maps SDK for JavaScript - Widget development\nウィジェットは再利用可能な UI コンポーネントで、リッチな UX を提供する鍵となります。ArcGIS Maps SDK for JavaScript では、完全にカスタム化されたウィジェットを HTML 要素として View に含めることができます。これには、完全に新しい機能を持つ独自のビューを開発する必要があり、ウィジェットの ViewModel を拡張することとは異なります。\nカスタムウィジェットを作成する場合、@arcgis/core ES モジュールをお好みのフロントエンド JavaScript フレームワークと共に使用することをお勧めします。React、Angular、Vue.js などのフレームワークは必須ではありませんが、最大の拡張性を提供します。SDK と疎結合で、フレームワークのよく知られた UI/UX パターンとコンポーネントのライフサイクルに準拠した複数のウィジェットを作成できます。独自のカスタムウィジェットの作成方法については、jsapi-custom-widget のサンプルを参照してください。\n非推奨のお知らせ\nバージョン 4.27 以降、完全なカスタム ウィジェットを構築するための基礎として、/esri/widgets/Widget をサブクラス化または拡張することは推奨されなくなりました。このパターンでは、SDK 内部への依存関係が作成され、文書化されていない変更が頻繁に発生する可能性があります。以下のガイド内容は、レガシー パターンに従ったものであり、既存のウィジェットを保守する場合にのみ使用してください。\n\rこのフレームワークはすべての Dijit を直接差し替えることを意図していません。例えば、dgrid の利用には Dijit が必要です。\nトピック\n 開発要件 ウィジェット ライフサイクル ウィジェットの実装 TypeScript デコレーター サンプルコード 関連リンク  開発要件 独自のカスタムウィジェットを作成する前に、自分のマシンでローカルにアプリケーションをビルドできるなど、最低限の要件を満たしていることを確認してください。このプロセスは、Web サーバー上でホストされ、ブラウザー上で実行される標準的な JavaScript アプリケーションを作成する場合に比べ、いくつかのステップが増えます。\nTypeScript TypeScript を使うことをお勧めします。その利点のひとつは、デコレーターを使って機能を強化できることです。TypeScript のセットアップ ガイド ページでは、ArcGIS Maps SDK for JavaScript を使用して TypeScript 開発環境をセットアップするための基本的な手順を説明しています。また、TypeScriptとは何か、なぜ使われるのか、どのように使うのかについて詳しく説明したオンライン リソースもたくさんあります。これらの基本に慣れることで、ウィジェット開発プロセスがより簡単になります\nJSX JSX は、JavaScriptの拡張構文で、HTMLと同様にウィジェットのユーザーインターフェイスを記述することができます。一般的には React と関連していますが、他の実装においても使うことができます。JavaScript とインラインで使えるという点では、HTML に似ています。カスタム ウィジェットは、TypeScript と JSX を組み合わせた拡張子 .tsx を使ってビルドされ、JavaScript に直接コンパイルされます。\nesri/core/Accessor の理解 Accessor は 4.x の主要な特徴のひとつであり、ウィジェットを含むすべてのクラスの基盤です。既存の API クラスを拡張してサブクラス、つまり子クラスを作成するため、カスタムウィジェットもこれに含まれます。カスタムウィジェットは、super() メソッドを呼び出すことで、親クラスからメソッドとプロパティを継承します。その他の詳細や使用パターンについては、Implementing Accessor のトピックを参照してください。\narcgis/core @arcgis/core のESモジュールは、AMD モジュールと同じ API 機能を持ちます。 ES モジュールは専用の AMD ローダーを必要としないため、ほぼすべての主要な JavaScript フレームワークやビルドツールでシームレスに動作し、ブラウザや最新のビルドツールでネイティブに消費できるため、カスタムウィジェットの構築には @arcgis/core を使用することをお勧めします。モジュールは npm を使って開発マシンのローカルにインストールします。\nウィジェット ライフサイクル 開発をはじめる前に、ウィジェット ライフサイクルを理解している必要があります。ウィジェットの種類にかかわらず、ライフサイクル特有の一般的な概念は同じです。\n constructor (params) - プロパティを設定している間に、ウィジェットが最初に作成されるところです。ウィジェットは Accessor から生じるので、get、set、watch を使いプロパティへアクセスできます（get、set、watch の詳細は Working with properties をご参照ください）。 postInitialize() - このメソッドは、ウィジェット作成後、UI の描画前に呼ばれます。 render() - ウィジェット開発で唯一の必須となるメソッドです。UI を描画するために使用されます。 destroy() - ウィジェットのインスタンスを解放するためのメソッドです。  TypeScript デコレーター ウィジェット開発では TypeScript のデコレーターが活用され、API ではデコレーターがクラスの作成に使用される基礎的なグルーとして使用されます。これにより、既存のプロパティ、メソッド、コンストラクタに共通する動作を設計時に拡張することができます。ウィジェット デコレーターの最も一般的なタイプについて、以下で説明します。\nAPI デコレーターを使用する場合は、後方互換性のために useDefineForClassFields フラグを false に設定する必要があります。詳細は TSConfig を参照してください。\n\r@subclass（declared と共に使われます） @subclass() デコレーターは、API クラスを拡張するために使用します。また、コンストラクタで declaredClass プロパティを文字列で指定することもできます。これは、declaredClass が読み取り専用である既存のクラスと、作成しようとしているカスタム クラスを区別するのに役立ちます。\n以下のスニペットは、ベースとなる Widget クラスをインポートして継承し、render メソッドで UI を定義しています。JSX は UI を定義するために使用されます。この単純なシナリオでは、div 要素が作成され、そのコンテンツとして John Smith という文字列が定義されます。\nimport Widget from \u0026#34;@arcgis/core/widgets/Widget.js\u0026#34;; @subclass(\u0026#34;esri.widgets.HelloWorld\u0026#34;) class HelloWorld extends declared(Widget) { render() { return ( \u0026lt;div\u0026gt;John Smith\u0026lt;/div\u0026gt; ); } } @property() Accessor プロパティを定義するには @property() デコレーターを使用します。このデコレーターで定義されたプロパティはすべて、get と set ができます。さらに、プロパティの変更を watch することもできます。\n@property() name: string; @aliasOf() @aliasOf() デコレーターは、デコレートするプロパティとそのメンバーの内部プロパティとの間に双方向バインディングを作成します。\n@aliasOf(\u0026#34;initialCenter.extent\u0026#34;) extent: Extent; ウィジェットの実装 以下のステップは、独自のカスタム ウィジェットを実装する際に必要なステップの簡単な概要を提供します。\nウィジェットの拡張\rプロパティとメソッドの実装\rウィジェットのレンダリング\rエクスポート モジュール\r新しいウィジェット クラスの作成 ベースとなる Widget クラスを拡張し、@subclass() コンストラクタで宣言されたクラスを指定することから始めます。\n// 拡張に使用する Widget クラスのインポート import Widget from \u0026#34;@arcgis/core/widgets/Widget.js\u0026#34;; @subclass(\u0026#34;esri.widgets.HelloWorld\u0026#34;) class HelloWorld extends Widget { } プロパティとメソッドの実装 次に、ウィジェット特有のプロパティとメソッドを実装します。このコードは、プロパティ作成において、デコレーターをどのように利用するのかを示しています。\n// \u0026#39;name\u0026#39; プロパティの作成 @property() name: string = \u0026#34;John Smith\u0026#34;; // private _onNameUpdateメソッドの作成 private _onNameUpdate(): string { return \u0026#39;${this.name}\u0026#39;;} デフォルトでは、要素の中で参照される関数は、実際の要素を参照する this を持ちます。必要に応じて、this の参照先を変更するために bind 属性を使用します。以下では、name プロパティを更新するときに呼ばれる _onNameUpdate コールバック関数を結び付けています。これは次の postInitialize メソッドに表示されます。\nclass HelloWorld extends Widget { constructor(params?: any) { super(params); this._onNameUpdate = this._onNameUpdate.bind(this); } } postInitialize メソッドは、ウィジェットのプロパティは用意されているが、描画される前に呼ばれます。以下のコードは name プロパティを監視しています。プロパティが更新されると、_onNameUpdate コールバック関数を呼びます。watchUtils.init() は WatchHandle オブジェクトを返し、own() に渡されます。これは、ウィジェットを削除した時点で、リソースを解放するメソッドです。\nimport * as watchUtils from \u0026#34;@arcgis/core/core/watchUtils.js\u0026#34;; postInitialize() { const handle = watchUtils.init(this, \u0026#34;name\u0026#34;, this._onNameUpdate); // Helper used for cleaning up resources once the widget is destroyed  this.own(handle); } ウィジェットのレンダリング プロパティが実装された後、ウィジェットの UI は JSX を使用して描画されます。これはウィジェットの renderer メソッドに処理されます。これは、ウィジェットの実装に必要な唯一のメソッドです。\nJSX 要素として作成されたウィジェットは、まだサポートされていないことに注意してください。例えば、以下のスニペットは動作しません。\rconst search = \u0026lt;Search view={view} /\u0026gt;;\r// UI の描画 render() { return ( \u0026lt;div\u0026gt; {this._onNameUpdate()} \u0026lt;/div\u0026gt; ); } 最後に、destroy を呼びます。このメソッドはウィジェットを削除し、postInitialize() 内で参照されている own() メソッドに登録された、すべてのリソースを解放します。\npostInitialize() { const handle = watchUtils.init(this, \u0026#34;name\u0026#34;, this._onNameUpdate); // ウィジェットが削除された時点でリソースを解放するメソッド  this.own(handle); } エクスポート モジュール コードページの一番最後に、モジュールをエクスポートする行を追加します。エクスポートは、ウィジェットの機能を import 文によって利用可能にします。\nexport default HelloWorld; 完成したコード jsapi-custom-widget サンプルは、widget.tsx ファイル全体を示します。TypeScript ファイルは、クラスが JSX を使用していることを示すために次のような拡張子を使用しています。例：.ts + .jsx = .tsx\nウィジェット レンダリング 以下のプロパティは、ウィジェットのレンダリングに使用できます。\nclasses: ウィジェットの class プロパティの値を構築するために使用されるユーティリティ メソッドです。これは、CSS クラスのセットアップを簡略化するのに役立ちます。\r// Widget のクラス ヘルパー メソッドで動作する新しいメソッド render() { const dynamicClass = { [CSS.bold]: this.isBold, [CSS.italic]: this.isItalic } return { \u0026lt;div class={this.classes(CSS.base, dynamicClass)}\u0026gt;Hello World!\u0026lt;/div\u0026gt; }; } styles: スタイルを動的に変更できるようにします。\rrender() { const dynamicStyles = { background-color: this.__hasBackgroundColor ? \u0026#34;chartreuse\u0026#34; : \u0026#34;\u0026#34; }; return ( \u0026lt;div styles={dynamicStyles}\u0026gt;Hello World!\u0026lt;/div\u0026gt; ); } afterCreate: このコールバック メソッドは、ノードが DOM に追加された後に実行されます。子ノードやプロパティはすでに適用されています。実際の DOM ノードにアクセスするには、render 内でこのメソッドを使用します。要素ごとに使用することも可能です。\rprivate _doSomethingWithRootNode(element: Element){ console.log(element); } private _doSomethingWithChildNode(element: Element){ console.log(element); } // Access real DOM node within render() render() { return ( \u0026lt;div afterCreate={this._doSomethingWithRootNode}\u0026gt;Hello World!\u0026lt;/div\u0026gt; ); } // Can also be used per element  render() { return ( \u0026lt;div afterCreate={this._doSomethingWithRootNode}\u0026gt; \u0026lt;span afterCreate={this._doSomethingWithChildNode}\u0026gt;Hello World!\u0026lt;span\u0026gt; \u0026lt;/div\u0026gt; ); } afterUpdate: このコールバック メソッドは、ノードが更新されるたびに実行されます。\rprivate _afterUpdate(element: Element){ console.log(element); } render() { return ( \u0026lt;div afterUpdate={this._afterUpdate}\u0026gt;Hello world!\u0026lt;/div\u0026gt; ); } bind: このプロパティは、イベント ハンドラーの `this` の値を設定するために使用される。\rprivate _whatIsThis(): void { console.log(\u0026#39;this === widget: ${this}\u0026#39;); } render() { return ( \u0026lt;div bind={this} onclick={this._whatIsThis}\u0026gt;\u0026#39;this\u0026#39; is the widget instance\u0026lt;/div\u0026gt; ); } key: これは、兄弟要素の中で DOM ノードを一意に識別するために使用されます。これは、同じセレクターを持つ兄弟要素があり、要素が動的に追加/削除される場合に重要です。\r// キーは、以下のサンプルでは文字列で指定されていますが、数値やオブジェクトを指定することもできます。  render() { const top = this.hasTop ? \u0026lt;li class={CSS.item} key=\u0026#34;top\u0026#34;\u0026gt;Top\u0026lt;/header\u0026gt; : null; const middle = this.hasMiddle ? \u0026lt;li class={CSS.item} key=\u0026#34;middle\u0026#34;\u0026gt;Middle\u0026lt;/section\u0026gt; : null; const bottom = this.hasBottom ? \u0026lt;li class={CSS.item} key=\u0026#34;bottom\u0026#34;\u0026gt;Bottom\u0026lt;/footer\u0026gt; : null; return ( \u0026lt;ol\u0026gt; {top} {middle} {bottom} \u0026lt;/ol\u0026gt; ); } 上記のメソッドに加えて、storeNode という便利なメソッドもあります。HTMLElement の DOM ノード リファレンスを変数に代入するときに使います。これは、カスタム データ属性 data-node-ref を使用して、要素の DOM ノードへの参照を格納します。これを正しく動作させるには、以下のスニペットに示すように、bind={this} のように、ウィジェット インスタンスにもバインドする必要があります。\n// data-node-ref 属性を DOM ノード値に割り当てます。 //これは `bind` プロパティと組み合わせて使用する必要があり、 // storeNode コンビニエンス メソッドを使用するときに使用します。  rootNode: HTMLElement = null; render() { return ( \u0026lt;div afterCreate={storeNode} bind={this} data-node-ref=\u0026#34;rootNode\u0026#34; /\u0026gt; ); } 関連リンク  Sample - jsapi-custom-widget（英語） Accessor class（英語） Guide - TypeScript Setup（英語） Guide - Implementing Accessor（英語） Guide - Build with ES modules（英語） Guide - Working with properties（英語） TypeScript reference（英語） JSX reference（英語） バージョン 3.x から 4.x への移行 ArcGIS Maps SDK for JavaScript を利用したウィジェット開発ハンズオン  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/",
	"title": "カスタム ウィジェット開発ガイド",
	"tags": [],
	"description": "カスタム ウィジェットを開発する手順を紹介します。",
	"content": "カスタム ウィジェットを開発する手順を紹介します。  ウィジェット開発のスタート\nウィジェット開発に使用しているライブラリから開発に必要な概要までを紹介します。\n\r ウィジェット manifest\nウィジェットの名前やバージョンなどのウィジェットの属性などを設定する manifest.json ファイルについて紹介します。\n\r ウィジェットの実装\nウィジェットの実装方法について紹介します。\n\r ウィジェット UI の作成\nウィジェット UI の作成方法について紹介します。\n\r ウィジェットでデータ ソースを使用\nウィジェットでデータ ソースを使用する方法について紹介します。\n\r ウィジェット間の通信\nウィジェット同士がどのように相互に通信する方法について紹介します。\n\r\rウィジェットに下位互換性を持たせる ウィジェットのバージョンと下位互換性について紹介しています。（米国 Esri のサイトに移動します）\nウィジェット開発のデバック ウィジェット開発におけるデバック方法について紹介しています。（米国 Esri のサイトに移動します）\nサードパーティ製のライブラリ使用 サードパーティ製のライブラリの使用方法について紹介しています。（米国 Esri のサイトに移動します）\n単体テスト 単体テストの方法について紹介しています。（米国 Esri のサイトに移動します）\nアセットの使用 アセットの使用について紹介しています。（米国 Esri のサイトに移動します）\nコード リンティング コード リンティングについて紹介しています。（米国 Esri のサイトに移動します）\nWebpack config のオーバーライド Webpack config をオーバーライドする方法について紹介しています。（米国 Esri のサイトに移動します）\ndist フォルダーへのファイルのコピー dist フォルダーへファイルをコピーする必要がある場合の方法について紹介しています。（米国 Esri のサイトに移動します）\nウィジェット間のコードの共有 ウィジェット間で同じコードを共有して利用する方法を紹介しています。（米国 Esri のサイトに移動します）\nウィジェットにヘルプを追加 作成したウィジェットのヘルプの追加する方法を紹介しています。（米国 Esri のサイトに移動します）\n\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/section-view/",
	"title": "セクションとビュー（Section and view）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Section and view\nこのページでは、ArcGIS Experience Builder のセクション コンポーネントとビュー コンポーネントについて説明します。また、セクションが複数のビューのコンテナとしてどのように機能するか、セクション内でビューがページやウィンドウとどのように同じように機能するか、ビュー ナビゲーション ウィジェットを使用してビュー間を移動する方法についても学びます。\nセクションとは セクションは、ページに追加できるレイアウト コンテナーです。セクションは、アプリケーション内のコンテンツを整理し、構造化します。セクションはモジュール レイアウトに便利で、関連するコンテンツをグループ化できます。ヘッダー、フッター、サイドバー、メイン コンテンツ エリアに使用できます。\nセクションには、そのセクションの代替レイアウトやコンテンツ領域である複数のビューを含めることができます。これにより、ページを離れることなく異なるコンテンツ セットを切り替えることで、よりダイナミックなユーザー エクスペリエンスを生み出すことができます。\nビューとは ビューはセクションに追加されるレイアウト コンテナーです。ページやウィンドウの機能に類似しますが、セクションで使用されます。ビューは、ウィジェットとコンテンツのための明確な領域を作成します。\nビューは、タブ、ワークフローのステップ、異なる情報の状態など、同じセクションで別のコンテンツやレイアウトを表示するのに便利です。ビューの切り替えは、ビュー ナビゲーション ウィジェットなどのナビゲーション コントロールを使用するか、トリガーを設定することで行うことができます。\nビューは、関連するコンテンツへのアクセスを維持しながら、ユーザーが一度に 1 つのコンテンツ セットに集中できるようにすることで、アプリケーションを整理するのに役立ちます。これは、ユーザーがページを離れることなく異なる情報やツールの間を移動する、ガイド付きエクスペリエンス、ウィザード、またはダッシュボードに役立ちます。\nビューは異なるレイアウトやウィジェットを持つことができ、切り替え時にトランジション アニメーションを適用できます。\nセクションとビューの使用方法 セクションとビューをナビゲーション ウィジェットと一緒に使うことで、インタラクティブで、整理された、モジュール化されたエクスペリエンスを作ることができます。\nセクションとビューを使用するには、次の手順に従います。\n ページにセクションを追加します。 セクションにビューを追加します。 ビューを設定し、ビュー間のナビゲーションを設定する。 オプションで、よりスムーズなユーザー エクスペリエンスのためにトランジション アニメーションを適用する。  セクションとビューの追加方法については、セクションの追加とビューの追加のトピックを参照してください。\n\rセクションとビューの違い セクションとビューはどちらもコンテンツを整理するために使用されますが、構造、レンダリング、ユーザー インタラクションが異なります。以下の表は、主な違いをまとめたものです。\n   観点 セクション ビュー     定義 コンテンツをグループ化し、レイアウトを管理するためにページに追加されるコンテナー 代替コンテンツやレイアウトを表示するためにセクションに追加されるコンテナー   階層 ページレベルまたは他のビュー内に存在 セクション内に存在   コンテンツ 複数のビューを含むことが可能 そのビューに固有のウィジェットやコンテンツを含むことが可能   ナビゲーション ナビゲーションはセクション内のビュー間で行われる ビューナビゲーションウィジェットやトリガーを使ってナビゲート可能   レンダリング セクション内のすべてのビューがレンダリングされるが、アクティブなビューだけが表示される 一度に表示されるのは1つのビューのみで、他のビューは非表示になるがレンダリングはされる   アニメーション ビューの切り替えにトランジション アニメーションを設定可能 セクションのアニメーションを継承   ユースケース ページレイアウトの整理、関連するコンテンツのグループ化、モジュール化されたデザインの作成 タブ、ワークフローのステップ、代替状態、ガイド付きエクスペリエンス    セクションとビューの主な違いは以下の通りです。\n レンダリング：複数のページをロードする場合、最初にレンダリングされるのは現在のページのコンテンツだけです。一方、セクション内の複数のビューをロードする場合、ビュー内のすべてのコンテンツがレンダリングされますが、現在のビューのみが表示され、他のビューは非表示になります。 アニメーション：トランジション アニメーションをセクション上で定義することができ、セクション内のビュー間のスムーズなトランジションが可能になります。 ナビゲーション：セクションは構造を提供し、ビューはその構造の中で異なるコンテンツのセットを切り替える機能を提供します。  セクションとビューの AppConfig AppConfig では、セクションは sections プロパティで定義され、sectionId がキーとなる。ビューは views プロパティで定義します。この構造により、アプリケーションを効果的に整理し、セクションとビューを簡単に管理し、アクセスできるようにすることができます。\n sections プロパティには、アプリケーションに追加されたセクションを表すセクション オブジェクトの配列が含まれます。各セクション オブジェクトには、スタイルや含まれるビューのリストなどの構成の詳細が含まれます。 views プロパティには、セクション内の各ビューの定義が含まれます。各ビュー オブジェクトは、固有の ID、保持するウィジェットやコンテンツ、そのビューに適用される特定の設定やスタイルを指定します。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/dotnet/migration-dotnet-100.x/",
	"title": "バージョン 10.2.x から 100.x への移行",
	"tags": [],
	"description": "今まで ArcGIS Runtime SDK for .NET バージョン 10.2.x を使用してアプリケーションを開発されていた開発者向けのガイドです。",
	"content": "ArcGIS Runtime SDK バージョン 100.x は新しいアーキテクチャを使用してゼロから開発された次世代の ArcGIS Runtime です。このバージョンアップに伴い API の再設計が行なわれています。このドキュメントでは、バージョン 100.x の変更点について説明します。\nArcGIS Runtime SDK for .NET に関しては、ESRIジャパン 製品ページをご参照ください。\n以下は、バージョン 100.x の主な変更点です。\n マップとシーン ビュー レイヤー クラス名の変更 フィーチャ レイヤーの表示 フィーチャの操作 個別属性表示 グラフィックス オーバーレイ ジオメトリとジオメトリ ビルダー スケッチ エディター ローダブル パターン ローカルサーバー 既知の制限事項  マップとシーン 100.x では、Map オブジェクト（2D表示用）と Scene オブジェクト（3D表示用） を API のコアとして、ArcGIS プラットフォームの Web GIS 機能を迅速に利用できるようになりました。\nMap オブジェクトと Scene オブジェクトは 、それらを表示する View と分離されています。Map オブジェクトと Scene オブジェクトには 、操作レイヤー、ベースマップ、ブックマーク等の ArcGIS 固有のデータを設定でき、アプリケーションで利用することができます。\nビュー MapView（2D表示用）と SceneView（3D表示用）は、UI コンポーネントです。MapView クラスの map プロパティに、Map オブジェクトを、MapSceneView クラスの scene プロパティには Scene オブジェクトを設定します。\n100.x では、以下のようにマップを表示します。\n// ベースマップを指定してマップを初期化 Map myMap = Map(Basemap.CreateImagery()); // マップビューにマップを設定 MyMapView.Map = myMap; レイヤー クラス名の変更 各レイヤーのクラス名が以下のように変更されています。\n   レイヤー 10.2.x のクラス名 100.x のクラス名     ArcGIS Server ダイナミック マップ サービス レイヤー ArcGISDynamicMapServiceLayer ArcGISMapImageLayer   タイル マップ サービス レイヤー ArcGISTiledMapServiceLayer ArcGISTiledLayer   タイル パッケージ レイヤー ArcGISLocalTiledLayer ArcGISTiledLayer    100.x でサポートされているレイヤーのタイプについては、ArcGIS Runtime SDK for .NET: レイヤー（英語）をご参照ください。\n作成した各レイヤーは、以下の方法でマップに追加します。\n// 操作レイヤーとしてマップに追加する myMap.OperationalLayers.Add(arcgis_map_image_layer) // ベースマップとしてマップに追加する myMap.Basemap.BaseLayers.Add(arcgis_tiled_layer); フィーチャ レイヤーの表示 フィーチャ サービスや端末のローカルに格納されたジオデータベースのデータをマップに表示するにはフィーチャ レイヤーを使用します。 フィーチャ レイヤーを表示するには、はじめにフィーチャ テーブルを作成します（フィーチャ サービスのデータをフィーチャ レイヤーとして表示するに場合は ServiceFeatureTable オブジェクト、ジオデータベースのデータ表示する場合は GeodatabaseFeatureTable オブジェクトを使用します）。次に作成したフィーチャ テーブルを引数として FeatureLayer オブジェクトを作成し、Map オブジェクトの OperationalLayers に追加します。\n次のコードは、フィーチャ サービスのデータを FeatureLayer として追加する方法を示しています。\n// フィーチャ サービスの URL からフィーチャ テーブルを作成 ServiceFeatureTable featureTable = new ServiceFeatureTable(new Uri(\u0026#34;https://services.arcgis.com/wlVTGRSYTzAbjjiC/arcgis/rest/services/all_Japan_shikuchoson/FeatureServer/0\u0026#34;)); // フィーチャ テーブルからフィーチャ レイヤーを作成 FeatureLayer featureLayer = new FeatureLayer(featureTable); // フィーチャ レイヤーをマップの操作レイヤーに追加 myMap.OperationalLayers.Add(featureLayer); フィーチャの操作 フィーチャの検索や編集はフィーチャ テーブル （ServiceFeatureTable または GeodatabaseFeatureTable）に対して行います。\nフィーチャ サービスから作成したフィーチャ テーブル（ServiceFeatureTable）の場合、フィーチャ テーブルのフィーチャは、マップ上にレンダリングするために必要最小限の情報だけを含むように最適化されています。これにより、フィーチャを表示するための待機時間と帯域幅の消費が削減されます。フィーチャの編集やすべての属性情報を表示するような場合は完全な情報を取得するために、ローダブル パターン等を使用して、フィーチャを明示的にロードしておく必要があります。\nフィーチャのリクエスト モード フィーチャ サービスからフィーチャを取得する場合は、 リクエスト モードの設定によってフィーチャの取得頻度とや端末上でのデータのキャッシュ方法を制御します。リクエスト モードには、OnInteractionCache、 OnInteractionNoCache、ManualCache があります。リクエスト モードはフィーチャ テーブルが初期化される前に、ServiceFeatureTable の FeatureRequestMode プロパティを使用して設定できます。\n  OnInteractionCache: ユーザーの操作によりマップの表示領域が変更されると、フィーチャが自動的にリクエストされます。リクエストされたすべてのデータはローカルにキャッシュされます。キャッシュされたデータは、既に表示された領域にマップが移動しても、再度リクエストされません。サーバー上のデータが変更される可能性が少ない静的なデータに適したモードです。\n  OnInteractionNoCache: ユーザーの操作によりマップの表示領域が変更されると、フィーチャが自動的にリクエストされますが、キャッシュはされません。既に表示された領域にマップが移動すると、再度リクエストされます。サーバー上のデータが継続的に更新される可能性がある場合に適したモードです。\n  ManualCache: ユーザーによるマップ操作では、フィーチャは自動的にリクエストされません。このモードを使用する場合は、ServiceFeatureTable の PopulateFromServiceAsync メソッドを使用して明示的にデータをリクエストする必要があります。\n以下のコードは PopulateFromServiceAsync メソッドを使用して、サーバー上のすべてのフィーチャを取得する方法の例です。\n  // フィーチャの取得（検索）時のパラメーターを設定 QueryParameters queryParameters = new QueryParameters(); // すべてのフィーチャを取得するように条件を設定 queryParameters.WhereClause = \u0026#34;1 = 1\u0026#34;; // 検索結果にフィーチャのすべての属性情報（outFields の配列に \u0026#34;*\u0026#34; を指定）を含める var outputFields = new string[] { \u0026#34;*\u0026#34; }; // クエリの条件に基づいてフィーチャ テーブルにデータを設定する await featureTable.PopulateFromServiceAsync(queryParameters, true, outputFields); フィーチャの編集 フィーチャの編集はフィーチャ テーブルに対して行います。フィーチャ サービスまたはジオデータベースのデータから作成したフィーチャ テーブルのどちらを編集する場合も実装方法に違いはありません。\nフィーチャの編集方法は、 ArcGIS Runtime SDK for .NET: フィーチャの編集（英語）をご参照ください。\nフィーチャの検索 フィーチャの検索はフィーチャ テーブルに対して行います。フィーチャ サービスまたはジオデータベースのデータから作成したフィーチャ テーブルのどちらを編集する場合も実装方法に違いはありません。検索を行うには ServiceFeatureTable または GeodatabaseFeatureTable クラスの QueryFeaturesAsync メソッドを使用します。\n次のコードは、フィーチャ テーブルからフィーチャを検索する方法を示しています。\ntry { // フィーチャの取得（検索）時のパラメーターを設定  QueryParameters queryParams = new QueryParameters(); // 検索条件を設定  queryParams.WhereClause = \u0026#34;upper(KEN) LIKE \u0026#39;%東京%\u0026#39;\u0026#34;; // フィーチャ テーブルから検索条件を取得  FeatureQueryResult queryResult = await _featureTable.QueryFeaturesAsync(queryParams); // 結果に問い合わせるためにリストを取得  var features = queryResult.ToList(); if (features.Any()) { // 結果から1件のフィーチャを取得  Feature feature = features[0]; } else { MessageBox.Show(\u0026#34;検索結果が見つかりませんでした。\u0026#34;); } } catch (Exception ex) { MessageBox.Show(\u0026#34;処理エラー\u0026#34;, \u0026#34;検索処理でエラーが発生しました：\u0026#34; + ex.ToString()); } 個別属性表示 マップ上で特定の場所をタップして、その位置にあるフィーチャをすべてのレイヤーから検索して取得することができます。その操作はビューに対して行います。次のコードは、MapView クラスの IdentifyLayerResult メソッドを使用してフィーチャを取得する方法を示しています。\n// MapView のすべてのレイヤーを識別し、タップしたポイント、許容値、戻り値のタイプ、最大結果数を渡します IReadOnlyList\u0026lt;IdentifyLayerResult\u0026gt; idLayerResults = await MyMapView.IdentifyLayersAsync(tapScreenPoint, pixelTolerance, returnPopupsOnly, maxLayerResults); foreach (IdentifyLayerResult idResults in idLayerResults) { // 検索されたレイヤーを取得して FeatureLayer にキャストする  FeatureLayer idLayer = idResults.LayerContent as FeatureLayer; // 反復処理を行い、検索されたレイヤー内の GeoElement を取得する  foreach (GeoElement idElement in idResults.GeoElements) { // GeoElement を Feature にキャストする  Feature idFeature = idElement as Feature; // フィーチャ レイヤーでフィーチャを選択状態にする  idLayer.SelectFeature(idFeature); } } グラフィックス オーバーレイ グラフィックは、マップ上に一時的なデータを表示するために使用されます。MapView と SceneView オブジェクトにはグラフィックを表示するためのグラフィックス オーバーレイ（GraphicsOverlay）が含まれています。 グラフィックス オーバーレイを使用することで、マップ上のレイヤーの順序が変更されても、グラフィックが常に最上位に表示されます。\n次のコードは、MapView オブジェクトに、グラフィックス オーバーレイを使用してグラフィックを追加する方法を示しています。\n// ジオメトリとシンボルを使用してグラフィックを作成 var pointGraphic = new Graphic(pointGeometry, poitnSymbol); // グラフィックス オーバーレイに作成したグラフィックを追加 var graphicsOverlay = new GraphicsOverlay(); graphicsOverlay.Graphics.add(pointGraphic); // MapView の GraphicsOverlays に作成したグラフィックス オーバーレイを追加 MyMapView.GraphicsOverlays.Add(graphicsOverlay); ジオメトリとジオメトリ ビルダー Geometry オブジェクトのコンストラクタを使用すると、既知の座標を使用してジオメトリを作成できますが、作成後にそのジオメトリを変更することはできません。\nジオメトリ ビルダー（GeometryBuilder）を使用すると、ゼロから新しいジオメトリを作成したり、既存のジオメトリを基に、ジオメトリを変更することができます。\nスケッチ エディター スケッチ エディター（SketchEditor）を使用すると、ユーザーがマップ上で対話的にジオメトリをスケッチすることができます。\n次のコードは、SketchEditor の使用方法の例を示しています。\n// 頂点の編集、サイズ変更、移動ができるようにスケッチエディタの設定を行います var config = MyMapView.SketchEditor.EditConfiguration; config.AllowVertexEditing = true; config.ResizeMode = SketchResizeMode.Uniform; config.AllowMove = true; // スケッチエディタをページのデータコンテキストとして設定する DataContext = MyMapView.SketchEditor; ・・・・・・ try { // ジオメトリの種類を設定してスケッチを開始  geometry = await MyMapView.SketchEditor.StartAsync(creationMode, true); ・・・・・・ // ジオメトリが更新された際の処理 } catch (TaskCanceledException) { // スケッチのキャンセル } catch (Exception ex) { // スケッチのエラー } ローダブル パターン データを非同期的にロードして状態を初期化するマップやレイヤー等のリソースは、ローダブル パターンを採用しています。各リソースのプロパティにアクセスするときは、ローダブル パターンを使用して、リソースがロードされた後にアクセスすることが推奨されます。ローダブル パターンは、ロード状態の振る舞いをより均一にして且つ一貫性を持たせることで、非同期性をより明示的にします。ローダブル パターンでは、各リソースは自動的にリソースの状態をロードしません。それらは、開発者が明示的に実行したときに、遅延ロードします。 ローダブル パターンを採用しているリソースの状態は、NotLoaded（ロードが開始していない、Loading（ロード中）、Loaded（ロードに成功）、FailedToLoad（ロードに失敗） のいずれかで監視することができ、ロードに失敗した場合はロードを再試行することができます。\n詳細は、ArcGIS Runtime SDK for .NET: ローダブル パターン（英語）を参照してください。\n次のコードは、ローダブル パターンの使用方法の例を示しています。\n// ローダブル時のイベント featureLayer.Loaded += (s, e) =\u0026gt; { // フィーチャ レイヤーのプロパティにアクセス  Debug.Assert(featureLayer.MinScale == 5000); Debug.Assert(featureLayer.MaxScale == 1000000); }; // フィーチャ レイヤーのロード await featureLayer.LoadAsync(); ローカルサーバー ローカル サーバーの機能を使用する場合は、ArcGIS Runtime SDK for .NET とは別に ArcGIS Runtime Local Server SDK のインストールが必要となります。インストールの詳細は、ArcGIS Runtime SDK for .NET: ローカル サーバー（英語）を参照してください。\n既知の制限事項 現バージョンでの既知の制限事項が、ArcGIS Runtime SDK for .NET: リリース ノート（英語）に記載されていますので、ご参照ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/services/basemaps/",
	"title": "ベースマップ",
	"tags": [],
	"description": "マッピングAPI＆ロケーションサービス内のベースマップについて紹介します",
	"content": "出典：Mapping APIs and location services - Basemaps\n\rベースマップとは？ ベースマップはベースマップ レイヤーとも呼ばれ、マップとシーンの全体的なビジュアルを提供するレイヤーです。ベースマップには通常は大陸、湖沼、行政境界、道路、都市、地名などの地理的な特徴やラベルが含まれます。ベースマップの最も一般的なデータ ソースは、ベースマップ サービスとデータ サービス です。\nベースマップ レイヤーを使って以下のようなことができます。\n マップとシーンの両方で、世界中のさまざまな地理データの表示 ArcGIS streets、navigation、light gray canvas、OSM streets などのベースマップの表示 自身で指定した色、字体、フォントを使用したベースマップの表示 街路やナビゲーションのベクター タイル レイヤーの表示 衛星画像や陰影起伏図用のマップ タイル レイヤーの表示 独自のデータを独自の空間参照で表示  ベースマップの仕組み ベースマップ レイヤーは、マッピング アプリケーションの視覚的な基礎を提供します。ベースマップ レイヤーは、一般的にグローバルなデータを含み、マップやシーンに追加される最初のレイヤーです。マップを表示する場合、ベースマップ レイヤーが最初に描画され、次にデータ レイヤー、グラフィックス レイヤーの順に描画されます。\nベスト プラクティス：ほとんどの場合、アプリケーションはフィーチャの選択やポップアップの表示など、ベースマップ レイヤーとのやり取りを許可していません。ベースマップ レイヤー上にあるデータ レイヤーを使用してマップ内のフィーチャの表示や操作をすることができます。\n\rデータ ソースの種類 ベースマップの一般的なデータ ソースは、ベースマップ サービスとデータ サービスの 2 つです。\nベースマップ サービス ベースマップ サービスは、ベースマップ レイヤーのデータを提供する Esri がホストするサービスです。ベースマップ サービスには、ベースマップ スタイル サービスと静的ベースマップ タイル サービスが含まれます。\nベースマップ スタイル サービス ベースマップ スタイル サービスは、世界中のベースマップ スタイルとデータを提供するロケーション サービスです。各ベースマップ スタイルには、地理的なフィーチャとラベルの視覚的なプロパティに固有のセットがあります。このサービスには ArcGIS と OSM のスタイルが含まれます。デフォルトのベースマップ スタイルには、streets、navigation、light gray canvas、imagery などがあります。各スタイルのデータは、ArcGIS でホストされているベクター タイル レイヤーとマップ タイル レイヤーを通じて提供され、Web メルカトル空間参照に格納されます。このサービスでは、場所、ローカル言語、worldview を表示することもできます。\nサービスを利用するための手順は以下の通りです。\n  スタイルを選択します。\n  サービスの URL とスタイルを参照します。\n URL : https://basemapstyles-api.arcgis.com/arcgis/rest/services/styles/v2/styles/{STYLE_TYPE}/{STYLE} スタイルの種類 : ArcGIS または OSM スタイルの例 : streets、imagery、navigation、topography、light gray canvas、outdoors など    ベースマップを API で表示します。以下のコード例をご参照ください。\n  例 : ArcGIS API for Python from arcgis import GIS gis = GIS(api_key=\u0026#34;YOUR_API_KEY\u0026#34;) map = gis.map() map.basemap = \u0026#34;streets-navigation-vector\u0026#34; API リファリンスへ\r\rArcGIS Maps SDKs は、各スタイルにアクセスするための列挙型またはヘルパークラスを提供します。また、正しい Esri とデータの帰属も表示されます。ただし、オープン ソース ライブラリを使用する場合は、サービスを直接参照する必要があり、帰属の表示を行う必要がある場合があります。\n\rArcGIS REST API : さまざまなスタイルと機能の詳細についてはベースマップ スタイル サービス を参照してください。\n\r静的ベースマップ タイル サービス 静的ベースマップ タイル サービスは、世界の範囲のラスター ベースマップ タイルを提供するロケーション サービスです。各ベースマップ スタイルには、地理的なフィーチャとラベルの視覚的なプロパティに固有のセットがあります。このサービスは、streets、navigation、outdoor、light gray canvas など、デフォルトのベースマップ スタイルをサポートしています。タイルは Web メルカトル空間参照で 512 x 512 の .png ファイルとして提供されます。またこのサービスは、英語以外の言語での地名ラベル表示もサポートしています。\nサービスを利用するための手順は以下の通りです。\n  ベースマップ スタイルを選択します。\n  サービスの URL とスタイルを参照します。\n URL : https://static-map-tiles-api.arcgis.com/arcgis/rest/services/static-basemap-tiles-service/v1/{STYLE} スタイルの例 : arcgis/navigation、arcgis/streets、arcgis/outdoor、arcgis/light-gray    ベースマップを API で表示します。以下のコード例をご参照ください。\n  例 : ArcGIS Maps SDK for JavaScript const basemapStyle = \u0026#34;arcgis/navigation\u0026#34; // const basemapStyle = \u0026#34;arcgis/streets\u0026#34; // const basemapStyle = \u0026#34;arcgis/outdoor\u0026#34; // const basemapStyle = \u0026#34;arcgis/light-gray\u0026#34; // const basemapStyle = \u0026#34;arcgis/dark-gray\u0026#34; const basemap = new Basemap({ baseLayers: [ new TileLayer({ url: `https://static-map-tiles-api.arcgis.com/arcgis/rest/services/static-basemap-tiles-service/v1/${basemapStyle}/static` }) ] }); const map = new Map({ basemap: basemap }); ArcGIS Maps SDKs は、正しい Esri とデータの帰属が表示されます。ただし、オープン ソース ライブラリを使用する場合は、サービスを直接参照する必要があり、帰属の表示を行う必要がある場合があります。\n\rArcGIS REST API : サービス パラメーターやアクセス条件の詳細については、Static basemap tiles service を参照してください。\n\rデータ サービス フィーチャ サービス、ベクター タイル サービス、マップ タイル サービスなどのデータ サービスは、ArcGIS Online または ArcGIS Enterprise でホストされているデータを含むサービスです。ほとんどの場合、クライアント API でサポートされているデータ サービスは、ベースマップのデータ ソースとして使用できます。データ サービスは、ArcGIS のホスト レイヤー (アイテム) でアクセスおよび管理できます。\nデータ サービス は通常、ホストされている既存のデータ サービスまたは独自のホスト型データ サービスを ArcGIS で使用する場合にベースマップに使用します。また、Web メルカトル以外の空間参照を必要とする小規模な地域やエリアのデータを表示する場合にも使用します。\nデータ サービスを利用するための一般的な手順は以下の通りです。\n  ホスト レイヤーおよびデータ サービスを検索または作成します。\n ArcGIS Online および ArcGIS Living Atlas of the World で既存のサービスを検索します。 独自のデータ サービスを作成する方法については、Data hosting を参照してください。    レイヤーのアイテム ID またはサービス URL を取得します。例 :\n レイヤー アイテム : https://www.arcgis.com/home/item.html?id=4d9fb5c0a6344407aec56f47a11482b5 アイテム ID : 4d9fb5c0a6344407aec56f47a11482b5 サービス URL : https://services2.arcgis.com/FiaPA4ga0iQKduv3/arcgis/rest/services/State_Geologic_Map_Compilation_%E2%80%93_Geology/FeatureServer/0    ベースマップを API で表示します。ホスト レイヤーの表示も参照してください。\n  例 : ArcGIS Maps SDK for JavaScript const featureLayer = new FeatureLayer({ portalItem: { id: \u0026#34;4d9fb5c0a6344407aec56f47a11482b5\u0026#34; // ArcGIS Online 上の State Geologic Map Compilation – Geology を参照  } }); const basemap = new Basemap({ baseLayers: [featureLayer] }); チュートリアルへ\r\rArcGIS Maps SDKs は、ホスト レイヤーのアイテム ID またはサービス URL を使用してデータ サービスにアクセスできます。一方、オープンソース ライブラリは、サービス URL を使用してデータ サービスにアクセスします。\n\rベースマップ用に独自のサービスを作成する方法については、Data services \u0026gt; Introduction を参照してください。\n\rコード例 : ベースマップ スタイル サービス ベースマップ スタイルの表示 この例では、ベースマップのデータ ソースとしてベースマップ スタイル サービスを使用する方法を示します。そのためには、デフォルトのベースマップ スタイルの 1 つを使用します。すべてのスタイルについては、ベースマップ スタイル サービス を参照してください。\nステップ  マップを作成します。 ベースマップ スタイル サービスからスタイルを参照します。 ベースマップをマップに追加します。  例 : ArcGIS Maps SDK for JavaScript esriConfig.apiKey = \u0026#34;YOUR_ACCESS_TOKEN\u0026#34; const map = new Map({ basemap: \u0026#34;arcgis/streets\u0026#34;, //basemap: \u0026#34;arcgis/navigation\u0026#34;  //basemap: \u0026#34;arcgis/topographic\u0026#34;  //basemap: \u0026#34;arcgis/outdoor\u0026#34;  //basemap: \u0026#34;arcgis/light-gray\u0026#34;  //basemap: \u0026#34;arcgis/imagery\u0026#34;  //basemap: \u0026#34;osm/standard\u0026#34;  //basemap: \u0026#34;osm/navigation\u0026#34;  //basemap: \u0026#34;osm/blueprint\u0026#34; }) const view = new MapView({ map: map, center: [-118.805, 34.027], zoom: 12, container: \u0026#34;viewDiv\u0026#34;, constraints: { snapToZoom: false, }, }) チュートリアルヘ\r\r\r#### ArcGIS/Navigation\r\r#### ArcGIS/Topographic\r\r#### ArcGIS/Outdoor\r\r#### ArcGIS/Light gray canvas\r\r#### ArcGIS/Imagery\r\r#### OSM/Standard\r\r#### OSM/Navigation\r\r#### OSM/Blueprint\r\r--\rローカライズされた地名ラベルの表示 ベースマップ スタイル サービスはデフォルトで英語のラベルを表示します。以下の例では、ローカライズされた言語ベースの地名ラベルで OSM スタイルを表示する方法を示します。\nステップ  マップまたはシーンを作成します。 ベースマップ スタイル サービス (v2) からスタイルを参照します。 スタイルの URL で、language パラメーターに言語コードを設定します。 ベースマップをマップに追加します。  ローカライズされた地名ラベル (ローカル) この例では、arcgis/light-gray のマップ スタイルを使用します。デフォルトでは地名ラベルはグローバルな地名を表示します。ローカライズされた地名ラベルをレンダリングするには、language パラメーターを local に設定します。ローカライズされたラベルはズームレベル 10 以降でレンダリングされます。\n\r--\r例 : Esri Leaflet const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; const map = L.map(\u0026#34;map\u0026#34;).setView([35.67255187657312, 139.76323442958844], 14); L.esri.Vector.vectorBasemapLayer(\u0026#34;arcgis/light-gray\u0026#34;, { apikey: apiKey, language: \u0026#39;local\u0026#39;, version: 2 }).addTo(map); チュートリアルへ\r\r言語ベースの地名ラベル (グローバル) この例では、arcgis/dark-gray マップ スタイルを使用しています。language パラメーターに言語コード (ここでは ja) を設定し、全てのズームレベルで地名ラベルがすべて日本語で表示されるようにしています。\n\r--\r例 : Esri Leaflet const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; const map = L.map(\u0026#34;map\u0026#34;).setView([2.35, 48.856], 6); L.esri.Vector.vectorBasemapLayer(\u0026#34;arcgis/dark-gray\u0026#34;, { apikey: apiKey, language: \u0026#39;ja\u0026#39;, version: 2 }).addTo(map); チュートリアルへ\r\rworldview の表示 ベースマップ スタイル サービスは、デフォルトのグローバルな worldview を使用して、国の境界線とラベルを表示します。この例では、ある国の特定のビューに基づいてベースマップの境界線とラベルを表示する方法を示します。worldview は、navigation、streets、community など一部の ArcGIS ベースマップ スタイルでのみ使用できます。OSM スタイルはサポートされていません。\n特定の worlview を選択した場合、その国以外の国際的な方針ではないことに注意してください。\n\rステップ  マップまたはシーンを作成します。 ベースマップ スタイル サービスからベースマップ レイヤーを参照します。 スタイルの URL で、サポートされている worldview 名を worldview パラメーターに設定します。 ベースマップをマップに追加します。  この例では、 arcgis/light-gray のマップ スタイルを使用し、境界線とラベルの worldview を morocco に設定しています。すべての worldview オプションを見るには、ベースマップ スタイル サービス をご覧ください。\n\r--\r例 : MapLible GL JS const worldView = \u0026#34;morocco\u0026#34; // モロッコの worldview を指定  const map = new maplibregl.Map({ container: \u0026#34;map\u0026#34;, // div 要素の ID  style: `https://basemapstyles-api.arcgis.com/arcgis/rest/services/styles/v2/styles/arcgis/light-gray?token=${apiKey}\u0026amp;worldview=${worldView}`, zoom: 3, center: [-7.09, 31], // 初期位置 [経度, 緯度]  }) コード例 : 静的ベースマップ タイル サービス 静的ベースマップ タイルの表示 この例では、静的ベースマップ タイル サービスをベースマップのデータ ソースとして使用する方法を示します。そのためには、デフォルトのベースマップ スタイルの 1 つを使用します。すべてのスタイルについては、Static basemap tiles service を参照してください。\nステップ  マップを作成します。 静的ベースマップ スタイル サービスからスタイルを参照します。 ベースマップをマップに追加します。  例 : ArcGIS Maps SDK for JavaScript const basemapStyle = \u0026#34;arcgis/navigation\u0026#34; // const basemapStyle = \u0026#34;arcgis/streets\u0026#34; // const basemapStyle = \u0026#34;arcgis/outdoor\u0026#34; // const basemapStyle = \u0026#34;arcgis/light-gray\u0026#34; // const basemapStyle = \u0026#34;arcgis/dark-gray\u0026#34; const basemap = new Basemap({ baseLayers: [ new TileLayer({ url: `https://static-map-tiles-api.arcgis.com/arcgis/rest/services/static-basemap-tiles-service/v1/${basemapStyle}/static` }) ] }); const map = new Map({ basemap: basemap }); const view = new MapView({ container: \u0026#34;viewDiv\u0026#34;, map: map, center: [-91.2996, 37.1174], // USA (x, y)  zoom: 4 }); \r#### ArcGIS/Navigation\r\r#### ArcGIS/Outdoor\r\r#### ArcGIS/Light gray canvas\r\r#### ArcGIS/Dark gray canvas\r\r--\r静的ベースマップ タイル サービスの言語ラベルの変更 この例では、静的ベースマップ タイル サービスを使用するときに言語ラベルを変更する方法を示します。URL エンドポイントに、サポートされている言語コードの language パラメーターを渡すことができます。以下のマップはスイスを中心としており、言語を切り替えるとラベルが変化するのがわかります。\nステップ  マップを作成します。 静的ベースマップ タイル サービスからスタイルを参照し、language パラメーターを渡します。 ベースマップをマップに追加します。  \r--\r例 : ArcGIS Maps SDK for JavaScript const updateBasemapLanguage = (language) =\u0026gt; { let basemapLayer = new TileLayer({ url: `https://static-map-tiles-api.arcgis.com/arcgis/rest/services/static-basemap-tiles-service/v1/${basemapEnum}/static` }); // Remove existing language interceptor  if (languageInterceptor) { esriConfig.request.interceptors = esriConfig.request.interceptors.filter(interceptor =\u0026gt; interceptor !== languageInterceptor); } languageInterceptor = { urls: [basemapLayer.url], before({ requestOptions }) { requestOptions.query.language = language; }, }; esriConfig.request.interceptors.push(languageInterceptor); map.add(basemapLayer); basemapLayer.refresh(); }; コード例 : データ サービス ホスト レイヤーの表示 この例では、ベースマップのデータ ソースとして ArcGIS のデータ サービスを使用する方法を示します。データはアメリカ全土の地質を示すホスト フィーチャ レイヤーです。データ サービスを利用するためには、ホスト レイヤーのアイテム ID を参照する必要があります。\nステップ  ホスト レイヤーのアイテム ID を検索します。 ベースマップを作成し、そのレイヤーをベース レイヤーとして追加します。 マップを作成し、ベースマップを使用します。  \r--\r例 : ArcGIS Maps SDK for JavaScript const featureLayer = new FeatureLayer({ portalItem: { id: \u0026#34;4d9fb5c0a6344407aec56f47a11482b5\u0026#34; // ArcGIS Online 上の State Geologic Map Compilation – Geology を参照  } }); const basemap = new Basemap({ baseLayers: [featureLayer] }); チュートリアルへ\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/calcite-design-system/tutorials/create-a-mapping-app/",
	"title": "マッピング アプリの作成",
	"tags": [],
	"description": "Calcite コンポーネントとArcGIS Maps SDK for JavaScript Mapコンポーネントを使用して、シンプルなマッピング アプリケーションのUIを作成する方法について学びます。",
	"content": "出典：Calcite Design System - Create a mapping app\nCalcite コンポーネントと ArcGIS Maps SDK for JavaScript のマップ コンポーネントを使用して、シンプルなマッピング アプリケーションの UI を作成する方法について学びます。\nCalcite コンポーネントを使用して、マッピング アプリケーションでポジティブなユーザー エクスペリエンスを設計し、ユーザーとのインタラクションを促進します。このチュートリアルではユーザー インターフェースに焦点を当てており、ArcGIS Maps SDK for JavaScript の基本的な知識が必要です。ArcGIS Maps SDK for JavaScript に初めて触れる場合は、このアプリケーションで用いられるマッピング概念を解説したチュートリアルをご覧ください。\n前提条件 ArcGIS 開発者アカウント このチュートリアルで使用するサービスにアクセスするには、無料の ArcGIS Location Platform アカウントまたは ArcGIS Online 組織のアカウントが必要です。\n\rステップ 新しいペンの作成  CodePen にアクセスして、マッピング アプリケーション用の新しいペンを作成してください。  HTML の追加 CodePen の HTML で、HTML と CSS を追加して、arcgis-mapを表示するページを作成します。CSS は、マップがブラウザー ウィンドウの全幅と全高に表示されるようにします。 \u0026lt;!DOCTYPE html\u0026gt; タグは CodePen では必要ありません。異なるエディターを使用している場合や、ページをローカル サーバーで実行している場合は、HTML ページの先頭にこのタグを追加してください。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Calcite Components: Create a mapping app\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;style\u0026gt; html, body, #mapEl { padding: 0; margin: 0; height: 100%; width: 100%; display: flex; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;arcgis-map id=\u0026#34;mapEl\u0026#34;\u0026gt; \u0026lt;arcgis-zoom position=\u0026#34;top-right\u0026#34;\u0026gt;\u0026lt;/arcgis-zoom\u0026gt; \u0026lt;/arcgis-map\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  \u0026lt;head\u0026gt; 要素に、Calcite コンポーネント、ArcGIS Maps SDK for JavaScript、およびマップ コンポーネントへの参照を追加します。  \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Calcite Components: Create a mapping app\u0026lt;/title\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/calcite-components/3.2.1/calcite.esm.js\u0026#34; type=\u0026#34;module\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.33/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.33/esri/themes/light/main.css\u0026#34; /\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;https://js.arcgis.com/4.33/map-components\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;style\u0026gt; API キーの設定   このチュートリアルで使用されるロケーション サービスにアクセスするには、適切な権限を持つ API キーが必要です。\n1.1. API キーの取得の手順に従って、以下の権限を持つ API キーを作成します。\n 権限：ロケーション サービス \u0026gt; ベースマップ  1.2. CodePen で、esriConfig.apiKey に作成した API キーを設定してください。\n  \u0026lt;!-- esriConfig 変数は、他の Esri ライブラリーを追加する前に定義する必要があります --\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; var esriConfig = { apiKey: \u0026#34;API キー\u0026#34; }; \u0026lt;/script\u0026gt; アクセス トークンを取得するほかの方法については、Types of authentication 参照してください。\nマップの表示 このアプリケーションはマップが中心となっています。上記に CSS を追加することで、マップがウィンドウの全幅と全高に表示されるように設定しました。さらに、マップと関係を持つ ArcGIS Maps SDK for JavaScript のコンポーネントを追加します。これらのコンポーネントは、ユーザー インターフェースをシンプルに保つためにCalcite コンポーネントで管理されます。\n \u0026lt;body\u0026gt; 内で、Web マップのアイテム ID を指定する item-id 属性を使用して、arcgis-map コンポーネントを初期化します。  \u0026lt;arcgis-map id=\u0026#34;mapEl\u0026#34; item-id=\u0026#34;210c5b77056846808c7a5ce93920be81\u0026#34;\u0026gt; \u0026lt;arcgis-zoom position=\u0026#34;top-right\u0026#34;\u0026gt;\u0026lt;/arcgis-zoom\u0026gt; \u0026lt;/arcgis-map\u0026gt; レイアウトの作成 レイアウトを作成するには、calcite-shell を使用します。calcite-shell は、スロットを使用してページ上の他のコンポーネントを配置します。スロットは Web コンポーネントの概念であり、コア コンセプトのセクションで簡単に説明されています。コンポーネントがスロットを保有する場合、そのスロットのリストはコンポーネントのリファレンス ページで確認できます。例えば、シェルのスロットはこちらの通りです。\n calcite-shell コンポーネントを追加します。  content-behind 属性を設定し、ユーザーがシェル背後のマップとインタラクションできるようにします。   calcite-shell-panel コンポーネントを追加し、シェル パネルの panel-start スロットに配置します。displayMode 属性を float-content に設定し、シェル パネルの中身がマップの上で動作するように表示されます。  \u0026lt;body\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;calcite-shell content-behind\u0026gt; \u0026lt;calcite-shell-panel slot=\u0026#34;panel-start\u0026#34; display-mode=\u0026#34;float-content\u0026#34;\u0026gt; \u0026lt;/calcite-shell-panel\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;arcgis-map id=\u0026#34;mapEl\u0026#34; item-id=\u0026#34;210c5b77056846808c7a5ce93920be81\u0026#34;\u0026gt; \u0026lt;arcgis-zoom position=\u0026#34;top-right\u0026#34;\u0026gt;\u0026lt;/arcgis-zoom\u0026gt; \u0026lt;/arcgis-map\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;/calcite-shell\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/body\u0026gt;   calcite-navigation コンポーネントを追加し、シェルの header スロットに配置します。\n  次に、calcite-navigation-logo コンポーネントをナビゲーションの logo スロットに配置します。Web マップのタイトルでヘッダーを動的に表示するために、id を指定します。\n  \u0026lt;calcite-shell content-behind\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;calcite-navigation slot=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;calcite-navigation-logo id=\u0026#34;header-title\u0026#34; heading-level=\u0026#34;1\u0026#34; slot=\u0026#34;logo\u0026#34;\u0026gt; \u0026lt;!-- Dynamically populated --\u0026gt; \u0026lt;/calcite-navigation-logo\u0026gt; \u0026lt;/calcite-navigation\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;calcite-shell-panel slot=\u0026#34;panel-start\u0026#34; display-mode=\u0026#34;float-content\u0026#34;\u0026gt; \u0026lt;/calcite-shell-panel\u0026gt; アクションとパネル コンポーネントを追加する 次に、ArcGIS Maps SDK for JavaScript コンポーネントにアクセスするために使用するコンポーネントを追加します。calcite-panel コンポーネントにはマップ コンポーネント コンテナーが含まれます。パネルは初期状態では非表示になっており、ユーザーは対応する calcite-action コンポーネントを使用して表示できます。\n calcite-action-bar コンポーネントを追加し、シェル パネルの action-bar スロットに配置します。 calcite-action コンポーネントを追加し、クリックするとパネルが開くようにします。  アクションで開くマップ コンポーネントの名前を icon 属性に設定します。追加のオプションを確認するには、Calcite iconsを表示してください。 action-bar を展開した際に表示されるテキスト属性を設定します。 data-action-id のグローバル属性を設定します。この属性は、以降のステップでアクションを操作する際に使用されます。    \u0026lt;calcite-shell content-behind\u0026gt; \u0026lt;calcite-navigation slot=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;calcite-navigation-logo id=\u0026#34;header-title\u0026#34; heading-level=\u0026#34;1\u0026#34; slot=\u0026#34;logo\u0026#34;\u0026gt; \u0026lt;!-- Dynamically populated --\u0026gt; \u0026lt;/calcite-navigation-logo\u0026gt; \u0026lt;/calcite-navigation\u0026gt; \u0026lt;calcite-shell-panel slot=\u0026#34;panel-start\u0026#34; display-mode=\u0026#34;float-content\u0026#34;\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;calcite-action-bar slot=\u0026#34;action-bar\u0026#34;\u0026gt; \u0026lt;calcite-action data-action-id=\u0026#34;layers\u0026#34; icon=\u0026#34;layers\u0026#34; text=\u0026#34;Layers\u0026#34;\u0026gt;\u0026lt;/calcite-action\u0026gt; \u0026lt;calcite-action data-action-id=\u0026#34;basemaps\u0026#34; icon=\u0026#34;basemap\u0026#34; text=\u0026#34;Basemaps\u0026#34;\u0026gt;\u0026lt;/calcite-action\u0026gt; \u0026lt;calcite-action data-action-id=\u0026#34;legend\u0026#34; icon=\u0026#34;legend\u0026#34; text=\u0026#34;Legend\u0026#34;\u0026gt;\u0026lt;/calcite-action\u0026gt; \u0026lt;calcite-action data-action-id=\u0026#34;bookmarks\u0026#34; icon=\u0026#34;bookmark\u0026#34; text=\u0026#34;Bookmarks\u0026#34;\u0026gt;\u0026lt;/calcite-action\u0026gt; \u0026lt;calcite-action data-action-id=\u0026#34;print\u0026#34; icon=\u0026#34;print\u0026#34; text=\u0026#34;Print\u0026#34;\u0026gt;\u0026lt;/calcite-action\u0026gt; \u0026lt;calcite-action data-action-id=\u0026#34;information\u0026#34; icon=\u0026#34;information\u0026#34; text=\u0026#34;Information\u0026#34;\u0026gt;\u0026lt;/calcite-action\u0026gt; \u0026lt;/calcite-action-bar\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/calcite-shell-panel\u0026gt;  アクション バーの下に、ArcGIS Maps SDK for JavaScript コンポーネント（arcgis-layer-list、arcgis-basemap-gallery、arcgis-legend、arcgis-bookmarks、arcgis-print を含む）用のコンテナを含む calcite-panel コンポーネントを追加します。  パネルのタイトルの heading 属性を設定します。 パネルの高さを height 属性を使用して設定します。 対応するアクションをクリックした際に削除されるclosed 属性を設定します。 パネルのグローバル属性 data-panel-id を設定します。この属性は、後の手順でパネルを操作する際に使用されます。    \u0026lt;/calcite-action-bar\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;!-- Map-specific panels (each one provides a div for ArcGIS Maps SDK for JavaScript widgets) --\u0026gt; \u0026lt;calcite-panel heading=\u0026#34;Layers\u0026#34; height-scale=\u0026#34;l\u0026#34; data-panel-id=\u0026#34;layers\u0026#34; closed closable\u0026gt; \u0026lt;arcgis-layer-list drag-enabled reference-element=\u0026#34;mapEl\u0026#34; visibility-appearance=\u0026#34;checkbox\u0026#34;\u0026gt;\u0026lt;/arcgis-layer-list\u0026gt; \u0026lt;/calcite-panel\u0026gt; \u0026lt;calcite-panel heading=\u0026#34;Basemaps\u0026#34; height-scale=\u0026#34;l\u0026#34; data-panel-id=\u0026#34;basemaps\u0026#34; closed closable\u0026gt; \u0026lt;arcgis-basemap-gallery reference-element=\u0026#34;mapEl\u0026#34;\u0026gt;\u0026lt;/arcgis-basemap-gallery\u0026gt; \u0026lt;/calcite-panel\u0026gt; \u0026lt;calcite-panel heading=\u0026#34;Legend\u0026#34; height-scale=\u0026#34;l\u0026#34; data-panel-id=\u0026#34;legend\u0026#34; closed closable\u0026gt; \u0026lt;arcgis-legend legend-style=\u0026#34;classic\u0026#34; reference-element=\u0026#34;mapEl\u0026#34;\u0026gt;\u0026lt;/arcgis-legend\u0026gt; \u0026lt;/calcite-panel\u0026gt; \u0026lt;calcite-panel heading=\u0026#34;Bookmarks\u0026#34; height-scale=\u0026#34;l\u0026#34; data-panel-id=\u0026#34;bookmarks\u0026#34; closed closable\u0026gt; \u0026lt;arcgis-bookmarks editing-enabled=\u0026#34;false\u0026#34; reference-element=\u0026#34;mapEl\u0026#34;\u0026gt;\u0026lt;/arcgis-bookmarks\u0026gt; \u0026lt;/calcite-panel\u0026gt; \u0026lt;calcite-panel heading=\u0026#34;Print\u0026#34; height-scale=\u0026#34;l\u0026#34; data-panel-id=\u0026#34;print\u0026#34; closed closable\u0026gt; \u0026lt;arcgis-print allowed-formats=\u0026#34;all\u0026#34; allowed-layouts=\u0026#34;all\u0026#34; include-default-templates=\u0026#34;false\u0026#34; reference-element=\u0026#34;mapEl\u0026#34;\u0026gt;\u0026lt;/arcgis-print\u0026gt; \u0026lt;/calcite-panel\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/calcite-shell-panel\u0026gt;  別の calcite-panel のコンポーネントを追加します。 div 要素を作成し、その中にグローバル属性 id が指定されている img 要素と div 要素の子要素を追加します。これらの要素には、Web マップのサムネイルと説明が表示されます。 calcite-label コンポーネントを追加し、layout 属性を inline に設定します。 ラベルの子要素として calcite-rating コンポーネントを追加し、read-only 属性を設定します。このコンポーネントには、Web マップの平均評価が取り込まれます。  \u0026lt;calcite-panel heading=\u0026#34;Print\u0026#34; height-scale=\u0026#34;l\u0026#34; data-panel-id=\u0026#34;print\u0026#34; closed closable\u0026gt; \u0026lt;arcgis-print allowed-formats=\u0026#34;all\u0026#34; allowed-layouts=\u0026#34;all\u0026#34; include-default-templates=\u0026#34;false\u0026#34; reference-element=\u0026#34;mapEl\u0026#34;\u0026gt;\u0026lt;/arcgis-print\u0026gt; \u0026lt;/calcite-panel\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;!-- Info panel (populates with info from the web map) --\u0026gt; \u0026lt;calcite-panel heading=\u0026#34;Details\u0026#34; data-panel-id=\u0026#34;information\u0026#34; closed closable\u0026gt; \u0026lt;div id=\u0026#34;info-content\u0026#34;\u0026gt; \u0026lt;img id=\u0026#34;item-thumbnail\u0026#34; alt=\u0026#34;webmap thumbnail\u0026#34; /\u0026gt; \u0026lt;div id=\u0026#34;item-description\u0026#34;\u0026gt; \u0026lt;!-- Dynamically populated --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;calcite-label layout=\u0026#34;inline\u0026#34;\u0026gt; \u0026lt;b\u0026gt;Rating:\u0026lt;/b\u0026gt; \u0026lt;calcite-rating id=\u0026#34;item-rating\u0026#34; read-only\u0026gt; \u0026lt;!-- Dynamically populated --\u0026gt; \u0026lt;/calcite-rating\u0026gt; \u0026lt;/calcite-label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/calcite-panel\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/calcite-shell-panel\u0026gt; \u0026lt;arcgis-map id=\u0026#34;mapEl\u0026#34; item-id=\u0026#34;210c5b77056846808c7a5ce93920be81\u0026#34;\u0026gt; \u0026lt;arcgis-zoom position=\u0026#34;top-right\u0026#34;\u0026gt;\u0026lt;/arcgis-zoom\u0026gt; \u0026lt;/arcgis-map\u0026gt; 内容を追加する これまで Calcite コンポーネントをアプリケーションに追加してきました。 次に、ナビゲーション ロゴの heading と情報パネルに Web マップの内容を反映させます。\n 既存の JavaScript コードの \u0026lt;script\u0026gt; 要素の中に、arcgisViewReadyChange イベントを使用して、マップが非同期で読み込みが完了するのを待ちます。 マップが読み込まれると、querySelector() メソッドを使用して DOM にアクセスし、コンテンツを格納します。 次に、arcgis-map の左側に padding を追加し、ArcGIS Maps SDK for JavaScript コンポーネントのためのスペースを確保します。  \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; const mapEl = document.getElementById(\u0026#34;mapEl\u0026#34;); mapEl.addEventListener(\u0026#34;arcgisViewReadyChange\u0026#34;, (evt) =\u0026gt; { const { title, description, thumbnailUrl, avgRating } = mapEl.map.portalItem; document.querySelector(\u0026#34;#header-title\u0026#34;).heading = title; document.querySelector(\u0026#34;#item-description\u0026#34;).innerHTML = description; document.querySelector(\u0026#34;#item-thumbnail\u0026#34;).src = thumbnailUrl; document.querySelector(\u0026#34;#item-rating\u0026#34;).value = avgRating; mapEl.view.padding = { left: 49 }; \u0026lt;!-- 追加終了 --\u0026gt; }); \u0026lt;/script\u0026gt; コンポーネントを操作する 次のステップは、対応する calcite-action コンポーネントをクリックした際に、ArcGIS Maps SDK for JavaScript コンポーネントを含む calcite-panel コンポーネントを開くことです。\n  arcgisViewReadyChange イベント内で、現在開かれているマップ コンポーネントの名前を格納するための変数を初期化します。\n  アクションがクリックされた際に実行される関数を作成します。この関数は、アクティブなパネルを閉じ、クリックされたアクションに対応するパネルを開きます。ユーザーがアクティブなアクションをクリックした場合、対応するパネルが閉じられ、開いているパネルはなくなります。\n  このステップでは、 属性セレクター を使用して、上記で追加した データ属性 を使用してアクションとパネル要素にアクセスします。データ属性の値は、対応するマップ コンポーネントの名前です。\n 上記の関数をコールバックとして使用して、calcite-action-bar にクリック イベント リスナーを作成します。  mapEl.view.padding = { left: 49 }; // 追加開始  let activeWidget; const handleActionBarClick = ({ target }) =\u0026gt; { if (target.tagName !== \u0026#34;CALCITE-ACTION\u0026#34;) { return; } if (activeWidget) { document.querySelector(`[data-action-id=${activeWidget}]`).active = false; document.querySelector(`[data-panel-id=${activeWidget}]`).closed = true; } const nextWidget = target.dataset.actionId; if (nextWidget !== activeWidget) { document.querySelector(`[data-action-id=${nextWidget}]`).active = true; document.querySelector(`[data-panel-id=${nextWidget}]`).closed = false; activeWidget = nextWidget; document.querySelector(`[data-panel-id=${nextWidget}]`).setFocus(); } else { activeWidget = null; } }; // Panel interaction  const panelEls = document.querySelectorAll(\u0026#34;calcite-panel\u0026#34;); for (let i = 0; i \u0026lt; panelEls.length; i++) { panelEls[i].addEventListener(\u0026#34;calcitePanelClose\u0026#34;, () =\u0026gt; { document.querySelector(`[data-action-id=${activeWidget}]`).active = false; document.querySelector(`[data-action-id=${activeWidget}]`).setFocus(); activeWidget = null; }); } // 追加終了  }); \u0026lt;/script\u0026gt; マップを動的にサイズ変更する コンポーネントが操作可能になったため、calcite-action-bar が展開または折りたたまれる際に、マップが自動的に調整される必要があります。\n arcgisViewReadyChange イベント内で、calciteActionBarToggle にイベント リスナーを追加します。このリスナーは、ビューが展開されたり折りたたまれたりした際に、それぞれに応じて padding を追加または削除します。  activeWidget = null; }); } // 追加開始  document.querySelector(\u0026#34;calcite-action-bar\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, handleActionBarClick); let actionBarExpanded = false; document.addEventListener(\u0026#34;calciteActionBarToggle\u0026#34;, event =\u0026gt; { actionBarExpanded = !actionBarExpanded; mapEl.view.padding = { left: actionBarExpanded ? 135 : 49 }; }); // 追加終了 loader コンポーネントを追加する ここまでで、アプリケーション内のすべての要素が操作可能になりました。Calcite コンポーネントを使用して、マップ コンポーネントの表示と非表示を切り替えることができます。ただし、アプリケーションの読み込みに数秒かかりますので、ユーザーにその旨を通知する必要があります。\n \u0026lt;body\u0026gt; 要素内に、コンポーネントを表示するための calcite-loader を追加します。 calcite-shell に hiddun グローバル属性を追加します。  \u0026lt;body\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;calcite-loader\u0026gt;\u0026lt;/calcite-loader\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;!-- 変更開始 --\u0026gt; \u0026lt;calcite-shell content-behind hidden\u0026gt; \u0026lt;!-- 変更終了 --\u0026gt; \u0026lt;calcite-navigation slot=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;calcite-navigation-logo id=\u0026#34;header-title\u0026#34; heading-level=\u0026#34;1\u0026#34; slot=\u0026#34;logo\u0026#34;\u0026gt; \u0026lt;!--dynamically populated--\u0026gt; \u0026lt;/calcite-navigation-logo\u0026gt; \u0026lt;/calcite-navigation\u0026gt;  arcgisViewReadyChange イベント内において、JavaScript コードの残りの部分の下で、calcite-loader コンポーネントの hidden プロパティを true に設定して非表示にし、calcite-shell コンポーネントの hidden プロパティを false に設定して表示します。  document.querySelector(\u0026#34;calcite-shell\u0026#34;).hidden = false; document.querySelector(\u0026#34;calcite-loader\u0026#34;).hidden = true; スタイルを追加する  \u0026lt;style\u0026gt; 要素に、ユーザー インターフェースを整理するための追加の CSS を追加します。  #mapEl { padding: 0; margin: 0; height: 100%; width: 100%; display: flex; } \u0026lt;!-- 追加開始 --\u0026gt; body { display: flex; } calcite-loader { align-self: center; justify-self: center; } #info-content { padding: 0.75rem; } calcite-rating { margin-top: 0.25rem; } \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/style\u0026gt; アプリを実行する CodePen でコードを実行してアプリケーションを表示します。アプリケーションの読み込みが完了すると、マップが表示され、Web マップのタイトルと calcite-action-bar が表示されます。calcite-action コンポーネントをクリックすると、 ArcGIS Maps SDK for JavaScript Map コンポーネントが含まれているcalcite-panel コンポーネントが開閉します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/dotnet/",
	"title": "ArcGIS Maps SDK for .NET",
	"tags": [],
	"description": "ArcGIS Maps SDK for .NET の開発に役立つガイド集です。",
	"content": "ArcGIS Maps SDK for .NET (バージョン 200.x) の開発に役立つガイド集です。\n インストール ガイド\nArcGIS Maps SDK for .NET のインストールとセットアップ手順を紹介します。\n\r アプリケーション配布ガイド\nArcGIS Maps SDK for .NET を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を紹介します。\n\r バージョン 100.x から 200.x への移行\n今まで ArcGIS Runtime SDK for .NET バージョン 100.x を使用してアプリケーションを開発されていた開発者向けのガイドです。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-cesium/",
	"title": "CesiumJS",
	"tags": [],
	"description": "CesiumJS を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。",
	"content": "シーンを表示する このチュートリアルでは、CesiumJS と ベースマップ レイヤー サービスを使用して、シーンを表示する方法を紹介します。\nArcGIS マップ タイル サービスを使用すると、CesiumJS で地図が表示できます。例えば ArcGIS:Imagery マップ タイル レイヤーには、世界の地形と組み合わせて使用できる、グローバルなカバレッジを持つ衛星画像が含まれています。\nこのチュートリアルでは、ArcGIS:Imagery と Cesium World Terrain を使用して、富士山周辺のシーンを表示します。\nベースマップ レイヤーの詳細については、Mapping and location services ガイドの Basemaps とベースマップを参照してください。\n\r前提条件 この機能を使うには、開発者アカウントが必要です。アカウントの作成手順については「開発者アカウントの作成」を参照してください。\nステップ 新しい Pen の作成 CodePen にアクセスして、新しい Pen を作成します。\nHTML の追加 HTML ページを定義して、Web ブラウザの幅と高さにあわせたマップを作成します。\n CodePen \u0026gt; HTML で、HTML と CSS を追加して、cesiumContainer という id 属性を持つ div 要素のあるページを作成します。 cesiumContainer は、マップを表示するために使用される id 属性です。CSS はブラウザの設定をリセットして、マップがブラウザの幅と高さ全体に表示されるようにします。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;CesiumJS: Display a Scene\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #cesiumContainer { margin: 0; padding: 0; width: 100%; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;cesiumContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; スクリプト参照の追加  \u0026lt;head\u0026gt;タグで、CesiumJS CSS および JS ライブラリへの参照を追加します。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;CesiumJS: Display a Scene\u0026lt;/title\u0026gt; \u0026lt;!-- cesium js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;style\u0026gt; html, body, #cesiumContainer { margin: 0; padding: 0; width: 100%; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;cesiumContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Cesium ion アクセス トークンの取得 すべての Cesium アプリケーションは、Cesium ion を通じて提供されるアクセス トークンを使用する必要があります。このトークンによって、アプリケーションで Cesium World Terrain などのアセットにアクセスできるようになります。\n Cesium ion のダッシュボード にアクセスし、アクセス トークンを生成し、取得します。 \u0026lt;body\u0026gt;タグ内に\u0026lt;script\u0026gt;タグを追加します。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;CesiumJS: Display a Scene\u0026lt;/title\u0026gt; \u0026lt;!-- cesium js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;style\u0026gt; html, body, #cesiumContainer { margin: 0; padding: 0; width: 100%; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;cesiumContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script のタグを追加--\u0026gt; \u0026lt;script\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 変数 cesiumAccessToken を作成し、Cesium ion ダッシュボードからコピーしたアクセス トークンを格納し、Cesium.Ion.defaultAccessToken に設定します。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;CesiumJS: Display a Scene\u0026lt;/title\u0026gt; \u0026lt;!-- cesium js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;style\u0026gt; html, body, #cesiumContainer { margin: 0; padding: 0; width: 100%; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;cesiumContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script のタグを追加--\u0026gt; \u0026lt;script\u0026gt; // 取得した Cesium ion のアクセス トークンを貼り付け  const cesiumAccessToken = \u0026#34;YOUR_CESIUM_ACCESS_TOKEN\u0026#34;; // Cesium ion へのアクセス トークンを cesiumAccessToken に設定  Cesium.Ion.defaultAccessToken = cesiumAccessToken; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ArcGIS APIキーの取得 ロケーション サービスにアクセスするには、API キーまたは OAuth2.0 アクセス トークンが必要です。API キーの作成手順については「API キーの取得」を参照してください。\n認証方法とアクセストークンの取得方法の詳細については、「セキュリティと認証」を参照してください。\n  ダッシュボードにアクセスして、Developer credentials から API キーを取得します。\n  作成した ArcGIS API キーを変数 apiKey に格納し、Cesium.ArcGisMapService.defaultAccessToken に設定します。\n  CesiumJS で利用可能な ArcGIS サービスの詳細については、Key features を参照してください。\n\r\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;CesiumJS: Display a Scene\u0026lt;/title\u0026gt; \u0026lt;!-- cesium js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;style\u0026gt; html, body, #cesiumContainer { margin: 0; padding: 0; width: 100%; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;cesiumContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script のタグを追加--\u0026gt; \u0026lt;script\u0026gt; // ArcGIS API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ArcGIS API キーを Cesium.ArcGisMapService.defaultAccessToken に設定  Cesium.ArcGisMapService.defaultAccessToken = apiKey; // 取得した Cesium ion のアクセス トークンを貼り付け  const cesiumAccessToken = \u0026#34;YOUR_CESIUM_ACCESS_TOKEN\u0026#34;; // Cesium ion へのアクセス トークンを cesiumAccessToken に設定  Cesium.Ion.defaultAccessToken = cesiumAccessToken; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; シーンの作成 World Imagery マップ タイル レイヤーにアクセスする Viewer を作成します。ArcGisMapServerImageryProvider クラスを使用して、ベースマップ スタイル サービスに認証済み要求を行います。\n SATTELITE ベースマップ タイプを使用して新しい ArcGisMapServerImageryProvider クラスを作成します。SATTELITE ベースマップ タイプは、ArcGIS:World Imagery マップ タイル サービスにアクセスします。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;CesiumJS: Display a Scene\u0026lt;/title\u0026gt; \u0026lt;!-- cesium js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;style\u0026gt; html, body, #cesiumContainer { margin: 0; padding: 0; width: 100%; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;cesiumContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script のタグを追加--\u0026gt; \u0026lt;script\u0026gt; // ArcGIS API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ArcGIS API キーを Cesium.ArcGisMapService.defaultAccessToken に設定  Cesium.ArcGisMapService.defaultAccessToken = apiKey; // 取得した Cesium ion のアクセス トークンを貼り付け  const cesiumAccessToken = \u0026#34;YOUR_CESIUM_ACCESS_TOKEN\u0026#34;; // Cesium ion へのアクセス トークンを cesiumAccessToken に設定  Cesium.Ion.defaultAccessToken = cesiumAccessToken; // fromBasemapType メソッドを利用して ArcGIS のベースマップを呼び出し  const arcGisImagery = Cesium.ArcGisMapServerImageryProvider.fromBasemapType(Cesium.ArcGisBaseMapType.SATELLITE); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; CesiumContainer に接続された Cesium.Viewer クラスを作成します。 Cesium.ImageryLayer.fromProviderAsync メソッドで、baseLayer プロパティを設定します。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;CesiumJS: Display a Scene\u0026lt;/title\u0026gt; \u0026lt;!-- cesium js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;style\u0026gt; html, body, #cesiumContainer { margin: 0; padding: 0; width: 100%; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;cesiumContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script のタグを追加--\u0026gt; \u0026lt;script\u0026gt; // ArcGIS API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ArcGIS API キーを Cesium.ArcGisMapService.defaultAccessToken に設定  Cesium.ArcGisMapService.defaultAccessToken = apiKey; // 取得した Cesium ion のアクセス トークンを貼り付け  const cesiumAccessToken = \u0026#34;YOUR_CESIUM_ACCESS_TOKEN\u0026#34;; // Cesium ion へのアクセス トークンを cesiumAccessToken に設定  Cesium.Ion.defaultAccessToken = cesiumAccessToken; // fromBasemapType メソッドを利用して ArcGIS のベースマップを呼び出し  const arcGisImagery = Cesium.ArcGisMapServerImageryProvider.fromBasemapType(Cesium.ArcGisBaseMapType.SATELLITE); // CesiumContainer に接続された Cesium.Viewer クラスを作成  const viewer = new Cesium.Viewer(\u0026#34;cesiumContainer\u0026#34;, { // Cesium のベースマップを SATELLITE に設定  baseLayer: Cesium.ImageryLayer.fromProviderAsync(arcGisImagery), }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; オプションの追加パラメーターを設定し、Viewer の外観を構成します。今回は、timeline、animation、geocoder コントロールを無効にし、Cesium World Terrain を追加します。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;CesiumJS: Display a Scene\u0026lt;/title\u0026gt; \u0026lt;!-- cesium js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;style\u0026gt; html, body, #cesiumContainer { margin: 0; padding: 0; width: 100%; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;cesiumContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script のタグを追加--\u0026gt; \u0026lt;script\u0026gt; // ArcGIS API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ArcGIS API キーを Cesium.ArcGisMapService.defaultAccessToken に設定  Cesium.ArcGisMapService.defaultAccessToken = apiKey; // 取得した Cesium ion のアクセス トークンを貼り付け  const cesiumAccessToken = \u0026#34;YOUR_CESIUM_ACCESS_TOKEN\u0026#34;; // Cesium ion へのアクセス トークンを cesiumAccessToken に設定  Cesium.Ion.defaultAccessToken = cesiumAccessToken; // fromBasemapType メソッドを利用して ArcGIS のベースマップを呼び出し  const arcGisImagery = Cesium.ArcGisMapServerImageryProvider.fromBasemapType(Cesium.ArcGisBaseMapType.SATELLITE); // CesiumContainer に接続された Cesium.Viewer クラスを作成  const viewer = new Cesium.Viewer(\u0026#34;cesiumContainer\u0026#34;, { // Cesium のベースマップを SATELLITE に設定  baseLayer: Cesium.ImageryLayer.fromProviderAsync(arcGisImagery), // Viewer のオプションを設定。  terrain: Cesium.Terrain.fromWorldTerrain(), timeline: false, animation: false, geocoder:false }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; viewer.camera.setView を使用して、シーンのカメラの位置は河口湖付近に設定し、少し上から見下ろしているような視点にします。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;CesiumJS: Display a Scene\u0026lt;/title\u0026gt; \u0026lt;!-- cesium js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;style\u0026gt; html, body, #cesiumContainer { margin: 0; padding: 0; width: 100%; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;cesiumContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script のタグを追加--\u0026gt; \u0026lt;script\u0026gt; // ArcGIS API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ArcGIS API キーを Cesium.ArcGisMapService.defaultAccessToken に設定  Cesium.ArcGisMapService.defaultAccessToken = apiKey; // 取得した Cesium ion のアクセス トークンを貼り付け  const cesiumAccessToken = \u0026#34;YOUR_CESIUM_ACCESS_TOKEN\u0026#34;; // Cesium ion へのアクセス トークンを cesiumAccessToken に設定  Cesium.Ion.defaultAccessToken = cesiumAccessToken; // fromBasemapType メソッドを利用して ArcGIS のベースマップを呼び出し  const arcGisImagery = Cesium.ArcGisMapServerImageryProvider.fromBasemapType(Cesium.ArcGisBaseMapType.SATELLITE); // CesiumContainer に接続された Cesium.Viewer クラスを作成  const viewer = new Cesium.Viewer(\u0026#34;cesiumContainer\u0026#34;, { // Cesium のベースマップを SATELLITE に設定  baseLayer: Cesium.ImageryLayer.fromProviderAsync(arcGisImagery), // Viewer のオプションを設定。  terrain: Cesium.Terrain.fromWorldTerrain(), timeline: false, animation: false, geocoder:false }); // カメラの位置と角度を設定  viewer.camera.setView({ destination : Cesium.Cartesian3.fromDegrees(138.74482706645605,35.509217041554955, 3500), orientation : { heading : Cesium.Math.toRadians(180.0), pitch : Cesium.Math.toRadians(-10.0), } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; アプリの実行 CodePen で、作成したコードを実行してシーンを表示します。\n表示されるシーンには、日本の富士山周辺の衛星画像が 3D で表示されています。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/python-api-jnlabsetup/",
	"title": "Jupyter Lab を使ってみよう",
	"tags": [],
	"description": "ArcGIS API for Python の実行に便利な Jupyter Notebook の基本的な起動と使用方法を簡単に紹介します。",
	"content": "JupyterLab は、コード、データ、そして Jupyter Notebook のファイル形式（*.ipynb）を扱う最新の対話型開発環境（IDE）です。Jupyter Notebook 同様、オープンソースとして公開されています。\nArcGIS API for Python（以下、Python API ）のバージョン 1.5.0 以降で対応しています。バージョン 2.4.0 以降は Jupyter Lab 4.0 に対応しています。\nJupyterLab で GIS データとグラフの操作\n\rJupyterLab は、より柔軟で強力なユーザー体験を実現するために Jupyter Notebook の主要コンポーネント (ノートブック、ターミナル、テキスト エディター、ファイル ブラウザー、ipywidgets など) をベースに構築されています。JupyterLab の詳細は JupyterLab のドキュメントや GitHub をご参照ください。\nJupyterLab をはじめる Python API を JupyterLab で使用するためには、いくつかインストールなどの設定が必要です。\nインストール   バージョン 1.5.0 以上の Python API をインストールするか、既存の環境を 1.5.0 以上にアップデートする ターゲットの仮想環境がある場合は、アクティベート（activate）してから行います。Python API のインストールまたはアップデートの方法はインストールガイドをご覧ください。\n  次の 2 つのコマンドを実行します\n jupyter labextension install @jupyter-widgets/jupyterlab-manager jupyter labextension install arcgis-map-ipywidget@バージョン番号    2 つ目のコマンドの最後にある「バージョン番号」部分は、使用する Python API のバージョンに合わせて変更してください (例：1.6.1)。\nエラー等で正常に完了できない場合は、お使いの端末または現在の環境に npm および nodejs をインストールする必要があります。インストールの詳細は npm のウェブサイト、または node.js のウェブサイトを参照してください。\n\r\\anaconda3\\share\\jupyter\\lab\r@jupyter-widgets/jupyterlab-manager v0.38.1 enabled ok\rarcgis-map-ipywidget v1.5.1 enabled ok\r``` --\r 以上の設定が完了したら、次のコマンドで JupyterLab を起動します。  jupyter lab    任意のディレクトリをルート ディレクトリとして起動したい場合は、cd コマンドでディレクトリを移動してから起動コマンドを実行します。\nファイルエクスプローラー JupyterLab は、従来の Jupyter Notebook のように、既存のノートブックを開いたり、新しいノートブックを作成したり、コンテンツを整理するためのファイルエクスプローラを備えています。 JupyterLab のファイルエクスプローラは、メインビューの左側のウィンドウです。\n\rJupyterLab も Jupyter Notebook と同様に、ノートブック形式（*.ipynb）で動作しコードや結果を保存できます。この 2 つのツールの違いは、主にユーザーインターフェースといくつかの外部エクステンションが追加された点です。\nウィンドウとタブを使用する JupyterLab には、Jupyter Notebook とは違って、「ウィンドウ」と「タブ」という概念があります。 これにより、ノートブックを重ねたり、横に並べたり、タブで整理したりすることができます。これらの操作は、以下のように「タブ」をクリックしてドラッグするだけで可能です。\n\rどのようなウィンドウでもこのようにドラッグすることが可能です。*.csv、*.json などのファイルも表示や編集することができます。\rセルの使用 上記のウィンドウとタブと同様に、JupyterLab ではノートブックのセルをドラッグアンドドロップして移動することができます。 JupyterLab は、1 つのノートブックから別のノートブックにセルをドラッグする機能もサポートしています。 移動したいセルの左側の領域をクリックして、それをドラッグします。\n\rJupyterLab では、Shift キーを押しながら複数のセルを選択することもできます。前述のようにこれらのセルを移動するか、右クリックして [Copy Cells] を選択してコピーします。また、右クリックのメニューには、[Create New View For Output] を含む多くのオプションがあります。[Create New View For Output] を使用すると、任意のセルの実行結果を別のタブで表示することができ、重ねたり、並べて表示したりすることができます。\n\rJupyterLab には他にも様々なセルの操作ができるので、いろいろと探してみてください！\rマップ ウィジェットとの連携 バージョン 1.5.0 以上の Python API では、2D 回転、3D モード、3D レンダラーのサポートなどマップ ウィジェットの機能が多数追加されています。これらの機能の詳細については、ガイド ページの Advanced Map Widget Usage で紹介しています。\n\r--\rPython API の Map クラスのデフォルトの表示動作は、Jupyter Notebook と同じで、ウィジェットはセルの出力にマップが表示されます。\n\rこのボタンを押すと、ウィジェットが新しいウィンドウで表示されます。 このウィンドウは、他のすべてのウィンドウと同様に、タブでの表示、分割などが可能です。 ウィジェットを元に戻すには、以下のボタンを押します。\r\r--\r実際にコードを試してみましょう。 以下のセルを実行します。\nfrom arcgis.gis import GIS # JupyterLab へ地図を表示する gis = GIS() map = gis.map() map \rWeb マップや Web シーン も表示することができます。\nfrom arcgis.map import Map webmap_item = gis.content.get(\u0026#34;\u0026lt;Web マップのアイテム ID\u0026gt;\u0026#34;) webmap = Map(webmap_item) webmap from arcgis.map import Scene webscene_item = gis.content.get(\u0026#34;\u0026lt;Web シーンのアイテム ID\u0026gt;\u0026#34;) webscene = Scene(webscene_item) webscene \r\rUI ボタンによる新しいウィンドウでの地図表示は、`toggle_window_view（）` メソッドを使用することでも制御できます。次のコードでは、マップが表示されたらメソッドを使用して新しいウィンドウで表示させます。新しいウィンドウに戻すときも、このメソッドを使用可能です。\r以下のコードを実行してみてください。\r```python\rfrom arcgis.widgets import MapView\r# 対象の地図を表示する\rmap = MapView(gis=gis)\rmap\r```\r```python\rmap.toggle_window_view()\r```\r\rタイトル（タブに表示されるテキスト）と `tab_mode` をメソッドを呼び出すたびに指定することも可能です。\r```python\r# 対象の地図を表示する\rmap = gis.map(mode=\"3D\")\rmap\r```\r```python\r# このセルを実行して、新しいウィンドウに地図を表示します\rmap.toggle_window_view(title=\"My 3D Map\", tab_mode=\"split-top\")\r# ウィンドウを元に戻す\rmap.toggle_window_view()\r```\r```python\rimport time\r# このセルを実行して全てのタブモードの挙動を確認してみてください\rtab_modes = ['auto', 'split-top' 'split-bottom', 'split-left',\r'split-right', 'tab-before', 'tab-after']\rfor tab_mode in tab_modes:\r# 新しいウィンドウで開く\rmap.toggle_window_view(title=tab_mode, tab_mode=tab_mode)\rtime.sleep(4)\r# ウィンドウを元に戻す\rmap.toggle_window_view()\rtime.sleep(4)\r```\r\r最後に、3 つ以上の Web シーンを表示すると仮定した表示方法をご紹介します。各マップ ID で構成したリストから、1 度だけ処理を実行し、3 つの　Web シーンを一度にすべて新しいタブに表示します。\r```python\r#このセルの内容を1度で実行する\rfrom arcgis.gis import GIS\rfrom arcgis.widgets import MapView\rgis = GIS()\rfor webscene_id in ['31874da8a16d45bfbc1273422f772270', '91b46c2b162c48dba264b2190e1dbcff', '46c47340708f446ba7f112f139e8ae5e']:\rwebscene_item = gis.content.get(webscene_id)\rmap = MapView(gis=gis, item=webscene_item, mode=\"3D\")\rmap.toggle_window_view(title=webscene_item.title, tab_mode='tab-after')\r```\r\r--\rより詳細な情報は、ガイド ページの Working with web maps and web scenes を参照してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/install-jsapi/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for JavaScript ライブラリのインストール方法を紹介します。",
	"content": "JavaScriptライブラリをインストールする前に利用規約をご覧ください。 ArcGIS Maps SDK for JavaScript へのアクセスには、CDN（Content Delivery Network）上のホスト バージョンを使用することをお勧めします。\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.33/esri/themes/light/main.css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.33/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; ただし、API のコピーを自分の Web サーバー上でローカルにホストしたい場合もあります。 詳細については、\u0026ldquo;AMD モジュールをローカルでホストできますか？\u0026rdquo; をお読みください。 FAQ トピックをご覧ください。\nライブラリーのダウンロード ライブラリとヘルプ ドキュメントは ArcGIS Maps SDK for JavaScript リファレンスの Downloads ページからダウンロードできます。ダウンロードしたいバージョンの [API] ボタンをクリックするとダウンロードが開始します。\n※ バージョンによってはインストール方法が本手順とは異なる場合があります。詳しくはダウンロード フォルダ内にあります install.html をご参照ください。\n [Documentation] ボタンをクリックすると https://developers.arcgis.com/javascript/ で公開されているヘルプ ドキュメントとサンプル一式をダウンロードできます。\n ArcGIS Maps SDK for JavaScript ライブラリーのインストール Windows オペレーティング システムに ArcGIS Maps SDK for JavaScript ライブラリーをインストールする手順と、Unix/Linux ベースのシステムに ArcGIS Maps SDK for JavaScript ライブラリをインストールする手順は、オペレーティング システムと Web サーバー インスタンスに固有の Web サーバー ソフトウェアを構成する必要があるという事実を除いて、概念的に同じです。\nApache HTTP サーバー これらの手順では、ArcGIS Maps SDK for JavaScript ライブラリーを Apache HTTP サーバー上の次の場所 https://www.example.com/javascript/api/4.33/ (/var/www/html/javascript/api/4.33) にインストールすることを前提としています。www.example.com は、Web サイトの完全修飾ドメイン名とトップ レベル ドメインの組み合わせです。\nインターネット インフォメーション サービス（IIS） この手順では、Windows® Server の インターネット インフォメーション サービス (IIS) 上の次の場所 https://www.example.com/javascript/api/4.33/ (C:\\Inetpubwwwroot\\javascript\\api\\4.33) に ArcGIS Maps SDK for JavaScript ライブラリをインストールするものとします。www.example.com は、Web サイトの完全修飾ドメイン名とトップ レベル ドメインの組み合わせです。\nArcGIS Maps SDK for JavaScript ライブラリーは、その全体を Web サーバー ディレクトリーにコピーできます。ArcGIS Maps SDK for JavaScript のダウンロードから、\\arcgis_js_v433_api\\arcgis_js_api\\javascript\\4.33\\ ディレクトリーとその中のすべてのファイルを Web サーバーにコピーします。この例では、ファイルは次の場所にコピーしています。C:\\Inetpub\\wwwroot\\javascript\\api\\4.33\\\n必要条件 ArcGIS Maps SDK for JavaScript ライブラリおよびドキュメントのデフォルトのホスティング構成は、いずれも HTTPS です。\n  HTTPS では、Web サーバーに Web サーバー証明書を使用する必要があります。\n  IIS には、以下の MIME タイプの登録が必要です。\n   拡張 MIME/type 説明     .ttf application/octet-stream True Typeフォント   .wasm application/wasm WebAssembly   .woff application/font-woff Web Open Font Format   .woff2 application/font-woff2 WOFF File Format 2.0   .wsv application/octet-stream SceneViewの星の可視化に対応      Google: HTTPSが重要な理由\n  Google: HTTPS でサイトを保護する\n  インストールのテスト 次のサンプルは、ダウンロード版の ArcGIS Maps SDK for JavaScript に含まれています。 ダウンロードした ArcGIS Maps SDK for JavaScript から /arcgis_js_v433_api/arcgis_js_api/javascript/4.33/ とそのすべてのコンテンツを Web サーバーにコピーした後、サポート対象の Web ブラウザーでアプリケーション https://www.example.com/javascript/api/4.33/index.html を開くことで API をテストできます。\n\u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1,maximum-scale=1,user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Test local installation of ArcGIS Maps SDK for JavaScript\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 93%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./esri/themes/light/main.css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;./init.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; const [Basemap, TileLayer, Map, SceneView] = await $arcgis.import([ \u0026#34;@arcgis/core/Basemap.js\u0026#34;, \u0026#34;@arcgis/core/layers/TileLayer.js\u0026#34;, \u0026#34;@arcgis/core/Map.js\u0026#34;, \u0026#34;@arcgis/core/views/SceneView.js\u0026#34;, ]); // --------------------------------------------------------------------  // If you do not have public internet access, change the layer URL to  // point to your own locally accessible cached service.  // --------------------------------------------------------------------  const layer = new TileLayer({ url: \u0026#34;https://services.arcgisonline.com/arcgis/rest/services/World_Street_Map/MapServer\u0026#34;, }); const customBasemap = new Basemap({ baseLayers: [layer], title: \u0026#34;My Basemap\u0026#34;, }); const myMap = new Map({ basemap: customBasemap, }); const view = new SceneView({ container: \u0026#34;viewDiv\u0026#34;, map: myMap, }); checkThisOne(\u0026#34;./esri/views/3d/environment/resources/stars.wsv\u0026#34;, \u0026#34;wsv mimetype\u0026#34;); checkThisOne(\u0026#34;./esri/t9n/basemaps.json\u0026#34;, \u0026#34;json mimetype\u0026#34;); checkThisOne(\u0026#34;./esri/themes/base/icons/fonts/CalciteWebCoreIcons.ttf\u0026#34;, \u0026#34;ttf mimetype\u0026#34;); checkThisOne(\u0026#34;./esri/themes/base/icons/fonts/CalciteWebCoreIcons.woff\u0026#34;, \u0026#34;woff mimetype\u0026#34;); function checkThisOne(url, desc) { fetch(url, { method: \u0026#34;HEAD\u0026#34;, }) .then(function (response) { if (response.ok) { logDiv.innerHTML += \u0026#34;* OK: \u0026#34; + desc + \u0026#34;\u0026lt;br/\u0026gt;\u0026#34;; if (response.status !== 200) { logDiv.innerHTML += \u0026#34;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;status: \u0026#34; + response.status + \u0026#34;\u0026lt;br/\u0026gt;\u0026#34;; } return response.blob(); } else { // response not ok  logDiv.innerHTML += \u0026#34;* HTTP error \u0026#34; + response.status + \u0026#39; for \u0026lt;a href=\u0026#34;\u0026#39; + url + \u0026#39;\u0026#34;\u0026gt;\u0026#39; + url + \u0026#34;\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt;\u0026#34;; alert(\u0026#34;Problem accessing \u0026#34; + desc); } }) .catch(function (error) { logDiv.innerHTML += \u0026#39;* BAD: \u0026lt;a href=\u0026#34;\u0026#39; + url + \u0026#39;\u0026#34;\u0026gt;\u0026#39; + url + \u0026#34;\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt;\u0026#34;; }); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;logDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 以下のスクリーンショットのような結果が表示されます。(X.YZの部分は4.33となります。) "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/getting-started-widget/",
	"title": "ウィジェット開発のスタート",
	"tags": [],
	"description": "ウィジェット開発に使用しているライブラリから開発に必要な概要までを紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Getting started with widget development\nArcGIS Experience Builder は、React と ArcGIS Maps SDK for JavaScript を使用して構築されています。これにより、特定のワークフローに合わせて、カスタム ウィジェットを作成することができます。独自のウィジェットを作成するには、以下の基本的な理解が必要となります。\n TypeScript は、JavaScript のスーパーセットです。TypeScript は、ウィジェットの開発に使用される言語です。 React は、ユーザーインターフェースを作成するための JavaScript ライブラリです。React は DOM を抽象化したもので、アプリケーションや UI を様々な状態で考え、それらの状態をレンダリングすることで、UI の一貫性を保つことを容易にしています。 JSX は JavaScript の拡張構文で、React を通じてウィジェットの UI のあるべき姿を記述することができます。 Jimu は、Experience Builder がウィジェットを作成する際に使用する JavaScript ライブラリです。  インストール Experience Builder は、インストール用の ZIP ファイルとして提供されています。詳細については、インストール ガイドを参照してください。\nウィジェット開発環境のセットアップ カスタム ウィジェットの開発には、使い慣れた IDE やテキスト エディタを使うことができます。Visual Studio Code は、デフォルトで TypeScript に対応しているため、良い選択肢です。\n構築したカスタム ウィジェットは ArcGIS Experience Builder の client フォルダー内のディレクトリに配置されます。Visual Studio Code で client フォルダーをプロジェクトとして開きます。\n [ファイル] メニューをクリックします。 [フォルダーを開く] をクリックします。 Experience Builder の初回起動時に展開した Experience Builder フォルダー内の client フォルダーを参照します。  これにより、client フォルダー内のすべてのファイル（カスタム ウィジェットのファイルを含む）が左側のエクスプローラー タブで利用できるようになります。また Visual Studio Code は Experience Builder ライブラリの TypeScript 定義について client フォルダーのコンテンツ全体をスキャンし、カスタム ウィジェットの作成中に TypeScript の検証とオート コンプリートが有効になります。\nVisual Studio Code Visual Studio Code をテキスト エディタとして使用している場合、テキスト エディタに機能を追加するために使用できる、拡張機能のマーケット プレイスが用意されています。ArcGIS Experience Builder のカスタム ウィジェットの開発では、インストールする React 拡張機能に加えて、これらの拡張機能が推奨されます (必須ではありません)。\n IntelliSense for CSS class names in HTML：ワークスペースにある定義に基づいて、HTML の class 属性の CSS クラス名を補完します。 vscode-styled-components：スタイル付きコンポーネントの強調表示します。 ESLint：ESLint を Visual Studio Code に統合します。  ウィジェット ウィジェットは、Experience Builder で設定可能で共有可能な機能群です。基本的に、ウィジェットは jimu フレームワークによってこれらの共通のプロパティが設定された React コンポーネントです。\n ウィジェットの設定 (id、label、configなど) state や isClassLoaded などを含むウィジェットのランタイム情報 ローカル言語の文字列 データソースのインスタンスとステータス情報 URL パラメータ情報  ウィジェットの配置場所 カスタム ウィジェットは Experience Builder の Web 拡張機能リポジトリに配置されます。Web 拡張機能リポジトリは、client フォルダー内のフォルダーで下のコンテンツを含む manifest.json ファイルが格納されています。\n{ \u0026#34;name\u0026#34;: \u0026#34;my-web-extension-repo\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;exb-web-extension-repo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is a sample extension repository.\u0026#34;, \u0026#34;copyright\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;\u0026#34; } Experience Builder (Developer Edition) には、client/your-extensions にサンプルの Web 拡張機能リポジトリが付属しています。このリポジトリを使用することも、独自のリポジトリを作成することもできます。Git のようなソース コード リポジトリ システムを使用する場合は、独自のものを使用した方がうまくいく場合があります。独自に作成する場合、Jimu モジュールの型宣言がないなど、コード エディター上でエラーが表示されることがあります。これを修正するには、tsconfig.json ファイル内の include 配列に、Web 拡張機能リポジトリのフォルダーを次のように追加します。\n{ \u0026#34;include\u0026#34;: [ \u0026#34;dist/widgets\u0026#34;, \u0026#34;your-extensions\u0026#34;, \u0026#34;types\u0026#34;, \u0026#34;jimu-core/lib/types\u0026#34;, /** Web 拡張機能リポジトリのフォルダー名を追加します **/ \u0026#34;my-web-extension-repo\u0026#34; ], } ウィジェット ファイル Web 拡張機能リポジトリのルート フォルダーには、widgets と themes の 2 つのフォルダーがあります。カスタム ウィジェットを作成するには、widgets フォルダー内にカスタム ウィジェットの名前で新しいフォルダーを作成してください。カスタム ウィジェットのすべてのファイルは、この新しいフォルダーに配置されます。\n- my-web-extension-repo/ - manifest.json - themes/ - widgets/ - my-custom-widget/ ウィジェット フォルダー内には、有効なウィジェットとして、manifest.json とその他の必要なファイルが含まれている必要があります。\n manifest.json ファイルの詳細については、ウィジェット manifest を参照してください。 その他の必要なファイルや一般的なウィジェット開発の詳細については、ウィジェットの実装 を参照してください。 必要最小限のファイルですぐに始めるには、your-extensions/widgets フォルダーにある、simple ウィジェットを参照してください。  基本的な考え方 Experience Builder 開発が初めての方で、基本的な考え方を理解したい方は、以下をチェックしてください。\n コア コンセプト コードを見て学ぶのが一番良い場合は、リポジトリからクローンして、サンプルを参照してください。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/screen/",
	"title": "スクリーン グループ（Screen groups）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Screen groups\nスクリーン グループとは ArcGIS Experience Builder のスクリーン グループは、複数のスクリーンを含むことができるレイアウト コンテナーです。スクロール ページのコンテンツやウィジェットを整理するために使用されます。スクリーン グループ内の各スクリーンにはメイン ステージがあり、スクリーン グループによってはスクロール パネルもあります。\nユーザーがスクリーン グループにスクロールすると、スクリーンの高さ全体を占めます。スクリーン グループにスクロール パネルがある場合、ユーザーがパネル内のコンテンツをスクロールする間、メイン ステージはその場に留まります。メイン ステージが変わるのは、最後のパネルがスクロールするときだけです。 パネルがない場合、メイン ステージはスクリーン一杯の高さまでスクロールするまでその場に留まります。\nスクリーン グループでの操作方法 アプリケーションにスクリーン グループを追加して構成するには、以下の手順に従います。\n スクリーン グループを追加したいキャンバスに移動します。 キャンバス上のスクリーン グループの挿入ボタンをクリックします。 ギャラリーからスクリーン グループ テンプレートを選択します。 スクリーン数やレイアウト オプションなどのプロパティを設定します。 スクリーン グループ内のスクリーンの追加ボタンをクリックして、必要に応じて新しいスクリーンを追加します。  スクリーン グループの詳細については、add screen groupsを参照してください。\n\rスクリーン グループ テンプレート スクリーン グループで利用可能なテンプレートをいくつか紹介します。\n   テンプレート 説明     カスケード マルチスクリーン、フローティング パネル、メインステージのフェード、パネルのプッシュ スルー   インデックス ドッキングされたパネル、カスケードと同様のトランジション   フライヤー ブックマーク付きの地図用にデザインされたシングルスクリーンで、パネルのスクロールに合わせて地図が移動   ストリーム マルチスクリーン、フローティング パネル、パララックス効果、次の画面へのフェード    スクリーン グループ テンプレートの詳細については、Add Screen groups \u0026gt; templates を参照してください。\n\rスクリーン グループの AppConfig appConfig オブジェクトでは、一意の screenGroupId を持つオブジェクトを表す screenGroups プロパティの下にスクリーン グループが定義されます。screenGroups プロパティにはスクリーン グループ オブジェクトの配列が含まれ、各オブジェクトはアプリケーションに追加されたスクリーン グループを表します。各スクリーン グループ オブジェクトには、screenId、name、layout など、スクリーンの構成詳細が含まれます。\nappConfig でスクリーン グループを定義する例を以下に示します。\n{ \u0026#34;screenGroups\u0026#34;: { \u0026#34;screenGroup1\u0026#34;: { \u0026#34;screenGroupId\u0026#34;: \u0026#34;screenGroup1\u0026#34;, \u0026#34;screens\u0026#34;: [ { \u0026#34;screenId\u0026#34;: \u0026#34;screen1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Screen 1\u0026#34;, \u0026#34;layout\u0026#34;: { \u0026#34;mainStage\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;mainStage\u0026#34;, \u0026#34;height\u0026#34;: 600 }, \u0026#34;panels\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;scrollingPanel\u0026#34;, \u0026#34;height\u0026#34;: 300 } ] } }, { \u0026#34;screenId\u0026#34;: \u0026#34;screen2\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Screen 2\u0026#34;, \u0026#34;layout\u0026#34;: { \u0026#34;mainStage\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;mainStage\u0026#34;, \u0026#34;height\u0026#34;: 600 } } } ] } } } "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/security/",
	"title": "セキュリティと認証の紹介",
	"tags": [],
	"description": "API キー、ユーザー認証、アプリ認証を使用して、サービスやセキュアなリソースに認証済みのリクエストを行う方法について説明します。",
	"content": "出典：Security and authentication guide - Security and authentication\nArcGIS は、許可されたユーザーとアプリケーションのみがセキュリティで保護されたリソースにアクセスできる安全なシステムです。開発者は、認証を使用してポータル、データ サービス、ロケーション サービスなどのセキュリティで保護されたリソースにアクセスするアプリケーションを構築できます。ArcGIS は 3 種類の認証をサポートしています。ロケーション サービスを利用した公開アプリを構築するための API キー認証、組織用のプライベートなアプリを構築するためのユーザー認証、ArcGIS Enterprise リソースで動作するサーバー対応のアプリケーションを構築するためのアプリ認証です。実装する認証の種類は、アプリケーションの要件と、ユーザーに ArcGIS アカウントを使用してサイン インさせるかどうかによって異なります。\nガイドの内容 \r\r以下のガイドでは、次の種類の認証を使用して安全なリソースにアクセスする方法を説明します (英語)。\r API キー認証 ユーザー認証 アプリ認証  認証の開始\n\r\r\rOAuth 2.0 を使用して ArcGIS にサイン イン\n\r\rポータルで開発者認証情報を作成\n\r\r開発者認証情報の権限を選択\n\r\rポータルで API キーの認証情報を管理\n\r\rポータルで OAuth 認証情報を管理\n\r\r\r\rAPI キーの認証ワークフロー\n\r\rユーザー認証 OAuth 2.0 のフロー\n\r\rアプリ認証 OAuth 2.0 のフロー\n\r\r認証を使用するアプリの構築\n\r\r\r\r\r認証について学ぶ \r\r\r認証の概要\nArcGIS が認証を使用して安全なリソースを保護する方法について学習します。\n\r\r認証の種類\nさまざまな認証の種類とその課金方法について学習します。\n\r\r認証の使用方法\n認証を使用してアクセス トークンを取得する方法を学習します。\n\r\r\r\r\rAPI キー認証\n認証を迅速に実装するために、長期間有効なアクセス トークンを作成します。\n\r\r\nユーザー認証\nユーザーに代わってリソースにアクセスするには、ユーザーに ArcGIS でサインインするよう要求します。\n\r\r\rアプリ認証\nOAuth 資格情報のセットを使用して、アプリケーションのアクセス トークンを要求します。\n\r\r\r\r\rベストプラクティス\nカスタム アプリでの認証に推奨されるセキュリティのベスト プラクティスについて説明します。\n\r\r\rチュートリアルへ進む\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/visualization/data-visualization-procedure-3d/",
	"title": "データ可視化の手順（3D）",
	"tags": [],
	"description": "",
	"content": "ArcGIS Online が提供するシーン ビューアーを使用して、3D マップにデータを可視化する方法を紹介します。\n [3D マップを作成したい](#3D マップを作成したい) シンボルを変更したい 高さを表現したい  3D マップを作成したい シーン ビューアー → [新しいシーン] → [レイヤーの追加] → [シーンの保存]\nArcGIS Online などに公開されている Web サービスを、レイヤーとしてマップに追加し、様々なレイヤーを組み合わせて 3D マップを作成することができます。3D マップの保存には、コンテンツを作成する権限が必要です（権限を持っていない場合でも 3D マップは作成できますが、保存することはできません）。\n  シーン ビューアーを開きます。シーン ビューアーを開いた時点でベースとなる背景地図(ベースマップ)は自動的に表示されます。\n  [レイヤーの追加] をクリックします。\n  [レイヤーの検索]、[レイヤー URL の入力] いずれかのレイヤーの追加方法を選択します。\n  それぞれのレイヤー追加方法は、以下の通りです。\nレイヤーの検索   [レイヤーの検索] ボックスにキーワードを入力し、[検索] をクリックします。\n  検索結果は下部のボックス内に表示され、[追加] をクリックします。\n  [完了] をクリックし、レイヤーの追加を終了します。\n  レイヤー URL の入力 URL を指定して、ArcGIS Server Web サービスのレイヤーを追加することができます。\nシンボルを変更したい シーン ビューアー → [レイヤー] → [レイヤーの構成] → [スタイル]\nシンボルの色や形を変更します。コンテンツを作成する権限を持っている場合に可能です。\nシンボルを変更できるのは、フィーチャ レイヤーまたはシーン レイヤーです。\n  シーン ビューアーの [レイヤー] が表示されていることを確認し、シンボルを変更したいレイヤーをクリックします。\n  [レイヤーの構成] が表示されます。レイヤーの種類により、設定できるシンボルが異なります。\n  フィーチャ レイヤー（ポイント）のシンボル設定  [①表示するメイン属性を選択] ドロップダウン リストから、シンボルの設定を行う属性フィールドを選択します。\n属性値でシンボル設定をしない場合は、[\u0026lt;なし\u0026gt;] を選択します。\n  [②描画スタイルを選択] で、変更したい描画方法の [選択] をクリックします。既に選択されている描画スタイルは [オプション] と表示されます。\n  2D マーカー / 3D オブジェクト すべてのフィーチャを同じシンボルで表現します。\n2D タイプ / 3D タイプ 樹木の種類、道路クラス、都道府県名など、属性のカテゴリごとにシンボルを割り当てて描画します。\n2D 数と量/ 3D 数と量 数値データをシンボルの色や大きさ、高さで表現します。データの数値が大きいほど、シンボルは大きく、高く表示されます。 ※レイヤーが持つ属性フィールドのタイプに応じて選択できる種類が異なります。例えば、文字列型のフィールドのみで構成されるレイヤーでは、[種類] ドロップダウン リストでサイズや色の指定はできません。\nフィーチャ レイヤー（ライン/ポリゴン）のシンボル設定  [シンボル] ドロップダウン リストから [シンボルの変更] を選択します。\n  シンボルのタイプ（2D または 3D）、大きさ/高さ、色を設定します。\n  シーン レイヤーのシンボル設定  [①表示するメイン属性を選択] ドロップダウン リストから、シンボルの設定を行う属性フィールドを選択します。\n属性値でシンボル設定をしない場合は、[\u0026lt;なし\u0026gt;] を選択します。\n  [②描画スタイルを選択] で、変更したい描画方法の [選択] をクリックします。既に選択されている描画スタイルは [オプション] と表示されます。\n  色 すべてのフィーチャを同じシンボルで表現します。\nタイプ 樹木の種類、道路クラス、都道府県名など、属性のカテゴリごとにシンボルを割り当てて描画します。\n数と量 数値データをシンボルの色で表現します。 ※レイヤーが持つ属性フィールドのタイプに応じて選択できる種類が異なります。例えば、文字列型のフィールドのみで構成されるレイヤーでは、[種類] ドロップダウン リストでサイズや色の指定はできません。\n[オプション] をクリックすると、シンボルの詳細な設定をすることができます。  2D マーカー / 3D オブジェクトの場合 [シンボル] - あらかじめ用意されているシンボルから形状を選択します。\n[色] - シンボルの色を選択します。\n[サイズ] - 大きさを設定します。固定値のほかに属性値をもとに大きさを指定することもできます。\n[回転] - 属性値をもとに回転の角度を設定します。\n2D タイプ / 3D タイプの場合 表からスタイルを変更したい値を選択し、[シンボル]、[色]、[サイズ] を設定します。\n属性値をもとに、すべてのシンボルのサイズと回転を指定することも可能です。\n2D 数と量/ 3D 数と量 [スライダー] - スライダーの上部、下部のバーを動かして、最大 / 最小クラスの閾値を変更できます。また、数値をクリックして、直接入力することもできます。\n[シンボル] - あらかじめ用意されているシンボルから形状を選択します。\n[色] - 色のパターンなどを変更します。\n[サイズ] - 最大 / 最小クラスに設定した値の大きさを設定します。\n[回転] - 属性値をもとに回転の角度を設定します。\n色の場合 [テクスチャ] - テクスチャのタイプを選択します。\n[色] - シンボルの色を選択します。\nタイプの場合 表からスタイルを変更したい値を選択し、[テクスチャ]、[色] を設定します。\n数と量の場合 [スライダー] - スライダーの上部、下部のバーを動かして、最大 / 最小クラスの閾値を変更できます。また、数値をクリックして、直接入力することもできます。\n[色] - 色のパターンなどを変更します。 6. 設定後、各パネルにおいて [完了] をクリックします。\n高さを表現したい シーン ビューアー → [レイヤー] → [レイヤーの構成] → [標高モード] レイヤーに含まれる Z 値や、オフセットを定義して、グラフィックの高さを表現することができます。\n  シーン ビューアーの [レイヤー] が表示されていることを確認し、高さを表現したいレイヤーをクリックします。\n  [レイヤーの構成] が表示されます。\n  [標高モード] でモードを選択し、必要に応じてオフセットを設定します。\n  標高モード 地表 グラフィックは、地表を覆うように配置されます。\nグラフィックに含まれる Z 値は無視されます。また、オフセットを設定することはできません。\n地面を基準 グラフィックは、地面を基準にした高さに配置されます。\nグラフィックに Z 値が含まれる場合、Z 値を使用して高さは表現されます。\nシーンを基準 グラフィックは、シーンを基準にした高さに配置されます。\nグラフィックに含まれる Z 値は無視されます。\n絶対高度 グラフィックは、測地系を基準にした高さに配置されます。\n絶対高度は、各グラフィックの Z 値により決まります。[地面を基準] と似ていますが、[絶対高度] は地表の高さを無視します。\n※レイヤーの種類により、選択できるモードが異なります。例えば、シーン レイヤーでは、[絶対高度] 以外のモードは指定はできません。\nオフセット オフセットは、すべてのグラフィックに高さを加えます。例えば、オフセットに 100 メートルを設定した場合、グラフィックは現在の高さから 100 メートル上に表示されます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/calcite-design-system/tutorials/build-a-dark-mode-switch/",
	"title": "暗色 (dark) モード スイッチの構築",
	"tags": [],
	"description": "Calcite コンポーネントと ArcGIS Maps SDK for JavaScript の明色 (light) モードと暗色 (dark) モードを切り替えるコンポーネントの作成方法について学びます。",
	"content": "出典：Calcite Design System - Build a dark mode switch\nCalcite コンポーネントと ArcGIS Maps SDK for JavaScript の明色 (light) モードと暗色 (dark) モードを切り替えるコンポーネントの作成方法について学びます。\nCalcite コンポーネントを使用して、Calcite コンポーネント、ArcGIS Maps SDK for JavaScript のコンポーネントおよびベースマップに対して暗色 (dark) モードを有効にするスイッチを設計します。このアプリケーションはマッピング アプリの作成チュートリアルで作成したアプリケーションを基にしています。\nCalcite では CSS クラスを使用して明色 (light) モードと暗色 (dark) モードを切り替えることができます (calcite-mode-light (デフォルト) と calcite-mode-dark)。また、calcite-mode-auto クラスも用意されており、これはブラウザーの CSS の prefers-color-scheme メディア クエリーに従います。モード クラスを要素に設定すると、そのすべての子ノードにも適用されます。\nモードやスタイリングに関する詳細は、Calcite Design System の colors and modes および ArcGIS Maps SDK for JavaScript の Styling ドキュメントを参照してください。\nArcGIS 開発者アカウント このチュートリアルで使用するサービスにアクセスするには、無料の ArcGIS Location Platform アカウントまたは ArcGIS Online 組織のアカウントが必要です。\n\rステップ 新しいペンの作成  まずはマッピング アプリの作成チュートリアルを完了するか、コード例のペンを使用してください。  API キーの設定   このチュートリアルで使用されるロケーション サービスにアクセスするには、適切な権限を持つ API キーが必要です。\n1.1. API キーの取得の手順に従って、以下の権限を持つ API キーを作成します。\n 権限：ロケーション サービス \u0026gt; ベースマップ  1.2. CodePen で、esriConfig.apiKey に作成した API キーを設定してください。\n  \u0026lt;!-- esriConfig 変数は、他の Esri ライブラリーを追加する前に定義する必要があります --\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; var esriConfig = { apiKey: \u0026#34;API キー\u0026#34; }; \u0026lt;/script\u0026gt; アクセス トークンを取得するほかの方法については、Types of authentication 参照してください。\nテーマのスタイル シートを追加 ArcGIS Maps SDK for JavaScript では、テーマごとに個別のスタイル シートを使用します。JavaScript で id 属性を使って動的に切り替えるため、明色 (light) テーマと暗色 (dark) テーマの両方のスタイル シートを追加します。\n 暗色 (dark) テーマのスタイル シートを追加し、disable 属性を設定し、id を追加します。 既存の明色 (light) テーマのスタイル シートに id を追加します。  \u0026lt;script src=\u0026#34;https://js.arcgis.com/calcite-components/3.2.1/calcite.esm.js\u0026#34; type=\u0026#34;module\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.33/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;https://js.arcgis.com/4.33/map-components\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;link disabled id=\u0026#34;arcgis-maps-sdk-theme-dark\u0026#34; rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.33/esri/themes/dark/main.css\u0026#34; /\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;!-- 更新開始 --\u0026gt; \u0026lt;link id=\u0026#34;arcgis-maps-sdk-theme-light\u0026#34; rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.33/esri/themes/light/main.css\u0026#34; /\u0026gt; \u0026lt;!-- 更新終了 --\u0026gt; HTML の追加 暗色 (dark) モード切り替えの主要なコンポーネントは calcite-switch です。モードの切り替えには、calcite-label を使用して、暗色 (dark) モードに切り替えられた際のコンテキストを付与します。\n calcite-navigation コンポーネント内に div 要素を追加し、ナビゲーションの content-end スロットに配置します。この div には、後でスタイリングに使用する id 属性を付与します。 calcite-label コンポーネントを追加します。layout 属性を \u0026quot;inline\u0026quot; に設定し、後でスタイリングに使用する class 属性も付与します。 calcite-switch コンポーネントを追加します。  スロットの概念について詳しくはコア コンセプト内のセクションを参照してください。次のステップで CSS を追加した後、ナビゲーションの content-end スロットからコンポーネントを削除することで、暗色 (dark) モードへのスイッチをマップ上に配置できます。\n\u0026lt;body\u0026gt; \u0026lt;calcite-shell content-behind\u0026gt; \u0026lt;calcite-navigation slot=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;calcite-navigation-logo id=\u0026#34;header-title\u0026#34; heading-level=\u0026#34;1\u0026#34; slot=\u0026#34;logo\u0026#34;\u0026gt; \u0026lt;!-- 動的に入力される --\u0026gt; \u0026lt;/calcite-navigation-logo\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;div slot=\u0026#34;content-end\u0026#34;\u0026gt; \u0026lt;!-- 暗色 (dark) モード スイッチ --\u0026gt; \u0026lt;calcite-label layout=\u0026#34;inline\u0026#34; class=\u0026#34;label-wrapper\u0026#34;\u0026gt; Dark mode: Off \u0026lt;calcite-switch\u0026gt;\u0026lt;/calcite-switch\u0026gt; On \u0026lt;/calcite-label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/calcite-navigation\u0026gt; CSS の追加 この時点でアプリを実行すると、暗色 (dark) モード スイッチがナビゲーションの \u0026ldquo;content-end\u0026rdquo; スロットに配置されていることが確認できます。\n次に、Flexbox を使用してコンポーネントの位置を調整するための CSS スタイリングを追加します。\n  \u0026lt;style\u0026gt; 要素内に、暗色 (dark) モード スイッチのレイアウトを設定する CSS プロパティを設定します。margin-inline と padding の CSS プロパティを設定します。--calcite-color-border-1 CSS 変数を使用して境界線を追加します。次に、calcite-switch に margin プロパティを追加し、将来的にインターフェイスをコントロールできるようにします。\nCSS 変数の基本的な概念については、コア コンセプトの CSS 変数 セクションを参照してください。Calcite のカラー モードには明色 (light) と暗色 (dark) の値があり、モードの切り替え時に自動で変更されます。モードを切り替えるアプリケーションでは、Calcite 以外の要素にもカラー モード変数を使用してください。\n  次に、calcite-label に --calcite-label-margin-bottom CSS 変数を追加して、コンポーネントの下にスペースを設定します。また、calcite-switch の cursor プロパティを \u0026quot;pointer\u0026quot; に設定し、スイッチのコンテナーがクリック可能であることを示します。\n  .label-wrapper { --calcite-label-margin-bottom: 0px; display: flex; margin-inline: 1rem; padding: 0.5rem; border: 1px solid var(--calcite-color-border-1); cursor: pointer; } JavaScript の追加 ここまでの手順で見栄えの良いコンポーネントが完成しましたが、まだ暗色 (dark) モードは有効になっていません。次に、JavaScript を使って暗色 (dark) モード スイッチを実装します。\n \u0026lt;script\u0026gt; 要素内の既存の JavaScript コードの下に、新しく暗色 (dark) モードを有効にする関数を作成します。 \u0026lt;body\u0026gt; 要素の calcite-mode-dark クラスを切り替えます。calcite-mode-light クラスはデフォルトのため追加する必要はありません。 上で追加した id 属性を使用して、ArcGIS Maps SDK for JavaScript の明色 (light) テーマと暗色 (dark) テーマのスタイル シートにアクセスします。 両方のスタイル シートの disabled 属性を反転させ、ブール値を切り替えます。 現在のモードに応じて、ベースマップを gray-vector と dark-gray-vector を切り替えます。 .esri-ui を使って、ArcGIS Maps SDK for JavaScript のコンポーネント全体で calcite-mode-dark クラスを切り替えます。 calcite-switch コンポーネントにイベント リスナーを追加します。calciteSwitchChange イベントを監視し、作成した関数を実行します。  Calcite では、多くのコンポーネントに対してカスタム イベントが用意されています。これらのカスタム イベントはすべて接頭辞として calcite が付けられ、次にコンポーネント名、最後にイベントの種類が付けられます。各コンポーネントがイベントを持っているかどうか、およびその詳細を確認するにはコンポーネントの API リファレンスを参照してください。\ndocument.querySelector(\u0026#34;calcite-shell\u0026#34;).hidden = false; document.querySelector(\u0026#34;calcite-loader\u0026#34;).hidden = true; }); // 追加開始  const updateDarkMode = () =\u0026gt; { document.querySelector(\u0026#34;calcite-loader\u0026#34;).hidden = false; // Calcite モード  document.body.classList.toggle(\u0026#34;calcite-mode-dark\u0026#34;); // ArcGIS Maps SDK テーマ  const dark = document.querySelector(\u0026#34;#arcgis-maps-sdk-theme-dark\u0026#34;); const light = document.querySelector(\u0026#34;#arcgis-maps-sdk-theme-light\u0026#34;); dark.disabled = !dark.disabled; light.disabled = !light.disabled; // ArcGIS Maps SDK ベースマップ  mapEl.basemap = dark.disabled ? \u0026#34;gray-vector\u0026#34; : \u0026#34;dark-gray-vector\u0026#34;; // Toggle ArcGIS Maps SDK ウィジェット モード  const widgets = document.getElementsByClassName(\u0026#34;esri-ui\u0026#34;); for (let i = 0; i \u0026lt; widgets.length; i++) { widgets.item(i).classList.toggle(\u0026#34;calcite-mode-dark\u0026#34;); } document.querySelector(\u0026#34;calcite-loader\u0026#34;).hidden = true; }; document.querySelector(\u0026#34;calcite-switch\u0026#34;).addEventListener(\u0026#34;calciteSwitchChange\u0026#34;, updateDarkMode); // 追加終了  \u0026lt;/script\u0026gt; アプリの実行 CodePen でコードを実行すると、アプリケーションが表示されます。\n画面右上には、新しく暗色 (dark) モード スイッチ コンポーネントが表示されます。コンポーネントの任意の場所をクリックすると、calcite-switch が切り替わります。イベント リスナーに設定した関数が実行され、Calcite コンポーネントを暗色 (dark) モードに切り替えると同時に、ArcGIS Maps SDK for JavaScript のベースマップやコンポーネントも暗色に切り替わります。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-dotnet/",
	"title": ".NET",
	"tags": [],
	"description": "ArcGIS Maps SDK for .NET を用いたネイティブ地図アプリの作成方法を紹介します。",
	"content": "出典：ArcGIS Maps SDK for .NET - Tutorials - Display a map\nマップを表示する このチュートリアルでは ArcGIS Maps SDK for .NET を使用して、マップとベースマップ レイヤーを表示する方法を紹介します。\nマップには、地理データのレイヤーが含まれています。マップには、ベースマップ レイヤーと、オプションで 1 つ以上のデータ レイヤーを追加できます。マップ ビューを使用し、場所とズーム レベルを設定することで、マップの特定の領域を表示できます。\nこのチュートリアルでは、地形図ベクター タイル ベースマップ レイヤーを使用して、富士山付近を表示する地図を作成します。\nこのチュートリアルのトピックの背景情報については、Mapping API and location services guide の Maps (2D) と ベースマップ を参照してください。\n\r前提条件 このチュートリアルを実施するには、以下が必要です。\n API キーにアクセスするための開発者アカウントもしくは ArcGIS Online アカウントが必要です。アカウントをお持ちでない場合は、サインアップ (無料)してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。 開発環境がシステム要件を満たしていることを確認します。  必要に応じて、ArcGIS Maps SDK for .NET をインストールして、Visual Studio プロジェクト テンプレート (Windows のみ) とオフラインにコピーされた NuGet パッケージを利用することもできます。\n認証の設定 このチュートリアルで使用するセキュアな ArcGIS ロケーション サービスにアクセスするには、ArcGIS Location Platform または ArcGIS Online アカウントを使用して、API キー認証またはユーザー認証を実装する必要があります。\nこのチュートリアルでは、API キー認証またはユーザー認証を実装することができます。以下の違いを比較してください。\nAPI キー認証  ユーザーはサインインする必要がありません。 適切な権限を持つ API キーの認証情報を作成する必要があります。 API キーは長期間のアクセス トークンです。 サービス使用料は、API キーの所有者/開発者に請求されます。 実装が最も簡単な認証方法です。 新規の ArcGIS 開発者に推奨される方法です。  詳しくは API キー認証をご覧ください。\nこのチュートリアルで使用するセキュアなリソースにアクセスする権限を持つ、新しい API キーのアクセス トークンを作成します。\n API キーの作成のチュートリアルを完了し、以下の権限を持つ API キーを作成します。  Privileges  Location services \u0026gt; Basemaps     API キーのアクセス トークン をコピーし、安全な場所に貼り付けます。これは後のステップで使用します。  ユーザー認証  ユーザーは、ArcGIS アカウントでサインインする必要があります。 ユーザー アカウントには、アプリケーションで使用する ArcGIS サービスにアクセスする権限が必要です。 OAuth 認証情報の作成が必要です。 アプリケーションには、リダイレクト URL とクライアント ID を使用します。 サービスの使用料は、アプリケーションにサインインしたユーザーの組織に請求されます。  詳しくは、ユーザー認証をご覧ください。\nこのチュートリアルで使用するセキュアなリソースにアクセスするための新しい OAuth 認証情報を作成します。\nチュートリアルの後の設定ステップでは、リダイレクト URL が my-app://auth であると仮定します。別の URL を使用する場合は、それに応じてアプリの設定を行ってください。\n\r  ユーザー認証用の OAuth 認証情報を作成するチュートリアルを完了します。\n  ClientID と RedirectURL をコピーして安全な場所に貼り付けます。これらは後のステップで使用します。\n  このアプリケーションにアクセスするすべてのユーザーには、ベースマップ スタイル サービスにアクセスするためのアカウント権限が必要です。\nセキュリティと認証ガイド : 認証の種類について詳しくは、認証の種類をご覧ください。\n\r開発またはダウンロード このチュートリアルを完了するには、2 つの選択肢があります。\n オプション 1: コードを開発する オプション 2: 完成したソリューションをダウンロードする  オプション 1: コードを開発する 新しい Visual Studio プロジェクトを作成する ArcGIS Maps SDK for .NET は、Windows Presentation Framework (WPF)、Universal Windows Platform (UWP)、Windows UI Library (WinUI)、.NET MAUI 向けのアプリをサポートしています。 このチュートリアルの説明は、Visual Studio for Windows を使用して WPF .NET プロジェクトを作成する手順を説明します。\n.NET API アプリを開発できるプラットフォームは、開発環境に応じて異なります。例えば、Visual Studio for Mac を使用する場合、WPFと UWP のプロジェクトは利用できません。詳しくは、システム要件をご覧ください。\n\r Visual Studio を起動し、新しいプロジェクトを作成します。  Visual Studio の開始画面で、[新しいプロジェクトの作成] をクリックします。 C# 用の [WPF アプリケーション]テンプレートを選択します。テンプレートが表示されていない場合は、テンプレートの検索テキストボックスに WPF アプリケーション と入力すると、テンプレートを見つけることができます。 [次へ] をクリックします。 [新しいプロジェクトを構成します] 画面で必要な値を入力します。  プロジェクト名: DisplayAMap 場所: 任意のフォルダーを選択   [次へ] をクリックします。  フレームワークで .NET 8.0 (長期的なサポート) を選択します。   [作成] をクリックしてプロジェクトを作成します。    Visual Studio for Windows で開発する場合、ArcGIS Maps SDK for .NET には、サポートされる .NET プラットフォームごとにプロジェクト テンプレート セットが用意されています。これらのテンプレートは、Model-View-ViewModel（MVVM）デザイン パターンに従っています。ArcGIS Maps SDK for .NET Visual Studio Extension をインストールして、テンプレートを Visual Studio に追加します（Windows のみ）。詳細については、インストールとセットアップを参照してください。\nこのチュートリアルの手順は、WPF for .NET（Visual Studio 2022 以降が必要）を使用してアプリケーションを作成することに特化しています。サポートされている他の .NET プラットフォームでアプリを完成させるには、ArcGIS Maps SDK for .NET プロジェクト テンプレートの 1 つからプロジェクトを作成できます。Visual Studio テンプレートの 1 つから開始する場合、ガイドに記載されているコードとプロジェクトに含まれるコードにいくつかの違いがあることがあります。\n\rAPI の参照を追加する ArcGIS Maps SDK for .NET プロジェクト テンプレートの 1 つからプロジェクトを作成した場合、必要な NuGet パッケージが既にプロジェクトに追加されています。\n\r  NuGet パッケージをインストールして、API への参照を追加します。\n ソリューション エクスプローラーで、[参照] を右クリックし、[NuGet パッケージの管理] を選択します。 [NuGet パッケージ マネージャー] ウィンドウで、[パッケージ ソース] に nuget.org (右上)が選択されていることを確認します。 [参照] タブを選択して、ArcGIS Maps SDK を検索します。 検索結果から、プラットフォームに適したパッケージを選択します。このチュートリアルではEsri.ArcGISRuntime.WPF NuGet パッケージを選択します。 [バージョン] にパッケージの「最新の安定版\u0026hellip;」が選択されていることを確認します。 [インストール] をクリックします。 NuGet は、パッケージの依存関係または競合を自動的に解決します。デフォルトでは、[変更のプレビュー] ダイアログが表示されます。 変更を確認し [OK] をクリックしてパッケージのインストールを続行します。 [ライセンスへの同意] ダイアログでライセンス条項を確認し、[同意する] をクリックしてパッケージをプロジェクトに追加します。 Visual Studio の [出力] ウィンドウで、パッケージが正常にインストールされたことを確認します。ターゲットの Windows バージョンに関するエラーが表示された場合は、次の手順で修正します。 [NuGet パッケージ マネージャー] ウィンドウを閉じます。    Visual Studio エラー リストに The 'Esri.ArcGISRuntime.WPF' nuget package cannot be used to target 'net8.0-windows'. Target 'net8.0-windows10.0.19041.0' or later instead. のようなエラーが表示される場合があります。その場合は、次の手順に従って対処してください。\n  ソリューション エクスプローラーで、ツリー ビューの DisplayAMap プロジェクト エントリーを右クリックし、[プロジェクト ファイルの編集] を選択します。\n  \u0026lt;TargetFramework\u0026gt; 要素を net8.0-windows10.0.19041.0（またはそれ以上）で更新します。\n\u0026lt;PropertyGroup\u0026gt; \u0026lt;OutputType\u0026gt;WinExe\u0026lt;/OutputType\u0026gt; \u0026lt;TargetFramework\u0026gt;net8.0-windows10.0.19041.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;UseWPF\u0026gt;true\u0026lt;/UseWPF\u0026gt; \u0026lt;/PropertyGroup\u0026gt;   プロジェクト ファイル (DisplayAMap) を保存して閉じます。\n    アプリ ロジックを保存するビュー モデルを作成する このアプリは、以降のすべてのチュートリアルで使用する基盤を構築するためのものです。堅固な設計で構築することをお勧めします。\nModel-View-ViewModel (MVVM) デザイン パターンは、ユーザー インターフェイス要素 (および関連するコード) をアプリの基礎となるロジックから分離するアーキテクチャを提供します。このパターンでは、モデルはアプリで消費されるデータを表し、ビュー はユーザー インターフェイスであり、ビュー モデル にはモデルとビューをバインド (結合) するロジックが含まれます。このようなパターンに必要な追加のフレームワークは、小規模なプロジェクトでは大変な作業に思えるかもしれませんが、プロジェクトの複雑さが増すにつれて、堅固な設計を行うことでコードの保守性と柔軟性が大幅に向上します。\nMVVM で設計された ArcGIS アプリでは、通常、マップ ビューがメインのビュー コンポーネントになります。クラスの多くは、モデルの役割を果たします (データをマップ、レイヤー、グラフィックス、フィーチャなどとして表します)。 ビュー モデル コンポーネントには、ArcGIS オブジェクトを操作するためのロジックを追加したり、ビューに表示するためのデータを提供したりするため、記述するコードの多くはここになります。\nすべての ArcGIS Maps SDK for .NET プロジェクト テンプレートは、MVVM デザイン パターンを使用しています。\n\r  プロジェクトのビュー モデルを定義する新しいクラスを追加します。\n [プロジェクト] メニュー \u0026gt; [クラスの追加\u0026hellip;] をクリックします。 新しいクラスに MapViewModel.cs と名前を付けます。 [追加] をクリックして新しいクラスを作成し、プロジェクトに追加します。 新しいクラスが VisualStudio で開きます。    必要な using ステートメントをビュー モデルに追加します。\nMapViewModel.cs\nusing System; using System.Collections.Generic; using System.Text; // 追加開始 using Esri.ArcGISRuntime.Mapping; using System.ComponentModel; using System.Runtime.CompilerServices; using Esri.ArcGISRuntime.Geometry; // 追加終了   MapViewModel クラスに INotifyPropertyChanged インターフェイスを実装します。\nこのインターフェイスは、ビュー モデルのプロパティが変更されたことをクライアント (ビュー) に通知するために使用される PropertyChanged イベントを定義します。\nMapViewModel.cs\nnamespace DisplayAMap { // 変更前  // internal class MapViewModel  // 変更後  internal class MapViewModel : INotifyPropertyChanged { } }   MapViewModel クラス内に、PropertyChanged イベントを実装するコードを追加します。\nビュー モデルのプロパティが変更されると、OnPropertyChanged の呼び出しにより、このイベントが発生します。\nMapViewModel.cs\nclass MapViewModel : INotifyPropertyChanged { // 追加開始  public event PropertyChangedEventHandler? PropertyChanged; protected void OnPropertyChanged([CallerMemberName] string propertyName = \u0026#34;\u0026#34;) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } // 追加終了 }   ビュー モデルに Map オブジェクトを公開する Map という新しいプロパティを定義します。 プロパティが設定されると、OnPropertyChanged を呼び出します。\nMapViewModel.cs\npublic event PropertyChangedEventHandler? PropertyChanged; protected void OnPropertyChanged([CallerMemberName] string propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } // 追加開始  private Map? _map; public Map? Map { get { return _map; } set { _map = value; OnPropertyChanged(); } } // 追加終了 }   MapViewModel クラスに SetupMap という関数を追加します。この関数は、新しいマップを作成して Map プロパティを設定します。\n地図は、セキュアな ArcGIS ベースマップ スタイルの1つを使用し、富士山を中心に表示されます。\nマップは、地形図ベクター タイル ベースマップを使用します。ベースマップのデフォルトのラベル表示は英語のため、日本語に変更します。\nMapViewModel.cs\nprivate Map _map; public Map Map { get { return _map; } set { _map = value; OnPropertyChanged(); } } // 追加開始  private void SetupMap() { //ベースマップのラベルを日本語で表示します。  BasemapStyleParameters bsp = new BasemapStyleParameters(); bsp.SpecificLanguage = System.Globalization.CultureInfo.CreateSpecificCulture(\u0026#34;ja\u0026#34;); Basemap basemap = new Basemap(BasemapStyle.ArcGISTopographic, bsp); //地形図ベクター タイル ベースマップを使用して新しいマップを作成します。  Map = new Map(basemap); } // 追加終了 }   MapViewModel が新規にインスタンス化された際に、SetupMap 関数を呼び出すコンストラクターを追加します。\nMapViewModel newMapVM = new MapViewModel(); のようなコードを書くと、クラス コンストラクターが実行されます。これはクラスが初期化された時に実行する必要があるコードを追加するのに良い場所です。\nMapViewModel.cs\nclass MapViewModel : INotifyPropertyChanged { // 追加開始  public MapViewModel() { SetupMap(); } // 追加終了  public event PropertyChangedEventHandler? PropertyChanged; protected void OnPropertyChanged([CallerMemberName] string propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); }   これで MapViewModel が完成しました。\nMVVM デザイン パターンを使用する利点は、ビュー モデルのコードを再利用できることです。API はプラットフォーム間でほぼ標準的な API サーフェスを持っているため、１つのアプリ用に作成した ビュー モデル のコードは、通常、サポートされているすべての .NET プラットフォームで動作します。\n開発者認証情報の設定 アプリのユーザーが ArcGIS ロケーション サービスやセキュアなコンテンツにアクセスできるようにするには、認証の設定ステップで作成した開発者認証情報を使用して、リソースへのアクセスを認証します。\nAPI キー認証   ソリューション エクスプローラーで、App.xaml のノードを展開し、App.xaml.cs をダブルクリックして開きます。\n  App クラスで、OnStartup() 関数のオーバーライドを追加して、ArcGISRuntimeEnvironment で ApiKey プロパティを設定します。\nApp.xaml.cs\npublic partial class App : Application { // 追加開始  protected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); // 注: API キーをソース コードに保存することはベスト プラクティスではありません。  // API キーは、チュートリアルの便宜上、ここで参照されています。  Esri.ArcGISRuntime.ArcGISRuntimeEnvironment.ApiKey = \u0026#34;API キー\u0026#34;; } // 追加終了 }   \u0026ldquo;API キー\u0026rdquo; は先ほど作成した API キーに置き換えてください。\n  App.xaml.cs ファイルを保存して閉じます。\nAPI キーは、このチュートリアルの便宜上、コードに直接格納されていますが、ソース コードに API キーを格納することは、ベスト プラクティスではありません。\n\r  ユーザー認証  Visual Studio の [プロジェクト] メニューから [クラスの追加] を選択します。クラス名を ArcGISLoginPrompt.cs とし、[追加] をクリックします。新しいクラスがプロジェクトに追加され、Visual Studio で開きます。 新しいクラスのコードをすべて選択し、削除します。 以下のコードをすべてコピーし、プロジェクトの ArcGISLoginPrompt.cs クラスに貼り付けます。  ArcGISLoginPrompt.cs\n// Copyright 2021 Esri. // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. // You may obtain a copy of the License at: http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an // \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific // language governing permissions and limitations under the License.  using Esri.ArcGISRuntime.Security; using System; using System.Collections.Generic; using System.Threading.Tasks; using System.Windows; using System.Windows.Controls; using System.Windows.Navigation; using System.Windows.Threading; namespace UserAuth { internal static class ArcGISLoginPrompt { private const string ArcGISOnlineUrl = \u0026#34;https://www.arcgis.com/sharing/rest\u0026#34;; // Specify the Client ID and Redirect URL to use with OAuth authentication.  // See the instructions here for creating OAuth app settings:  // https://developers.arcgis.com/documentation/security-and-authentication/user-authentication/tutorials/create-oauth-credentials-user-auth/  private const string AppClientId = \u0026#34;YOUR_CLIENT_ID\u0026#34;; private const string OAuthRedirectUrl = \u0026#34;YOUR_REDIRECT_URL\u0026#34;; public static async Task\u0026lt;bool\u0026gt; EnsureAGOLCredentialAsync() { bool loggedIn = false; try { // Create a challenge request for portal credentials (OAuth credential request for arcgis.com)  CredentialRequestInfo challengeRequest = new CredentialRequestInfo { // Use the OAuth authorization code workflow.  GenerateTokenOptions = new GenerateTokenOptions { TokenAuthenticationType = TokenAuthenticationType.OAuthAuthorizationCode }, // Indicate the url (portal) to authenticate with (ArcGIS Online)  ServiceUri = new Uri(ArcGISOnlineUrl) }; // Call GetCredentialAsync on the AuthenticationManager to invoke the challenge handler  Credential? cred = await AuthenticationManager.Current.GetCredentialAsync(challengeRequest, false); loggedIn = cred != null; } catch (OperationCanceledException) { // OAuth login was canceled, no need to display error to user.  } catch (Exception ex) { // Login failure  MessageBox.Show(\u0026#34;Login failed: \u0026#34; + ex.Message); } return loggedIn; } public static void SetChallengeHandler() { var userConfig = new OAuthUserConfiguration(new Uri(ArcGISOnlineUrl), AppClientId, new Uri(OAuthRedirectUrl)); AuthenticationManager.Current.OAuthUserConfigurations.Add(userConfig); AuthenticationManager.Current.OAuthAuthorizeHandler = new OAuthAuthorize(); } #region OAuth handler  // In a desktop (WPF) app, an IOAuthAuthorizeHandler component is used to handle some of the OAuth details. Specifically, it  // implements AuthorizeAsync to show the login UI (generated by the server that hosts secure content) in a web control.  // When the user logs in successfully, cancels the login, or closes the window without continuing, the IOAuthAuthorizeHandler  // is responsible for obtaining the authorization from the server or raising an OperationCanceledException.  public class OAuthAuthorize : IOAuthAuthorizeHandler { // Window to contain the OAuth UI.  private Window? _authWindow; // Use a TaskCompletionSource to track the completion of the authorization.  private TaskCompletionSource\u0026lt;IDictionary\u0026lt;string, string\u0026gt;\u0026gt; _tcs; // URL for the authorization callback result (the redirect URI configured for your application).  private string _callbackUrl = \u0026#34;\u0026#34;; // URL that handles the OAuth request.  private string? _authorizeUrl; // Function to handle authorization requests, takes the URIs for the secured service, the authorization endpoint, and the redirect URI.  public Task\u0026lt;IDictionary\u0026lt;string, string\u0026gt;\u0026gt; AuthorizeAsync(Uri serviceUri, Uri authorizeUri, Uri callbackUri) { if (_tcs != null \u0026amp;\u0026amp; !_tcs.Task.IsCompleted) throw new Exception(\u0026#34;Task in progress\u0026#34;); _tcs = new TaskCompletionSource\u0026lt;IDictionary\u0026lt;string, string\u0026gt;\u0026gt;(); // Store the authorization and redirect URLs.  _authorizeUrl = authorizeUri.AbsoluteUri; _callbackUrl = callbackUri.AbsoluteUri; // Call a function to show the login controls, make sure it runs on the UI thread for this app.  Dispatcher dispatcher = Application.Current.Dispatcher; if (dispatcher == null || dispatcher.CheckAccess()) { AuthorizeOnUIThread(_authorizeUrl); } else { Action authorizeOnUIAction = () =\u0026gt; AuthorizeOnUIThread(_authorizeUrl); dispatcher.BeginInvoke(authorizeOnUIAction); } // Return the task associated with the TaskCompletionSource.  return _tcs.Task; } // Challenge for OAuth credentials on the UI thread.  private void AuthorizeOnUIThread(string authorizeUri) { // Create a WebBrowser control to display the authorize page.  WebBrowser webBrowser = new WebBrowser(); // Handle the navigation event for the browser to check for a response to the redirect URL.  webBrowser.Navigating += WebBrowserOnNavigating; // Display the web browser in a new window.  _authWindow = new Window { Content = webBrowser, Width = 450, Height = 450, WindowStartupLocation = WindowStartupLocation.CenterOwner }; // Set the app\u0026#39;s window as the owner of the browser window (if main window closes, so will the browser).  if (Application.Current != null \u0026amp;\u0026amp; Application.Current.MainWindow != null) { _authWindow.Owner = Application.Current.MainWindow; } // Handle the window closed event then navigate to the authorize url.  _authWindow.Closed += OnWindowClosed; webBrowser.Navigate(authorizeUri); // Display the window.  _authWindow.ShowDialog(); } // Handle the browser window closing.  private void OnWindowClosed(object? sender, EventArgs e) { // If the browser window closes, return the focus to the main window.  if (_authWindow != null \u0026amp;\u0026amp; _authWindow.Owner != null) { _authWindow.Owner.Focus(); } // If the task wasn\u0026#39;t completed, the user must have closed the window without logging in.  if (!_tcs.Task.IsCompleted) { // Set the task completion source exception to indicate a canceled operation.  _tcs.SetCanceled(); } _authWindow = null; } // Handle browser navigation (content changing).  private void WebBrowserOnNavigating(object sender, NavigatingCancelEventArgs e) { // Check for a response to the callback url.  const string portalApprovalMarker = \u0026#34;/oauth2/approval\u0026#34;; WebBrowser? webBrowser = sender as WebBrowser; Uri uri = e.Uri; // If no browser, uri, or an empty url, return.  if (webBrowser == null || uri == null || string.IsNullOrEmpty(uri.AbsoluteUri)) return; // Check for redirect.  bool isRedirected = uri.AbsoluteUri.StartsWith(_callbackUrl) || _callbackUrl.Contains(portalApprovalMarker) \u0026amp;\u0026amp; uri.AbsoluteUri.Contains(portalApprovalMarker); // Check if browser was redirected to the callback URL. (This indicates succesful authentication.)  if (isRedirected) { e.Cancel = true; // Call a helper function to decode the response parameters.  IDictionary\u0026lt;string, string\u0026gt; authResponse = DecodeParameters(uri); // Set the result for the task completion source.  _tcs.SetResult(authResponse); // Close the window.  if (_authWindow != null) { _authWindow.Close(); } } } private static IDictionary\u0026lt;string, string\u0026gt; DecodeParameters(Uri uri) { // Create a dictionary of key value pairs returned in an OAuth authorization response URI query string.  string answer = \u0026#34;\u0026#34;; // Get the values from the URI fragment or query string.  if (!string.IsNullOrEmpty(uri.Fragment)) { answer = uri.Fragment.Substring(1); } else { if (!string.IsNullOrEmpty(uri.Query)) { answer = uri.Query.Substring(1); } } // Parse parameters into key / value pairs.  Dictionary\u0026lt;string, string\u0026gt; keyValueDictionary = new Dictionary\u0026lt;string, string\u0026gt;(); string[] keysAndValues = answer.Split(new[] { \u0026#39;\u0026amp;\u0026#39; }, StringSplitOptions.RemoveEmptyEntries); foreach (string kvString in keysAndValues) { string[] pair = kvString.Split(\u0026#39;=\u0026#39;); string key = pair[0]; string value = string.Empty; if (key.Length \u0026gt; 1) { value = Uri.UnescapeDataString(pair[1]); } keyValueDictionary.Add(key, value); } // Return the dictionary of string keys/values.  return keyValueDictionary; } } #endregion OAuth handler  } } クライアント ID (AppClientId) とリダイレクト URL (OAuthRedirectUri)の値を追加します。これらは、認証の設定ステップで作成したユーザー認証設定です。  ArcGISLoginPrompt.cs\ninternal static class ArcGISLoginPrompt { private const string ArcGISOnlineUrl = \u0026#34;https://www.arcgis.com/sharing/rest\u0026#34;; // Specify the Client ID and Redirect URL to use with OAuth authentication.  // See the instructions here for creating OAuth app settings:  // https://developers.arcgis.com/documentation/security-and-authentication/user-authentication/tutorials/create-oauth-credentials-user-auth/  // 更新開始  private const string AppClientId = \u0026#34;YOUR_CLIENT_ID\u0026#34;; private const string OAuthRedirectUrl = \u0026#34;YOUR_REDIRECT_URL\u0026#34;; // 更新終了 [ソリューション エクスプローラー] で App.xaml のノードを展開し、App.xaml.cs をダブルクリックして開きます。 App クラスで OnStartup() 関数のオーバーライドを追加して、静的 ArcGISLoginPrompt クラスの SetChallengeHandler() メソッドを呼び出します。  App.xaml.cs\npublic partial class App : Application { // 追加開始  protected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); // Call a function to set up the AuthenticationManager for OAuth.  UserAuth.ArcGISLoginPrompt.SetChallengeHandler(); } // 追加終了  } } App.xaml.cs ファイルを保存して閉じます。  OAuth 認証情報は、このチュートリアルの便宜上、コードに直接格納されていますが、本番環境では認証情報をソース コードに直接保存しないでください。\n\r次に、ビュー モデルを使用するビューをプロジェクトに設定します。\nマップ ビューを追加する MapView コントロールは、マップを表示するために使用します。 マップ ビューをプロジェクトの UI に追加し、MapViewModel で定義したマップを使用するように設定します。\n  必要な XML 名前空間とリソースを追加します。\n MainWindow.xaml を開き、XAML ビューに切り替えます。 既存の名前空間の宣言内に、ArcGIS コントロールの esri XML 名前空間を追加します。 MapViewModel インスタンスを静的リソースとして定義する XAML を追加します。  MainWindow.xaml\n\u0026lt;Window x:Class=\u0026#34;DisplayAMap.MainWindow\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:d=\u0026#34;http://schemas.microsoft.com/expression/blend/2008\u0026#34; xmlns:mc=\u0026#34;http://schemas.openxmlformats.org/markup-compatibility/2006\u0026#34; xmlns:local=\u0026#34;clr-namespace:DisplayAMap\u0026#34; \u0026lt;!--追加開始--\u0026gt; xmlns:esri=\u0026#34;http://schemas.esri.com/arcgis/runtime/2013\u0026#34; \u0026lt;!--追加終了--\u0026gt; mc:Ignorable=\u0026#34;d\u0026#34; Title=\u0026#34;MainWindow\u0026#34; Height=\u0026#34;450\u0026#34; Width=\u0026#34;800\u0026#34;\u0026gt; \u0026lt;!--追加開始--\u0026gt; \u0026lt;Window.Resources\u0026gt; \u0026lt;local:MapViewModel x:Key=\u0026#34;MapViewModel\u0026#34; /\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;!--追加終了--\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;/Grid\u0026gt;   MapView コントロールを MainWindow.xaml に追加し、MapViewModel にバインドします。\n MainMapView という名前の MapView コントロールを定義する XAML を追加します。 データ バインディングを使用して、MapViewModel リソースを使用しコントロールの Map プロパティを設定します。  MainWindow.xaml\n\u0026lt;Window.Resources\u0026gt; \u0026lt;local:MapViewModel x:Key=\u0026#34;MapViewModel\u0026#34; /\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;!--追加開始--\u0026gt; \u0026lt;esri:MapView x:Name=\u0026#34;MainMapView\u0026#34; Map=\u0026#34;{Binding Map, Source={StaticResource MapViewModel}}\u0026#34; /\u0026gt; \u0026lt;!--追加終了--\u0026gt; \u0026lt;/Grid\u0026gt;   マップ ビューの視点を設定する ウィンドウの読み込み時にマップ ビューの視点 (ビュー ポイント) を設定します。富士山を中心にマップを表示するための、位置と縮尺を定義します。\n  MainWindow.xaml.cs を開きます。 これは、MainWindow.xaml に関連付けられたコードと、それが定義するユーザー インターフェイス要素を含むコード ビハインド ファイルです。\n  必要な using ステートメントを追加します。\nMainWindow.xaml.cs\nusing System.Windows.Navigation; using System.Windows.Shapes; // 追加開始 using Esri.ArcGISRuntime.Geometry; using Esri.ArcGISRuntime.Mapping; // 追加終了  namespace DisplayAMap {   MainWindow のコンストラクターで、新しい Viewpoint を定義するコードを追加し、マップ ビューに適用します。\nMainWindow.xaml.cs\npublic MainWindow() { InitializeComponent(); // 追加開始  // マップの中心位置として設定する MapPoint を作成  MapPoint mapCenterPoint = new MapPoint(138.727363, 35.360626, SpatialReferences.Wgs84); // マップの視点を決める Viewpoint を設定  MainMapView.SetViewpoint(new Viewpoint(mapCenterPoint, 200000.0)); // 追加終了 }   アプリを実行する [デバッグ] メニュー \u0026gt; [デバッグの開始] をクリックして (またはキーボードの \u0026lt;F5\u0026gt; キーを押して) アプリを実行します。\n富士山を中心に、地形図ベクター タイル ベースマップ レイヤーが追加されたマップが表示されます。マップ ビュー上でマウス ホイールをダブルクリック、ドラッグ、およびスクロールして、マップを操作します。\nプロジェクトはこちらからダウンロードできます (マップの表示場所は本チュートリアルで設定した場所とは異なります)。\nWeb マップを表示する 「Web マップの作成」のガイドで Web マップを作成している場合は、作成した Web マップも基本的に同じステップで表示できます。\n  Visual Studio で、マップを表示するのステップで作成したプロジェクトの MapViewModel.cs を開きます。\n  必要な using ステートメントを追加します。\nMapViewModel.cs\nusing Esri.ArcGISRuntime.Portal; using System.Threading.Tasks;   MapViewModel.cs 内の SetupMap 関数を下記のように書き換えます。\nMapViewModel.cs\nprivate async Task SetupMap() { // ArcGIS ポータルを作成します。URI を指定しない場合は \u0026#34;www.arcgis.com\u0026#34; を使用します。  ArcGISPortal portal = await ArcGISPortal.CreateAsync(); // アイテム ID を使用して、Web マップをポータル アイテムとして取得します。  PortalItem mapItem = await PortalItem.CreateAsync(portal, \u0026#34;Web マップの ID\u0026#34;); // ポータル アイテムからマップを作成します。  Map map = new Map(mapItem); // マップを表示するには、マップ ビューにバインドされている MapViewModel.Map プロパティを設定します。  this.Map = map; }   オプション 2: 完成したソリューションをダウンロードする  Download solution をクリックしてください。 マシンの任意の場所にファイルを解凍します。 .sln ファイルを Visual Studio で開きます。  ダウンロードしたソリューションには認証情報が含まれていないため、認証の設定で作成した開発者認証情報を追加する必要があります。\nソリューションに開発者認証情報を設定する アプリのユーザーが ArcGIS ロケーション サービスやセキュアなコンテンツにアクセスできるようにするには、認証の設定ステップで作成した開発者認証情報を使用して、リソースへのアクセスを認証します。\nAPI キー認証  Visual Studio のソリューション エクスプローラーで、App.xaml.cs をクリックしてファイルを開きます。 ArcGISEnvironment.ApiKey プロパティーに API キーのアクセス トークンを設定します。  App.xaml.cs\nprotected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); // Set the access token for ArcGIS Maps SDK for .NET.  Esri.ArcGISRuntime.ArcGISRuntimeEnvironment.ApiKey = \u0026#34;YOUR_ACCESS_TOKEN\u0026#34;; // Call a function to set up the AuthenticationManager for OAuth.  UserAuth.ArcGISLoginPrompt.SetChallengeHandler(); } ユーザー認証を設定するコードを削除します。  App.xaml.cs\nprotected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); // Set the access token for ArcGIS Maps SDK for .NET.  Esri.ArcGISRuntime.ArcGISRuntimeEnvironment.ApiKey = \u0026#34;YOUR_ACCESS_TOKEN\u0026#34;; // 削除開始  // Call a function to set up the AuthenticationManager for OAuth.  UserAuth.ArcGISLoginPrompt.SetChallengeHandler(); // 削除終了  } アクセス トークンは、このチュートリアルの便宜上、コードに直接格納されていますが、本番環境では認証情報をソース コードに直接保存しないでください。\n\rユーザー認証  Visual Studio のソリューション エクスプローラーから ArcGISLoginPrompt.cs ファイルを開きます。 クライアント ID (OAuthClientID) とリダイレクト URL (OAuthRedirectUri) の値を設定します。これらは認証の設定で作成したユーザー認証設定です。  ArcGISLoginPrompt.cs\ninternal static class ArcGISLoginPrompt { private const string ArcGISOnlineUrl = \u0026#34;https://www.arcgis.com/sharing/rest\u0026#34;; // Specify the Client ID and Redirect URL to use with OAuth authentication.  // See the instructions here for creating OAuth app settings:  // https://developers.arcgis.com/documentation/security-and-authentication/user-authentication/tutorials/create-oauth-credentials-user-auth/  private const string AppClientId = \u0026#34;YOUR_CLIENT_ID\u0026#34;; private const string OAuthRedirectUrl = \u0026#34;YOUR_REDIRECT_URL\u0026#34;; Visual Studio のソリューション エクスプローラーで App.xaml.cs をクリックしてファイルを開きます。 API キーのアクセス トークンを設定するコード行を削除します。  App.xaml.cs\nprotected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); // 削除開始  // Set the access token for ArcGIS Maps SDK for .NET.  Esri.ArcGISRuntime.ArcGISRuntimeEnvironment.ApiKey = \u0026#34;YOUR_ACCESS_TOKEN\u0026#34;; // 削除終了  // Call a function to set up the AuthenticationManager for OAuth.  UserAuth.ArcGISLoginPrompt.SetChallengeHandler(); } OAuth 認証情報は、このチュートリアルの便宜上、コードに直接格納されていますが、本番環境では認証情報をソース コードに直接保存しないでください。\n\rアプリを実行する [デバッグ] メニュー \u0026gt; [デバッグの開始] をクリックして (またはキーボードの \u0026lt;F5\u0026gt; キーを押して) アプリを実行します。\n富士山を中心とした地形図ベースマップ レイヤーの地図が表示されます。マップ ビューをダブルクリック、ドラッグ、マウス ホイールをスクロールしてマップを操作します。\n次のチュートリアル これらのチュートリアルでは、追加の API 機能、ArcGIS ロケーション サービスおよび ArcGIS ツールの使用方法について説明します。(英語ページ)\n ポイント、ラインおよびポリゴンの追加 シーンの表示 フィーチャ レイヤーの追加  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/android/",
	"title": "ArcGIS Maps SDK for Kotlin",
	"tags": [],
	"description": "ArcGIS Maps SDK for Kotlin の開発に役立つガイド集です。",
	"content": "ArcGIS Maps SDK for Kotlin (バージョン 200.x) の開発に役立つガイド集です。\n インストール ガイド\nArcGIS Maps SDK for Kotlin のインストールとセットアップ手順を紹介します。\n\r アプリケーション配布ガイド\nArcGIS Maps SDK for Kotlin を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を紹介します。\n\r バージョン 100.x から 200.x への移行\n今まで ArcGIS Runtime SDK for Android バージョン 100.x を使用してアプリケーションを開発されていた開発者向けのガイドです。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/calcite-design-system/tutorials/construct-a-mapping-app-with-web-components/",
	"title": "Web コンポーネントでマッピング アプリを構築",
	"tags": [],
	"description": "Calcite コンポーネントと Map コンポーネントを使用して、インタラクティブなマッピング アプリケーションを構築する方法を学びます。",
	"content": "出典：Calcite Design System - Construct a mapping app with web components\nCalcite コンポーネントと ArcGIS Maps SDK for JavaScript の Map コンポーネントを使用して、Web コンポーネントでマッピング アプリケーションの UI を構築する方法をご紹介します。\nCalcite コンポーネントを使用して、マッピング アプリケーションのユーザー エクスペリエンスを向上させ、インタラクションを促進します。このチュートリアルでは、アプリの作成を効率化するためのユーザー インタフェースとマップ コンポーネントに焦点を当て、ArcGIS Maps SDK for JavaScript の予備知識は必要ありません。ArcGIS Maps SDK for JavaScript を初めてお使いになる場合は、このアプリケーションで使用されている同様のマッピングをコンセプトに扱った素晴らしいチュートリアルをご覧ください。\n前提条件 ArcGIS 開発者アカウント このチュートリアルで使用するサービスにアクセスするには、無料の ArcGIS Location Platform アカウントまたは ArcGIS Online 組織のアカウントが必要です。\n\rステップ 新しいペンの作成  CodePen に移動し、マッピングアプリケーション用の新しいペンを作成します。  HTML の追加   CodePen \u0026gt; HTML で、地図を表示する arcgis-map コンポーネントを含むページを作成するための HTML と CSS を追加してください。\n  arcgis-map コンポーネントに id を追加して、アプリ開発全体で参照できるようにし、CSS を使って幅と高さをブラウザーのウィンドウに合わせて設定し、さらにアプリのスタイリングを補うために Flexbox を使用してください。\n  CodePen では、\u0026lt;!DOCTYPE html\u0026gt; タグは必須ではありません。別のエディターを使用している場合や、ローカル サーバーでページを運営している場合は、必ずこのタグを HTML ページの先頭に追加してください。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Calcite Components: Construct a mapping app with web components\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;style\u0026gt; html, body, #mapEl { padding: 0; margin: 0; height: 100%; width: 100%; display: flex; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;arcgis-map id=\u0026#34;mapEl\u0026#34;\u0026gt;\u0026lt;/arcgis-map\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;head\u0026gt; 要素に、Calcite コンポーネントと ArcGIS Maps SDK for JavaScript への参照を追加します。  \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Calcite Components: Create a mapping app with web components\u0026lt;/title\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/calcite-components/3.2.1/calcite.esm.js\u0026#34; type=\u0026#34;module\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.33/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.33/esri/themes/light/main.css\u0026#34; /\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/head\u0026gt; 次に、ArcGIS Maps SDK for JavaScript のマップ コンポーネントへの参照を追加します。  \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Calcite Components: Create a mapping app with web components\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/calcite-components/3.2.1/calcite.esm.js\u0026#34; type=\u0026#34;module\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.33/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.33/esri/themes/light/main.css\u0026#34; /\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;https://js.arcgis.com/4.33/map-components\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/head\u0026gt; API キーの使用 開発者アカウントを使用している場合、ArcGIS サービスにアクセスするには API キーが必要です。ArcGIS Online の組織に関連付けられているアカウントがある場合は、この手順を省略できます。\n セキュアなリソースにアクセスできるアプリを作るには、セキュリティと認証を始めるをご覧ください。 CodePen \u0026gt; \u0026lt;script\u0026gt; に戻り、esriConfig クラスをインポートします。 apiKey プロパティを設定します。  \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; // 追加開始  const [esriConfig] = await $arcgis.import([ \u0026#34;@arcgis/core/config.js\u0026#34; ]); esriConfig.apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // 追加終了 \u0026lt;/script\u0026gt; マップの表示 マップはこのアプリケーションの中心です。HTML の追加で追加したCSSは、マップをウィンドウの幅と高さいっぱいに表示します。また、マップと連動する ArcGIS Maps SDK for JavaScript のマップ コンポーネントも追加します。\n \u0026lt;body\u0026gt; 内で、item-id 属性を使って arcgis-map コンポーネントを初期化します。この属性は Web マップのアイテム ID を指定します。  \u0026lt;body\u0026gt; \u0026lt;!-- 更新開始 --\u0026gt; \u0026lt;arcgis-map id=\u0026#34;mapEl\u0026#34; item-id=\u0026#34;03d584a7c9874b44821c6a766c3bbc11\u0026#34;\u0026gt; \u0026lt;/arcgis-map\u0026gt; \u0026lt;!-- 更新終了 --\u0026gt; \u0026lt;/body\u0026gt; 次に、arcgis-zoom コンポーネントを追加し、arcgis-map コンポーネントに対する位置を設定します。  \u0026lt;body\u0026gt; \u0026lt;arcgis-map id=\u0026#34;mapEl\u0026#34; item-id=\u0026#34;03d584a7c9874b44821c6a766c3bbc11\u0026#34;\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;arcgis-zoom position=\u0026#34;top-left\u0026#34;\u0026gt;\u0026lt;/arcgis-zoom\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/arcgis-map\u0026gt; \u0026lt;/body\u0026gt; この時点でアプリケーションはマップを表示します。 次に、Calcite コンポーネントを使ってアプリのユーザー インターフェイスを構築します。\nレイアウトの作成 レイアウトを作るために、スロットを使ってページ上の他のコンポーネントを整理する calcite-shell を使います。スロットは Web コンポーネントの概念であり、コア コンセプトのセクションに簡単な説明があります。Calcite コンポーネントにスロットがある場合は、その一覧がリファレンス ページに記載されています。たとえば、こちらが シェルのスロットです。\n calcite-shell コンポーネントを追加し、content-behind 属性を設定して、ユーザーがシェルの背後にある地図と操作できるようにします。  \u0026lt;body\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;calcite-shell content-behind\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;arcgis-map id=\u0026#34;mapEl\u0026#34; item-id=\u0026#34;03d584a7c9874b44821c6a766c3bbc11\u0026#34;\u0026gt; \u0026lt;arcgis-zoom position=\u0026#34;top-left\u0026#34;\u0026gt;\u0026lt;/arcgis-zoom\u0026gt; \u0026lt;/arcgis-map\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;/calcite-shell\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/body\u0026gt;  次に、calcite-shell-panel コンポーネントを追加し、それをシェルの \u0026quot;panel-end\u0026quot; スロットに配置します。\n  次に、シェル パネルの displayMode 属性を \u0026quot;float\u0026quot; に設定して、コンテンツが地図の上に浮かんで表示されるようにします。\n  \u0026lt;calcite-shell content-behind\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;calcite-shell-panel id=\u0026#34;shell-panel-nav\u0026#34; slot=\u0026#34;panel-end\u0026#34; display-mode=\u0026#34;float\u0026#34; height=\u0026#34;l\u0026#34;\u0026gt; \u0026lt;/calcite-shell-panel\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;arcgis-map id=\u0026#34;mapEl\u0026#34; item-id=\u0026#34;03d584a7c9874b44821c6a766c3bbc11\u0026#34;\u0026gt; \u0026lt;arcgis-zoom position=\u0026#34;top-left\u0026#34;\u0026gt;\u0026lt;/arcgis-zoom\u0026gt; \u0026lt;/arcgis-map\u0026gt; \u0026lt;/calcite-shell\u0026gt;  calcite-panel コンポーネントを追加します。heading に Web マップのタイトルを動的に入力するために id を指定し、初期化時にコンポーネントを隠すために hidden 属性を追加します。\n  次に、calcite-icon をパネルの \u0026quot;header-actions-start\u0026quot; スロットに挿入します。\n  次に、calcite-action-bar をパネルの \u0026quot;action-bar\u0026quot; スロットに挿入します。ここに calcite-action を追加して、マップ コンポーネントを表示できるようにします。\n  各アクションに、一意の data-action-id の値を追加する。\n  \u0026lt;calcite-shell content-behind\u0026gt; \u0026lt;calcite-shell-panel id=\u0026#34;shell-panel-nav\u0026#34; slot=\u0026#34;panel-end\u0026#34; display-mode=\u0026#34;float\u0026#34; height=\u0026#34;l\u0026#34;\u0026gt; \u0026lt;!-- 追加開始--\u0026gt; \u0026lt;calcite-panel id=\u0026#34;app-heading\u0026#34; hidden\u0026gt; \u0026lt;calcite-icon id=\u0026#34;logo-icon\u0026#34; slot=\u0026#34;header-actions-start\u0026#34; icon=\u0026#34;explore\u0026#34; text-label=\u0026#34;explore\u0026#34;\u0026gt;\u0026lt;/calcite-icon\u0026gt; \u0026lt;calcite-action-bar id=\u0026#34;map-actions\u0026#34; slot=\u0026#34;action-bar\u0026#34; layout=\u0026#34;horizontal\u0026#34; expand-disabled\u0026gt; \u0026lt;calcite-action icon=\u0026#34;layers\u0026#34; text=\u0026#34;Layers\u0026#34; data-action-id=\u0026#34;layers\u0026#34;\u0026gt;\u0026lt;/calcite-action\u0026gt; \u0026lt;calcite-action icon=\u0026#34;basemap\u0026#34; text=\u0026#34;Basemaps\u0026#34; data-action-id=\u0026#34;basemaps\u0026#34;\u0026gt;\u0026lt;/calcite-action\u0026gt; \u0026lt;calcite-action icon=\u0026#34;legend\u0026#34; text=\u0026#34;Legend\u0026#34; data-action-id=\u0026#34;legend\u0026#34;\u0026gt;\u0026lt;/calcite-action\u0026gt; \u0026lt;calcite-action icon=\u0026#34;bookmark\u0026#34; text=\u0026#34;Bookmarks\u0026#34; data-action-id=\u0026#34;bookmarks\u0026#34;\u0026gt;\u0026lt;/calcite-action\u0026gt; \u0026lt;calcite-action icon=\u0026#34;print\u0026#34; text=\u0026#34;Print\u0026#34; data-action-id=\u0026#34;print\u0026#34;\u0026gt;\u0026lt;/calcite-action\u0026gt; \u0026lt;calcite-action icon=\u0026#34;information\u0026#34; text=\u0026#34;About\u0026#34; data-action-id=\u0026#34;information\u0026#34;\u0026gt;\u0026lt;/calcite-action\u0026gt; \u0026lt;/calcite-action-bar\u0026gt; \u0026lt;/calcite-panel\u0026gt; \u0026lt;!-- 追加開始--\u0026gt; \u0026lt;/calcite-shell-panel\u0026gt; マップ コンポーネントの追加 レイアウトをさらに構築するために、ユーザーが calcite-action に操作したときに表示されるマップ コンポーネントを追加します。\n  はじめに calcite-block コンポーネントを追加する。\n コンテンツを表示するために expanded 属性を追加します。 ユニークな heading を付けます。 対応する data-action-id の値を、ブロックの data-block-id 属性に指定します。 アプリの初期化時にコンポーネントとそのコンテンツが表示されないように、hidden 属性を追加します。    calcite-block に、arcgis-layer-list マップ コンポーネントをスロットに挿入します。\n reference-element にマップ コンポーネントの id に設定します。    \u0026lt;calcite-shell-panel id=\u0026#34;shell-panel-nav\u0026#34; slot=\u0026#34;panel-end\u0026#34; display-mode=\u0026#34;float\u0026#34; height=\u0026#34;l\u0026#34;\u0026gt; \u0026lt;calcite-panel id=\u0026#34;app-heading\u0026#34; hidden\u0026gt; \u0026lt;calcite-icon id=\u0026#34;logo-icon\u0026#34; slot=\u0026#34;header-actions-start\u0026#34; icon=\u0026#34;explore\u0026#34; text-label=\u0026#34;explore\u0026#34;\u0026gt;\u0026lt;/calcite-icon\u0026gt; \u0026lt;calcite-action-bar id=\u0026#34;map-actions\u0026#34; slot=\u0026#34;action-bar\u0026#34; layout=\u0026#34;horizontal\u0026#34; expand-disabled\u0026gt; \u0026lt;calcite-action icon=\u0026#34;layers\u0026#34; text=\u0026#34;Layers\u0026#34; data-action-id=\u0026#34;layers\u0026#34;\u0026gt;\u0026lt;/calcite-action\u0026gt; \u0026lt;calcite-action icon=\u0026#34;basemap\u0026#34; text=\u0026#34;Basemaps\u0026#34; data-action-id=\u0026#34;basemaps\u0026#34;\u0026gt;\u0026lt;/calcite-action\u0026gt; \u0026lt;calcite-action icon=\u0026#34;legend\u0026#34; text=\u0026#34;Legend\u0026#34; data-action-id=\u0026#34;legend\u0026#34;\u0026gt;\u0026lt;/calcite-action\u0026gt; \u0026lt;calcite-action icon=\u0026#34;bookmark\u0026#34; text=\u0026#34;Bookmarks\u0026#34; data-action-id=\u0026#34;bookmarks\u0026#34;\u0026gt;\u0026lt;/calcite-action\u0026gt; \u0026lt;calcite-action icon=\u0026#34;print\u0026#34; text=\u0026#34;Print\u0026#34; data-action-id=\u0026#34;print\u0026#34;\u0026gt;\u0026lt;/calcite-action\u0026gt; \u0026lt;calcite-action icon=\u0026#34;information\u0026#34; text=\u0026#34;About\u0026#34; data-action-id=\u0026#34;information\u0026#34;\u0026gt;\u0026lt;/calcite-action\u0026gt; \u0026lt;/calcite-action-bar\u0026gt; \u0026lt;/calcite-panel\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;!-- ArcGIS Maps SDK for JavaScript コンポーネントを含むマップ固有のブロック --\u0026gt; \u0026lt;calcite-block expanded heading=\u0026#34;Layers\u0026#34; data-block-id=\u0026#34;layers\u0026#34; hidden\u0026gt; \u0026lt;arcgis-layer-list drag-enabled reference-element=\u0026#34;mapEl\u0026#34; visibility-appearance=\u0026#34;checkbox\u0026#34;\u0026gt;\u0026lt;/arcgis-layer-list\u0026gt; \u0026lt;/calcite-block\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/calcite-shell-panel\u0026gt; ステップ 1 と 2 を繰り返して、calcite-block コンポーネントを追加し、arcgis-basemap-gallery、arcgis-legend、arcgis-bookmarks、および arcgis-print コンポーネントをそれぞれ含めます。  \u0026lt;!-- ArcGIS Maps SDK for JavaScript コンポーネントを含むマップ固有のブロック --\u0026gt; \u0026lt;calcite-block expanded heading=\u0026#34;Layers\u0026#34; data-block-id=\u0026#34;layers\u0026#34; hidden\u0026gt; \u0026lt;arcgis-layer-list drag-enabled reference-element=\u0026#34;mapEl\u0026#34; visibility-appearance=\u0026#34;checkbox\u0026#34;\u0026gt;\u0026lt;/arcgis-layer-list\u0026gt; \u0026lt;/calcite-block\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;calcite-block expanded heading=\u0026#34;Basemaps\u0026#34; data-block-id=\u0026#34;basemaps\u0026#34; hidden\u0026gt; \u0026lt;arcgis-basemap-gallery reference-element=\u0026#34;mapEl\u0026#34;\u0026gt;\u0026lt;/arcgis-basemap-gallery\u0026gt; \u0026lt;/calcite-block\u0026gt; \u0026lt;calcite-block expanded heading=\u0026#34;Legend\u0026#34; data-block-id=\u0026#34;legend\u0026#34; hidden\u0026gt; \u0026lt;arcgis-legend legend-style=\u0026#34;classic\u0026#34; reference-element=\u0026#34;mapEl\u0026#34;\u0026gt;\u0026lt;/arcgis-legend\u0026gt; \u0026lt;/calcite-block\u0026gt; \u0026lt;calcite-block expanded heading=\u0026#34;Bookmarks\u0026#34; data-block-id=\u0026#34;bookmarks\u0026#34; hidden\u0026gt; \u0026lt;arcgis-bookmarks editing-enabled=\u0026#34;false\u0026#34; reference-element=\u0026#34;mapEl\u0026#34;\u0026gt;\u0026lt;/arcgis-bookmarks\u0026gt; \u0026lt;/calcite-block\u0026gt; \u0026lt;calcite-block expanded heading=\u0026#34;Print\u0026#34; data-block-id=\u0026#34;print\u0026#34; hidden\u0026gt; \u0026lt;arcgis-print allowed-formats=\u0026#34;all\u0026#34; allowed-layouts=\u0026#34;all\u0026#34; include-default-templates=\u0026#34;false\u0026#34; reference-element=\u0026#34;mapEl\u0026#34;\u0026gt;\u0026lt;/arcgis-print\u0026gt; \u0026lt;/calcite-block\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; インフォメーション カードの作成 インフォメーション カードは、アプリのデータに関する情報をユーザーに提供できます。calcite-card を使用して Web マップの情報を表示します。このカードには、タイトル、サムネイル画像、説明、最終更新日、タグが動的に入力・整理されます。\n  他の地図コンポーネントと同様に、calcite-block コンポーネントを追加します。\n コンテンツを表示するために expanded 属性を追加します。 ユニークな heading を付けます。 対応する data-action-id の値を、ブロックの data-block-id 属性に指定します。 closed 属性を追加し、アプリの初期化時にコンポーネントとそのコンテンツが表示されないようにします。    calcite-card コンポーネントを追加します。\n  カードに以下の子要素を、固有の ID を付けて追加します。\n カードの thumbnail スロットに img 要素を定義します。 3 つの div 要素を追加してください。1 つは heading スロットに、もう 1 つは description スロットに、最後の 1 つは footer-end スロットに配置します。    \u0026lt;calcite-block expanded heading=\u0026#34;Print\u0026#34; data-block-id=\u0026#34;print\u0026#34; hidden\u0026gt; \u0026lt;arcgis-print allowed-formats=\u0026#34;all\u0026#34; allowed-layouts=\u0026#34;all\u0026#34; include-default-templates=\u0026#34;false\u0026#34; reference-element=\u0026#34;mapEl\u0026#34;\u0026gt;\u0026lt;/arcgis-print\u0026gt; \u0026lt;/calcite-block\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;!-- Info block (populates with info from the web map) --\u0026gt; \u0026lt;calcite-block expanded heading=\u0026#34;About the data\u0026#34; data-block-id=\u0026#34;information\u0026#34; hidden\u0026gt; \u0026lt;calcite-card id=\u0026#34;card-content\u0026#34;\u0026gt; \u0026lt;img id=\u0026#34;card-thumbnail\u0026#34; alt=\u0026#34;Webmap thumbnail\u0026#34; slot=\u0026#34;thumbnail\u0026#34; /\u0026gt; \u0026lt;div id=\u0026#34;card-heading\u0026#34; slot=\u0026#34;heading\u0026#34;\u0026gt; \u0026lt;!-- Dynamically populated --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;card-description\u0026#34; slot=\u0026#34;description\u0026#34;\u0026gt; \u0026lt;!-- Dynamically populated --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;card-tags\u0026#34; slot=\u0026#34;footer-end\u0026#34;\u0026gt; \u0026lt;!-- Dynamically populated --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/calcite-card\u0026gt; \u0026lt;/calcite-block\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/calcite-shell-panel\u0026gt; コンテンツの設定 アプリケーションにコンポーネントの追加が終わりました。パネルの見出しとインフォメーション カードに Web マップの内容を入力します。\n \u0026lt;script\u0026gt; タグで arcgis-map コンポーネントを宣言します。  \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; // 追加開始  const mapEl = document.getElementById(\u0026#34;mapEl\u0026#34;); // 追加終了  \u0026lt;/script\u0026gt;  マップの arcgisViewReadyChange イベントで、Web マップのコンテンツを取得するために、次の portalItem の定数を宣言してください。：title、thumbnailUrl、snippet、modified、および tags\n  次に、UI に値を追加します。\n title は、パネルの見出しおよびカードの \u0026quot;heading\u0026quot; スロットに使用されます。 thumbnailUrl は、カードの画像（img）の src プロパティとして \u0026quot;thumbnail\u0026quot; スロットに追加されます。 snippet と modified は、カードの \u0026quot;description\u0026quot; スロットを補足します。 tags は、それぞれのタグを繰り返し処理して、カードの \u0026quot;footer-end\u0026quot; スロットに個別の calcite-chip コンポーネントを作成します。    \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; const mapEl = document.getElementById(\u0026#34;mapEl\u0026#34;); // 追加開始  mapEl.addEventListener(\u0026#34;arcgisViewReadyChange\u0026#34;, () =\u0026gt; { const { title, thumbnailUrl, snippet, modified, tags } = mapEl.map.portalItem; document.getElementById(\u0026#34;app-heading\u0026#34;).heading = `${title}Explorer`; document.getElementById(\u0026#34;card-heading\u0026#34;).innerHTML = title; document.getElementById(\u0026#34;card-thumbnail\u0026#34;).src = thumbnailUrl; document.getElementById(\u0026#34;card-description\u0026#34;).innerHTML = `\u0026lt;p\u0026gt;${snippet}\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;Last modified on ${modified}.\u0026lt;/p\u0026gt;`; tags.forEach(tag =\u0026gt; { document.getElementById(\u0026#34;card-tags\u0026#34;).innerHTML += `\u0026lt;calcite-chip\u0026gt;${tag}\u0026lt;/calcite-chip\u0026gt;`; }); }); // 追加終了  \u0026lt;/script\u0026gt; コンポーネントをインタラクティブにする 次のステップは、対応する calcite-action コンポーネントをクリックしたときに、マップ コンポーネントを含む calcite-block コンポーネントを表示します。\n 各 calcite-action がクリックされたときに実行される関数を作成します。この関数は、現在表示されている calcite-block を非表示にし、クリックされたアクションに対応するブロックを表示します。ユーザーが現在アクティブなアクションをクリックした場合、対応するブロックは閉じられ、展開されたブロックは存在しなくなります。  このステップでは、上で追加したデータ属性を使って、アクション要素とブロック要素にアクセスするために属性セレクターを使用します。データ属性の値は、対応するマップコンポーネントの名前です。\nmapEl.addEventListener(\u0026#34;arcgisViewReadyChange\u0026#34;, () =\u0026gt; { const { title, thumbnailUrl, snippet, modified, tags } = mapEl.map.portalItem; document.getElementById(\u0026#34;app-heading\u0026#34;).heading = `${title}Explorer`; document.getElementById(\u0026#34;card-heading\u0026#34;).innerHTML = title; document.getElementById(\u0026#34;card-thumbnail\u0026#34;).src = thumbnailUrl; document.getElementById(\u0026#34;card-description\u0026#34;).innerHTML = `\u0026lt;p\u0026gt;${snippet}\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;Last modified on ${modified}.\u0026lt;/p\u0026gt;`; tags.forEach(tag =\u0026gt; { document.getElementById(\u0026#34;card-tags\u0026#34;).innerHTML += `\u0026lt;calcite-chip\u0026gt;${tag}\u0026lt;/calcite-chip\u0026gt;`; }); }); // 追加開始  let activeWidget; const handleActionBarClick = ({ target }) =\u0026gt; { if (target.tagName !== \u0026#34;CALCITE-ACTION\u0026#34;) { return; } if (activeWidget) { document.querySelector(`[data-action-id=${activeWidget}]`).active = false; document.querySelector(`[data-block-id=${activeWidget}]`).hidden = true; } const nextWidget = target.dataset.actionId; if (nextWidget !== activeWidget) { document.querySelector(`[data-action-id=${nextWidget}]`).active = true; document.querySelector(`[data-block-id=${nextWidget}]`).hidden = false; activeWidget = nextWidget; } else { activeWidget = null; } }; document.querySelector(\u0026#34;calcite-action-bar\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, handleActionBarClick); // 追加終了  \u0026lt;/script\u0026gt; ローダー コンポーネントの追加 ここまでで、アプリケーションがインタラクティブになりました。Calcite コンポーネントを使用して、マップ コンポーネントを開いたり閉じたりできます。しかし、アプリケーションのロードには1秒かかるので、それをユーザーに伝える必要があります。\n   要素内で、シェルの終了タグの後に calcite-loader を追加して、コンポーネントを表示します。\r  \u0026lt;/calcite-shell\u0026gt; \u0026lt;!-- 追加開始 --\u0026gt; \u0026lt;calcite-loader\u0026gt;\u0026lt;/calcite-loader\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/body\u0026gt; arcgisViewReadyChange イベントの内部で、他の JavaScript コードの下に、calcite-loader コンポーネントを hidden プロパティを true に設定して非表示にし、calcite-panel を表示してください。マップとそのプロパティがアプリに読み込まれると、ローダーは非表示になり、パネルが UI に表示されます。  mapEl.addEventListener(\u0026#34;arcgisViewReadyChange\u0026#34;, () =\u0026gt; { const { title, thumbnailUrl, snippet, modified, tags } = mapEl.map.portalItem; document.getElementById(\u0026#34;app-heading\u0026#34;).heading = `${title}Explorer`; document.getElementById(\u0026#34;card-heading\u0026#34;).innerHTML = title; document.getElementById(\u0026#34;card-thumbnail\u0026#34;).src = thumbnailUrl; document.getElementById(\u0026#34;card-description\u0026#34;).innerHTML = `\u0026lt;p\u0026gt;${snippet}\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;Last modified on ${modified}.\u0026lt;/p\u0026gt;`; tags.forEach(tag =\u0026gt; { document.getElementById(\u0026#34;card-tags\u0026#34;).innerHTML += `\u0026lt;calcite-chip\u0026gt;${tag}\u0026lt;/calcite-chip\u0026gt;`; }); // 追加開始  document.querySelector(\u0026#34;calcite-loader\u0026#34;).hidden = true; document.getElementById(\u0026#34;app-heading\u0026#34;).removeAttribute(\u0026#34;hidden\u0026#34;); // 追加終了  }); スタイルの追加 \u0026lt;style\u0026gt; 要素内で、見出しの calcite-panel と情報の calcite-card のユーザー インターフェースを強化するために、追加の CSS を記述します。\n  calcite-icon をパネルの \u0026quot;header-actions-start\u0026quot; にスロットしている場合、そのコンポーネントを整列させるために Flexbox の変数を追加します。\n  次に、パネルの幅と高さを設定するためのスタイルを追加します。\n calcite-shell-panel に \u0026ndash;calcite-shell-panel-min-width を追加します。 calcite-shell-panel がスマートフォンなどの小型デバイスに対応できるように、メディア クエリーを追加します。 data-block-id 属性を含む calcite-block コンポーネントに対して、max-height を設定します。    \u0026lt;style\u0026gt; html, body, #mapEl { padding: 0; margin: 0; height: 100%; width: 100%; display: flex; } /** 追加開始 */ #logo-icon { align-self: center; height: auto; margin-inline-start: 0.5rem; } #shell-panel-nav { --calcite-shell-panel-min-width: 18rem; } @media (max-width: 400px) { #shell-panel-nav { --calcite-shell-panel-min-width: 80vw; } } calcite-block[data-block-id] { max-height: 50vh; overflow-y: auto; } /** 追加終了 */ \u0026lt;/style\u0026gt; 最後に、calcite-card にスタイルを追加してください。具体的には、コンポーネントにパディングを追加し、CSS 変数を使ってフォント サイズを更新し、タグを flex-wrap で折り返すようにしてください。  \u0026lt;style\u0026gt; /** ～ 中略 ～ */ calcite-block[data-block-id] { max-height: 50vh; overflow-y: auto; } /* 追加開始 */ #card-heading { font-size: var(--calcite-font-size-md); } #card-description { font-size: var(--calcite-font-size); } #card-tags { flex-wrap: wrap; } /* 追加終了 */ \u0026lt;/style\u0026gt; アプリの実行 CodePen でコードを実行すると、アプリケーションが表示されます。\nアプリケーションの読み込みが完了すると、マップが表示され、Web マップのタイトルと calcite-action-bar も一緒に表示されます。calcite-action コンポーネントをクリックすると、calcite-block コンポーネントが展開・折りたたみされます。これらのブロックには、ArcGIS Maps SDK for JavaScript のマップ コンポーネントが含まれています。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/widget-manifest/",
	"title": "ウィジェット manifest",
	"tags": [],
	"description": "ウィジェットの名前やバージョンなどのウィジェットの属性などを設定する manifest.json ファイルについて紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Widget manifest\n各 ArcGIS Experience Builder ウィジェットには、ウィジェットの属性とプロパティを記述した manifest.json ファイルがあります。ウィジェットの manifest には、name、type、version、exbVersion、および translatedLocales プロパティを含める必要があります。ウィジェットの manifest を作成する簡単な方法は、demo widget から manifest.json ファイルをコピーすることです。以下は manifest.json ファイルの例です。ウィジェット内で ArcGIS Maps SDK for JavaScript を使用するには、dependency プロパティに jimu-arcgis を設定します。\n{ \u0026#34;name\u0026#34;: \u0026#34;count-features\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Count Features\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;widget\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.15.0\u0026#34;, \u0026#34;exbVersion\u0026#34;: \u0026#34;1.15.0\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Esri R\u0026amp;D Center Beijing\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is widget is designed to display the numeric attributes of features.\u0026#34;, \u0026#34;copyright\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;http://www.apache.org/licenses/LICENSE-2.0\u0026#34;, \u0026#34;publishMessages\u0026#34;: [ \u0026#34;EXTENT_CHANGE\u0026#34;, \u0026#34;DATA_RECORDS_SELECTION_CHANGE\u0026#34; ], \u0026#34;messageActions\u0026#34;: [], \u0026#34;defaultSize\u0026#34;: { \u0026#34;width\u0026#34;: 360, \u0026#34;height\u0026#34;: 80 }, \u0026#34;properties\u0026#34;: {}, \u0026#34;translatedLocales\u0026#34;: [ \u0026#34;en\u0026#34;, \u0026#34;es\u0026#34;, \u0026#34;zh-cn\u0026#34; ] } widget\u0026rsquo;s manifest で利用可能なプロパティの詳細を参照してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/components/",
	"title": "コンポーネント",
	"tags": [],
	"description": "ArcGIS Maps SDK for JavaScript コンポーネントについて紹介します。",
	"content": "出典：ArcGIS Maps SDK for JavaScript - Components\nArcGIS Maps SDK for JavaScript コンポーネントは、最小限のコードで Web アプリを構築するための事前構築された UI コンポーネントのコレクションです。\n標準ベースの Web コンポーネントとして構築されており、JavaScript Maps SDK のコア API を再利用可能なカスタム HTML エレメント（例：\u0026lt;arcgis-map\u0026gt;\u0026lt;/arcgis-map\u0026gt;）に拡張します。また、JavaScript フレームワークに依存しないように設計されているため、バニラ JavaScript やほとんどのフレームワークおよびモジュール バンドラーで構築されたアプリケーションで使用できます。\nマップ コンポーネント @arcgis/map-components パッケージには、マップ コンポーネント、シーン コンポーネント、および SDK の既存のウィジェットと同等の機能を持つ他のコンポーネントが含まれています。\n以下は、item-id 属性を持つマップ コンポーネント \u0026lt;arcgis-map\u0026gt; の使い方を示すコード スニペットで、指定されたアイテム ID を使用して ArcGIS マップを Web ページに埋め込むことができます。\n\u0026lt;arcgis-map item-id=\u0026#34;05e015c5f0314db9a487a9b46cb37eca\u0026#34;\u0026gt;\u0026lt;/arcgis-map\u0026gt; チャート コンポーネント（ベータ版） @arcgis/charts-components パッケージには、ArcGIS Maps SDK for JavaScript アプリケーションでチャートを作成するために使用されるチャート コンポーネントとチャート アクション バー コンポーネントが含まれています。このパッケージは 9 種類のチャート タイプをサポートしており、各チャート タイプは、共有チャート仕様に準拠した model オブジェクトを設定することでレンダリングできます。この model オブジェクトは、Web マップまたはフィーチャ レイヤーから読み込むか、チャート モデル メソッドを使用してプログラムで構成できます。\n以下は、\u0026lt;arcgis-chart\u0026gt; チャート コンポーネントとデフォルトのチャート インタラクション アクションを追加する \u0026lt;arcgis-charts-action-bar\u0026gt; の使用方法を示すコード スニペットです。チャート要素に有効な model が設定され、チャートがレンダリングされます:\n\u0026lt;arcgis-chart\u0026gt; \u0026lt;arcgis-charts-action-bar slot=\u0026#34;action-bar\u0026#34;\u0026gt;\u0026lt;/arcgis-charts-action-bar\u0026gt; \u0026lt;/arcgis-chart\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; const WebMap = await $arcgis.import(\u0026#34;@arcgis/core/WebMap.js\u0026#34;); const webmap = new WebMap({ portalItem: { id: \u0026#34;96cb2d2825dc459abadcabc941958125\u0026#34; }}); await webmap.loadAll(); const featureLayer = webmap.layers.find((layer) =\u0026gt; layer.title === \u0026#34;College Scorecard\u0026#34;); const scatterplotModel = featureLayer.charts[0]; const chartElement = document.querySelector(\u0026#34;arcgis-chart\u0026#34;); chartElement.layer = featureLayer; chartElement.model = scatterplotModel; \u0026lt;/script\u0026gt; コーディング コンポーネント @arcgis/coding-components パッケージには、Arcade エディター コンポーネントが含まれています。このコンポーネントを使用すると、エンド ユーザーはレンダラー、ポップアップ、ラベルのために新しいデータ値を動的に作成するための Arcade 式を作成できます。ユーザーは、Map Viewer や Arcade プレイグラウンドでの編集と同じ体験を得ることができます。 埋め込み可能なコンポーネント 埋め込み可能なコンポーネントには、埋め込み マップ コンポーネントが含まれています。 このコンポーネントを使用すると、デフォルトのコンポーネント（ズーム、凡例、ブックマークなど）があらかじめ設定されたWebマップを、あらゆる Web サイトにすばやく統合することができます。ArcGIS Online の Map Viewer から、最小限の設定でインタラクティブなマップを追加できます。\n\u0026lt;arcgis-embedded-map item-id=\u0026#34;ceb8954a5f2c457284c5074efd5a5ca0\u0026#34; theme=\u0026#34;dark\u0026#34; heading-enabled legend-enabled information-enabled style=\u0026#34;height:300px;\u0026#34;\u0026gt;\u0026lt;/arcgis-embedded-map\u0026gt; MDN で Web コンポーネント全般について詳しく学ぶことができます。\n\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/automate-tasks/",
	"title": "スクリプト実行の自動化",
	"tags": [],
	"description": "タスクスケジューラや cron を使用した Python スクリプトの実行の自動化について紹介します。",
	"content": "ArcGIS API for Python や ArcPy は、タスク スケジューラなどと組み合わせることで、様々な GIS タスクの実行を自動化することが可能です。\nここでは、例として以下のようなディレクトリ構成で実行する Python スクリプトを作成したと想定し、そのスクリプトを Windows 及び Linux で 30 分ごとに無期限で定期実行する方法を紹介します。\npy-script/\n├ config.ini\n└ task.py\ntask.py は実行する Python スクリプト、config.ini は task.py の実行に必要なパラメータを記載した設定ファイルとします。\nWindows のタスク スケジューラを使用する場合 Windows ではタスク スケジューラを使用することでプログラムやスクリプトを決められた時間や一定の間隔で実行することができます。\nタスク スケジューラは以下の手順で設定します。\n タスク スケジューラを開く  スタート メニューからタスク スケジューラを検索して開く    \r 右側の [操作] ペインから [タスクの作成] をクリック  新規タスクを作成するウィザードが開きます    \r [全般] タブ内のパラメーターを設定する  名前：タスクの名前 説明：タスクの説明を記載 セキュリティ オプション：  タスク実行時に使う Windows のユーザーアカウントを指定 [ユーザーがログオンしているかどうかにかかわらず実行する] をクリック [最上位の特権で実行する] にチェックを入れる   [構成] は使用している Windows のバージョンに合わせる (今回は Windows 10)    \r [トリガー] タブ内のパラメーターを設定する  [新規] をクリックし、新しいトリガーを作成 [タスクの開始] は [スケジュールに従う] をドロップダウンから選択 任意の開始時間を指定 [繰り返し間隔] にチェックを入れ、30分間を指定 [継続時間] は [無期限] を指定    \r [操作] タブのパラメーターを設定する  [操作] のドロップダウンから [プログラムの開始] を選択 [プログラム/スクリプト] で実行する Python の エグゼキュータブル ファイルのパスを指定  上の画像では ArcGIS Pro の Python パッケージ マネージャー で作成した環境の Python を指定しています。 パスが不明な場合、実行したい環境で ArcGIS Pro を起動し、Python ウィンドウを表示させて以下のコードを実行することで確認することができます。  import sys sys.executable     [引数の追加 (オプション)] で実行する Python スクリプトのファイル名を指定 [開始 (オプション)] で Python スクリプトが格納されているディレクトリを指定    \r指定するパス等にスペースが含まれている場合はダブル クォーテーションで囲んでください。\nまた半角括弧 () が含まれるパスを指定すると正常に動作しないため、ディレクトリ名などを変更してください\n\r OK ボタンをクリックし、要求された場合はユーザーアカウント情報を入力  Linux の cron を使用する場合 Linux で特定のタスクを定期実行する場合は cron が用いられます。\ncron は任意のタスクを任意の時間にバックグラウンドで実行するデーモンです。実行する内容は crontab と呼ばれるテキスト ファイルに記述します。\n設定方法は以下のとおりです。\ncrontab を開く  以下のコマンドを Bash ターミナルから実行   crontab -e\r 次のような使用するテキスト エディタを選択する画像が表示された場合、任意の番号のテキストエディタを選択します (今回は 1 番を選択)。  \rcrontab を編集する  crontab の編集画面が開くので次のとおり実行する内容を記述  */30 * * * * cd /home/\u0026lt;ユーザー名\u0026gt;/py-script \u0026amp;\u0026amp; /home/\u0026lt;ユーザー名\u0026gt;/anaconda3/envs/arcgis171/bin/python task.py\r\r 記述した内容の概要は以下のとおりです  */30 * * * *  30分に一回の実行間隔を指定   cd /home/\u0026lt;ユーザー名\u0026gt;/py-script  cd コマンドでカレントのディレクトリを実行するスクリプトと設定ファイルが格納されているディレクトリに移動 ※ ここではログインしているユーザーのホーム ディレクトリ直下に配置していると想定   \u0026amp;\u0026amp;  連続してコマンドを実行する場合に用いるオペレーター   /home/\u0026lt;ユーザー名\u0026gt;/anaconda3/envs/arcgis171/bin/python  実行する Python のパスを指定   task.py  実行する Python スクリプトを指定      上記の内容は Anaconda3 をインストールして構築した ArcGIS API for Python の実行環境を想定しています。詳細はインストールガイドを参照ください。\nより詳細な cron の使い方はubuntu の Community Help Wiki の Cron How to をご覧下さい。\n\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/deployment/",
	"title": "デプロイの紹介",
	"tags": [],
	"description": "開発したアプリをデプロイするために必要なライセンスや利用規約などについて紹介します。",
	"content": "出典：ArcGIS Location Platform - Deployment\nアプリケーションをデプロイするためのライセンスと配布の要件は、開発するアプリケーションのタイプと使用する API によって決まります。これには、Web、ネイティブ、およびサービスベースのアプリケーションが含まれます。このヘルプ トピックでは、ソリューションをデプロイする前に知っておく必要がある情報について説明します。\nアプリケーションをデプロイする前に、必ず利用規約を確認してください。 使用条件に従わない特別な導入要件がある場合はお問い合わせください。\n\rすべての ArcGIS Location Platform アカウントには、サブスクリプション プランが関連付けられています。各サブスクリプションには、無料枠のロケーション サービスが付属しており、従量課金は無効になっています。このアカウントを使用して、API キーまたは OAuth 2.0 のいずれかを使用してロケーション サービスにアクセスするアプリケーションを構築できますが、利用できるのは無料レベルの使用量でアクセスできるロケーション サービスのみです。すべてのロケーション サービスにアクセスするには、従量課金を有効にする必要があります。利用可能な機能の一覧については、以下の表をご確認ください。\nアプリケーションが特定の課金サイクルで無料枠を超えて使用した場合、従量課金を有効にしない限り、サービスへのアクセスは無効になります。従量課金は、アカウントのサブスクリプションの課金設定で構成することができます。従量課金と課金について詳しくはこちらをご覧ください。\nすべてのロケーション サービスのトランザクションは米ドルで課金されます。サービスの利用料については、価格をご確認ください。\nアプリケーションを導入する前に、従量課金を有効にして、中断のないサービス アクセスを確保することをお勧めします。\n\r    無料枠 従量課金     ベースマップ 〇 〇   プレイス 〇 〇   住所検索 (データ保存しない) 〇 〇   住所検索 (データ保存する) × 〇   ルート検索 〇 〇   ルート検索（経由地の最適化） × 〇   到達圏 〇 〇   配車ルート解析 × 〇   最寄りの検索 × 〇   ラスト マイル デリバリー × 〇   ロケーション-アロケーション × 〇   移動コスト マトリックス × 〇   インフォグラフィックス × 〇   レポート作成 × 〇   標高サービス 〇 〇   空間解析 × 〇   タイル、ファイル、アタッチメントの保存 (250 MB) 〇 〇   フィーチャの保存 (250 MB) 〇 〇   フィーチャのクエリ (転送量、125 MB) 〇 〇   フィーチャの編集 (転送量、125 MB) 〇 〇    〇：対応　△：一部対応　×：未対応\nWeb アプリケーション Web アプリケーションは、ArcGIS Maps SDK for JavaScript、オープン ソース、またはその他の API を使用して構築します。\nWeb アプリケーションを構築してデプロイするには、以下が必要です。\n ArcGIS Location Platform アカウント 利用規約への同意  \r\r アプリケーション例  クライアントサイド、静的、単一 Web ページアプリケーション フロントエンドとバックエンドの技術を使用した動的な Web アプリケーション プログレッシブ Web アプリ (PWA) リッチインターネットアプリ (RIA、Web アプリをカプセル化したデスクトップ、または、モバイルのハイブリッドアプリ) ブラウザと IDE の拡張機能  注意：ここに掲載されていない種類の Web プリケーションも開発できる可能性があります。\n\r\r\rネイティブ アプリケーション ネイティブ アプリケーションは、ArcGIS Maps SDK for Native Apps のいずれかを使用して構築され、デスクトップ、モバイル デバイス、または、組み込みシステムにデプロイされます。ネイティブ アプリケーションは、Microsoft Windows Installer（.msi）などの様々なインストーラー テクノロジを使用するか、Google Play ストア、Apple App Store、Microsoft Store、または ArcGIS Marketplace で展開できます。\nネイティブ アプリケーションを構築してデプロイするには、以下が必要です。\n ArcGIS Location Platform アカウント 利用規約への同意 ArcGIS Runtime ライセンス文字列、または、ユーザー認証の実装。これにより、アプリケーションの「ロックが解除」され、マップおよびコンソール ログに表示される「Licensed for Developer Use Only」のウォーターマーク (透かし)が削除されます。  ArcGIS Runtime ライセンス文字列の取得方法については、以下の「License and deployment」のセクションをご確認ください。\n ArcGIS Maps SDK for .NET ArcGIS Maps SDK for Swift ArcGIS Maps SDK for Kotlin ArcGIS Maps SDK for Java ArcGIS Maps SDK for Qt  Runtime ライセンス文字列は、ArcGIS Runtime SDKs 100.x および ArcGIS Maps SDKs for Native Apps 200.x で使用されます。ネイティブ アプリケーションが ArcGIS ロケーション サービスを使用する場合でも、ロケーション サービスにアクセスするには有効なアクセス トークンが必要です。\n\r\r\r\rアプリケーション例  スマートフォン、または、タブレット用のモバイルアプリ デスクトップ アプリ (Linux、macOS、Windows)  注：ここに掲載されていない種類のネイティブ アプリケーションも開発できる可能性があります。\n\r\r\rゲームエンジン アプリケーション ゲームエンジン アプリケーションは、ArcGIS Maps SDKs のいずれかを使用して構築され、サポート対象のデバイス、オペレーティング システム、または組み込みシステムにデプロイされます。\nゲームエンジン アプリケーションを構築してデプロイするには、以下が必要です。\n ArcGIS Location Platform アカウント 利用規約への同意 ArcGIS Maps SDK for Unity ガイドのデプロイメント もしくは、ArcGIS Maps SDK for Unreal Engine ガイドのデプロイメントを参照  ゲームエンジン アプリケーションが ArcGIS のロケーション サービスを使用する場合、ロケーション サービスにアクセスするには有効なアクセス トークンが必要です。\n\r\r\r\rアプリケーション例  Android、または iOS の携帯電話、または、タブレット用アプリ スタンドアロン Windows プラットフォーム、または、ユニバーサル Windows アプリケーション macOS アプリケーション XR プラットフォーム向け AR/VR アプリケーション  注：ここに掲載されていない種類のゲームエンジン アプリケーションも開発できる可能性があります。\n\r\r\rサービス ベース アプリケーション サービス ベースのアプリケーションは、ArcGIS のロケーション サービスを使用するもので、エンド ユーザー インタフェースを持たない場合があります。ロケーション サービス、API、ライブラリ、または、その他のバックエンド機能を使用できます。サービス ベースのアプリケーションは、Esri 以外のクライアント側 API で構築されたサービスやプロセス、Web フック、その他のスケジュールされたプロセスなど、ユーザーとのインタラクションによってトリガーされます。\n通常、これらのアプリケーションは、REST API サービスのエンドポイント、Node.js アプリ内の ArcGIS REST JS、または ArcGIS Maps SDK for JavaScript のモジュール、または ArcGIS API for Python を使用して構築されます。\nサービス ベース アプリケーションを構築してデプロイするには、以下が必要です。\n ArcGIS Location Platform アカウント 利用規約への同意  ArcGIS Maps SDKs for Native Apps は、サービスベースのアプリケーションの構築には使用できません。\n\r\r\r\rアプリケーション例  Web サービス REST アプリケーション スクリプト アプリケーション 内部ライブラリ 開発者向け API M2M (Machine to Machine)  注：ここに掲載されていない種類のサービスベースのアプリケーションも開発できる可能性があります。\n\r\r\rベースマップの帰属 ベースマップ スタイル サービスを使用するマッピング アプリケーションを構築、およびデプロイする場合は、ベースマップの帰属表示が必要です。ベースマップの帰属については、こちらをご確認ください。\n3rd party データ 多くの組織は、ArcGIS で独自のコンテンツやデータをホストし、ArcGIS Online、ArcGIS Hub、または ArcGIS Living Atlas of the World を通じて利用できるようにしています。これらのデータをアプリケーションで使用する前に、利用規約を準拠する必要があり、組織によって定義されている場合は、帰属表示を行う必要があります。利用規約は通常、各データ プロバイダによって異なります。\nデプロイ サポート機能 アプリケーションに実装されている ArcGIS サービスに基づくデプロイの種類については、以下の表をご確認ください。\n    ArcGIS Location Platform サブスクリプション     プライベート アプリケーションの構築とデプロイ 〇   公開アプリケーションの構築とデプロイ 〇   無料 (非商用) アプリケーションの構築とデプロイ 〇   商用アプリケーションの構築とデプロイ 〇   ArcGIS およびオープン ソース API を使用した Web アプリケーションの構築 〇   ArcGIS およびオープン ソース API を使用したネイティブ アプリケーションの構築 〇   ArcGIS およびオープン ソース API を使用したサービス ベースのアプリケーションの構築 〇   ArcGIS のプライベート コンテンツにアクセスするアプリケーションの構築とデプロイ 〇   Living Atlas のオープン データを使用するアプリケーションの構築とデプロイ △1   Living Atlas の加入者データを使用するアプリケーションの構築とデプロイ △1   アプリケーション ストアを通じたアプリケーションの配布\t 〇   ArcGIS Marketplace を通じたアプリケーションの配布 △2   オフライン機能を備えたアプリケーションの配布 △1    〇：対応　△：一部対応　×：未サポート\n お問い合わせください。 Esri パートナーとしてサインアップする必要があります。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/visualization/",
	"title": "データ ビジュアライゼーション",
	"tags": [],
	"description": "地図にデータを可視化する際の Tips を紹介します。",
	"content": "地図にデータを可視化する際の Tips を紹介します。\n データ可視化のワークフロー\nマップ ビューアーを使用した地図上でのデータ可視化のプロセスを紹介します。\n\r データ可視化の手順\nArcGIS Online 上のデータを可視化するための方法を紹介します。\n\r 地図上に賢くデータを可視化するための 6 つの方法\nマップ ビューアーを使って地図データを賢く可視化するために おさえておくべき６つの方法を紹介します。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/layout/",
	"title": "レイアウト（Layout）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Layout\nレイアウト（Layout） レイアウトは、レイアウト コンテナーにコンテンツを配置する方法を定義します。コンテンツには、ウィジェット、セクション、または画面グループが含まれ、レイアウト コンテナーには、ページ、ビュー、またはダイアログなどがあります。ArcGIS Experience Builder には、いくつかのレイアウト規則があります。たとえば、新しいページを作成するときに、Fixed レイアウトまたは Flow レイアウトを選択したり、Layout ウィジェットを使用して異なるレイアウトを作成したりすることができます。\nアプリ コンフィグでは、レイアウトは layouts プロパティで定義され、レイアウト コンテナーは layout id でレイアウトを参照します。レイアウト コンテナーには、異なるサイズ モードでのレイアウトを定義する layout オブジェクト プロパティがあります。Experience Builder では、Large、Medium、Small の各サイズ モードをサポートしています。レイアウトが定義されていないサイズ モードでは、アプリの設定で定義された mainSizeMode レイアウトが使用されます。\nフレームワークのレイアウト コンテナーの他に、ウィジェットもレイアウト コンテナーになることができます。ウィジェットがレイアウト コンテナになると，ユーザーは他のウィジェットをドラッグ アンド ドロップすることができます。例えば、Map や Card はレイアウト コンテナー ウィジェットです。レイアウト コンテナー ウィジェットは、manifest.json で layouts プロパティを宣言し、LayoutEntry コンポーネントを使用する必要があります。パフォーマンス上の理由から、以下のロジックを使用する必要があります。\nimport {LayoutEntry} from \u0026#39;jimu-layouts/layout-runtime\u0026#39; let LayoutEntryComponent if (window.jimuConfig.isInBuilder) { LayoutEntryComponent = this.props.builderSupportModules.LayoutEntry } else { LayoutEntryComponent = LayoutEntry } "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-android/",
	"title": "Android",
	"tags": [],
	"description": "ArcGIS Maps SDK for Kotlin を用いたネイティブ地図アプリの作成方法を紹介します。",
	"content": "出典：ArcGIS Maps SDK for Kotlin - Tutorials - Display a map\nマップを表示する このチュートリアルでは ArcGIS Maps SDK for Kotlin を使用して、マップとベースマップ レイヤーを表示する方法を紹介します。\nマップには、地理データのレイヤーが含まれています。マップには、ベースマップ レイヤーと、オプションで 1 つ以上のデータ レイヤーを追加できます。マップ ビューを使用し、場所とズーム レベルを設定することで、マップの特定の領域を表示できます。\nこのチュートリアルでは、地形図ベースマップ レイヤーを使用して、富士山付近を表示する地図を作成します。\nこのチュートリアルのトピックの背景情報については、Mapping API and location services guide の Maps (2D) と ベースマップ を参照してください。\n\r前提条件 このチュートリアルを実施するには、以下が必要です。\n API キーにアクセスするための ArcGIS 開発者アカウント。アカウントをお持ちでない場合は、サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。 開発環境がシステム要件を満たしていることを確認します。 Kotlin で Android 開発をするための IDE。  このチュートリアル アプリを作成するには、最新の安定板 Android Studio を使用することが推奨されます。ただし、以下の手順で説明されているコードは Kotlin をサポートする最新の Android IDE であれば、どれでも動作するはずです。\n\r認証の設定 このチュートリアルで使用するセキュアな ArcGIS ロケーション サービスにアクセスするには、ArcGIS Location Platform または ArcGIS Online アカウントを使用して、API キー認証またはユーザー認証を実装する必要があります。\nこのチュートリアルでは、API キー認証またはユーザー認証を実装することができます。以下の違いを比較してください。\nAPI キー認証  ユーザーはサインインする必要がありません。 適切な権限を持つ API キーの認証情報を作成する必要があります。 API キーは長期間のアクセス トークンです。 サービス使用料は API キーの所有者/開発者に請求されます。 実装が最も簡単な認証方法です。 新規の ArcGIS 開発者に推奨される方法です。  詳しくは API キー認証をご覧ください。\nこのチュートリアルで使用するセキュアなリソースにアクセスする権限を持つ、新しい API キーのアクセス トークンを作成します。\n API キーの作成のチュートリアルを完了し、以下の権限を持つ API キーを作成します。  Privileges  Location services \u0026gt; Basemaps     API キーのアクセス トークン をコピーし、安全な場所に貼り付けます。これは後のステップで使用します。  ユーザー認証  ユーザーは、ArcGIS アカウントでサインインする必要があります。 ユーザー アカウントには、アプリケーションで使用する ArcGIS サービスにアクセスする権限が必要です。 OAuth 認証情報の作成が必要です。 アプリケーションは、リダイレクト URL とクライアント ID を使用します。 サービスの使用料は、アプリケーションにサインインしたユーザーの組織に請求されます。  詳しくは、ユーザー認証をご覧ください。\nこのチュートリアルで使用するセキュアなリソースにアクセスするための新しい OAuth 認証情報を作成します。\n  ユーザー認証用の OAuth 認証情報を作成するチュートリアルを完了します。\n  ClientID と RedirectURL をコピーして安全な場所に貼り付けます。これらは後のステップで使用します。\n  このアプリケーションにアクセスするすべてのユーザーには、ベースマップ スタイル サービスにアクセスするためのアカウント権限が必要です。\nセキュリティと認証ガイド : 認証の種類について詳しくは、認証の種類をご覧ください。\n\r開発またはダウンロード このチュートリアルを完了するには、2 つの選択肢があります。\n オプション 1:コードを開発する か オプション 2:完成したソリューションをダウンロードする  オプション 1:コードを開発する 新しい Android Studio プロジェクトを作成する Android Studio を使用してアプリを作成し、API を参照するように構成します。\n  Android Studio を開きます。\n [Welcome to Android Studio] ウィンドウで [New Project] をクリックします。\nまたは、メニュー バーで [File] → [New] → [New Project] をクリックします。 [Create New Project] ウィンドウで、[Phone and Tablet] タブが選択されていることを確認してから、[Empty Activity] を選択して、[Next] をクリックします。 次のウィンドウで、以下の項目を設定し、[Finish] をクリックします。  Name: Tutorial Package name： com.example.app に変更します。または、組織に合わせて変更してください。 Save location: 新しいフォルダーに設定します。 Minimum SDK: API 28 (\u0026ldquo;Pie\u0026rdquo;; Android 9.0) Build configuration language: Kotlin DSL (build.gradle.kts)      [プロジェクト] のツール ウィンドウで、現在のビューが [Android] であることを確認してください。チュートリアルの説明では、そのビューを参照しています。\nビュー名が [Android] 以外の名前 （[プロジェクト]や[パッケージ]など） の場合、プロジェクト ツール ウィンドウのタイトル バーの左端のコントロールをクリックし、リストから [Android] を選択します。   [Android] ビューから、[Gradle Scripts] \u0026gt; [build.gradle.kts (Project: Tutorial)] を開きます。ファイルの内容を次のコードに置き換えます。\nbuild.gradle.kts (Project: Tutorial)\n// すべてのサブプロジェクト/モジュールに共通の構成オプションを追加できる最上位のビルド ファイル plugins { alias(libs.plugins.android.application) apply false alias(libs.plugins.kotlin.android) apply false alias(libs.plugins.kotlin.compose) apply false }   [Android] ビューから、[Gradle Scripts] \u0026gt; [build.gradle.kts (Module: app)] を開きます。ファイルの内容を次のコードに置き換えます。\nbuild.gradle.kts (Module: app)\nplugins { alias(libs.plugins.android.application) alias(libs.plugins.kotlin.android) alias(libs.plugins.kotlin.compose) } android { namespace = \u0026#34;com.example.app\u0026#34; compileSdk = libs.versions.compileSdk.get().toInt() defaultConfig { applicationId = \u0026#34;com.example.app\u0026#34; minSdk = libs.versions.minSdk.get().toInt() targetSdk = libs.versions.targetSdk.get().toInt() versionCode = 1 versionName = \u0026#34;1.0\u0026#34; testInstrumentationRunner = \u0026#34;androidx.test.runner.AndroidJUnitRunner\u0026#34; vectorDrawables { useSupportLibrary = true } } buildTypes { release { isMinifyEnabled = false proguardFiles(getDefaultProguardFile(\u0026#34;proguard-android-optimize.txt\u0026#34;), \u0026#34;proguard-rules.pro\u0026#34;) } } compileOptions { sourceCompatibility = JavaVersion.VERSION_17 targetCompatibility = JavaVersion.VERSION_17 } kotlinOptions { jvmTarget = \u0026#34;17\u0026#34; } buildFeatures { compose = true } packaging { resources { excludes += \u0026#34;/META-INF/{AL2.0,LGPL2.1}\u0026#34; } } } dependencies { implementation(libs.androidx.core.ktx) implementation(libs.androidx.lifecycle.runtime.ktx) implementation(libs.androidx.activity.compose) implementation(platform(libs.androidx.compose.bom)) implementation(libs.androidx.ui) implementation(libs.androidx.ui.graphics) implementation(libs.androidx.ui.tooling.preview) implementation(libs.androidx.material3) testImplementation(libs.junit) androidTestImplementation(libs.androidx.junit) androidTestImplementation(libs.androidx.espresso.core) androidTestImplementation(platform(libs.androidx.compose.bom)) androidTestImplementation(libs.androidx.ui.test.junit4) debugImplementation(libs.androidx.ui.tooling) debugImplementation(libs.androidx.ui.test.manifest) // ArcGIS Maps for Kotlin - SDK dependency  implementation(libs.arcgis.maps.kotlin) // Toolkit dependencies  implementation(platform(libs.arcgis.maps.kotlin.toolkit.bom)) implementation(libs.arcgis.maps.kotlin.toolkit.geoview.compose) implementation(libs.arcgis.maps.kotlin.toolkit.authentication) } Kotlin 2.0+ では、Compose Compiler Gradle プラグインが必要です。このプラグインは、build.gradle.kts(Module :app)の plugins ブロックで alias(libs.plugins.kotlin.compose) として参照され、libs.versions.toml ファイルでは kotlin-compose = { id = \u0026quot;org.jetbrains.kotlin.plugin.compose\u0026quot;, version.ref = \u0026quot;kotlin\u0026quot; } として宣言されています。Compose Compiler Gradle プラグインと Kotlin Android プラグインのバージョンは同じです。\n2.0 より前の Kotlin バージョンを使用している場合は、Compose コンパイラーと Kotlin コンパイラーのバージョンが互換性があることを確認する必要があります。詳細については、Compose to Kotlin Compatibility Map を参照してください。\n  [Android] ビューから、[Gradle Scripts] \u0026gt; [libs.versions.toml] を開きます。[version] セクションで、ArcGIS Maps SDK for Kotlin のバージョン番号を宣言します。また、[libraries] セクションには、以下のライブラリの宣言を追加します。\n ArcGIS Maps SDK for Kotlin SDK ArcGIS Maps SDK for Kotlin Toolkit BOM アプリで使用するすべてのツールキット コンポーネント。マップビューまたはシーンビューを表示するには、コンポーザブルな MapView とSceneView を含む geoview-compose モジュールの宣言が必要です。ユーザー認証を実装するには、authentication モジュールが必要です。  Toolkit BOM のバージョンは、宣言したすべての Toolkit コンポーネントに適用されます。\nGradle バージョン カタログは依存関係のバージョンを宣言するための標準的な Android のアプローチです。build.gradle.kts でバージョン番号を指定したり、version.gradle でバージョン番号を列挙するよりも推奨されます。Android Studio の最近のリリースでは、[New Project Wizard] がこの標準をサポートする build.gradle.kts と gradle/libs.version.toml ファイルを生成します。\nGradle バージョン カタログでは、BOM ファイルを使用して、BOM 内のすべての成果物に対して単一のバージョン番号を指定することもできます。詳細については、ArcGIS Maps SDK for Kotlin Toolkit の README の Using the BOM を参照してください。\ngradle/libs.versions.toml\n[versions] arcgisMapsKotlin = \u0026#34;200.8.0\u0026#34; [libraries] arcgis-maps-kotlin = { group = \u0026#34;com.esri\u0026#34;, name = \u0026#34;arcgis-maps-kotlin\u0026#34;, version.ref = \u0026#34;arcgisMapsKotlin\u0026#34; } arcgis-maps-kotlin-toolkit-bom = { group = \u0026#34;com.esri\u0026#34;, name = \u0026#34;arcgis-maps-kotlin-toolkit-bom\u0026#34;, version.ref = \u0026#34;arcgisMapsKotlin\u0026#34; } arcgis-maps-kotlin-toolkit-geoview-compose = { group = \u0026#34;com.esri\u0026#34;, name = \u0026#34;arcgis-maps-kotlin-toolkit-geoview-compose\u0026#34; } arcgis-maps-kotlin-toolkit-authentication = { group = \u0026#34;com.esri\u0026#34;, name = \u0026#34;arcgis-maps-kotlin-toolkit-authentication\u0026#34; }  libs.versions.toml を手で編集しないでください。代わりに、以下のコードを展開し、展開した内容をすべてコピーして libs.versions.toml ファイルに貼り付け、新規プロジェクト ウィザードで生成された元の内容を置き換えてください。\ngradle/libs.versions.toml\n[versions] arcgisMapsKotlin = \u0026#34;200.8.0\u0026#34; # Version numbers added by Android Studio New Project Wizard agp = \u0026#34;8.9.2\u0026#34; kotlin = \u0026#34;2.1.20\u0026#34; coreKtx = \u0026#34;1.16.0\u0026#34; junit = \u0026#34;4.13.2\u0026#34; junitVersion = \u0026#34;1.2.1\u0026#34; espressoCore = \u0026#34;3.6.1\u0026#34; lifecycleRuntimeKtx = \u0026#34;2.8.7\u0026#34; activityCompose = \u0026#34;1.10.1\u0026#34; composeBom = \u0026#34;2025.04.00\u0026#34; # Other version numbers compileSdk = \u0026#34;36\u0026#34; minSdk = \u0026#34;28\u0026#34; targetSdk = \u0026#34;36\u0026#34; [libraries] arcgis-maps-kotlin = { group = \u0026#34;com.esri\u0026#34;, name = \u0026#34;arcgis-maps-kotlin\u0026#34;, version.ref = \u0026#34;arcgisMapsKotlin\u0026#34; } arcgis-maps-kotlin-toolkit-bom = { group = \u0026#34;com.esri\u0026#34;, name = \u0026#34;arcgis-maps-kotlin-toolkit-bom\u0026#34;, version.ref = \u0026#34;arcgisMapsKotlin\u0026#34; } arcgis-maps-kotlin-toolkit-geoview-compose = { group = \u0026#34;com.esri\u0026#34;, name = \u0026#34;arcgis-maps-kotlin-toolkit-geoview-compose\u0026#34; } arcgis-maps-kotlin-toolkit-authentication = { group = \u0026#34;com.esri\u0026#34;, name = \u0026#34;arcgis-maps-kotlin-toolkit-authentication\u0026#34; } androidx-core-ktx = { group = \u0026#34;androidx.core\u0026#34;, name = \u0026#34;core-ktx\u0026#34;, version.ref = \u0026#34;coreKtx\u0026#34; } junit = { group = \u0026#34;junit\u0026#34;, name = \u0026#34;junit\u0026#34;, version.ref = \u0026#34;junit\u0026#34; } androidx-junit = { group = \u0026#34;androidx.test.ext\u0026#34;, name = \u0026#34;junit\u0026#34;, version.ref = \u0026#34;junitVersion\u0026#34; } androidx-espresso-core = { group = \u0026#34;androidx.test.espresso\u0026#34;, name = \u0026#34;espresso-core\u0026#34;, version.ref = \u0026#34;espressoCore\u0026#34; } androidx-lifecycle-runtime-ktx = { group = \u0026#34;androidx.lifecycle\u0026#34;, name = \u0026#34;lifecycle-runtime-ktx\u0026#34;, version.ref = \u0026#34;lifecycleRuntimeKtx\u0026#34; } androidx-activity-compose = { group = \u0026#34;androidx.activity\u0026#34;, name = \u0026#34;activity-compose\u0026#34;, version.ref = \u0026#34;activityCompose\u0026#34; } androidx-compose-bom = { group = \u0026#34;androidx.compose\u0026#34;, name = \u0026#34;compose-bom\u0026#34;, version.ref = \u0026#34;composeBom\u0026#34; } androidx-ui = { group = \u0026#34;androidx.compose.ui\u0026#34;, name = \u0026#34;ui\u0026#34; } androidx-ui-graphics = { group = \u0026#34;androidx.compose.ui\u0026#34;, name = \u0026#34;ui-graphics\u0026#34; } androidx-ui-tooling = { group = \u0026#34;androidx.compose.ui\u0026#34;, name = \u0026#34;ui-tooling\u0026#34; } androidx-ui-tooling-preview = { group = \u0026#34;androidx.compose.ui\u0026#34;, name = \u0026#34;ui-tooling-preview\u0026#34; } androidx-ui-test-manifest = { group = \u0026#34;androidx.compose.ui\u0026#34;, name = \u0026#34;ui-test-manifest\u0026#34; } androidx-ui-test-junit4 = { group = \u0026#34;androidx.compose.ui\u0026#34;, name = \u0026#34;ui-test-junit4\u0026#34; } androidx-material3 = { group = \u0026#34;androidx.compose.material3\u0026#34;, name = \u0026#34;material3\u0026#34; } [plugins] android-application = { id = \u0026#34;com.android.application\u0026#34;, version.ref = \u0026#34;agp\u0026#34; } kotlin-android = { id = \u0026#34;org.jetbrains.kotlin.android\u0026#34;, version.ref = \u0026#34;kotlin\u0026#34; } kotlin-compose = { id = \u0026#34;org.jetbrains.kotlin.plugin.compose\u0026#34;, version.ref = \u0026#34;kotlin\u0026#34; }  \r  [Android] ビューから、[Gradle Scripts] \u0026gt; [settings.gradle.kts] を開きます。ファイルの内容を次のコードに置き換えます。\nsettings.gradle.kts (Tutorial)\npluginManagement { repositories { google { content { includeGroupByRegex(\u0026#34;com\\\\.android.*\u0026#34;) includeGroupByRegex(\u0026#34;com\\\\.google.*\u0026#34;) includeGroupByRegex(\u0026#34;androidx.*\u0026#34;) } } mavenCentral() gradlePluginPortal() } } dependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { google() mavenCentral() maven { url = uri(\u0026#34;https://esri.jfrog.io/artifactory/arcgis\u0026#34;) } } } rootProject.name = \u0026#34;Tutorial\u0026#34; include(\u0026#34;:app\u0026#34;)   Gradle の変更を同期します。[Sync now] プロンプトをクリックするか、ツール バーの更新アイコン ([Sync Project with Gradle Files]) をクリックします。同期に数分かかるかもしれません。\n  [Android] ビューから、[app] \u0026gt; [manifests] \u0026gt; [AndroidManifest.xml] を開きます。Android マニフェストを更新して、インターネット接続を許可します。\nこれらの新しい要素を manifest 要素内に挿入します。 他のステートメントを変更または削除しないでください。\n今後のチュートリアルで追加する ArcGIS の機能によっては、マニフェストに追加のアクセス許可を追加する必要がある可能性があります。\nAndroidManifest.xml\n\u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;!--追加開始--\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34;/\u0026gt; \u0026lt;!--追加終了--\u0026gt; \u0026lt;application ・・・   マップを作成する   [Android] ビューから、[app] \u0026gt; [Kotlin+java] \u0026gt; [com.example.app] を右クリックし、リストから [New] \u0026gt; [package] を選択します。パッケージ名に com.example.app.screens と入力し、キーボードの Enter キーを押します。このステップで、すべての UI ファイルを含む新しいパッケージが作成されます。\n  作成した screens パッケージを右クリックし、リストから [New] \u0026gt; [Kotlin Class/File] を選択します。ポップアップ ウィンドウで [File] を選択し、ファイル名に MainScreen と入力し、キーボードの Enter キーを押します。\n  MainScreen.kt で、Android Studio によって自動的に挿入されたコード行をすべて削除します。次に、以下のオプトイン アノテーション、パッケージ名、インポートを追加します。\n以下のコード ブロックでコンポーザブル関数 com.arcgismaps.tookit.geoviewcompose.MapView をインポートしていることを確認してください。これは ArcGIS Maps SDK for Kotlin Toolkit で定義されています。コンポーザブルに対応したコードでは ArcGIS Maps SDK API の com.arcgismaps.mapping.view.MapView という名前のクラスは使用しないでください。\n\rMainScreen.kt\n@file:OptIn(ExperimentalMaterial3Api::class) package com.example.app.screens import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.foundation.layout.padding import androidx.compose.material3.ExperimentalMaterial3Api import androidx.compose.material3.Scaffold import androidx.compose.material3.Text import androidx.compose.material3.TopAppBar import androidx.compose.runtime.Composable import androidx.compose.runtime.remember import androidx.compose.ui.Modifier import androidx.compose.ui.res.stringResource import com.arcgismaps.mapping.ArcGISMap import com.arcgismaps.mapping.BasemapStyle import com.arcgismaps.mapping.Viewpoint import com.arcgismaps.toolkit.geoviewcompose.MapView import com.example.app.R   ArcGISMap を返す createMap() という名前のトップ レベル関数を作成します。\nMainScreen.kt\n// 追加開始 fun createMap(): ArcGISMap { } // 追加終了   BasemapStyle.ArcGISTopographic を使用して ArcGISMap を作成し、マップ上で apply{} を呼び出します。この関数は ArcGISMap を返します。\napply {} の詳細については Kotlin の Scope functions を参照してください。\nMainScreen.kt\nfun createMap(): ArcGISMap { // 追加開始  return ArcGISMap(BasemapStyle.ArcGISTopographic).apply { } // 追加終了  }   apply ブロックで、x (経度) と y (緯度) の座標と縮尺を持つ Viewpoint を作成します。この Viewpoint を ArcGISMap の initialViewpoint プロパティに割り当てます。\nまた、ベースマップのデフォルトのラベル表示は英語のため、日本語に変更します。\nMainScreen.kt\nfun createMap(): ArcGISMap { // 追加開始  val basemapStyleParams = BasemapStyleParameters() basemapStyleParams.languageStrategy = BasemapStyleLanguageStrategy.Specific(Locale(\u0026#34;ja\u0026#34;)) // 追加終了  // 追加修正開始  return ArcGISMap(basemap = Basemap(BasemapStyle.ArcGISTopographic, basemapStyleParameters = basemapStyleParams)).apply { initialViewpoint = Viewpoint( latitude = 35.360626, longitude = 138.727363, scale = 200000.0 ) // 追加修正終了  } }   マップを保持する MainScreen を作成する   MapView を呼び出す MainScreen という名前のコンポーザブル関数を作成します。\nMainScreen.kt\n// 追加開始 @Composable fun MainScreen() { } // 追加終了  fun createMap(): ArcGISMap { ・・・   remember ブロックを追加し、その中で createMap() を呼び出します。そして remember を map というローカル変数に割り当てます。\nトップ レベルのコンポーザブル関数 remember は再構成時に状態を保持するために使用されます。\nMainScreen.kt\n@Composable fun MainScreen() { // 追加開始  val map = remember { createMap() } // 追加終了  }   Android Jetpack Compose からいくつかのコンポーザブル関数を呼び出します。Scaffold を呼び出し、アプリ名 (R.string.app_name) を含む Text で TopAppBar を渡します。\nMainScreen.kt\n@Composable fun MainScreen() { val map = remember { createMap() } // 追加開始  Scaffold( topBar = { TopAppBar(title = { Text(text = stringResource(id = R.string.app_name)) }) } ) { } // 追加終了  }   Scaffold の末尾のラムダで、ArcGIS Maps SDK for Kotlin Toolkit で定義されている MapView コンポーザブルを呼び出し、最大サイズとデフォルトのパディングを持つ Modifier を設定します。そして、map を arcGISMap パラメーターとして渡します。\nMainScreen.kt\n@Composable fun MainScreen() { val map = remember { createMap() } Scaffold( topBar = { TopAppBar(title = { Text(text = stringResource(id = R.string.app_name)) }) } ) { // 追加開始  MapView( modifier = Modifier.fillMaxSize().padding(it), arcGISMap = map ) // 追加終了  } }   MainActivity クラス内で MainScreen を呼び出す   [app] \u0026gt; [kotlin+java] \u0026gt; [com.example.app] の MainActivity.kt を開きます。ファイル内のコードをすべて削除します。パッケージ宣言、import 文、 MainActivity クラスを追加します。\nMainActivity.kt\n//追加開始 package com.example.app import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import androidx.activity.enableEdgeToEdge import com.arcgismaps.ApiKey import com.arcgismaps.ArcGISEnvironment import com.arcgismaps.httpcore.authentication.OAuthUserConfiguration import com.arcgismaps.toolkit.authentication.AuthenticatorState import com.arcgismaps.toolkit.authentication.DialogAuthenticator import com.example.app.screens.MainScreen import com.example.app.ui.theme.TutorialTheme class MainActivity : ComponentActivity() { } //追加終了   onCreate() ライフサイクル関数の setContent ブロックでは、デフォルトのテーマが適用されたコンポーザブル関数 MainScreen を呼び出します。これを行うには、onCreate() に以下のコードを追加します。\nMainActivity.kt\nclass MainActivity : ComponentActivity() { // 追加開始  override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { DisplayAMapTheme { MainScreen() } } } // 追加終了 }   開発者認証情報を設定する アプリのユーザーが ArcGIS Location Services にアクセスできるようにするには、認証の設定 ステップで作成した開発者認証情報を使用して、リソースへの要求を認証します。\nAPI キーでの認証 API キーを使用すると、ArcGIS Online でホストされているサービス、Web マップ、および Web シーンにアクセスできるようになります。\n  Android Studio の [Android] ビューで、[app] \u0026gt; [kotlin+java] \u0026gt; [com.example.app] \u0026gt; [MainActivity] を開きます。\n  MainActivity クラスの onCreate() ライフサイクル メソッドで、ApiKey.create() を呼び出して ArcGISEnvironment.apiKey プロパティを設定します。API キーのアクセス トークンを文字列として渡し、二重引用符を忘れないでください。これは setContent ブロックの前に行います。\nMainActivity.kt\nclass MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) //追加開始  ArcGISEnvironment.apiKey = ApiKey.create(\u0026#34;YOUR_ACCESS_TOKEN\u0026#34;) //追加終了  enableEdgeToEdge() setContent { TutorialTheme { MainScreen() } } } }  ベスト プラクティス: アクセス トークンは、このチュートリアルの便宜のためにコードに直接格納されています。本番環境では、認証情報をソース コードに直接保存しないでください。\n\r  ユーザー認証   Android Studio の [Android] ビューで、[app] \u0026gt; [kotlin+java] \u0026gt; [com.example.app] \u0026gt; [MainActivity] を開きます。MainActivity クラスで、ArcGIS Maps SDK for Kotlin Toolkit の authentication モジュール AuthenticatorState のインスタンスを作成します。これを setContent ブロックの前に追加します。\nMainActivity.kt\nclass MainActivity : ComponentActivity() { //追加開始  private val authenticatorState = AuthenticatorState() //追加終了  override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) enableEdgeToEdge() setContent { TutorialTheme { MainScreen() } } } }   MainActivity クラスの onCreate() ライフサイクル メソッドで、OAuthUserConfiguration をインスタンス化して authenticatorState.oAuthUserConfiguration プロパティを設定します。以前のステップで作成した clientId と redirectURL を渡します。\nredirectURL は、scheme と host コンポーネントで構成されます。リダイレクト URL の形式は scheme://host です。たとえば、リダイレクト URL が myscheme://myhost の場合、スキームは myscheme、ホストは myhost となります。認証の設定ステップのユーザー認証の部分で、アプリに指定した RedirectURL を使用する必要があります。\nMainActivity.kt\noverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) //追加開始  authenticatorState.oAuthUserConfiguration = OAuthUserConfiguration( portalUrl = \u0026#34;https://www.arcgis.com\u0026#34;, clientId = \u0026#34;YOUR_CLIENT_ID\u0026#34;, redirectUrl = \u0026#34;YOUR_REDIRECT_URL\u0026#34; ) //追加終了  enableEdgeToEdge() setContent { TutorialTheme { MainScreen() } } }   setContent ブロックで、DialogAuthenticator コンポーザブル関数を呼び出し、authenticatorState を渡します。DialogAuthenticator 組み込み関数を、MainScreen() 組み込み関数の後で呼び出します。\nMainActivity.kt\noverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) authenticatorState.oAuthUserConfiguration = OAuthUserConfiguration( portalUrl = \u0026#34;https://www.arcgis.com\u0026#34;, clientId = \u0026#34;YOUR_CLIENT_ID\u0026#34;, redirectUrl = \u0026#34;YOUR_REDIRECT_URL\u0026#34; ) enableEdgeToEdge() setContent { TutorialTheme { MainScreen() //追加開始  DialogAuthenticator(authenticatorState) //追加終了  } } }   [app] \u0026gt; [manifests] \u0026gt; [AndroidManifest.xml] を開きます。OAuth ユーザー サインイン アクティビティーを宣言する \u0026lt;activity\u0026gt; タグを追加します。RedirectURL のスキームとホストを使用して、android:scheme と android:host を設定します。\nredirectURL は scheme と host コンポーネントで構成されます。リダイレクト URL のフォーマットは scheme://host です。たとえば、リダイレクト URL が myscheme://myhost の場合、スキームは myscheme、ホストは myhost となります。認証の設定ステップのユーザー認証の部分で、アプリに指定した RedirectURL を使用する必要があります。\n  AndroidManifest.xml\n\u0026lt;/activity\u0026gt; \u0026lt;!--追加開始--\u0026gt; \u0026lt;activity android:name=\u0026#34;com.arcgismaps.toolkit.authentication.OAuthUserSignInActivity\u0026#34; android:configChanges=\u0026#34;keyboard|keyboardHidden|orientation|screenSize\u0026#34; android:exported=\u0026#34;true\u0026#34; android:launchMode=\u0026#34;singleTop\u0026#34; \u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34; /\u0026gt; \u0026lt;data android:scheme=\u0026#34;your_redirect_url_scheme\u0026#34; android:host=\u0026#34;your_redirect_url_host\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;!--追加終了--\u0026gt;  ベスト プラクティス: OAuth 認証情報は、このチュートリアルの便宜のためにコードに直接保存されています。本番環境では、認証情報をソースコードに直接保存しないでください。\n\rアプリを実行する   [Run] \u0026gt; [Run] \u0026gt; [app] をクリックして、アプリを実行します。\nAndroid Studio では、アプリを実行するのに、実際の Android 端末と Android エミュレータの 2 通りの方法があります。\nAndroid デバイス パソコンと Android 端末を、USB または Wi-Fi で接続します。詳しくは、「Android デバイスを接続する方法」をご覧ください。\nAndroid エミュレーター Android エミュレーターで動作させるための AVD(Android Virtual Device) を作成します。 詳しくは、「Android Emulator 上でアプリを実行する」をご覧ください。\nデバイスの選択 Android Studio でアプリをビルドして実行する場合、まずデバイスを選択する必要があります。Android Studio のツール バーから、現在利用可能なデバイス（仮想および物理の両方）のドロップダウン リストにアクセスできます。 ツール バーのリストにアクセスできない場合は、[Tools] → [Device Manader] をクリックします。\n富士山を中心に、地形ベースマップ レイヤーが追加されたマップが表示されます。マップ ビュー上でマウス ホイールをダブル クリック、ドラッグ、およびスクロールして、マップを操作します。\n   あるいは、以下のチュートリアル ソリューションをダウンロードすることもできます。\nオプション 2:完成したソリューションをダウンロードする  Download solution をクリックしてください。 マシンの任意の場所にファイルを解凍します。 Android Studio を起動します。 [File] \u0026gt; [Open\u0026hellip;] に進みます。ソリューション フォルダーに移動し、[開く]をクリックします。\nWindows の場合\n[Welcome to Android Studio] ダイアログが表示されたら、[開く]をクリックし、ソリューション フォルダーに移動します。次に、[開く]をクリックします。  ダウンロードしたソリューションには認証情報が含まれていないため、認証の設定セクションで作成した開発者認証情報を追加する必要があります。\nソリューションに開発者認証情報を設定する アプリのユーザが ArcGIS 位置情報サービスにアクセスできるようにするには、認証の設定ステップで作成した開発者認証情報を使用して、リソースへの要求を認証します。\nAPI キー認証  Android Studio の [Android] ビューで、[app] \u0026gt; [kotlin+java] \u0026gt; [com.example.app] \u0026gt; [MainActivity] を開きます。AuthenticationMode を .API_KEY に設定します。  MainActivity.kt\nclass MainActivity : ComponentActivity() { private enum class AuthenticationMode { API_KEY, USER_AUTH } //追加開始  private val authenticationMode = AuthenticationMode.API_KEY //追加終了  private val authenticatorState = AuthenticatorState() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) when (authenticationMode) { AuthenticationMode.API_KEY -\u0026gt; { ArcGISEnvironment.apiKey = ApiKey.create(\u0026#34;YOUR_ACCESS_TOKEN\u0026#34;) } AuthenticationMode.USER_AUTH -\u0026gt; { authenticatorState.oAuthUserConfiguration = OAuthUserConfiguration( portalUrl = \u0026#34;https://www.arcgis.com\u0026#34;, clientId = \u0026#34;YOUR_CLIENT_ID\u0026#34;, redirectUrl = \u0026#34;YOUR_REDIRECT_URL\u0026#34; ) } } enableEdgeToEdge() setContent { TutorialTheme { MainScreen() if (authenticationMode == AuthenticationMode.USER_AUTH) { DialogAuthenticator(authenticatorState) } } } } } apiKey プロパティに API キーのアクセス トークンを設定します。  MainActivity.kt\noverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) when (authenticationMode) { AuthenticationMode.API_KEY -\u0026gt; { //追加開始  ArcGISEnvironment.apiKey = Apikey.create(\u0026#34;YOUR_ACCESS_TOKEN\u0026#34;) //追加終了  }  ベスト プラクティス: アクセストークンは、このチュートリアルの便宜のためにコードに直接格納されています。本番環境では、認証情報をソース コードに直接保存しないでください。\n\rユーザー認証  Android Studio の [Android] ビューで、[app] \u0026gt; [kotlin+java] \u0026gt; [com.example.app] \u0026gt; [MainActivity] を開きます。AuthenticationMode を .USER_AUTH に設定します。  MainActivity.kt\nclass MainActivity : ComponentActivity() { private enum class AuthenticationMode { API_KEY, USER_AUTH } //追加開始  private val authenticationMode = AuthenticationMode.USER_AUTH //追加終了 clientID と redirectURL の値を設定します。認証の設定ステップのユーザー認証パートでアプリに提供した RedirectURL を使用する必要があります。  MainActivity.kt\nAuthenticationMode.USER_AUTH -\u0026gt; { authenticatorState.oAuthUserConfiguration = OAuthUserConfiguration( portalUrl = \u0026#34;https://www.arcgis.com\u0026#34;, //追加開始  clientId = \u0026#34;YOUR_CLIENT_ID\u0026#34;, redirectUrl = \u0026#34;YOUR_REDIRECT_URL\u0026#34; //追加終了  ) [app] \u0026gt; [manifests] \u0026gt; [AndroidManifest.xml] を開きます。 android:scheme と android:hostは、RedirectURL の scheme と host を使って設定します。\nRedirectURL は scheme と host コンポーネントで構成されます。リダイレクト URL のフォーマットは scheme://host です。たとえば、リダイレクト URL が myscheme://myhost の場合、スキームは myscheme、ホストは myhost となります。  AndroidManifest.xml\n\u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34; /\u0026gt; \u0026lt;!--追加開始--\u0026gt; \u0026lt;data android:scheme=\u0026#34;your_redirect_url_scheme\u0026#34; android:host=\u0026#34;your_redirect_url_host\u0026#34; /\u0026gt; \u0026lt;!--追加終了--\u0026gt; \u0026lt;/intent-filter\u0026gt;  ベスト プラクティス: OAuth 認証情報は、このチュートリアルの便宜のためにコードに直接保存されています。本番環境では、認証情報をソースコードに直接保存しないでください。\n\rアプリを実行する [Run] \u0026gt; [Run] \u0026gt; [app] をクリックしてアプリを実行します。\n富士山を中心とした地形ベースマップ レイヤーの地図が表示されるはずです。マップ ビューをピンチ、ドラッグ、ダブルタップしてマップを探索します。\n 次のチュートリアル これらのチュートリアルでは、追加の API 機能、ArcGIS ロケーション サービス、および ArcGIS ツールの使用方法について説明します。(英語ページ)\n ポイント、ライン、およびポリゴンの追加 フィーチャ レイヤの追加  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/ios/",
	"title": "ArcGIS Maps SDK for Swift",
	"tags": [],
	"description": "ArcGIS Maps SDK for Swift の開発に役立つガイド集です。",
	"content": "ArcGIS Maps SDK for Swift (バージョン 200.x) の開発に役立つガイド集です。\n インストール ガイド\nArcGIS Maps SDK for Swift のインストールとセットアップ手順を紹介します。\n\r アプリケーション配布ガイド\nArcGIS Maps SDK for Swift を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を紹介します。\n\r バージョン 100.x から 200.x への移行\n今まで ArcGIS Runtime SDK for iOS バージョン 100.x を使用してアプリケーションを開発されていた開発者向けのガイドです。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/matplotlib-japanese/",
	"title": "matplotlib での日本語利用について",
	"tags": [],
	"description": "ArcGIS API for Python で利用されているグラフ描画ライブラリの matplotlib で日本語を使う方法を説明します。",
	"content": "ArcGIS API for Python では様々な オープンソース ライブラリを活用していますが、グラフを描画する際は主に matplotlib が使用されています。\nmatplotlib をデフォルトのまま使用すると日本語のテキストは文字化けしてしまいますが、フォント設定を変更することで表示させることが可能です。\n対応環境 ここでは、次の環境を用いた場合の設定方法を説明します。\n ArcGIS Pro 2.5 ArcGIS API for Python 1.7.0 matplotlib 3.1.1  日本語フォントの多くは ttc ファイルで提供されていますが、以前の matplotlib は ttc ファイルに対応していませんでした。matplotlib 3.1.0 から ttc ファイルに対応するようになったため、フォントを追加でインストールすることなく日本語を表示させることができるようになっています。それ以前のバージョンをご利用されている場合は以下をご検討ください。\n ArcGIS Pro のアップグレード  ArcGIS Pro 2.5 では、デフォルトで作成されている arcgispro-py3 という名前の環境に、ArcGIS API for Python 1.7.0 及び matplotlib 3.1.1 がインストールされています。   ArcGIS API for Python をアップグレード  Anaconda を利用して環境構築している場合、ArcGIS API for Python を最新バージョンにアップグレードすることで、依存パッケージである matplotlib も併せてアップグレードされます。    matplotlib での日本語フォントの設定方法 設定方法は主に以下の 2 通りがあります。\n スクリプトで matplotlib の設定を都度変更する matplotlib の設定ファイル (matplotlibrc) を編集する  前者の方法では一時的な設定変更、後者では恒久的な設定変更が可能です。 どちらが適しているかはご自身の状況に合わせて選択してください。\nスクリプトで matplotlib の設定を都度変更する 次のコードをスクリプトの最初に実行することでフォント設定を変更することが可能です。\nimport matplotlib.pyplot as plt from matplotlib import rcParams rcParams[\u0026#34;font.family\u0026#34;] = \u0026#34;sans-serif\u0026#34; rcParams[\u0026#34;font.sans-serif\u0026#34;] = [\u0026#34;Meiryo\u0026#34;] rcParams は matplotlib のデフォルト設定が入っているオブジェクトです。\n上記では Windows で利用可能な Meriyo に変更していますが、ご自身の OS 等に応じて適宜フォントファミリー、フォントを変更してください。\n設定したらサンプル コードを実行してみましょう。\nmatplotlib の設定ファイル (matplotlibrc) を編集する 上記の設定方法では毎回スクリプトの最初にコードを実行する必要がありますが、以下の方法でデフォルトのフォントを恒久的に変更することが可能です。\nmatplotlibrc のパスを確認 次のコードを実行して matplotlib の設定ファイルである matplotlibrc のパスを確認します。\nimport matplotlib as mpl mpl.matplotlib_fname() matplotlibrc を C:\\Users\\\u0026lt;ユーザー名\u0026gt;\\.matplotlib にコピー \u0026amp; ペーストで配置 matplotlibrc が格納されているパスへ移動しファイルをコピーしたら、以下のディレクトリにペーストします。\n C:\\Users\\\u0026lt;ユーザー名\u0026gt;\\.matplotlib  conda を使用して複数の環境を作成・利用している場合、それぞれの環境が matplotlibrc を保持しています。\n上記のパスに配置された matplotlibrc は各環境の matplotlibrc よりも優先されるため、当該ファイルを修正するだけで全ての環境で日本語のフォントを設定することができます。\n\rmatplotlibrc の内容を修正 ペーストした matplotlibrc のフォント設定部分を書き換えます。\nmatplotlibrc は非常に長いファイルですが、160 行目あたりからフォント設定のセクションが始まります。\n\r198 行目にフォント ファミリー、210 行目に sans-serif のフォント設定の箇所があります。\nフォント ファミリーはデフォルトが sans-serif なので、ここではデフォルト設定のままにしておきます。\n210 行目のフォント設定の行で、# を削除し、: の後に日本語のフォントを追加しましょう。\nここでは Meiryo に設定します。設定後の画面は以下のようになります。\n\rキャッシュの再構築 以上で設定は終了ですが、うまく反映されない場合があるので、念のため以下のコードを実行してキャッシュを再構築します。\nimport matplotlib.font_manager matplotlib.font_manager._rebuild() 設定が完了したらしたら以下のサンプルコードを実行してみましょう。\nサンプル コード フォント設定が完了したら以下のサンプル コードを実行してみましょう。\nimport matplotlib.pyplot as plt import numpy as np def test_function(x): return 3*x**3 + 2*x**2 + 4*x - 10 x = np.linspace(-3, 3, 200) plt.plot(x, test_function(x), color = \u0026#34;cornflowerblue\u0026#34;, label = \u0026#34;日本語のラベル\u0026#34;) plt.legend(loc = \u0026#34;upper left\u0026#34;) plt.ylim(-120, 120) plt.title(\u0026#34;日本語のタイトル\u0026#34;) plt.xlabel(\u0026#34;日本語のX軸\u0026#34;) plt.ylabel(\u0026#34;日本語のY軸\u0026#34;) plt.grid(True) plt.show() 次のようなグラフが描ければ成功です。\n\r参考  matplotlibで日本語 - Qiita matplotlib 公式ドキュメント  Configuring the font family The matplotlibrc file    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/extend-base-widget/",
	"title": "ウィジェットの実装",
	"tags": [],
	"description": "ウィジェットの実装方法について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Widget implementation\nExperience Builder ウィジェットは、次のファイルで構成されています。\n src: ウィジェットのソースコード  runtime: フォルダー  widget.tsx: メインのファイル assets: widget.tsx で使用される assets フォルダー translations: ウィジェットで使われる strings フォルダー   setting: フォルダー  setting.tsx: ウィジェットで使用する設定ファイル assets: 設定で使用する assets フォルダー translations: 設定で使用する strings フォルダー     dist: コンパイル済みのウィジェットのソースコードを配置。ウィジェットのソースコードのフォルダーと同じ構成 icon.svg: ウィジェットパネルのウィジェットのアイコン config.json: ウィジェットのデフォルト設定 manifest.json: プロパティのリストは jimu-core/WidgetManifest で設定した内容を表示  Client サーバー Experience Builder (開発者向けエディション) で必要なモジュールをインストールしたら、/client ディレクトリで npm start を実行して webpack サーバーを起動します。webpack サーバーを起動した状態にすることでソースコードの編集におけるファイル変更を監視し、自動的にコンパイルを行います。通常は、ソースコードを編集する際に webpack サーバーを再起動する必要はありませんが、以下の場合では、サーバーを再起動する必要があります。\n 新しいモジュールのインストール ウィジェットの追加、削除、名前の変更 ウィジェットの manifest.json の編集 ファイルやフォルダーの追加、削除、名前の変更  ctrl + c で webpack サーバーを停止させることができます。\n\rウィジェットの作成 ウィジェットに必要なファイルを作成する簡単な方法は、samples repo にある demo widget をコピーして、client/your-extensions/widgets ディレクトリに配置する方法です。demo widget フォルダーの名前を変更し、maniest.json で名前とラベルを変更し、ウィジェットの translations フォルダーにある default.ts ファイルの _widgetLabel のプロパティを変更します。widget/React コンポーネントを作成するには、クラスと関数の 2 つの方法があります。以下に、2 つの違いについて紹介します。\ndefault.ts の _widgetLabel は、常に manifest.json のラベルと同じとすることを推奨します。\n\r  クラス コンポーネント\n ES6 クラスを利用し、React のコンポーネントクラスを拡張します。 独自のデータを state で維持します。 props(properties) をクラスコンポーネントに渡し、this.props でアクセスします。 render() メソッドを使います。    関数コンポーネント\n アロー関数を使った JavaScript の基本的な関数ですが、通常の関数キーワードを使用することができます。 props を受け入れて使用します。 React Hooks を使用して state やその他の機能を使用します。 render() メソッドはありません。    開発者向けドキュメントで使用されているサンプルは、1 つを除いてすべてクラス コンポーネントに基づいています。今後のリリースでは、関数コンポーネントのサンプルを追加する予定です。\nクラス コンポーネントを使ったウィジェットの作成 以下の例では、React.PureComponent クラスを拡張して、シンプルな hello world クラスの widget/component を作成する方法を示しています。ウィジェットは、export default class Widget extends React.Component\u0026lt;AllWidgetProps\u0026gt;, any\u0026gt; で AllWidgetProps 型で宣言されており、ウィジェットの props を使用しています。 render() メソッドは、translations ファイル内の _widgetLabel のプロパティで設定した テキスト名：hello world とウィジェット名を返すために呼び出されます。\n//a custom pragma to transform your jsx into plain JavaScript /** @jsx jsx */ import { React, AllWidgetProps, jsx } from \u0026#34;jimu-core\u0026#34;; export default class Widget extends React.PureComponent\u0026lt;AllWidgetProps\u0026lt;{}\u0026gt;, any\u0026gt; { render() { return ( \u0026lt;div className=\u0026#34;widget-starter jimu-widget\u0026#34; style={{ overflow: \u0026#34;auto\u0026#34; }}\u0026gt; \u0026lt;p\u0026gt;Hello world!\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Widget Name: {this.props.label}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } } 関数コンポーネントを使ったウィジェットの作成 以下の例では、シンプルな hello world 関数の widget/component を作成するために必要なモジュールをロードしています。ウィジェットは、export default function Widget (props: AllWidgetProps) { で AllWidgetProps 型の関数として宣言されており、ウィジェットの props を使用しています。translations ファイルの _widgetLabel のプロパティで設定した テキスト名: hello world とウィジェット名を返します。\n/** @jsx jsx */ import { AllWidgetProps, jsx} from \u0026#34;jimu-core\u0026#34;; export default function Widget (props:AllWidgetProps) { return \u0026lt;div className=\u0026#34;widget-starter jimu-widget\u0026#34; style={{ overflow: \u0026#34;auto\u0026#34; }}\u0026gt; \u0026lt;p\u0026gt;Hello world!\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Widget Name: {props.label}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; } ウィジェットの UI 設定 ウィジェットの UI 設定は、ウィジェットの作成と似ていますが、setting フォルダーの setting.tsx を使用することができます。ウィジェットの UI 設定を作成するには、クラスと関数の 2 つの方法があります。クラス コンポーネントを使用するには、React.PureComponent クラスを継承します。この例では、データソースを追加して設定パネルの config.json ファイルを操作する方法を示しています。また、この例では以下のインポートに注意する必要があります。\n import React は React.PureComponent クラスに使用されます。 import DataSourceTypes はデータソースの種類に使用します。 import SettingSection と SettingRow は設定に便利な UI コンポーネントです。 import DataSourceSelector もデータソースの選択に使われるコンポーネントです。 import IMConfig は config.json ファイルに使用されます。  import {React, Immutable, FormattedMessage} from \u0026#39;jimu-core\u0026#39;; import {AllWidgetSettingProps} from \u0026#39;jimu-for-builder\u0026#39;; import {DataSourceTypes} from \u0026#39;jimu-arcgis\u0026#39;; import {SettingSection, SettingRow} from \u0026#39;jimu-ui/advanced/setting-components\u0026#39;; import {DataSourceSelector} from \u0026#39;jimu-ui/advanced/data-source-selector\u0026#39;; import {IMConfig} from \u0026#39;../config\u0026#39;; import defaultI18nMessages from \u0026#39;./translations/default\u0026#39; React.PureComponent クラスは AllWidgetSettingsProps 型と IMConfig 型で宣言されています。supportedTypes プロパティは、クラス全体を通してデータソース タイプの Webmap に使用されます。onDataSourceSelected は、データソースの選択を処理する関数を持つクラス プロパティです。this.props.OnSettingChange() 関数は、設定 UI の変更を通知するために使用されます。onP1Change と onP2Change クラス プロパティは、React のイベント処理を使用して、config.json ファイルの値の設定を助けます。\nexport default class Setting extends React.PureComponent{ supportedTypes = Immutable([DataSourceTypes.WebMap]); onDataSourceSelected = (useDataSources: UseDataSource[]) =\u0026gt; { this.props.onSettingChange({ id: this.props.id, useDataSources: useDataSources }); } onP1Change = (evt: React.FormEvent\u0026lt;HTMLInputElement\u0026gt;) =\u0026gt; { this.props.onSettingChange({ id: this.props.id, config: this.props.config.set(\u0026#39;p1\u0026#39;, evt.currentTarget.value) }); } onP2Change = (evt: React.FormEvent\u0026lt;HTMLInputElement\u0026gt;) =\u0026gt; { this.props.onSettingChange({ id: this.props.id, config: this.props.config.set(\u0026#39;p2\u0026#39;, evt.currentTarget.value) }); } jimu ライブラリには、ウィジェットで使用できるコンポーネントがあります。例えば、Web マップを選択のための UI を支援するために、DataSourceSelector コンポーネントが、選択されたデータソースのタイプ、ID、およびコールバックを処理するために使用されます。さらに、SettingSection コンポーネントと SettingRow コンポーネントは、翻訳や config ファイルからの文字列のコンテナの整形を処理するために使用されます。\nrender(){ return \u0026lt;div className=\u0026#34;sample-map-view-setting p-2\u0026#34;\u0026gt; \u0026lt;DataSourceSelector types={this.supportedTypes} mustUseDataSource useDataSources={this.props.useDataSources} onChange={this.onDataSourceSelected} widgetId={this.props.id} /\u0026gt; \u0026lt;SettingSection\u0026gt; \u0026lt;SettingRow label={\u0026lt;FormattedMessage id=\u0026#34;p1\u0026#34; defaultMessage={defaultI18nMessages.p1}/\u0026gt;}\u0026gt; \u0026lt;input defaultValue={this.props.config.p1} onChange={this.onP1Change}/\u0026gt;\u0026lt;/SettingRow\u0026gt; \u0026lt;SettingRow label={\u0026lt;FormattedMessage id=\u0026#34;p2\u0026#34; defaultMessage={defaultI18nMessages.p2}/\u0026gt;}\u0026gt; \u0026lt;input defaultValue={this.props.config.p2} onChange={this.onP2Change}/\u0026gt;\u0026lt;/SettingRow\u0026gt; \u0026lt;/SettingSection\u0026gt; \u0026lt;/div\u0026gt; } } Props ウィジェットには様々な props を設定できます。クラス コンポーネントの this.props や関数コンポーネントの props パラメータ {props} を通してアクセスすることができます。例えば、クラス コンポーネントを使用してウィジェットの config.json にある props にアクセスするには、this.props.config を使用します。関数コンポーネントでアクセスするには、props.config を使用します。利用可能なプロパティの詳細については、Experience Builder の client/jimu-core/lib/types/props.ts を参照してください。\n場合によっては、this.props にないプロパティにアクセスする必要があるかもしれません。そのためには、ウィジェット クラスに以下のコード スニペットのような静的関数を定義します。\nstatic mapExtraStateProps = (state: IMState) =\u0026gt; { return { appMode: state \u0026amp;\u0026amp; state.appRuntimeInfo \u0026amp;\u0026amp; state.appRuntimeInfo.appMode }; }; i18n サポート Experience Builder は react-intl ライブラリを使用して i18n をサポートしています。ウィジェットで言語のサポートを有効にするには、ウィジェットの manifest.json で translatedLocales プロパティのロケールを宣言します。慣例によりデフォルトのロケールを最初に指定しなければなりません。例えば、以下のスニペットでは、translatedLocales プロパティのデフォルトロケールは、英語(米国)、スペイン語、中国語(北京語) の順になっています。\n\u0026#34;translatedLocales\u0026#34;: [ \u0026#34;en\u0026#34;, \u0026#34;es\u0026#34;, \u0026#34;zh-cn\u0026#34; ] 翻訳文字列は、runtime/translations フォルダーと settings/translations フォルダーにある default.ts というファイル内に設定する必要があります。default.ts はデフォルトで使用される文字列を定義し、ウィジェットにインポートしてデフォルト メッセージに使用できます。default.ts の書式は以下のとおりです。\nexport default { _widgetLabel: \u0026#39;My Widget\u0026#39;, str1: \u0026#39;String 1\u0026#39;, } サポートされる言語が増えるごとに、translations フォルダーにそのロケールに対応した名前のファイルを作成します。例えば、スペイン語は translations/es.js です。ファイルの内容は default.ts で定義されているものと同じプロパティを持ち、そのロケールの翻訳文字列を値として持つ形式となります。\nSystem.register([], function (_export) {return {execute: function () {_export({ // the strings  _widgetLabel: \u0026#39;Translated Widget Name\u0026#39;, str1: \u0026#39;Translated String 1\u0026#39;, })}}}); ウィジェット ファイル (例：widget.tsx) において、翻訳された文字列にアクセスする様々な方法を示します。\n// Class component this.props.intl.formatMessage({id: \u0026#39;str1\u0026#39;, defaultMessage: defaultMessages.str1}) // Function component props.intl.formatMessage({id: \u0026#39;str1\u0026#39;, defaultMessage: defaultMessage.str1}) // JSX \u0026lt;FormattedMessage id=\u0026#34;str1\u0026#34; defaultMessage={defaultMessages.str1}/\u0026gt; マップ ビュー/シーン ビュー ほとんどの Experience Builder では、ウィジェットはマップ ビュー/シーン ビューで動作し、同様にビュー内のレイヤーにアクセスする必要があります。一貫した拡張性モデルを持つことを保証するために、Experience Builder フレームワーク内での使用をより簡単にするために、他のクラスやメソッドに加えて、MapViewManager クラスが jimu-arcgis で利用可能です。基本的に全てのウィジェットは createJimuMapView メソッドを呼び出して MapViewManager にマップ ビュー/シーン ビューを追加し、他のウィジェットで使用できるようにすることができます。\nMapViewManager.getInstance().createJimuMapView({ mapWidgetId: this.props.id, view: new MapView(options), datasourceId: webmapDs.id, isActive: true }) マップ ビュー/シーン ビューを使用する必要がある他のウィジェットでは、UI 設定で MapWidgetSelector を使用して選択することができます。選択したマップ/シーンは WidgetJson.useMapWidgetsIds に保存されます。\n\u0026lt;MapWidgetSelector onSelect={this.onMapWidgetSelected} useMapWidgetIds={this.props.useMapWidgetIds[0]} /\u0026gt; ArcGIS Maps SDK for JavaScript のモジュール 既定では、Experience Builder はアプリのロード時に ArcGIS Maps SDK for JavaScript (JS API) をロードしません。JS API モジュールを利用するには、2 つのオプションがあります。\n JS API に依存するウィジェット (例：JS API がないと何もできません。)  ウィジェットの manifest.json で jimu-arcgis 依存関係を宣言します。 widget.tsx で必要なモジュールをインポート import Query = require('esri/tasks/support/Query') します。    const query = new Query({ where: `${typeIdField}= ${graphic.attributes[objectIdField]}`, outFields: [\u0026#39;FirstName\u0026#39;], returnGeometry: true })  条件付きで JS API に依存するウィジェット (例：JS API がなくても何かを実行することはできます。)  import {loadArcGISJSAPIModules} と loadArcGISJSAPIModules([]) を使用してモジュールを動的にロードします。    loadArcGISJSAPIModules([\u0026#39;esri/widgets/Directions\u0026#39;]).then(modules =\u0026gt; { [this.Directions] = modules; this.setState({ apiLoaded: true }); }) インライン編集をサポート 構成可能なすべてのウィジェットは、ウィジェットの構成を可能にする設定ページを提供する必要があります。ただし、構成によっては、設定パネルよりもウィジェットの設定を変更する方が簡単な場合があります。このワークフローでは、ウィジェットはインライン編集機能を提供することで、この機能をサポートすることができます。\nインライン編集を実装する方法はいくつかあります。\n ウィジェットの manifest.json の properties オブジェクトに supportInlineEditing を宣言します。このインスタンスでは、ウィジェットが Builder で起動されたときにウィジェットに編集ツールバーが表示されます。Text ウィジェットはこのように実装されています。 ウィジェットの manifest.json の properties オブジェクトに hasEmbeddedLayout を宣言します。この場合、ユーザーが他のウィジェットをウィジェットの中でドラッグ＆ドロップできるようにするために、レイアウト コンポーネントを使用することをお勧めします。jimu-layouts/layout-builder と jimu-layouts/layout-runtime からエクスポートされた 2 つのレイアウト コンポーネントがあります。ウィジェットでは、jimu-layouts/layout-runtime からエクスポートされたレイアウトコンポーネントを使用する必要があります。jimu-layouts/layout-builder からエクスポートされたコンポーネントにアクセスするには、this.props.builderSupportModules.LayoutClass を使用します。List ウィジェットはこの手法を使っています。 ウィジェットの manifest.json で CONTEXT_TOOL 拡張機能を宣言します。宣言した拡張機能は選択ツールバーで利用できるようになります。Image ウィジェットは、このように選択ツールバーに shape ツールや crop ツールを追加して使用します。  インライン編集をサポートするために、ウィジェットは Builder でウィジェットを起動した時にのみ必要なモジュールが含まれている場合があります。このシナリオでは、これらのモジュールを builder-support.tsx に配置します。このファイルは widget.tsx と同じフォルダーにあるはずです。このファイル内のモジュールは、ウィジェットが Builder で起動されると、this.props.builderSupportModules.widgetModules 内で利用できるようになります。\nベストプラクティス  ウィジェットのクラス名として widget-\u0026lt;widget name\u0026gt; を、ウィジェット設定のクラス名として widget-setting-\u0026lt;widget name\u0026gt; を使用して、ウィジェットのルート CSS クラス名を指定します。 サードパーティの内蔵ライブラリをロードするには import {} from 'jimu-core' を使います。例えば、import {React} from 'jimu-core から {React} をインポートします; import {} from '3rd_lib' を使うと、lib がウィジェットに組み込まれるので、ウィジェットのサイズは大きくなります。 widget の src フォルダーに Typesafe 設定ファイルを作成し、widget.tsx と setting.tsx の両方で使用します。 可能な限りアウトオブボックスの UI コンポーネントを活用して、ウィジェット UI を作成する方法の詳細をご覧ください。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/custom-font/",
	"title": "カスタム フォント",
	"tags": [],
	"description": "独自のフォントを使用する手順を紹介します。",
	"content": "ArcGIS Maps SDK for JavaScript のバージョン 4.10 以降、MapView 上のフィーチャ レイヤーのラベルやテキスト シンボルで使用するフォントは、pbf (Protocolbuffer Binary Format) で配信する必要があります。 デフォルトでは、pbf フォントは Esri が https://static.arcgis.com/fonts でホストしているフォントを使用できます。 利用可能なフォントの一覧は、Esri のガイドで確認できます（\u0026ldquo;Read more\u0026rdquo; をクリックしてページを展開してください）。\nデフォルトで提供されていないフォントを使用したい場合は、自身で pbf フォントを作成し Web サーバーで配信することで、API から使用することができます。このガイドでは ArcGIS Maps SDK for JavaScript バージョン 4.x で独自のフォントを使用する手順を紹介します。\n※ 本ガイドでご紹介する手順に関しては ESRIジャパンの技術サポート サービスの対象外となります。予めご了承ください。また、フォントの変換・配置を行う場合は、利用されるフォントの利用規約を予めご確認ください。\nフォントの入手 今回は、Google フォント からダウンロードして PBF に変換します。\npbf フォントの作成 pbf ファイルは符号付き距離フィールドのセットとして以下の URL で配信する必要があります。これは MapBox GL JS のスタイル仕様と同じです。\nhttps://fonts/\u0026lt;フォントスタック\u0026gt;/\u0026lt;ユニコード文字範囲\u0026gt;.pbf\npbf ファイルは node-fontnik を使用して、ttf や otf 等のフォントファイルから変換して作成できます。\n node-fontnik をクローンします。  git clone https://github.com/mapbox/node-fontnik.git\r node-fontnik フォルダに移動して、モジュールをインストールします。  npm install\r fonts フォルダを作成し、作成したフォルダにダウンロードした Google フォントを配置します。 glyphs フォルダと変換後のファイルを出力するサブフォルダ（例: glyphs/KosugiMaru-Regular）を作成します。 build-glyphs を実行して pbf ファイルを作成します。  node-fontnik/bin/build-glyphs fonts/KosugiMaru-Regular.ttf glyphs/KosugiMaru-Regular\r glyphs/KosugiMaru-Regular フォルダにユニコード文字範囲の pdf ファイル群が作成されていることを確認します。  PBF フォントの配置 以下のディレクトリ構成にして Web サーバーへ配置します。 IIS を使用する場合は、MIME に .pbf (binary/octet-stream) を登録します。\n「fonts」 フォルダ\n|\u0026ndash;「\u0026lt;フォントファミリー\u0026gt;-\u0026lt;ウェイト\u0026gt;-\u0026lt;スタイル\u0026gt;」フォルダ（例：arial-bold-italic） ※\n|\u0026ndash; pbf ファイル群\n※ \u0026lt;スタイル\u0026gt; は省略可能です。今回は「KosugiMaru-Regular」フォルダを作成します。 詳細は「API の設定」の項目を参照してください。\nAPI の設定   ArcGIS Maps SDK for JavaScript で参照するフォント リソースの URL を変更します。 フォントの URL の設定は、esri/config クラスの fontsUrl プロパティを使用します。\n  マップに表示するフォントを作成します。 フォントの作成は Font クラスを使用します。 family、weight、style の各プロパティに設定した値をもとに設定したフォント URL へリクエストが実行されます。 例えば、family に \u0026ldquo;arial\u0026rdquo;、weight に \u0026ldquo;bold\u0026rdquo;、style に \u0026ldquo;italic\u0026rdquo; を設定した場合は、https://\u0026lt;サーバー名\u0026gt;/fonts/arial-bold-italic フォルダにある pbf ファイルを取得します。 フォントに複数スタイルが存在しない場合は style プロパティは省略可能です。 また、weight プロパティも省略可能ですが、API で指定しない場合は regular が自動で設定され、https://\u0026lt;サーバー名\u0026gt;/fonts/arial-regular がリクエストされます。\n  以下は作成した pbf フォントをテキスト シンボルで表示した画面とサンプルコードです。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1,maximum-scale=1,user-scalable=no\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;font_mapView\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.xx/esri/themes/light/main.css\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; background-color: black; } \u0026lt;/style\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.xx/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; require([ \u0026#34;esri/Map\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;, \u0026#34;esri/Graphic\u0026#34;, \u0026#34;esri/config\u0026#34; ], function(Map, MapView, Graphic, esriConfig) { // .pbfファイルを独自に配信するURL  esriConfig.fontsUrl = \u0026#34;http://\u0026lt;サーバー名\u0026gt;/fonts\u0026#34;; // テキストシンボルの作成  var textSymbol = { type: \u0026#34;text\u0026#34;, color: \u0026#34;white\u0026#34;, text: \u0026#34;KosugiMaru フォントです\u0026#34;, // 表示する文字列  font: { size: 15, family: \u0026#39;KosugiMaru\u0026#39; // フォントファミリー  } }; var point = { type: \u0026#34;point\u0026#34;, longitude: 139.751068, latitude: 35.684482 }; var pointGraphic = new Graphic({ geometry: point, symbol: textSymbol }); var map = new Map({ basemap: \u0026#34;dark-gray-vector\u0026#34; }); const view = new MapView({ container: \u0026#34;viewDiv\u0026#34;, map: map, center: [139.751068, 35.684482], zoom: 12 }); view.graphics.add(pointGraphic); }); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/samples/",
	"title": "サンプル集",
	"tags": [],
	"description": "開発にすぐに使えるサンプル データ/コードを紹介します。",
	"content": "開発にすぐに使えるサンプル データ/コードを紹介します。\nサンプル データ 開発でサンプルとして利用可能なデータです。以下は抜粋ですので、他のサンプル データを探したい場合は、マップ ビューアーでレイヤー検索してみてください。\n マップ  Web マップ（ArcGIS for Developers 開発ガイドのサンプル Web マップ）   フィーチャ レイヤー  tokyo_23（東京都における東京23区、市部、町村部（郡部）（町村部（島部）以外））   タイル レイヤー  南海トラフ巨大地震の被害想定（震度/最大クラス） 南海トラフ巨大地震の被害想定（液状化/最大クラス）    サンプル コード GitHub にて開発サンプルとなるソースコードを公開しています。\n JavaScript  arcgis-samples-js: ArcGIS API for JavaScript のサンプル集 data-visualization-js: JavaScript で始めるデータ ビジュアライゼーションのサンプル webmap-startup-template-js: Web マップを使用した開発手法を伝えるためのアプリケーション テンプレートのサンプル   .NET  arcgis-samples-dotnet: ArcGIS Runtime SDK for .NET のサンプル集 startup-sample-dotnet: .NET SDK のスタートアップ サンプル アプリケーション webmap-startup-template-dotnet: Web マップを使用した開発手法を伝えるためのアプリケーションのサンプル   Android  arcgis-samples-android: ArcGIS Runtime SDK for Android のサンプル集   iOS  arcgis-samples-ios: ArcGIS Runtime SDK for iOS (Objective-C/Swift) のサンプル集 startup-swift-ios: iOS SDK のスタートアップ サンプル アプリケーション   Python  arcgis-samples-python-api    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/theme/",
	"title": "テーマ（Theme）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Theme\nテーマ（Theme） テーマは、エクスペリエンスの外観と使用感を定義します。エクスペリエンスは、すぐに使える (OOB) テーマがあり、カスタム テーマの作成も可能です。テーマ開発については、theme development をご覧ください。\napp config では、アプリが使用するテーマは theme で定義されます。テーマをカスタマイズした場合、そのカスタマイズ内容は customTheme に保存されます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/flutter/",
	"title": "ArcGIS Maps SDK for Flutter",
	"tags": [],
	"description": "ArcGIS Maps SDK for Flutter の開発に役立つガイド集です。",
	"content": "ArcGIS Maps SDK for Flutter (バージョン 200.x) の開発に役立つガイド集です。\n インストール ガイド\nArcGIS Maps SDK for Flutter のインストールとセットアップ手順を紹介します。\n\r アプリケーション配布ガイド\nArcGIS Maps SDK for Flutter を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を紹介します。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-ios/",
	"title": "iOS",
	"tags": [],
	"description": "ArcGIS Maps SDK for Swift を用いたモバイル地図アプリの作成方法を紹介します。",
	"content": "出典：ArcGIS Maps SDK for Swift - Tutorials - Display a map\nマップを表示する このチュートリアルでは ArcGIS Maps SDK for Swift を使用して、マップとベースマップ レイヤーを表示する方法を紹介します。\nマップには、地理データのレイヤーが含まれています。マップには、ベースマップ レイヤーと、オプションで 1 つ以上のデータレイヤーを追加できます。マップ ビューを使用し、場所とズーム レベルを設定することで、マップの特定の領域を表示できます。\nこのチュートリアルでは、地形ベースマップ レイヤーを使用して、富士山付近を表示する地図を作成します。\nこのチュートリアルのトピックの背景情報については、Mapping API and location services guide の Maps (2D) と ベースマップ を参照してください。\n\r前提条件 このチュートリアルを実施するには、以下が必要です。\n API キーにアクセスするための ArcGIS 開発者アカウント。アカウントをお持ちでない場合は、サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。 開発環境がシステム要件を満たしていることを確認します。  認証の設定 このチュートリアルで使用するセキュアな ArcGIS ロケーション サービスにアクセスするには、ArcGIS Location Platform または ArcGIS Online アカウントを使用して、API キー認証またはユーザー認証を実装する必要があります。\nこのチュートリアルでは、API キー認証またはユーザー認証を実装することができます。以下の違いを比較してください。\nAPI キー認証  ユーザーはサイン インする必要がありません。 適切な権限を持つ API キーの認証情報を作成する必要があります。 API キーは長期間のアクセス トークンです。 サービス使用料は API キーの所有者/開発者に請求されます。 実装が最も簡単な認証方法です。 新規の ArcGIS 開発者に推奨される方法です。  詳しくは API キー認証をご覧ください。\nこのチュートリアルで使用するセキュアなリソースにアクセスする権限を持つ、新しい API キーのアクセス トークンを作成します。\n API キーの作成のチュートリアルを完了し、以下の権限を持つ API キーを作成します。  Privileges  Location services \u0026gt; Basemaps     API キーのアクセス トークン をコピーし、安全な場所に貼り付けます。これは後のステップで使用します。  ユーザー認証  ユーザーは、ArcGIS アカウントでサイン インする必要があります。 ユーザー アカウントには、アプリケーションで使用する ArcGIS サービスにアクセスする権限が必要です。 OAuth 認証情報の作成が必要です。 アプリケーションは、リダイレクト URL とクライアント ID を使用します。 サービスの使用料は、アプリケーションにサイン インしたユーザーの組織に請求されます。  詳しくは、ユーザー認証をご覧ください。\nこのチュートリアルで使用するセキュアなリソースにアクセスするための新しい OAuth 認証情報を作成します。\n  ユーザー認証用の OAuth 認証情報を作成するチュートリアルを完了します。\nclient ID は、認証サーバー上でアプリを一意に識別します。サーバーは、提供された Client ID を持つアプリを見つけることができない場合、認証を続行しません。\nRedirect URL（callback url とも呼ばれる）は、OAuth ログイン後にシステムがアプリに制御を戻す際に、認証サーバーからの応答を識別するために使用されます。必ずしもユーザーがナビゲートできる有効なエンドポイントを表しているわけではないので、redirect URL は my-app://auth のようなカスタム スキームを使用できます。アプリのコードで使用する redirect URL が、認証サーバーで設定された redirect URL と一致することを確認することが重要です。\n  ClientID と RedirectURL をコピーして安全な場所に貼り付けます。これらは後のステップで使用します。\n  このアプリケーションにアクセスするすべてのユーザーには、ベースマップ スタイル サービスにアクセスするためのアカウント権限が必要です。\nセキュリティと認証ガイド : 認証の種類について詳しくは、認証の種類をご覧ください。\n\r開発またはダウンロード このチュートリアルを完了するには、2 つの選択肢があります。\n オプション 1:コードを開発する か オプション 2:完成したソリューションをダウンロードする  オプション 1:コードを開発する 新しいアプリを作成する 始めるには、Xcode を使って iOS アプリを作成し、API を参照するように設定する。\n  Xcode を開き、メニュー バーから [File] \u0026gt; [New] \u0026gt; [Project] をクリックします。\n  [Choose a template for your new project] ウィンドウで、次の値を設定します。\n Multiplatform iOS Application App    [Next] をクリックします。\n  [Choose options for your new project] ウィンドウで、次の値を設定します。\n Product Name: \u0026lt;your app name\u0026gt; Organization Identifier: \u0026lt;任意の組織\u0026gt; Interface: SwiftUI Language: Swift    他のすべてのオプションのチェックを外します。\n  [Next] をクリックします。\n  プロジェクトを保存する場所を選択して、[Create] をクリックします。\n    Project Navigator で、\u0026lt;your app name\u0026gt;.App をクリックします。Editor で、.App struct を右クリックします。 [Refactor]、[Rename\u0026hellip;] の順に選択して、構造体の名前を MainApp に変更します。 右上の [Rename] ボタンをクリックして、新しい名前を確認します。 これにより、影響を受けるすべての領域の構造体 (struct) とファイルの名前が変更されます。\n  Swift Package Manager を使用して API への参照を追加します。\n  MainApp.swift ファイルで、ArcGIS のインポート後にエラーが表示される場合があります。Scene と Scene protocol を区別することで、エラーを解決します。これを行うには、SwiftUI 接頭辞を Scene に追加します。\nMainApp.swift\n// 追加開始 var body: some SwiftUI.Scene { // 追加終了 WindowGroup { ContentView() } }   開発者認証情報を設定する アプリのユーザーが ArcGIS Location Services にアクセスできるようにするには、認証の設定 ステップで作成した開発者認証情報を使用して、リソースへの要求を認証します。\nAPI キーでの認証 API キーを使用すると、ArcGIS Online でホストされているサービス、Web マップ、および Web シーンにアクセスできるようになります。\nAPI キー アクセストークンを ArcGISEnvironment に渡します。\n  Project Navigator で、[MainApp.swift] をクリックします。\n  MainApp 構造体にイニシャライザーを実装し、ArcGISEnvironment.apiKey プロパティーに API キーのアクセス トークンを設定します。\nMainApp.swift\nimport SwiftUI import ArcGIS @main struct MainApp: App { // 追加開始 init() { ArcGISEnvironment.apiKey = APIKey(\u0026#34;\u0026lt;#アクセストークンを入力#\u0026gt;\u0026#34;) } // 追加終了   ベストプラクティス : アクセス トークンは、このチュートリアルの便宜のためにコードに直接格納されています。本番環境では、認証情報をソース コードに直接保存しないでください。\n\rユーザー認証 Authenticator toolkit コンポーネントを使用して OAuth 認証情報を管理し、ArcGISEnvironment に渡します。\n  以下の手順に従って、ArcGIS Maps SDK for Swift Toolkit パッケージをアプリケーションに追加します。\n  Project Navigator で、[MainApp.swift] をクリックします。\n    コードに import ArcGISToolkit を追加します。\n  MainApp 構造体で Authenticator ツールキット コンポーネントを宣言し、初期化します。\n  MainApp 構造体にイニシャライザーを実装します。\n  OAuthUserConfiguration を使用して Authenticator の新しいインスタンスを作成します。\n  PortalURL、clientID、および redirectURL の値を追加します。\n  authenticator を ArcGISEnvironment.authenticationManager に渡して、チャレンジを処理します。\nMainApp.swift\nimport SwiftUI import ArcGIS // 追加開始 import ArcGISToolkit // 追加終了 @main struct MainApp: App { // 追加開始 @ObservedObject var authenticator: Authenticator init() { authenticator = Authenticator(oAuthUserConfigurations: [ OAuthUserConfiguration( portalURL: URL(string: \u0026#34;\u0026lt;#YOUR-PORTAL-URL#\u0026gt;\u0026#34;)!, clientID: \u0026#34;\u0026#34;\u0026lt;#YOUR-CLIENT-ID#\u0026gt;\u0026#34;\u0026#34;, redirectURL: URL(string: \u0026#34;\u0026lt;#YOUR-REDIRECT-URL#\u0026gt;\u0026#34;)! ) ]) ArcGISEnvironment.authenticationManager.handleChallenges(using: authenticator) } // 追加終了    body で、ContentView に.authenticator(authenticator) 修飾子を追加します。\nベストプラクティス : OAuth 認証情報は、このチュートリアルの便宜のためにコードに直接格納されています。本番環境では、認証情報をソース コードに直接保存しないでください。\n\r  マップの追加 地形ベースマップ レイヤーを含むマップを作成します。 マップは、富士山付近が中心になります。\n  Project Navigator で、[ContentView.swift] をクリックします。\n  Editor で、API を参照する import ステートメントを追加します。\nContentView.swift\nimport SwiftUI // 追加開始 import ArcGIS // 追加終了   デフォルト値を持つ Map タイプの map という名前の @State プロパティー ラッパーを追加します。arcGISTopographic ベースマップ スタイルで Map を作成し、それを返します。\nContentView.swift\nstruct ContentView: View { // 追加開始 @State private var map = { //ベースマップのラベルを日本語で表示します。 let bsp = BasemapStyleParameters(language: BasemapStyleLanguage.specific(Locale.Language(identifier: \u0026#34;ja\u0026#34;))) let map = Map(basemap:Basemap(style:.arcGISTopographic,parameters: bsp)) return map }() // 追加終了 }   ArcGIS Enterprise ユーザーは、ArcGIS Location ベースマップ スタイル サービスにアクセスできません。ArcGIS Enterprise ユーザ向けのアプリを作成する場合は、ユーザーがアクセスできるベースマップを含む マップ を作成する必要があります。\n\r マップの initialViewpoint プロパティーを、富士山付近の座標を持つ Viewpoint で設定します。\nContentView.swift\nstruct ContentView: View { @State private var map = { //ベースマップのラベルを日本語で表示します。 let bsp = BasemapStyleParameters(language:BasemapStyleLanguage.specific(Locale(languageCode: \u0026#34;ja\u0026#34;))) let map = Map(basemap:Basemap(style:.arcGISTopographic,parameters: bsp)) // 追加開始 map.initialViewpoint = Viewpoint(latitude: 35.360626, longitude: 138.727363, scale: 200000) // 追加終了 return map }() }   マップ ビューの追加 マップ ビューは、マップを表示する UI コンポーネントです。 また、タッチ ジェスチャを使用したナビゲーションなど、マップとのユーザー インタラクションも処理します。Xcode と SwiftUI を使用してマップ ビューを追加します。\n  body で、前の手順で作成したマップを使用して MapView を作成します。\nContentView.swift\nstruct ContentView: View { @State private var map = { //ベースマップのラベルを日本語で表示します。 let bsp = BasemapStyleParameters(language:BasemapStyleLanguage.specific(Locale(languageCode: \u0026#34;ja\u0026#34;))) let map = Map(basemap:Basemap(style:.arcGISTopographic,parameters: bsp)) map.initialViewpoint = Viewpoint(latitude: 35.360626, longitude: 138.727363, scale: 200000) return map }() var body: some View { // 追加開始 MapView(map: map) // 追加終了 } } MapView は Apple View プロトコルに準拠しています。\n  ソリューションを実行する   Project Navigator で、[MainApp.swift] をクリックします。\n  ContentView に .ignoresSafeArea() 修飾子を追加します。ContentView の body には MapView が含まれており、この修飾子により、マップ ビューがセーフ エリアを超えてすべての端まで表示されるようになります。\nMainApp.swift\nvar body: some Scene { WindowGroup { ContentView() // 追加開始 .ignoresSafeArea() // 追加終了 } }   \u0026lt;Command + R\u0026gt; を押してアプリを実行します。\n富士山を中心とした地形ベースマップ レイヤーのマップが表示されます。マップ ビューをピンチ、ドラッグ、およびダブルタップして、マップを操作します。\n  Xcode シミュレータを使用する場合、システムは以下の最低要件を満たしている必要があります ( macOS 14 (Sonoma), Xcode 16, iOS 18)。 物理的なデバイスを使用する場合は、システム要件を参照してください。\nあるいは、以下のチュートリアル ソリューションをダウンロードすることもできます。\nオプション 2:完成したソリューションをダウンロードする  Download solution をクリックし、マシンの任意の場所にファイルを解凍します。 Xcode で .xcodeproj ファイルを開きます。  ダウンロードしたソリューションには認証情報が含まれていないため、認証の設定セクションで作成した開発者認証情報を追加する必要があります。\nソリューションに開発者認証情報を設定する アプリのユーザが ArcGIS 位置情報サービスにアクセスできるようにするには、認証の設定ステップで作成した開発者認証情報を使用して、リソースへの要求を認証します。\nAPI キー認証 API キー アクセス トークンを ArcGISEnvironment に渡します。\n  Project Navigator で、[MainApp.swift] をクリックします。\n  AuthenticationMode を .apiKey に設定する。\nMainApp.swift\n// Change the `AuthenticationMode` to `.apiKey` if your application uses API key authentication. // 追加開始 private var authenticationMode: AuthenticationMode { .apiKey } // 追加終了   apiKey プロパティーに API キーのアクセス トークンを設定します。\nMainApp.swift\n// Please enter an API key access token if your application uses API key authentication. // 追加開始 private let apiKey = APIKey(\u0026#34;\u0026lt;#YOUR-ACCESS-TOKEN#\u0026gt;\u0026#34;) // 追加終了  ベストプラクティス : アクセス トークンは、このチュートリアルの便宜のためにコードに直接格納されています。本番環境では、認証情報をソース コードに直接保存しないでください。\n\r  ユーザー認証 Authenticator toolkit コンポーネントを使用して OAuth 認証情報を管理し、ArcGISEnvironment に渡します。\n  Project Navigator で、[MainApp.swift] をクリックします。\n  AuthenticationMode を .user に設定します。\nMainApp.swift\n// Change the `AuthenticationMode` to `.user` if your application uses OAuth credentials. // 追加開始 private var authenticationMode: AuthenticationMode { .user } // 追加終了   portalURL、clientID、redirectURL の値を設定します。\nMainApp.swift\n// Setup an `Authenticator` with OAuth configuration if your application uses OAuth credentials. @ObservedObject var authenticator = Authenticator( oAuthUserConfigurations: [ OAuthUserConfiguration( // Please enter OAuth credentials for user authentication. // 追加開始 portalURL: URL(string: \u0026#34;\u0026lt;#YOUR-PORTAL-URL#\u0026gt;\u0026#34;)!, clientID: \u0026#34;\u0026lt;#YOUR-CLIENT-ID#\u0026gt;\u0026#34;, redirectURL: URL(string: \u0026#34;\u0026lt;#YOUR-REDIRECT-URL#\u0026gt;\u0026#34;)! // 追加終了 ) ] )   ベストプラクティス : アクセス トークンは、このチュートリアルの便宜のためにコードに直接格納されています。本番環境では、認証情報をソース コードに直接保存しないでください。\n\rアプリを実行する アプリを実行するには、\u0026lt;Command + R\u0026gt; キーを押します。\nXcode シミュレータを使用する場合、システムは以下の最低要件を満たしている必要があります ( macOS 14 (Sonoma), Xcode 16, iOS 18)。物理的なデバイスを使用する場合は、システム要件を参照してください。\nカリフォルニア州サンタモニカ山脈を中心とした地形ベースマップ レイヤーの地図が表示されるはずです。マップ ビューをピンチ、ドラッグ、ダブルタップしてマップを探索します。\n次のチュートリアル これらのチュートリアルでは、追加の API 機能、ArcGIS ロケーション サービス、および ArcGIS ツールの使用方法について説明します。(英語ページ)\n Web マップを表示 ポイント、ライン、およびポリゴンの追加 住所の検索 フィーチャ レイヤーの追加  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/cloning-content/",
	"title": "アイテムのクローン",
	"tags": [],
	"description": "Web GIS のアイテムを他のアカウントに複製する方法を紹介します",
	"content": "参考：ArcGIS API for Python - Cloning Content\nイントロダクション 企業または組織の開発環境からステージング、そして本番環境にコンテンツを移動させる最善の方法は何ですか？という質問がよくあります。このガイドでは、ある Web GIS から別の Web GIS にコンテンツを移動する方法について、可能なロードマップの 1 つを紹介します。これは、コンテンツを移動する際の基本的なソフトウェアの概念を示すためのテンプレートであり、ワークフローを他の種類のコンテンツ用に変更したり、管理者の特定のニーズに合わせて調整したりすることができます。\nContentManger の clone_items() メソッドは、ArcGIS Online、ArcGIS Enteprise、または ArcGIS Enterprise on Kubernetes などの元の組織から別の組織に、すべての用途と機能を持つ 1 つのアイテムの完全な複製を作成することを目的としています。アイテムのクローンを作成するときは、サポートされているアイテム、関連するアイテム、またはリソース アイテムとクローンされるアイテムとの関係を考慮する必要があります。\nアイテムのクローンついて、基本的な用語を定義しておきましょう。クローンとは、ArcGIS Enterprise、ArcGIS Online、または ArcGIS Enterprise on Kubernetes から他のデプロイメント タイプへの、あらゆる組織間でのアイテムの転送を指します。これらのポータルのタイプについて説明するときに、これらのポータルのタイプを区別しようとして混乱しないために、デプロイメントのタイプに関係なく、コンテンツ作成元の組織を「ソース」と呼び、コンテンツのクローン先の組織を「ターゲット」と呼びます。\nこのドキュメントでは、ソースの管理者アカウントを使用してソース アイテムを収集し、ターゲットの管理者アカウントにクローンするワークフローを説明します。具体的には、ホスト フィーチャ レイヤーと Web マップをクローンする方法を説明します。Web マップは、これらのレイヤー アイテムとそのソース サービスを操作レイヤーの構成要素として利用できます。各アイテムの詳細については、ハイパーリンクをクリックしてください。\nこれは管理者のワークフローです。管理者アカウントを使用することで、ソース内でアイテムや依存関係にアクセスすること及び、ターゲット内でアイテムやサービスを作成するための必要な権限が保証されます。ターゲットの管理者は、ユーザー アカウントを作成し、必要に応じてアイテムの所有権やグループ メンバーシップを再割り当てすることができます。これは、ポータルが外部のアイデンティティ ストアによって管理されるユーザーを持つ場合、最も単純なワークフローになります。\n対応アイテム 冒頭に記載したように、Python API の開発者は以下のアイテム タイプを転送する用に clone_items() メソッドを設計しました。\n Web マップ ホスト フィーチャ レイヤー ホスト フィーチャ レイヤーのビュー フィーチャ コレクション ArcGIS survey123 フォーム ArcGIS Workforce プロジェクト ArcGIS StoryMaps  Cloning Complex Items を参照   ArcGIS Experience Builder  Cloning Complex Items を参照   ArcGIS Dashboards  Cloning Complex Apps を参照   ArcGIS QuickCapture プロジェクト ArcGIS Notebooks シンプルなタイプ  ダウンロードオプションのあるアイテム。(Web GIS に含まれ、ダウンロード可能なアイテムについては、Data files を参照) ジオデータベースやシェープファイル、コードサンプル、zip ファイル、その他のパッケージなどが含まれます。    clone_items() は、上記の複雑なアイテムの依存関係をクローンします。例えば、既存の Web アプリケーションをクローンする場合、Web マップと、そのマップで参照されるすべてのホスト フィーチャ レイヤーをクローンします。\nclone_items() は、マップ サービスとイメージ サービスのクローンを作成できません。これらのサービスは、構成内のホストされているサーバー以外のサーバーに公開されるため、関数がターゲット内のどこに公開するかを決定することは不可能です。その結果、これらのアイテムはコピーされますが、元のソース URL を参照し続けます。\n個々のアイテムのクローンを作成し、その結果を検証する例を見てみましょう。\n※このドキュメントではバージョン 2.4.0 以降を対象とした書き方で紹介します。\nまず、必要なライブラリをインポートし、ソースの GIS とターゲットの GIS に接続します。\nライブラリのインポート from pathlib import Path import sys import pandas as pd from arcgis.gis import GIS, Item from arcgis.env import active_gis from arcgis.features import FeatureLayerCollection # 2.4.0 以降では from arcgis.mapping import WebMap の代わりに以下が必要 from arcgis.map import Map ソースとターゲットのポータルに接続 管理者としてログインするところから始めます。開発環境として ArcGIS Online を使用してテストや開発を行ってきた管理者が、本番環境となる ArcGIS Online にアイテムをクローンする場合を想定します。\nログイン例 source = GIS(\u0026#34;https://www.arcgis.com\u0026#34;, \u0026#34;USERNAME1\u0026#34;) #ID とパスワードを使用して ArcGIS Online にログイン print(source) target = GIS(\u0026#34;https://www.arcgis.com\u0026#34;, \u0026#34;USERNAME2\u0026#34;) #ここではクローン先を別のArcGIS Online アカウントとする print(target) クローンの作成 まず、clone_items() で何ができるかを簡単にデモンストレーションしてみます。管理者としてログインし、ソースのユーザーの 1 人が所有する特定のホスト フィーチャ レイヤー のアイテムを get() で取得し、ターゲットにクローンします。クローンされたフィーチャ レイヤーの URL を参照して、新しいアイテムを確認することができます。owner パラメーターを指定することで、組織内の他のユーザーにクローンを転送することもできます。 hosted_flyr = source.content.get(\u0026#34;71af4edb22c34c92893b983d7f7b52e6\u0026#34;) osted_flyr hosted_flyr.url cloned_flyr = target.content.clone_items(items = [hosted_flyr], folder=\u0026#34;クローン先1\u0026#34; )#ここでは owner パラメーターを使用しない cloned_flyr[0] cloned_flyr[0].url clone_items() は、クローンされたアイテムを含むリストを返すことがわかります。リストをインデックス化すると、この操作によって、ターゲット組織に、新しいホスト フィーチャ レイヤーが作成されたことがわかります。\n複数のアイテムを同時にクローンする 上記では、items パラメーター リストに 1 つのアイテムを渡す方法を示しました。次に、clone_items() がリスト内のすべてのアイテムをクローンする方法を見てみましょう。まず、search() 関数で特定のユーザーが所有するアイテムを検索し、リストのアイテムを全て同時にターゲットにクローンします。\n#複数アイテムのクローン tester_content=source.content.advanced_search(query=\u0026#39;tags:クローン AND owner:USERNAME1\u0026#39;)[\u0026#34;results\u0026#34;] tester_content cloned_items = target.content.clone_items(items=tester_content, search_existing_items=True, #既に存在するものはクローンしない folder=\u0026#34;クローン先2\u0026#34;) cloned_items #アイテム「品川駅」は上でクローンを作成済み clone_items() は、items 引数に渡したリスト内のすべてのアイテムをクローンしていることがわかります。また、owner 引数を渡さないことで、clone_items() を実行したログイン ユーザーにアイテムがクローンされます。\nclone_items() がソースからターゲットへアイテムをクローンする簡単な例をご紹介しました。次に、ホスト フィーチャ レイヤーのリストを繰り返し処理し、いくつかの追加パラメーターを使用して、それらを利用する ArcGIS コンテンツのクローンを作成します。\nクローンのプロセス clone_items() 関数の非常に重要なパラメーターは、その出力に影響します :\n search_existing_items - 設定可能な値は True または False です。  デフォルト値は True です。この値が True に設定されている場合の動作を説明します。クローン元アイテムがターゲットにクローンされると、clone_items() は、クローンされたアイテムにすべての必須アイテム タイプ typeKeywords (アイテムに自動的に割り当てられる typeKeywords についてはハイパーリンクを参照) に加えて、source-\u0026lt;source_item_id_value\u0026gt; という追加の typeKeyword を割り当てます。たとえば、clone_items() が ID d879c7d972b1d989b97d037c7a7737d6 のアイテムをソースとしてフィーチャ レイヤー アイテムをクローンする場合、ターゲットのフィーチャ レイヤー アイテムは、必須の typeKeyword に加えて、source-d879c7d972b1d989b97d037c7a7737d6 の typeKeyword を持つことになります。実際にクローンされる前に、clone_items() は、そのパターンに一致する typeKeyword を持つアイテムをターゲットから検索し、見つかった場合は、アイテムを再度クローンするのではなく、既存のターゲットアイテムを使用します。\n引数を False に設定すると、指定されたアイテムと参照するアイテムは、それらが既に存在するかどうかに関係なく、ターゲットにクローンされます。\nWeb マップ advanced_search() メソッドを使用して、Web マップのアイテムのリストを作成することができます。まず、全てのアイテムのリストを取得し、それをPandas DataFrame に変換して、Web マップ用にフィルタリングします\n# ユーザーが所有するすべてのアイテムを検索 owner_items = source.content.advanced_search(query=f\u0026#34;owner:{source.users.me.username}\u0026#34;, max_items=-1)[\u0026#34;results\u0026#34;] owner_items # Pandas DataFrame 形式のリストへ変換 owner_items_df = pd.DataFrame(owner_items) Pandas の groupby() を使用して、ユーザーが所有する各アイテムタイプ別のグループ オブジェクトを作成します。その後、get_group() メソッドを使用して、すべてのWeb マップを返します。\n# Web マップ形式を選択 wm_item_df = owner_items_df.groupby(\u0026#34;type\u0026#34;).get_group(\u0026#34;Web Map\u0026#34;) wm_item_df 出力されたデータフレームのインデックスは、元のデータフレームの各 Web マップの行番号を行インデックスに使っているので、0 から始まるインデックスにリセットします。\nwm_item_df.index web_maps = wm_item_df.reset_index(drop=True) web_maps.index タグ検索を使ってWeb マップを取得し、それをターゲットにクローンしてみましょう :\n#品川駅のみ駅タグをつけている def check_wm(tag_list): return \u0026#34;駅\u0026#34; in tag_list eki_df = web_maps[web_maps.tags.apply(check_wm)] eki_df.index eki_df.loc[1].id eki_wm_item = source.content.get(eki_df.loc[1].id) eki_wm_item Map オブジェクトを使って、Web マップ内の各レイヤーに関する情報を表示してみましょう。レイヤー名と URL に注目して見てみると、URL のパス コンポーネントの最初にレイヤーをホストしている組織が含まれていることが分かります。\nwm_obj = Map(eki_wm_item) lyr = wm_obj.content.layers[0] lyrname = lyr.properties.name print(lyrname) print(lyr.url) print(f\u0026#34;Host Organization id: {lyr.url.split(\u0026#39;/\u0026#39;)[3]}\u0026#34;) ソースの組織 ID を出力すると、Web マップのレイヤーがソースでホストされていることがわかります。\nprint(f\u0026#34;{source.properties.id}\u0026#34;) search_existing_items パラメーターを使用することで、クローン作成時に Web マップで利用されるアイテムの動作を処理することができます。このパラメーターについて学んできたことを踏まえると、Web マップで利用されるアイテムの ID が、ターゲットに既に存在する typeKeywords のどれかと一致するかどうかを検出するために、このパラメーターを頼りにすることができます。もしこの関数がターゲットに既存のアイテムを見つけたら、新しい Web マップの定義に適切な値を追加します。typeKeyword に基づいて既存のアイテムが見つからない場合、そのアイテムをクローンします。ホストされていないアイテムの場合は、結果の Web マップでそれらのアイテムを再作成します。\nこの場合、この Web マップをクローンしたことがないので、False に設定します。ホストされているレイヤーもターゲットにクローンするようにします。\ncloned_wm = target.content.clone_items(items=[eki_wm_item], folder=\u0026#34;クローン先3\u0026#34;, search_existing_items=False) その結果、ターゲットにどのようなアイテムがあるか見てみましょう。\ncloned_wm cloned_wm_obj = Map(cloned_wm[1]) cloned_lyr = cloned_wm_obj.content.layers[0] cloned_lyrname = cloned_lyr.properties.name print(cloned_lyrname) print(cloned_lyr.url) print(f\u0026#34;Host Organization id: {cloned_lyr.url.split(\u0026#39;/\u0026#39;)[3]}\u0026#34;) clone_items() によって Web マップが正常に再作成され、操作レイヤーがクローンされ、クローンされたフィーチャ レイヤーを使用するように Web マップが構成されていることがわかります。レイヤー URL からも別の ArcGIS Online へクローンされたことが確認できます。\nArcGIS Enterprise へクローンした場合は、レイヤー URL のスキーム名とパス コンポーネントから、クローンされたレイヤーが ArcGIS Online の組織ではなく ArcGIS Enterprise の組織を使用していることがわかります。\nWeb マップを視覚的に比較してみましょう :\nソース wm_obj ターゲット cloned_wm_obj マップが同じレイヤーを含んでいるように見えることが視覚的にわかります。wm_map ディクショナリの他の Web マップのソースとターゲットのペアにもこのプロセスを繰り返して、視覚的に比較することができます。\nArcGIS Dashboards ArcGIS Dashboards のクローンの詳細については、Cloning and Troubleshooting Complex Itemsガイドを参照してください。\nStory Maps ArcGIS StoryMap のクローンの詳細については、Cloning and Troubleshooting Complex Itemsガイドを参照してください。\nまとめ このガイドでは、ソースの Web GIS とターゲットの Web GIS の間でアイテムをクローンするための 1 つのワークフローを示しました。それぞれの GIS に管理者として接続し、個々のアイテムをクローンし、次にアイテムのセットをクローンしました。次に、Web マップ アイテムをクローンし、同時に Web マップ内のホスト フィーチャ レイヤーもクローンされ、クローンされた Web マップがターゲット組織でホストされているクローンされたフィーチャ レイヤーを読み込むように構成される方法を示した。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/widget-ui/",
	"title": "ウィジェット UI の作成",
	"tags": [],
	"description": "ウィジェット UI の作成方法について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Create UI for widget\nExperience Builder のベースとなる Widget クラスは、React のコンポーネントサブクラスから拡張されています。PureComponent から拡張されており、render() と呼ばれる関数を提供しています。UI の作業のほとんどは、この関数の内部で行われることが予想されます。\nJSX の記述 UI テンプレートの作成に使用される React の構文は JSX と呼ばれています。これは HTML を書くのと非常に似ていますが、JavaScript の機能を完全に組み込んでいます。\nJSX の詳細を参照してください。\nここでは、ウィジェットの UI にいくつかの基本的な HTML 要素を追加する簡単な例を示します。\n// in widget.tsx: import { React, AllWidgetProps } from \u0026#39;jimu-core\u0026#39;; export default class Widget extends React.PureComponent\u0026lt;AllWidgetProps\u0026lt;{}\u0026gt;, any\u0026gt;{ render() { return \u0026lt;div className=\u0026#34;myWidget\u0026#34;\u0026gt; \u0026lt;p\u0026gt;This is a sample widget\u0026lt;/p\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; style={{background: \u0026#39;orange\u0026#39;}}\u0026gt;I\u0026#39;m a button\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;; } } Output 例: Jimu UI ライブラリの使用 Jimu フレームワークは、開発者がウィジェット開発で使用するコンポーネントの UI ライブラリを提供しています。\n 基本的な UI コンポーネント: button, dropdown, form controls, icon, navigation, modal, grid layout container など 高度な UI コンポーネント: date picker, resource selector, expression builder など  内部的には、Jimu の UI コンポーネントは Reactstrap と呼ばれる React Bootstrap フレームワークから拡張・カスタマイズされています。このライブラリは、他の類似した React UI ライブラリと同様に、コンポーネントの使用方法についても同様のパターンを踏襲しています。\n一般的に使用されているコンポーネントやアイコンのほとんどは、Storybookのサイト (https://developers.arcgis.com/experience-builder/storybook) にアクセスしてプレビューすることができます。\nExperience Builder の Storybook の詳細を参照してください。\nJimu UI は Experience Builder の公式 UI ライブラリであり、このライブラリのコンポーネントを考慮して UI 開発を利用することを強くお勧めします。その理由は以下の通りです。\n UI/UX の一貫性: ウィジェットの全体的な外観と操作感、それを使って作成されたアプリは、一貫したパターンに従います。 テーマ性：コンポーネントのスタイルは設定可能でテーマ性があるため、さまざまなテーマに対応したウィジェットを簡単に作ることができます。 Experience Builder および ArcGIS とのより良い統合が実現できます。  UI コンポーネント コンポーネントのインポート 基本的な UI コンポーネントは「jimu-ui」から直接インポートでき、高度な UI コンポーネントはパスを使用して個別にインポートする必要があります。\nimport { Button, Icon, TextInput } from \u0026#39;jimu-ui\u0026#39;; // basic import { DatePicker } from \u0026#39;jimu-ui/date-picker\u0026#39;; // advanced クイック サンプル ここでは、\u0026ldquo;primary\u0026rdquo; スタイルの Button コンポーネントとスターアイコンをウィジェットに追加しています。\n// in widget.tsx: import { React, AllWidgetProps } from \u0026#39;jimu-core\u0026#39;; import { Button, Icon } from \u0026#39;jimu-ui\u0026#39;; // import components  // Create an svg icon using Icon component: const iconNode = \u0026lt;Icon icon={require(\u0026#39;jimu-ui/lib/icons/star.svg\u0026#39;)} /\u0026gt;; export default class Widget extends React.PureComponent\u0026lt;AllWidgetProps, any\u0026gt;{ render(){ // Add Button component containing an icon to the widget:  return \u0026lt;Button type=\u0026#34;primary\u0026#34;\u0026gt;{iconNode} primary button\u0026lt;/Button\u0026gt;; } } Output 例: CSS ユーティリティクラス Jimu UI は、Bootstrap と同じ CSS ユーティリティクラスを提供しており、UI 要素に素早くスタイルを適用することができます。\nクイック サンプル ここでは w-100、p-3、bg-primary、text-white を追加して要素を作成しています。\n 親要素の幅を 100% に設定 1 rem の padding（パディング）を設定 背景色を テーマの primary color として設定 テキストカラーを テーマの white color として設定  // in the render() function:  return \u0026lt;div className=\u0026#34;w-100 p-3 bg-primary text-white\u0026#34;\u0026gt; \u0026lt;p\u0026gt;This is a sample widget\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;; Output 例: ウィジェット スタイル設定 Experience Builder では、ウィジェットのスタイルを設定するには 3 つのオプションがあります。\nインライン CSS React のコンテキストでは、インラインの CSS スタイルは JavaScript オブジェクトとして記述され、DOM 要素の style 属性に適用されます。\n// in the render() function: const containerStyle = { background: \u0026#39;darkblue\u0026#39;, color: \u0026#39;white\u0026#39;, width: 200, height: 150, padding: \u0026#39;1rem\u0026#39;, borderRadius: 5 }; return \u0026lt;div style={containerStyle} // CSS styles applied \u0026gt; content \u0026lt;/div\u0026gt;; Output 例: 外部 CSS スタイルシート 別の方法としては、外部スタイルシートのファイルで CSS スタイルを定義し、ウィジェット内で個別にインポートする方法があります。使用できるスタイルシートのファイルの拡張子は .css、.sass、および .scss です。\n先ほどのコードサンプルを例に、CSS スタイルを別のスタイルシート (例: style.css) に移動します。\n/* style.css */ .my-widget { background: \u0026#39;darkblue\u0026#39;; color: \u0026#39;white\u0026#39;; width: 200px; height: 150px; padding: \u0026#39;1rem\u0026#39;; border-radius: 5px; } としてウィジェットにファイルをインポートします。\n// widget.tsx: import \u0026#39;path/to/style.css\u0026#39;; そして、style.css で定義されている DOM 要素にクラス名を追加することを忘れないでください。\n// widget.tsx: // in the render() function:  return \u0026lt;div className=\u0026#34;my-widget\u0026#34;\u0026gt; content \u0026lt;/div\u0026gt;; Output 例: CSS-in-JS (推奨) CSS-in-JS とは、ベンダープレフィックス、スコープ付き CSS、JS ロジック、テーマ機能など、CSS では解決できない問題に対処するために JavaScript で CSS を書く方法のことを指します。\nStyled Components や Emotion など、よく知られている CSS-in-JS のライブラリがたくさんあります。Experience Builder では、スタイリングとテーマ設定を目的としたフレームワークとして Emotion を使用しています。\nEmotion には 2 つのスタイリング パターンがあります。\n1. css prop Emotion の css prop を使うと、React の style prop に比べて、より自然で親しみやすい方法で CSS スタイルを書くことができます。CSS スタイルは template literals で書くことができるので、CSS の中に JS ロジックを書くことができます。\n例えば、以下のサンプルの Counter ウィジェットは、カウント値が 2 以上になるとテキストの色が赤から緑に変わります。\n/// widget.tsx: /** @jsx jsx */ // \u0026lt;-- make sure to include the jsx pragma import { React, AllWidgetProps } from \u0026#39;jimu-core\u0026#39;; import { css, jsx } from \u0026#39;jimu-core\u0026#39;; import { Button, ButtonGroup } from \u0026#39;jimu-ui\u0026#39;; interface State { count: number; } export default class Widget extends React.PureComponent\u0026lt;AllWidgetProps\u0026lt;{}\u0026gt;, State\u0026gt;{ constructor(props) { super(props); this.state = { count: 0, }; } render() { const numberStyle = css` font-size: 2.5rem; color: ${this.state.count \u0026gt; 2 ? \u0026#39;green\u0026#39; : \u0026#39;red\u0026#39;}; `; return \u0026lt;div className=\u0026#34;text-center\u0026#34;\u0026gt; \u0026lt;p css={numberStyle}\u0026gt;{this.state.count}\u0026lt;/p\u0026gt; \u0026lt;ButtonGroup\u0026gt; \u0026lt;Button type=\u0026#34;secondary\u0026#34; onClick={e =\u0026gt; {this.setState({ count: this.state.count - 1 })}}\u0026gt; - \u0026lt;/Button\u0026gt; \u0026lt;Button type=\u0026#34;secondary\u0026#34; onClick={e =\u0026gt; {this.setState({ count: this.state.count + 1 })}}\u0026gt; + \u0026lt;/Button\u0026gt; \u0026lt;/ButtonGroup\u0026gt; \u0026lt;/div\u0026gt;; } } Output 例: 2. Styled Components このパターンは Styled-Components ライブラリにインスピレーションされたもので、使い方は非常に似ています。\u0026ldquo;styled\u0026rdquo; アプローチは、ウィジェット内で再利用可能なコンポーネントを作成するのに最適です。\n/** @jsx jsx */ // \u0026lt;-- make sure to include the jsx pragma import { React, AllWidgetProps } from \u0026#39;jimu-core\u0026#39;; import { styled, jsx } from \u0026#39;jimu-core\u0026#39;; // A styled button component: const StyledButton = styled.button` color: white; background-color: blue; transition: 0.15s ease-in all; \u0026amp;:hover { background-color: darkblue; } `; export default class Widget extends React.PureComponent\u0026lt;AllWidgetProps\u0026lt;{}\u0026gt;\u0026gt;{ render() { return \u0026lt;StyledButton\u0026gt; A styled HTML Button \u0026lt;/StyledButton\u0026gt;; } } Output 例: 3. テーマを使った作業 これは、ウィジェットをアプリケーションの他の部分と一貫して見えるようにしたい場合や、テーマが変更されたときに自動的に見た目や操作感を更新したい場合に必要です。\nExperience Builder フレームワークは、テーマ変数を JSON オブジェクトとして提供し、それをプロパティとしてウィジェットに挿入します。色、フォント、サイズ、コンポーネントなど、すべてのテーマ変数にアクセスできます。\nウィジェット内のテーマ変数にアクセスし、CSS 宣言でそれらを参照するには this.props.theme を使用します。例えば、以下のようになります。\n/** @jsx jsx */ // \u0026lt;-- make sure to include the jsx pragma import { React, AllWidgetProps } from \u0026#39;jimu-core\u0026#39;; import { css, jsx } from \u0026#39;jimu-core\u0026#39;; export default class Widget extends React.PureComponent\u0026lt;AllWidgetProps\u0026lt;{}\u0026gt;\u0026gt;{ render() { const theme = this.props.theme; const style = css` background: ${theme.colors.palette.primary[100]}; color: ${theme.colors.black}; padding: ${theme.sizes[3]}; `; return \u0026lt;div css={style}\u0026gt; \u0026lt;p\u0026gt;This is a sample widget\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;; } } Output 例: default theme vs. dark theme\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/widget/",
	"title": "ウィジェット（Widget）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Widget\nウィジェット（Widget） ウィジェットは設定可能な機能単位で、エクスペリエンスのページを作成するために使用されるビルディング ブロックです。Experience Builder は、マップ、ボタン、リストなどのすぐに使える（OOB）ウィジェットが用意されており、カスタム ウィジェットを作成することも可能です。ウィジェットは通常、ユーザーがビルダー環境で機能を設定できるように設定 UI を提供します。ウィジェットに設定可能なオプションがありますが、設定 UI が含まれていない場合は、JSON エディタを使用して設定することが可能です。\nウィジェットの実装についてはこちらをご覧ください。\napp config では、widgets でウィジェットを定義します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/hackathon/",
	"title": "ミートアップ",
	"tags": [],
	"description": "ミートアップ参加者を支援するリソースをまとめています。",
	"content": "ミートアップ参加者を支援するリソースをまとめています。\nオープンデータを入手する ArcGIS Open Data では ArcGIS のクラウドで公開されている全世界のオープンデータを検索・参照・ダウンロードが可能です。 自由に使える地理データを取得する方法を紹介します。\n オープンデータの入手 (ArcGIS Open Data コミュニティサイト)  地図にデータを可視化する 座標情報を持った地理データや住所情報を持ったテキストデータなどを可視化して、アプリに組み込むための地図を作成する方法や Tips を紹介します。 なお、データ可視化の作業はコーディングが不要なので、プランナーやデザイナーの方でも取り組んでいただくことができます。\n データ可視化のワークフロー データ可視化の手順 データ可視化の手順（3D） 地図上に賢くデータを可視化するための 6 つの方法  アプリに地図を組み込む アプリに ArcGIS の地図を組み込む際に便利な開発キットやライブラリです。アプリ作成ツールを活用することで、ノンコーディングでアプリを作成することも可能です。\nコードを書く JavaScript  ArcGIS Web API: リファレンス (英語) | 日本語ガイド Leaflet.js (Esri Leaflet): リファレンス (英語) | 日本語ガイド(ブログ記事)  Android  ArcGIS Runtime SDK: リファレンス (英語) | 日本語ガイド  iOS  ArcGIS Runtime SDK: リファレンス (英語) | 日本語ガイド  .NET  ArcGIS Runtime SDK: リファレンス (英語) | 日本語ガイド  コードを書かない アプリケーション ビルダー  Web AppBuilder for ArcGIS: リファレンス | 日本語ガイド  ストーリーマップ  ストーリーマップ: リファレンス  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/unity/",
	"title": "ArcGIS Maps SDK for Unity",
	"tags": [],
	"description": "ArcGIS Maps SDK for Unity の開発に役立つガイド集です。",
	"content": "ArcGIS Maps SDK for Unity の開発に役立つガイド集です。\nArcGIS Map SDK for Unity は、現在 ESRIジャパンにおけるサポート対象外の製品です。\nESRIジャパンで提供する Esri 製品サポート サービスや開発者サポート サービスはご利用いただけませんので、予めご了承ください。\n\r インストール ガイド\nArcGIS Maps SDK for Unity のインストールとセットアップ手順を紹介します。\n\r 新規プロジェクトにプラグインを追加\nArcGIS Maps SDK for Unity を新規プロジェクトに導入する手順を紹介します 。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-flutter/",
	"title": "Flutter",
	"tags": [],
	"description": "ArcGIS Maps SDK for Flutter を用いたネイティブ地図アプリの作成方法を紹介します。",
	"content": "出典：ArcGIS Maps SDK for Flutter - Tutorials - Display a map\nマップを表示する このチュートリアルでは ArcGIS Maps SDK for Flutter を使用して、マップとベースマップ レイヤーを表示する方法を紹介します。\nマップには、地理データのレイヤーが含まれています。マップには、ベースマップ レイヤーと、オプションで 1 つ以上のデータ レイヤーを追加できます。\nこのチュートリアルでは、地形図ベースマップ レイヤーを使用して、富士山付近を表示する地図を作成します。\nこのマップとコードは、他の 2D チュートリアルの出発点として使用されます。\nこのチュートリアルのトピックの背景情報については、Mapping API and location services guide の Maps (2D) と ベースマップ を参照してください。\n\rAndroid Studio の最新リリースである Meerkat 2024.3.1 以降を使用している場合、pub.dev で arcgis_maps パッケージを使用すると、SDK の依存関係の管理で問題が発生する可能性があります。 これを解決するには、Flutter のデフォルト JDK として JDK 17 を設定する必要があります。\n  macOS の場合：Homebrew を使用して macOS に JDK 17 をインストールします。\nbrew install openjdk@17\rsudo ln -sfn /opt/homebrew/opt/openjdk@17/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-17.jdk\rflutter config --jdk-dir=/opt/homebrew/Cellar/openjdk@17/17.0.14/libexec/openjdk.jdk/Contents/Home\r  Windowsの場合：Microsoft の OpenJDK ページから OpenJDK 17 をダウンロードして、zip ファイルを任意のフォルダに解凍した後、PowerShell を使用して設定します。\nflutter config --jdk-dir PATH-TO-JDK\r  \r前提条件 このチュートリアルを実施するには、以下が必要です。\n API キーにアクセスするための ArcGIS 開発者アカウント。アカウントをお持ちでない場合は、サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。 開発環境がシステム要件を満たしており、Flutter の開発環境 が整っていることを確認します。 Flutter 用の IDE。VS Code を推奨しています。  ステップ 新しい Flutter アプリを作成する   VS Code を開き、Welcome タブで [Open Folder\u0026hellip;] を選択します。プロジェクトの場所を選んでください。\n  [View] \u0026gt; [Terminal] に進みます。\n  ターミナル ウィンドウで以下のコマンドを使い、display_a_map という新しい Flutter アプリを作成します。 必要なターゲット プラットフォームと 組織名 com.example.app を設定します。\nflutter create -e display_a_map --platforms ios,android --org com.example.app   ArcGIS Maps SDK for Flutter を追加する arcgis_maps パッケージに依存関係を追加します。\n VS Code のターミナルで、ディレクトリーを新しいプロジェクトに変更します。 cd display_a_map  以下のコマンドを実行します。 dart pub add arcgis_maps  以下のコマンドを実行します。 flutter pub upgrade  最後に、以下のコマンドを実行します。 dart run arcgis_maps install   プラットフォーム固有の構成 Android   プロジェクトの android/app/build.gradle.kts ファイルを編集して、最小要件を更新します。\nbuild.gradle.kts\nandroid { namespace = \u0026#34;com.example.app.display_a_map\u0026#34; compileSdk = flutter.compileSdkVersion ndkVersion = \u0026#34;27.0.12077973\u0026#34; //変更  compileOptions { sourceCompatibility = JavaVersion.VERSION_11 targetCompatibility = JavaVersion.VERSION_11 } kotlinOptions { jvmTarget = JavaVersion.VERSION_11.toString() } defaultConfig { // TODO: 任意のアプリケーション ID を指定します (https://developer.android.com/studio/build/application-id.html).  applicationId = \u0026#34;com.example.app.display_a_map\u0026#34; // アプリケーションの要件に合わせて次の値を更新します。  // 詳細については https://flutter.dev/to/review-gradle-config を参照してください。  minSdk = 26 //変更  targetSdk = flutter.targetSdkVersion versionCode = flutter.versionCode versionName = flutter.versionName }   プロジェクトの android/settings.gradle.kts ファイルを編集して、Kotlin のバージョンを更新します。\nsettings.gradle.kts\nplugins { id \u0026#34;dev.flutter.flutter-plugin-loader\u0026#34; version \u0026#34;1.0.0\u0026#34; id \u0026#34;com.android.application\u0026#34; version \u0026#34;8.7.0\u0026#34; apply false id \u0026#34;org.jetbrains.kotlin.android\u0026#34; version \u0026#34;1.9.0\u0026#34; apply false //変更 }   android/app/src/main/AndroidManifest.xml に、オンライン リソースにアクセスするためのパーミッションを追加します。\nAndroidManifest.xml\n\u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34; /\u0026gt; \u0026lt;!-- 追加 --\u0026gt; \u0026lt;application android:label=\u0026#34;display_a_map\u0026#34; android:name=\u0026#34;${applicationName}\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34;\u0026gt;   iOS   ios/Podfile ファイルを編集して iOS 16.0 を最小に設定します。 行のコメントを解除し、バージョン番号を更新します。\nPodfile\n# Uncomment this line to define a global platform for your project platform :ios, \u0026#39;16.0\u0026#39; #変更   Runtimecore pod と arcgis_maps_ffi pod を Runner ターゲット セクションに追加します。\nPodfile\ntarget \u0026#39;Runner\u0026#39; do use_frameworks! use_modular_headers! #変更開始 pod \u0026#39;Runtimecore\u0026#39;, :podspec =\u0026gt; \u0026#39;../arcgis_maps_core/ios/Runtimecore.podspec\u0026#39; pod \u0026#39;arcgis_maps_ffi\u0026#39;, :podspec =\u0026gt; \u0026#39;../arcgis_maps_core/ios/arcgis_maps_ffi.podspec\u0026#39; #変更終了 flutter_install_all_ios_pods File.dirname(File.realpath(__FILE__)) target \u0026#39;RunnerTests\u0026#39; do inherit! :search_paths end end   pod update を使用して Pods を設定します。\ncd ios \u0026amp;\u0026amp; pod update \u0026amp;\u0026amp; cd ..   アクセス トークンを取得する このチュートリアルで使用するロケーション サービスを使用するには、アクセス トークンが必要です。\n アクセス トークンを取得するには、API キーの取得 チュートリアルに進んでください。 次の権限が有効になっていることを確認してください。[ロケーション サービス] \u0026gt; [ベースマップ] \u0026gt; [ベースマップ スタイル サービス] アクセス トークンをコピーします。  アクセス トークンを取得する他の方法については、Types of authentication を参照してください。\nAPI キーを設定する   VS Codeで、lib/main.dart を開きます。\n  arcgis_maps パッケージをインポートします。\nmain.dart\nimport \u0026#39;package:flutter/material.dart\u0026#39;; import \u0026#39;package:arcgis_maps/arcgis_maps.dart\u0026#39;; //追加   main() 関数で、const apiKey を定義し、その値にアクセス トークンを設定します。\nvoid main() { const apiKey = \u0026#39;\u0026#39;; // アクセス トークンをここに記入します。 //追加  runApp(const MainApp()); }  このチュートリアルでは便宜上、アクセス トークンをコードに直接格納しています。アクセス トークンをソース コードに格納することはベスト プラクティスではありません。\n\r  ArcGISEnvironment.apiKey を apiKey 定数に設定します。\nmain.dart\nvoid main() { const apiKey = \u0026#39;\u0026#39;; // アクセス トークンをここに記入します。  ArcGISEnvironment.apiKey = apiKey; //追加  runApp(const MainApp()); }  API キーが必要なのにアクセス トークンが設定されていない（または無効な値が設定されている）場合、チュートリアルのコードを実行すると次のようなエラーが表示されることがあります。\nUnhandled Loadable ArcGISMap load error: ArcGISException: code=22; HttpException: Failed to parse header value\nこのエラーが発生した場合は、有効なアクセス トークンが ArcGISEnvironment.apiKey プロパティに設定されていることを確認してください。Flutter のコア HTTP スタックに既知の問題があるため、ArcGIS Maps SDK for Flutter は現時点でより明確なエラーを確実に提供することができません。\n\r  runApp() 内で MaterialApp をインスタンス化し、名前付き引数の home に MainApp のインスタンスを設定します。\nmain.dart\nvoid main() { const apiKey = \u0026#39;\u0026#39;; // アクセス トークンをここに記入します。  ArcGISEnvironment.apiKey = apiKey; runApp( //変更開始  const MaterialApp( home: MainApp(), ), //変更終了  ); }   マップを追加する 地形図ベースマップ レイヤーを含む地図を作成します。 地図は富士山の付近とします。\n  テンプレート MainApp クラス定義をリファクタリングして、StatefulWidget を拡張します。 StatelessWidget キーワードにマウス カーソルを合わせて右クリックし、[Refactor\u0026hellip;] から、[Convert to StatefulWidget] を選択してコードをリファクタリングします。\nArcGIS Maps SDK for Flutter で作業していると、データの変更に応じて UI を更新するなど、アプリケーションの状態の更新が必要になることがよくあります。 ステートフル ウィジェットを実装することで、アプリはこのような状況に対応できます。 ステートレス ウィジェットの実装を使用して、単に地図を表示することも可能です。Display map サンプルをご確認ください。\nmain.dart\nclass MainApp extends StatefulWidget { //変更  const MainApp({super.key}); // 変更開始  @override State\u0026lt;MainApp\u0026gt; createState() =\u0026gt; _MainAppState(); // 変更終了  } //追加開始 class _MainAppState extends State\u0026lt;MainApp\u0026gt; { @override Widget build(BuildContext context) { return const MaterialApp( home: Scaffold( body: Center( child: Text(\u0026#39;Hello World!\u0026#39;), ), ), ); } } //追加終了   build メソッド内で返される MaterialApp ウィジェットを削除します。 このコードは Flutter create テンプレートによって生成されたもので、次項でマップを含むウィジェットを返すコードに置き換えられます。\nmain.dart\nclass MainApp extends StatefulWidget { const MainApp({super.key}); @override State\u0026lt;MainApp\u0026gt; createState() =\u0026gt; _MainAppState(); } class _MainAppState extends State\u0026lt;MainApp\u0026gt; { @override Widget build(BuildContext context) { // 削除開始  return const MaterialApp( home: Scaffold( body: Center( child: Text(\u0026#39;Hello World!\u0026#39;), ), ), ); // 削除終了  } }   _MainAppState クラスの内部で、最後のクラス メンバー変数 _mapViewController を定義し、ArcGISMapView クラスの createController() を呼び出して ArcGISMapViewController で初期化します。\nArcGIS マップ ビュー コントローラーは、ArcGISMap で定義された 2 次元 (2D) 地理コンテンツを表示するユーザー インタフェース コントロールです。\nmain.dart\nclass _MainAppState extends State\u0026lt;MainApp\u0026gt; { final _mapViewController = ArcGISMapView.createController(); //追加  @override Widget build(BuildContext context) { } }   build メソッド内で Scaffold、Column、Expanded からなるウィジェット ツリーに ArcGISMapView ウィジェットを追加します。 引数名 controllerProvider をクラス メンバー変数 _mapViewController に設定し、onMapViewReady 引数を次に定義する引数と同じ名前の新しいメソッドに設定します。\nScaffold ウィジェットは基本的なマテリアル デザインのビジュアル レイアウト構造を提供し、Column ウィジェットは子ウィジェットを垂直配列で表示します。ArcGISMapView ウィジェットは、サイズが制限されたウィジェット内でのみ使用できます。 サイズが制限されていない状態で使用すると、アプリケーションは例外をスローします。 たとえば、ArcGISMapView を Column ウィジェット内で使用すると、サイズが制限されないため、このような例外が発生します。 代わりに、チュートリアルのこのステップで説明するように、ArcGISMapView を Expanded ウィジェットでラップして、適切な境界を提供することができます。\nmain.dart\nclass _MainAppState extends State\u0026lt;MainApp\u0026gt; { final _mapViewController = ArcGISMapView.createController(); @override Widget build(BuildContext context) { //追加開始  return Scaffold( body: Column( children: [ Expanded( child: ArcGISMapView( controllerProvider: () =\u0026gt; _mapViewController, onMapViewReady: onMapViewReady, ), ), ], ), ); //追加終了  } }   MainAppState 内で、何も返さない新しいメソッド onMapViewReady() を定義します。\nmain.dart\nclass _MainAppState extends State\u0026lt;MainApp\u0026gt; { final _mapViewController = ArcGISMapView.createController(); @override Widget build(BuildContext context) { return Scaffold( body: Column( children: [ Expanded( child: ArcGISMapView( controllerProvider: () =\u0026gt; _mapViewController, onMapViewReady: onMapViewReady, ), ), ], ), ); } //追加開始  void onMapViewReady() { } //追加終了  }   新しいメソッド内で final 変数 basemapStyleParams、basemap、map を定義します。それぞれの定義は以下の通りです。\n basemapStyleParams: BasemapStyleParameters をインスタンス化し、specificLanguage を日本語に変更します。 basemap: ArcGIS Topographic ベースマップ スタイルと 生成した basemapStyleParams で Basemap をインスタンス化します。 map: basemap で ArcGISMap をインスタンス化します。  main.dart\nclass _MainAppState extends State\u0026lt;MainApp\u0026gt; { final _mapViewController = ArcGISMapView.createController(); @override Widget build(BuildContext context) { return Scaffold( body: Column( children: [ Expanded( child: ArcGISMapView( controllerProvider: () =\u0026gt; _mapViewController, onMapViewReady: onMapViewReady, ), ), ], ), ); } void onMapViewReady() { //追加開始  final basemapStyleParams = BasemapStyleParameters(); basemapStyleParams.specificLanguage = \u0026#34;ja\u0026#34;; //ベースマップの言語を日本語に設定  final basemap = Basemap.withStyle(BasemapStyle.arcGISTopographic, parameters: basemapStyleParams); //ベースマップに設定を適用  final map = ArcGISMap.withBasemap(basemap); //設定したベースマップでマップを生成  //追加終了  } }   ArcGIS マップ ビュー コントローラーの arcGISMap プロパティーを map に設定します。 さらに、setViewpoint() を呼び出して、富士山にズームします。\nmain.dart\nclass _MainAppState extends State\u0026lt;MainApp\u0026gt; { final _mapViewController = ArcGISMapView.createController(); @override Widget build(BuildContext context) { return Scaffold( body: Column( children: [ Expanded( child: ArcGISMapView( controllerProvider: () =\u0026gt; _mapViewController, onMapViewReady: onMapViewReady, ), ), ], ), ); } void onMapViewReady() { final basemapStyleParams = BasemapStyleParameters(); basemapStyleParams.specificLanguage = \u0026#34;ja\u0026#34;; //ベースマップの言語を日本語に設定  final basemap = Basemap.withStyle(BasemapStyle.arcGISTopographic, parameters: basemapStyleParams); //ベースマップに設定を適用  final map = ArcGISMap.withBasemap(basemap); //設定したベースマップでマップを生成  //追加開始  _mapViewController.arcGISMap = map; _mapViewController.setViewpoint( Viewpoint.withLatLongScale( latitude: 35.360626, longitude: 138.727363, scale: 200000.0, ), ); //追加終了  } }   アプリを実行する  Android エミュレーター、iOS シミュレーター、または物理的なデバイスが設定され、実行されていることを確認します。 VS Codeで、[Run] \u0026gt; [Run Without Debugging] を選択します。  完成版のプロジェクトはこちらからダウンロードできます（マップの表示場所は本チュートリアルで設定した場所とは異なります）。\nダウンロードしたソリューションを実行する プロジェクト ソリューションをダウンロードした場合は、以下の手順に従ってアプリケーションを実行します。\n  VS Code で展開したプロジェクトを開きます。\n  VS Code のターミナルで、以下のコマンドを実行します。\nflutter pub upgrade   以下のコマンドを実行します。\ndart run arcgis_maps install   アクセス トークンを取得し、ソース コード ファイルに API キーを設定します。\n  Android エミュレーター、iOS シミュレーター、または物理デバイスが設定され、実行されていることを確認します。\n  VS Code で、[Run] \u0026gt; [Run Without Debugging] を選択します。\n  Web マップを表示する 「Web マップの作成」のガイドで Web マップを作成している場合は、作成した Web マップも基本的に同じステップで表示できます。\n  マップを表示するのステップで作成したプロジェクトの main.dart を開き、onMapViewReady() を下記のように書き換えます。\nmain.dart\nvoid onMapViewReady() { //アイテム ID を使用して、Web マップをポータル アイテムとして取得します。  final portalItem = PortalItem.withPortalAndItemId( portal: Portal.arcGISOnline(), itemId: \u0026#34;Web マップの ID\u0026#34;, ); //ポータル アイテムからマップを作成します。  final map = ArcGISMap.withItem(portalItem); _mapViewController.arcGISMap = map; }    アプリの動作が確認できたら ArcGIS の セキュリティーと認証について学びましょう！\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/jimu/",
	"title": "Jimu",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Jimu\nJimu Jimu は、設定可能なエクスペリエンスを作成するために使用される JavaScript ライブラリーで、以下のようなパッケージで構成される拡張フレームワークです。\n jimu-arcgis パッケージは、ArcGIS Maps SDK for JavaScript を実行するためのクラスとメソッドが含まれています。よく使われるクラスは JimuMapView と JimuMapViewComponent です。 jimu-core パッケージは、ウィジェットのプロパティ、メッセージ アクション、データ ソースを扱うためのインターフェイスと型を提供します。また、エクスペリエンスを通じて使用されるいくつかのクラスも定義しています。 jimu-for-builder パッケージは、SettingChangeFunction や WidgetSettingProps といったウィジェット設定ページを開発するためのクラスを提供します。 jimu-for-test パッケージは、ユニット テストに使用できるクラス、型、関数が含まれています。 jimu-ui パッケージは、エクスペリエンスが使用するすべての UI コンポーネントが含まれています。パフォーマンス上の理由から、UI コンポーネントは 3 つのカテゴリに分かれています。jimu-ui のエントリーには、Button や Input などの一般的な UI コンポーネントが含まれています。jimu-ui/basic 以下のエントリーには、ColorPicker や QRCode などの目的に応じたコンポーネントが含まれます。jimu-ui/advanced 以下のエントリーは重く、複雑です。例えば、setting-components エントリーには、ウィジェットの設定で使用される可能性のある複数のコンポーネントが含まれています。  これらのパッケージは同じ構造パターンを使用しているため、同じベストプラクティスに沿って使用することができます。各パッケージは import するためのいくつかのエントリーを定義し、これらのエントリーはパッケージのルート フォルダーの下に置かれます。lib フォルダー内のコンテンツは，パッケージの内部コンテンツとみなされますので，ウィジェットには import しないでください。例えば、jimu-ui の Button コンポーネントを使用する必要がある場合は、import {Button} from 'jimu-ui' ではなく、import {Button} from 'jimu-ui/lib/components/button' のようにインポートする必要があります。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/use-data-source-in-widget/",
	"title": "ウィジェットでデータ ソースを使用",
	"tags": [],
	"description": "ウィジェットでデータ ソースを使用する方法について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Use data source in widget\nデータ ソースは、ウィジェットがデータにアクセスする方法を定義します。データ ソースを使用して行いたいことは様々ですが、それぞれについて紹介します。\n ウィジェットの設定でデータ ソースを選択 ウィジェット ランタイムのデータを読み込んで表示 ユーザー入力に基づくデータのフィルタリングやクエリ データ上の選択を処理 ArcGIS Maps SDK for JavaScript のフィーチャ オブジェクトとデータ ソースの同期 ウィジェットで出力データ ソースの生成 ウィジェットでメッセージの公開  本ドキュメントで使用している appConfig という変数は、アプリの config JSON オブジェクトを指します。ArcGIS Online または Enterprise 版では、アプリの config JSON はアイテム データとして保存され、Developer Edition では server/public/apps/[appId]/config.json (公開版) または server/public/apps/[appId]/resources/config.json (ドラフト版) の下に保存されます。\n\rウィジェットの設定でデータ ソースを選択 ウィジェットの設定でデータ ソースを選択するには、DataSourceSelector コンポーネントを使用する必要があります。Experience Builder は、複数の種類のデータ ソースをサポートしています。これらのデータ ソースは jimu-core と jimu-arcgis の 2 つのパッケージに入っています。jimu-core の DataSourceTypes と jimu-arcgis の DataSourceTypes をご覧ください。jimu-arcgis のデータ ソースは ArcGIS Maps SDK for JavaScript に依存しており、jimu-core のデータ ソースは依存していません。\nDataSourceSelector コンポーネントを使用するには、types プロパティを通じてウィジェットがサポートするデータ ソースの種類を設定する必要があります。データ ソースを選択した後、onChange コールバックにより選択されたデータ ソースを取得することができます。onChange コールバックでは、props.onSettingChange() を呼び出して、選択したデータ ソースを appConfig に保存する必要があります (appConfig.widgets[widgetId].useDataSources)。ユーザーが新しいデータ ソースを追加した場合、新しく追加されたデータ ソースは appConfig.dataSources に保存されます。こちらのサンプルウィジェットを参照してください。\n\u0026lt;DataSourceSelector types={Immutable([AllDataSourceTypes.FeatureLayer])} useDataSources={props.useDataSources} useDataSourcesEnabled={props.useDataSourcesEnabled} onToggleUseDataEnabled={onToggleUseDataEnabled} onChange={onDataSourceChange} widgetId={props.id} /\u0026gt; データ ソースを選択した後、ユーザーがデータからフィールドを選択できるようにしたい場合があります。そのためには、FieldSelector コンポーネントを使用します。データ ソースと同様に、appConfig.widgets[widgetId].useDataSources にも選択したフィールドを保存する必要があります。\n{ props.useDataSources \u0026amp;\u0026amp; props.useDataSources.length \u0026gt; 0 \u0026amp;\u0026amp; \u0026lt;FieldSelector useDataSources={props.useDataSources} onChange={onFieldChange} selectedFields={props.useDataSources[0].fields || Immutable([])} /\u0026gt; } ウィジェット ランタイムのデータを読み込んで表示 ウィジェット設定でデータ ソースを選択すると、ウィジェットランタイムは props.useDataSources で選択したデータ ソースを取得することができます。データを読み込むには、DataSource インスタンスを使用します。DataSource インスタンスを取得するには、DataSourceManager またはDataSourceComponent を使用します。DataSourceComponent を使用する場合は、useDataSource プロパティを渡します。DataSource インスタンスを取得するには、onDataSourceCreated コールバックを使用します。\nデータを読み込むには、render 関数を使用してデータを表示します。こちらのサンプルウィジェットを参照してください。別の方法として、onDataSourceInfoChange コールバックを使用し、データ ソースの現在のデータに応じてこのコールバック関数でウィジェットの UI を更新することができます。ウィジェットがデータをロードする必要がある場合、query と widgetId プロパティを渡します。フレームワークは、複数のウィジェットが同じデータ ソースに適用するクエリパラメータを管理するのにこのプロパティを使用するため、widgetId は必須です。\nデータをロードしたいが、データ ソースのデータを変更したくない場合は、localId プロパティを渡します。これにより、ローカルデータ ソースが作成され、使用することができます。推奨される localId のパターンは、例えば、widget_1_my_local のように widgetId + ??? とします。\nDataSourceComponent をレンダリングすると、データ ソースのインスタンスが作成されますが、データは初期状態ではロードされません。なぜなら、query プロパティを渡すことを期待しているので、別のネットワーク要求が発生するためです。読み込まれたデータを取得するには、dataSource.getRecords() を使用します。データはページングされ、デフォルトのページングサイズは 100 です。ユーザーはビルダーデータ設定パネルでページングサイズを変更することができます。ロードされたデータはクライアント上にキャッシュされ、クエリ条件が変更されるとキャッシュはクリアされます。\nデータを表示する際、表示されるページサイズはクエリのページサイズと同じである必要はありません。例えば、クエリのページサイズが 100 の場合、dataSource.getRecordsByPage(1, 10) を使用して、最初の 10 レコードを取得して表示することが可能です。\nレコードの総数を取得するには、queryCount プロパティを渡し、dataSource.count で件数を取得します。\nデータ ソース情報が変更されるたびに、データレンダリング関数とonDataSourceInfoChange コールバックが呼び出されます。情報の内容は以下の通りです。\n instanceStatus: データ ソースのインスタンスが正常に作成されたかどうか status: データがロード中か、ロードされたか countStatus: データのカウントがロード中か、ロードされたか selectedIds: 選択されたデータ ID selectOptions: クエリ (フィルター) でデータを選択すると、データ ソースはクエリを実行し、その結果を selectedIds に格納する widgetQueries: データ ソースに適用されるクエリ (フィルター) ウィジェット version: バージョン番号は、クライアント側でデータの変更を管理するために使用されます。そのため、データ ソース利用者はデータが変更されたことを認識することができます。 gdbVersion: ブランチ バージョニングをサポートするフィーチャ サービスのためのもの。ブランチ バージョン管理ウィジェットでブランチ バージョンが切り替わると、そのバージョンがここに保存されます。  多くの場合、ウィジェットは現在のデータ ソース情報と以前の情報とを比較して、何を更新する必要があるかを判断する必要があります。\nウィジェットがデータ ソースの情報変更を聞く必要があるが、データ ソースのデータレコードを使う必要がない場合、query パラメータを省略し、onQueryRequired コールバックでクエリを実行することが可能です。\nデータ ソースのフィールドを取得するには、dataSource.getSchema().fields を使用します。\nユーザー入力に基づくデータのフィルタリングやクエリ ウィジェットがデータをフィルタリングすると、データ ソース インスタンスのデータが変更され、すべてのウィジェットがその変更を観察します。ウィジェットがデータ ソースを介してデータをクエリする場合、データ ソース インスタンスのデータは影響を受けません。\n複数のウィジェットが同じデータ ソースにフィルタを適用する場合、属性フィルターは and 演算子で結びつけられます。ジオメトリ フィルターの場合、最後にジオメトリ フィルターを適用したウィジェット (アプリ設定でのウィジェット追加順) からのフィルタが使用されます。\n  データ ソースにフィルタをかけるには、データ ソースの設定により、基本的に2つの方法があります。\n ウィジェットでデータを読み込む場合は、以下のようにDataSourceComponent を使うのがおすすめです。  \u0026lt;DataSourceComponent useDataSource={} widgetId={} query={}\u0026gt; { Your render method } \u0026lt;/DataSourceComponent\u0026gt; DataSourceComponent の使用例は、Message subscriber のサンプルと Server-side output data source のサンプルに記載されています。\ndataSource.load() を使用して、データの読み込みとフィルタリングも可能です。\n\r ウィジェットがデータを読み込まない場合は、Data Source の updateQueryParams() 関数を使用することができます。例として、Filter feature layer のサンプルをご覧ください。    データ ソースからデータをクエリするには、dataSource.query() を使用します。データをクエリする際には、このデータ ソースに適用されているフィルタも使用されます。\n  データ上の選択を処理 Experience Builder アプリで設計された選択の動作は、すべてのウィジェットが同じ選択を更新し、観察することです。例えば、ユーザーがリスト ウィジェット内のレコードを選択すると、選択ビューを使用しているテキスト ウィジェットにはその選択内容が表示されます。すべてのデータ ソースには、選択範囲を管理する選択範囲データ ビューがあります。選択データビューの他に、選択されたレコードの ID が Redux アプリ ストアに保存されるので、データ ソースを使用するウィジェットは、選択内容が変更されたときに通知を受けることができます。\nデータ ソース内のデータレコードを選択するには、dataSource.selectRecordById() または dataSource.selectRecordsByIds() を使用することができます。レコードがデータ ソースに読み込まれている場合は、2 番目のパラメータを渡す必要はありません。そうでない場合は、選択項目を使用する他のウィジェットがレコードを読み込めるようにするために、2 番目のパラメータを渡す必要があります。\n選択範囲を読み取るには、dataSource.getSelectedRecords() を使用します。\nWebMap/WebScene の使用 ArcGIS Maps SDK for JavaScript の WebMap と WebScene は、データ ソースとして jimu-arcgis パッケージでラッピングされています。WebMap にアクセスする場合は WebMapDataSource を、WebScene にアクセスする場合は WebSceneDataSource を使用します。これらのデータ ソースの使用方法については、MapView のサンプルをご覧ください。WebMap と WebScene オブジェクトに加えて、これらのオブジェクト内のすべてのレイヤーはデータ ソースとしてラッピングされているため、getChildDataSources() を呼び出してすべてのレイヤー データ ソースを取得できます。サポートされるレイヤーとサービスは、SupportedLayerServiceTypes と SupportedServiceTypes で定義されています。ArcGIS Maps SDK for JavaScript のlayerがあり、関連するレイヤーのデータ ソースを検索したい場合は、mapDs.getDataSourceByLayer() または mapDs.createDataSourceByLayer() を実行します。DataSourceComponent または DataSourceManager でマップ データ ソース (WebMapDataSource または WebSceneDataSource) を作成した場合、アプリの起動後、その子データ ソースは自動的に作成されないことに注意してください。すべての子データ ソースを作成するには、await mapDs.childDataSourcesReady() を実行します。\nFeatureLayer の使用 ワークフローによっては、フィーチャ レイヤーで直接動作する軽量なエクスペリエンスを作成する必要があります。このシナリオでは、FeatureLayerDataSource クラスを使用します。一般的に、スタンドアロン レイヤーを使用するウィジェットは、layer プロパティを持たない FeatureLayerDataSource オブジェクトを取得しますが、Web マップまたは Web シーンからのフィーチャ レイヤーを使用すると、layer プロパティを持つ FeatureLayerDataSource オブジェクトを返します。Layer オブジェクトは ArcGIS Maps SDK for JavaScript から提供されています。ポップアップ情報を取得するには featureLayerDs.getPopupInfo() を、ID フィールドを取得するには featureLayerDs.getIdField() を、ジオメトリ タイプを取得するには featureLayerDs.getGeometryType() を使用します。\nconst getLayerObject = (ds: FeatureLayerDataSource) =\u0026gt; { return ds.layer; // this can be null  } ウィジェット間のデータ共有 ウィジェットは、多くの場合、同じデータを共有します。この良い例が、エクスペリエンスでマップ ウィジェットとリスト ウィジェットを使用する場合です。リスト ウィジェットでフィーチャを選択すると、対応するフィーチャがマップ上で選択されます。これを実現する最も簡単な方法は、両方のウィジェットに同じデータ ソースを使用することです。たとえば、リスト ウィジェットでアイテムが選択されると、ウィジェットは datasource.selectRecord() を呼び出して、app store のデータ ソースの状態を更新します。これにより、マップ ウィジェットでは、現在選択されているアイテムを適宜レンダリングすることができます。また、現在選択されているアイテムの ID が URL に配置されるため、現在のアプリの状態を他の人と共有することが可能になります。\nArcGIS Maps SDK for JavaScript のフィーチャ オブジェクトとデータ ソースの同期 Experience Builder ウィジェットでは、ArcGIS Maps SDK for JavaScript を使用してフィーチャを取得することができます。その後、他のウィジェットがこれらのフィーチャを使用できるようにしたい場合があります。たとえば、マップ上でこれらのフィーチャをハイライト表示したり、リスト ウィジェットでこれらのフィーチャを表示したりする必要があるかもしれません。これには、以下の 3 つのオプションがあります。\n データ ソースでこれらのフィーチャ レコードを選択する  使用できるデータ ソース インスタンスがあれば、dataSource.selectRecordsByIds() を呼んでこれらのレコードを選択することができます。Graphic インスタンスを取得する場合は、まず FeatureRecord インスタンスを作成する (featureLayerDataSource.buildRecord(graphic)) 必要があります。   ウィジェットから出力データ ソースを生成する  Widget output data source サンプルを参照してください。   メッセージを公開する  ウィジェットが何らかのフィーチャを生成する場合、DataRecordSetChangeMessage メッセージを公開することで、他のウィジェットがサブスクライブできるようになります。    MapView/SceneView または LayerView での作業 ウィジェットがデータ ソースと連動する場合、MapView/SceneView とも連動する必要がある場合が多くあります。ウィジェットが JimuMapViewComponent によってJimuMapView インスタンスを取得した後、jimuMapView.dataSourceId によって MapView/SceneView の対応するデータ ソースを取得し、jimuMapView.jimuLayerViews によって関連レイヤーを取得することができます。jimuLayerView インスタンスを介して、jimuMapView.dataSource によって、レイヤー ビューの対応するデータ ソースを取得することもできます。一般に、レイヤーからデータ ソースと同期する機能を取得するには、以下のオプションがあります。\n フィーチャの ID フィールドを使用して、データ ソースから関連するデータ レコードを検索 FeatureDataRecord インスタンスを作成し、そのフィーチャに対応するデータ レコードを作成 FeatureDataRecord のインスタンスから、featureDataRecord.getFeature() でフィーチャを取得  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/unreal-engine/",
	"title": "ArcGIS Maps SDK for Unreal Engine",
	"tags": [],
	"description": "ArcGIS Maps SDK for Unreal Engine の開発に役立つガイド集です。",
	"content": "ArcGIS Maps SDK for Unreal Engine の開発に役立つガイド集です。\nArcGIS Map SDK for Unreal Engine は、現在 ESRIジャパンにおけるサポート対象外の製品です。\nESRIジャパンで提供する Esri 製品サポート サービスや開発者サポート サービスはご利用いただけませんので、予めご了承ください。\n\r インストール ガイド\nArcGIS Maps SDK for Unreal Engine のインストールとセットアップ手順を紹介します。\n\r 新規プロジェクトにプラグインを追加\nArcGIS Maps SDK for Unreal Engine を新規プロジェクトに導入する手順を紹介します。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-unity/",
	"title": "Unity",
	"tags": [],
	"description": "ArcGIS Maps SDK for Unity を用いたネイティブ地図アプリの作成方法を紹介します。",
	"content": "出典：ArcGIS Maps SDK for Unity - Tutorials - Display a map(UI)\nマップを表示する (UI) Unity の Map Creator UI と High Definition Render Pipeline を使用して、ベースマップ、標高ソースの設定、データ レイヤーの追加、特定エリアの表示方法をご紹介します。\nこのチュートリアルでは、ベースマップ レイヤー サービスとデータ レイヤーを含むローカル シーンを Unity で作成します。\nArcGIS Map SDK for Unity は、現在 ESRIジャパンにおけるサポート対象外の製品です。\nESRIジャパンで提供するEsri 製品サポート サービスや開発者サポート サービスはご利用いただけませんので、予めご了承ください。\n\r前提条件 このチュートリアルを実施するには、以下が必要です。\n  ArcGIS サービスにアクセスするには、ArcGIS Location Platform アカウントまたは ArcGIS Online アカウントと API キーが必要です。アカウントをお持ちでない場合は、サインアップ (無料) してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。\nAPI キー ページが開発者ダッシュボードに表示されない場合は、アカウントを ArcGIS Location Platform アカウントにアップグレードする必要があります。\n\r  開発環境がシステム要件を満たしていることを確認してください。\n  インストールとセットアップの手順に従って、プラグインをインストールしてください。必ずサンプル アセットをインポートしてください。\n  まだ作成されていない場合は、新しい HDRP プロジェクトを作成してください。\n  Unity のインターフェイスに慣れていない場合は、最も一般的なエディター ウィンドウとそれらを活用するための情報を Unity マニュアル で参照してください。\nステップ 新しいシーンを作成する   上部メニューで、[ファイル (File)] \u0026gt; [新しいシーン (New Scene)] をクリックし、ポップアップ ウィンドウを開きます。   [Basic Outdoors (HDRP)] テンプレートを選択し、[作成 (Create)] ボタンをクリックします。   Map Creator UI を開く 上部メニューで、[ツール (Tool)] \u0026gt; [ArcGIS Maps SDK] \u0026gt; [Map Creator] をクリックします。必要に応じて、Map Creator UI を開いた後にウィンドウ サイズを調整します。 マップを作成する このチュートリアルでは、ローカル シーンを作成し、円形の範囲を設定します。\n  [Map] タブをクリックし、パネルの内容を表示します。\n  [Map Type] セクションで [Local] をクリックします。\n  [Origin Position] セクションでは、GIS シーンの中心を座標とSpatial Reference Well-Known ID (WKID) で設定できます。チュートリアルでは、パラメーターを以下の値に設定します。\n Longitude : 139.745723 Latitude : 35.659041 Altitude : 0 Spatial Reference WKID : 4326  spatial reference に関する情報は、spatial references のページを参照してください。\n  [Enable Map Extent] チェック ボックスをオンにして、[Map Extent] セクションを表示し、マップの範囲をこれらの値に設定します。\n Longitude : 139.745723 Latitude : 35.659041 Shape : Circle Spatial Reference WKID : 4326 Shape Dimensions : (Radius) 5000 メートル    ArcGIS Map ゲーム オブジェクトをシーンに追加するには、[Create Map] をクリックします。\n  以下が、[Map] パネルに入力した画像です。\n[ヒエラルキー (Hierarchy)] ウィンドウで、作成された ArcGISMap ゲーム オブジェクトを確認できます。\n[ヒエラルキー (Hierarchy)] ウィンドウで ArcGISMap ゲーム オブジェクトをクリックすると、ゲーム オブジェクトに ArcGIS Map コンポーネントがアタッチされていることがわかります。\nArcGIS Map の作成の詳細については、Maps のページを参照してください。\nカメラの作成と設定 ArcGIS Maps SDK for Unity は、カメラに近いエリアにはより高い解像度の LOD を表示し、カメラから遠いエリアにはより低い解像度の LOD を表示します。\n  [Camera] タブをクリックする。\n  [Camera Position] はカメラの初期視点を定義します。パラメーターをこれらの値に設定します。\n Longitude : 139.745723 Latitude : 35.659041 Altitude : 290 Spatial Reference WKID : 4326    [Camera Rotation] はカメラの角度を定義します。パラメーターをこれらの値に設定します。\n Heading : 270 Pitch : 93 Roll : 0    [Create Camera] ボタンをクリックします。\n  以下が、[Camera] パネルに入力した画像です。\n[ヒエラルキー (Hierarchy)] ウィンドウで、Main Camera ゲーム オブジェクトが ArcGISCamera ゲーム オブジェクトに変換され、ArcGISMap ゲーム オブジェクトの下に移動していることがわかります。\nArcGISCamera ゲーム オブジェクトを右クリックし、ポップアップ メニューの [Align View to Selected] を選択すると、Scene ビューのカメラがその位置に移動します。ピッチ、ヘディング、ロールも調整したい場合は、Scene ビューでマウスの右ボタンを押しながら調整してください。\n\rこの時点で、追加するベースマップとデータ レイヤーを見るために、Volume Proflie の [フォグ (Fog)] を無効にするとよいでしょう。このチュートリアルの最後では、ライティングを調整します。\nカメラについての詳細は、Camera のページを参照してください。\nベースマップの設定 このチュートリアルでは、プリセット オプションからベースマップを選択します。\n  [Basemap] タブをクリックし、パネルの内容を表示します。\n  プリセットのベースマップ ギャラリーから [Imagery] ベースマップを選択します。\n  以下が、プリセットからベースマップを [Imagery] に設定した画像です。\nAPI キーの設定 前のセクションで選択したプリセット ベースマップには API キーが必要です。\n  ポータルへアクセスして API キーを取得してください。\n  [Auth] タブをクリックしてパネルの内容を表示します。\n  [API Key] セクションで API キーを設定します。\n  このスクリーンショットで Paste your API key here と表示されているフィールドに API キーが入力されていることを確認してください。API キーの取得方法については、[API キーの取得] をご覧ください。\nUnity プロジェクト内の複数のシーンに対してグローバル API キーを設定するもう 1 つの方法は、プロジェクト設定です。API キーの詳細については、API キーのセクションを参照してください。\n[Basemap] タブに戻ると、以前はグレーアウトしていたベースマップ アイコンが有効になり、API キーが正常に登録されたことがわかります。\nこの時点で、ローカル エクステントを持つマップデータが表示されるはずです。[シーン (Scene)] ビューに何も表示されない場合は、[ヒエラルキー (Hierarchy)] ウィンドウを開き、[ArcGIS Camera] をダブル クリックしてエディター カメラの位置を移動し、角度を調整してマップを表示します。\n[シーン (Scene)] ビューにベースマップが表示されない場合は、[ヒエラルキー (Hierarchy)] ウィンドウで ArcGISCamera ゲーム オブジェクトをダブルクリックして、設定した位置にカメラ ビューを設定し、必要に応じてマウスの右ボタンを押しながらカメラのピッチ、ヘディング、ロールを調整します。\n\r標高の設定 このチュートリアルでは、デフォルトの標高を使って地形を定義します。\n  [Elevation] タブをクリックし、パネルの内容を表示します。\n  [Terrain 3D] が選択され、[Enable All] のチェックボックスがチェックされていることを確認します。\n  以下が、設定した [Elevation] パネルの画像です。\n標高の詳細については、Elevation のページを参照してください。\nデータ レイヤーの追加 ArcGIS Online から使用できるデータを追加します。\n ArcGIS Online Item : 東京都23区・八王子市南大沢 3D 都市モデル（Project PLATEAU）  Layer name : Tokyo Model Type : ArcGIS 3DObject Scene Layer ArcGIS Online サービスの URL（ Source ）:  https://tiles.arcgis.com/tiles/wlVTGRSYTzAbjjiC/arcgis/rest/services/13100_13201_Tokyo-23ku_Minamiosawa_Building/SceneServer\r Opacity : 1.0    以下の手順でレイヤーを追加します。\n  [Layers] タブをクリックします。\n  右下の [+ Add New] ボタンを押して、[Add New Layer] ポップアップ ウィンドウを開きます。\n  [Type] のドロップダウン リストから適切なレイヤー タイプを選択します。\n  3D オブジェクト シーン レイヤーを追加するには、サービスの URL を [Source] フィールドに入力します。\n  [Name] フィールドにレイヤー名を入力します。\n  [Add] ボタンをクリックして、レイヤーをマップに追加します。レイヤーが追加されると、[Layers] セクションに表示されます。\n  [Opacity] スライダーを動かすか、[Opacity] フィールドに正確な値を入力して、レイヤーの不透明度を設定します。\n  以下が、[Layers] パネルの画像です。\n空とライティングの調整 Unity には空とライティングのシステムがあります。詳しくは Sky and lighting のページを参照してください。このチュートリアルでは、テンプレートによって追加されたゲーム オブジェクトの設定を調整します。\n太陽の調整   [ヒエラルキー (Hierarchy)] ウィンドウで、Sun ゲーム オブジェクトをクリックします。\n  [ヒエラルキー (Hierarchy)] ウィンドウの [トランスフォーム (Transform)] セクションで、回転を以下の値に設定します。\n X : 36 Y : 110 Z : 85    [放出 (Emission)] セクションを開き、[強さ (Intensity)] の値を 10000 に設定します。\n  以下が、設定した Sun ゲーム オブジェクトの画像です。\n空と霧のボリュームの調整   [ヒエラルキー (Hierarchy)] ウィンドウの Volume Profile をクリックします。\n  ArcGIS Maps SDK for Unity には、HDRP 用の Sky and Fog volume のサンプル プロファイルが用意されています。[インスペクター (Inspector)] ウィンドウの [Volume] セクションで、プロフィール名の横にあるアイコンをクリックします。\n  ポップアップ ウィンドウで [Sky and Fog Settings SampleScenes Profile] を選択します。\n  カメラ コントローラーのアタッチ エディター モードが有効になっている間、ビューポート内をナビゲートするために、シーン (Scene) ビュー カメラがあります。プレイ モードでは、シーンを探索するためにカメラ コントローラーをアタッチする必要があります。このチュートリアルでは、ArcGIS Maps SDK for Unity のサンプル アセットからコントローラーをアタッチします。\n  [ヒエラルキー (Hierarchy)] ウィンドウで [ArcGISCamera] をクリックします。\n  [インスペクター (Inspector)] ウィンドウで、[コンポーネントを追加 (Add Component)] ボタンをクリックします。\n  [ArcGIS Camera Controller] を検索し、[ArcGISCamera] ゲーム オブジェクトにアタッチします。\n  Map Creator UI でマップの設定が完了しました。[Toolbar] の [Play] アイコンをクリックすると、[ゲーム (Game)] ビューにマップが表示されます。\n キーで左右前後に移動します。マウスの左ボタンでシーンをパン、右ボタンでオービット、スクロール ホイールで拡大・縮小します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/widget-list/",
	"title": "ウィジェット一覧表",
	"tags": [],
	"description": "ArcGIS Web AppBuilder で提供されているウィジェットの一覧表です。",
	"content": "ArcGIS Web AppBuilder ウィジェット一覧表 ArcGIS Web AppBuilder（ArcGIS Online 版、ArcGIS Enterprise 版、Developer Edition 版 ※1）で提供されているウィジェットの一覧表です。\n表の「〇」をクリックすると、ウィジェットの詳細ページ（Web ガイド）にリンクします。\n 2D ウィジェット 3D ウィジェット 補足事項  2D ウィジェット    ウィジェット 機能概要 ArcGIS Online (2022 年 11 月アップデート) ArcGIS Enterprise バージョン 11.0 Developer Edition バージョン 2.26 ※1     情報ウィジェット 情報ウィジェットは、ウィジェットに表示するコンテンツを作成します。 〇 〇 〇   データ追加 データ追加ウィジェットを使用すると、ArcGIS Online または ArcGIS Enterprise のコンテンツからレイヤーを検索するか、URL を入力するか、ローカル ファイルをアップロードすることで、データをマップに追加できます。 〇 〇 〇   解析 解析ウィジェットを使用すると、アプリケーション内で ArcGIS Online または ArcGIS Enterprise の空間解析ツールを簡単に利用できます。 〇 〇 〇   属性テーブル 属性テーブル ウィジェットは、操作レイヤーの属性を表形式で表示します。 〇 〇 〇   属性一括編集 属性の一括編集ウィジェットではフィーチャ (関連フィーチャ、別のレイヤーに基づくフィーチャ、または図形内でスケッチしたフィーチャ) を選択し、共通属性を一括更新できます。 〇 〇 〇   ベースマップ ギャラリー ベースマップ ギャラリー ウィジェットには、ベースマップがギャラリー形式で表示され、ギャラリーの中から 1 つのベースマップを選択してアプリのベースマップにすることができます。 〇 〇 〇   ブックマーク ブックマーク ウィジェットには、アプリに表示されるマップ表示範囲 (空間ブックマーク) のコレクションが格納されます。 〇 〇 〇   Business Analyst Business Analyst ウィジェットを使用すると、マップ上のポイントまたはポリゴン フィーチャのレポートとインフォグラフィックスを実行することで、その詳細情報を表示することができます。 〇 〇 〇   チャート チャート ウィジェットには、操作レイヤーから取得された定量属性がデータのグラフィカルな表現として表示されます。 〇 〇 〇   コントローラー コントローラー ウィジェットはパネル内ウィジェット用のコンテナーです。ヘッダー構成とサイドバー構成という 2 種類のコントローラーが事前に組み込まれています。 〇 〇 〇   座標 座標ウィジェットは、マップ上に X と Y の座標値を表示します。 〇 〇 〇   座標変換 座標変換ウィジェットでは、1 つの座標系を使用する座標を入力し、複数の表記形式を使用する別の座標系に出力することができます。 〇 〇 〇   コスト解析 コスト解析ウィジェットを使用すると、作成する各フィーチャにコスト係数を割り当てることができます。 〇 〇 〇   データ集約 データ集約ウィジェットを使用すると、CSV (カンマ区切り値) ファイルに格納されている住所または座標情報から地理フィーチャを作成し、CSV ファイルとターゲット レイヤーのフィールド情報を関連付ける方法を定義できます。 〇 〇 〇   ルート案内 ルート案内ウィジェットは、2 つ以上の地点間のターンに基づくルート案内をすばやく効果的に算出する機能を提供します。 〇 〇 〇   地域検索 地域検索ウィジェットを使用すると、選択したポリゴンに関連するポイント フィーチャを検索したり、各フィーチャの詳細を表示したり、選択したポイント フィーチャへのルート案内を取得したりすることができます。 〇 〇 〇   距離と方向 距離と方向ウィジェットは、線、円、楕円、および範囲リングを描画し、重要な情報を視覚化できます。 〇 〇 〇   描画 描画ウィジェットでは、マップ上に任意のグラフィック (図形) を描画できます。 〇 〇 〇   編集 このウィジェットには、フィーチャ サービスのうち編集可能なレイヤーを編集する機能が含まれています。 〇 〇 〇   緊急時応急措置指針 ERG (緊急時応急措置指針) ウィジェットでは、危険物の流出の種類とユーザーが選択したマップ上の場所に基づいて、潜在的な危険を特定できます。 〇 〇 〇   範囲移動 範囲移動ウィジェットを使用すると、マップの前または次の範囲に移動することができます。 〇 〇 〇   フィルター フィルター ウィジェットを使用すると、レイヤー内のフィーチャの表示設定を制限できます。 〇 〇 〇   全画面 全画面ウィジェットでは、全画面モードを使用できます。 〇 〇 〇   ジオコーダー ジオコーダー ウィジェットは、検索ウィジェットに置き換えられました。検索ウィジェットの項目を参照してください。 〇 〇 〇   地理検索 地理検索ウィジェットは、マップ上のポリゴン フィーチャ レイヤーを使用して、CSV ファイル内の位置リストに情報を付加します。 〇 〇 〇   ジオプロセシング ジオプロセシング ウィジェットには、ジオプロセシング タスクを実行するダイナミック ユーザー インターフェイスが組み込まれています。 〇 〇 〇   グリッド オーバーレイ グリッド オーバーレイ ウィジェットでは、Web アプリでクライアント側のリソースを使用して、U.S. MGRS (Military Grid Reference System) グリッドをすばやくレンダリングできます。 〇 〇 〇   インデックス格子線 インデックス格子線 (GRG) を使用すると、アナリストは対象地理領域を分割する際に使用するグリッドを作成できます。 〇 〇 〇   グループ フィルター グループ フィルター ウィジェットでは、マップ内の 1 つ以上のレイヤーに基づき、マップにフィルターを適用できます。 〇 〇 〇   ホーム ボタン ホーム ボタン ウィジェットは、マップを初期表示範囲にズームします。 〇 〇 〇   画像計測 画像計測ウィジェットでは、計測機能を使用してイメージ サービスで測定を実行できます。 〇 〇 〇   インシデント解析 インシデント解析ウィジェットを使用すると、マップ上でインシデントを特定し、インシデントから指定した距離内にあるさまざまなフィーチャ レイヤーの情報を解析できます。 〇 〇 〇   インフォグラフィック インフォグラフィック ウィジェットが提供する 8 種類のグラフィックス テンプレートを使用すると、マップ内とその他のデータ ソースからの属性と統計情報データを視覚化してモニタリングできます。 〇 〇 〇   情報サマリー 情報サマリー ウィジェットを使用して、指定したレイヤーごとに、現在のマップ範囲内のフィーチャの数を表示できます。 〇 〇 〇   レイヤー リスト レイヤー リスト ウィジェットでは、操作レイヤーとそのシンボルがリスト形式で表示され、レイヤーを個別に表示または非表示にすることができます。 〇 〇 〇   凡例 凡例ウィジェットには、マップ内のレイヤーのラベルとシンボルが表示されます。 〇 〇 〇   計測 計測ウィジェットでは、ポリゴンの面積やラインの長さを計測したり、ポイントの座標を検索したりすることができます。 〇 〇 〇   現在地 現在地ウィジェットでは、ネットワークを使用してユーザーの物理的な位置を特定し、マップ上でその位置にズームできます。 〇 〇 〇   近隣検索 近隣検索ウィジェットを使用して、定義した住所または位置のバッファー内のフィーチャを検索したり、それらのフィーチャに関する詳細な情報を表示したり、選択したフィーチャまでのルート案内を取得したりすることができます。 〇 〇 〇   ネットワーク トレース※2 ネットワーク トレース ウィジェットは、任意のジオプロセシング サービスを呼び出して操作するように設計されています。 〇 〇 〇   傾斜ビューアー 傾斜ビューアー ウィジェットは、ArcGIS の [画像座標系 (ICS)] を使用して、ネイティブの座標系で画像を表示し、カメラ位置から自然なビューを提供します。 〇 〇 〇   概観図 概観図ウィジェットは、より大きなエリア内でマップの現在の範囲を表示し、マップ範囲が変更されるたびに更新します。 〇 〇 〇   パーセル ドラフター パーセル ドラフターは、マッピング技術者が土地境界の説明を入力し、クロージャ エラーをチェックするために使用できる Web AppBuilder for ArcGIS の構成です。 〇 〇 〇   印刷 印刷ウィジェットでは、Web アプリを印刷サービスに接続して、現在のマップを印刷できるようにします。 〇 〇 〇   パブリック通知 パブリック通知は、Web AppBuilder for ArcGIS の構成の 1 つで、地方自治体の職員が、所有者および占有者の財産を特定し、宛名ラベルや構造化テキスト ファイルを作成できるようにします。 〇 〇 〇   クエリ クエリ ウィジェットを使用すると、事前に定義されたクエリを実行して、ソース データから情報を取得することができます。 〇 〇 〇   関連テーブル チャート 関連テーブル チャート ウィジェットを使用して、フィーチャ レイヤーの関連テーブルの値のチャート (バー チャート、パイ チャート、または極座標チャート) を作成できます。 〇 〇 〇   フィーチャ レポート フィーチャ レポート ウィジェットでは、ユーザーからのデータ品質のフィードバックを収集および管理できます。 〇 〇 〇   レビューアー ダッシュボード レビューアー ダッシュボード ウィジェットには、ユーザーの GIS データで特定されたデータ品質の問題を集計し、インフォグラフィックスとしてデータ品質結果の統計情報が円グラフおよび棒グラフで表示されます。 〇 〇 〇   縮尺記号 縮尺記号ウィジェットは、マップに縮尺記号を表示します。 〇 〇 〇   スクリーニング スクリーニング ウィジェットを使用すると、対象地域を定義し、指定されたレイヤーを解析して、潜在的な影響がないか確認できます。 〇 〇 〇   検索 検索ウィジェットを使用すると、エンド ユーザーはマップ上で場所を見つけたり、フィーチャを検索したりできます。 〇 〇 〇   選択 選択ウィジェットを使用すると、マップ上のフィーチャを対話的に選択し、選択したフィーチャに対してアクションを行えます。 〇 〇 〇   共有 共有ウィジェットでは、アプリをソーシャル メディア アカウントにポストしたり、リンクを電子メールで送信したり、Web サイトやブログに埋め込んだりして共有することができます。 〇 〇 〇   状況認識 状況認識ウィジェットでは、マップ上の位置を指定し、指定の領域内にあるフィーチャ レイヤーの情報を解析することができます。 〇 〇 〇   スマート エディター スマート エディター ウィジェットを使用すると、フィーチャおよびその関連レコードを容易に編集できます。 〇 〇 〇   スプラッシュ スプラッシュ ウィジェットは、アプリのスプラッシュ画面上の表示コンテンツを定義します。 〇 〇 〇   ストリーム ストリーム ウィジェットを使用すると、ストリーミング フィーチャ レイヤーからのリアルタイムのデータ フィードを可視化および制御できます。 〇 〇 〇   適合性モデラー 適合性モデラー ウィジェットを使用すると、活動に最適な場所の検索、危険性の予測、事象が発生する可能性が高い場所の識別が可能になります。 〇 〇 〇   サマリー サマリー ウィジェットを使用すると、現在のマップ内のフィーチャ レイヤーから、表示されているマップ範囲内にある数値属性を集計できます。 〇 〇 〇   スワイプ スワイプ ウィジェットを使用して、マップ内のさまざまなレイヤーのコンテンツを簡単に比較できます。 〇 〇 〇   脅威分析 公共安全の担当者と初動対応者は、イベントの計画時に安全な距離と区域を特定します。 〇 〇 〇   タイム スライダー タイム スライダー ウィジェットを使用して時系列レイヤーをマップに表示し、アニメーションを再生して、データが時間とともにどのように変化するかを確認できます。 〇 〇 〇   可視解析 可視解析ウィジェットは、指定された距離、観測点の高さ、および視野に基づいて、観測点から見えるものを特定します。 〇 〇 〇   ズーム スライダー ズーム スライダー ウィジェットは、マップ表示に対話型のズーム コントロールを提供します。 〇 〇 〇    3D ウィジェット    ウィジェット 機能概要 ArcGIS Online (2022 年 11 月アップデート) ArcGIS Enterprise バージョン 11.0.1 Developer Edition バージョン 2.26 ※1     3DFx 3DFx ウィジェットが提供する一連の 3D アニメーション アプローチを使用して、地理情報を直感的で対話的な 3D 環境で視覚化および解析することができます。 〇 〇 〇   情報 情報ウィジェットは、ウィジェットに表示するコンテンツを作成します。 〇 〇 〇   ベースマップ ギャラリー ベースマップ ギャラリー ウィジェットには、組織から提供されるベースマップを表す画像のコレクション、またはユーザー定義の一連のマップ/イメージ サービスが表示されます。 〇 〇 〇   コンパス コンパス ウィジェットをクリックすると、シーンが北向きで再描画されます。 〇 〇 〇   座標 座標ウィジェットは、X,Y 座標、標高、およびカメラの高度の値を 3D アプリに表示します。 〇 〇 〇   日光 日光ウィジェットでは、時刻と月を変化させて日差しと影がシーンに与える影響を変更できます。 〇 〇 〇   全画面 全画面ウィジェットを使用して、全画面モードを開始できます。 〇 〇 〇   ホーム ボタン ホーム ボタン ウィジェットをクリックすると、最初のカメラ位置に戻ります。 〇 〇 〇   レイヤー リスト レイヤー リスト ウィジェットは、シーン内の 2D レイヤーまたは 3D レイヤーをリスト表示します。 〇 〇 〇   凡例 凡例ウィジェットには、シーン内のレイヤーのラベルとシンボルが表示されます。 〇 〇 〇   計測 3D アプリの計測ウィジェットでは、2 つのポイント間の水平、垂直、および直線距離、ポリゴンの面積および周囲長を計測できます。 〇 〇 〇   現在地 現在地ウィジェットでは、ネットワークを使用してユーザーの物理的な位置を特定し、マップ上でその位置にズームできます。 〇 〇 〇   ナビゲート ナビゲート ウィジェットを使用して、シーンを回転したり画面移動したりします。 〇 〇 〇   検索 検索ウィジェットを使用して、シーン内で場所を見つけることができます。 〇 〇 〇   共有 共有ウィジェットでは、3D アプリをソーシャル メディア アカウントにポストしたり、リンクを電子メールで送信したり、Web サイトやブログに埋め込んだりして共有することができます。 〇 〇 〇   スライド スライド ウィジェットは、シーンのさまざまなビューを表示します。 〇 〇 〇   スプラッシュ スプラッシュ ウィジェットは、アプリのスプラッシュ画面上の表示コンテンツを定義します。 〇 〇 〇   ズーム スライダー ズーム スライダー ウィジェットは、マップ表示に対話型のズーム コントロールを提供します。 〇 〇 〇    補足事項  ※1: Developer Edition 版のガイドは英語です。ウィジェットの説明を日本語でご覧になりたい場合は、ArcGIS Online まはた ArcGIS Enterprise のヘルプを参照してください（ウィジェットの説明に関しては、基本的にどのガイドも共通です）。 ※2: 日本国内サポート対象外のウィジェットです。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/widget-communication/",
	"title": "ウィジェット間の通信",
	"tags": [],
	"description": "ウィジェット同士がどのように相互に通信する方法について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Widget communication\nArcGIS Experience Builder ウィジェットは機能の単位であり、ウィジェットは 1 つの機能に焦点を当てます。しかし、多くの場合、タスクを完了するために複数のウィジェットを連携させる必要があります。そのためには、フレーム ワーク レベルでウィジェット同士が通信できる方法が必要です。Experience Builder では次の方法でこれを実現できます。\n Configurable (設定によって実現)  ウィジェット間で同じデータ ソース/データ ビューを使用する ウィジェット間で同じマップ ウィジェットを使用する ウィジェットの出力するデータ ソースを使用する メッセージ/アクションを使用する データ アクションを使用する   Programming (プログラミングによって実現)  ウィジェットの state をウィジェット間で共有する ウィジェット間で state を共有するために、独自の redux ストア/アクション/リデューサーを用意する    Configurable とはユーザーがビルダー内でウィジェット間の通信方法を設定できることを意味します。Programming とはウィジェット間の通信がコードによって行われることを意味します。\nウィジェット間で同じデータソース/データビューを使用する 複数のウィジェットが同じデータ ソースまたはデータ ビューを使用する場合、それらのウィジェットは同じ選択、同じデータ レコードなど、同じデータ ソースの状態を取得できます。ウィジェットはこれらのデータを使用してデータ ソースの状態を同期できます。例えば、複数のウィジェットが同じデータ レコードを読み込んで、異なるビューを表示することができます。あるウィジェットはユーザーに選択を行わせ、別のウィジェットは選択状態を監視し、選択されたデータの詳細を表示することができます。\n複数のウィジェットが同じデータ ソースの異なるデータ ビューを使用しても選択内容がデータ ビューのフィルター条件を満たしていれば、同じ選択内容を取得できます。\n詳細はウィジェットでデータ ソースを使用を参照してください。\nウィジェット間で同じマップ ウィジェットを使用する 複数のウィジェットが同じマップ ウィジェットを使用する場合、それらのウィジェットは同じ JimuMapView インスタンスを取得します。この JimuMapView インスタンスは ArcGIS Maps SDK for JavaScript の MapView インスタンスをラップしたものです。 JimuMapView インスタンスを取得した後、ウィジェットは addJimuLayerViewCreatedListener() と addJimuLayerViewRemovedListener` を呼び出して、レイヤー ビューの作成と削除のイベントを監視し、他のウィジェットによる変更を読み取ることができます。詳細については、ウィジェットでのマップ ウィジェットの使用を参照してください。\nウィジェットの出力するデータ ソースを使用する 詳細はウィジェット出力データ ソースを参照してください。\nメッセージ/アクションを使用する 詳細はメッセージとアクションを参照してください。\nデータ アクション 詳細はデータ アクションを参照してください。\nウィジェットの state を使用してウィジェット間で状態を共有 React コンポーネントとしての Widget は内部 state (状態) を持つことができますが、他の Widget はこの state にアクセスすることができません。Jimu は state 管理 として Redux を使用しています。多くの情報を Redux store に保存します。情報の一つは widgetsState と呼ばれるもので、型の定義は jimu-core/lib/types/state にあります。widgetState に保存された情報は、他のすべてのウィジェットからアクセス可能です。widgetsState に情報を保存するには、以下のコードを参照してください。\nimport {appActions} from \u0026#39;jimu-core\u0026#39;; /* * state を保存する必要がある場合に呼び出します * * widgetId: 使用しているウィジェットの ID * propKey: \u0026#34;a.b.c\u0026#34; といったフォーマットの文字列 * value: 保存したい情報 */ this.props.dispatch(appActions.widgetStatePropChange(widgetId, propKey, value)) 例えば、this.props.dispatch(appActions.widgetStatePropChange(\u0026quot;w1\u0026quot;, \u0026quot;a.b1\u0026quot;, \u0026quot;value1\u0026quot;)) と this.props.dispatch(appActions.widgetStatePropChange(\u0026quot;w1\u0026quot;, \u0026quot;a.b2\u0026quot;, \u0026quot;value2\u0026quot;)) を呼び出すと、Redux store でこの store の state が取得されます。\nwidgetsState: { w1: { a: { b1: \u0026#39;value1\u0026#39;, b2: \u0026#39;value2\u0026#39; } } } ウィジェット2 の w1 が格納した情報にアクセスするには、mapExtraStateProps を使用するか、useSelect フックを使用して store から値を選択することができます。\nただし、widgetState にはプレーンな JavaScript オブジェクトのみを格納することができます。複雑な JavaScript オブジェクトを格納するには、this.props.dispatch(appActions.widgetMutableStatePropChange(widgetId, propKey, value)) を使用して値を格納し、MutableStoreManager.getInstance().getStateValue() を使用してアクセスすることができます。\nウィジェット間で state を共有するための独自の redux store/action/reducer を提供 これにより、state (状態) 管理をより柔軟にカスタマイズすることができます。これは通常の Redux で行う方法とほぼ同じです。ご存知のように、Redux には 1 つの store と 1 つの root reducer があり、これは jimu によって使用されます。ウィジェット開発者が通常の Redux の方法で state を管理できるようにするために、jimu は ReduxStore 拡張ポイントを定義しています。Redux を使用する必要があるウィジェットはこの拡張ポイント用の拡張を提供できます。\n ReduxStoreExtension インターフェイスを実装する拡張クラスを作成します。このクラスは my-store.ts として作成します。  import {extensionSpec} from \u0026#39;jimu-core\u0026#39;; export default class MyReduxStoreExtension implements extensionSpec.ReduxStoreExtension{ getActions(){ // 値を返す redux アクション  } getInitLocalState(){ // ローカル state 内の redux を返す  } getReducer(){ // redux reducer を返す  } getStoreKey(){ // redux のローカル キーを返す  } }  ウィジェットの manifest.json で拡張機能を宣言します。  \u0026#34;extensions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;My Store\u0026#34;, \u0026#34;point\u0026#34;: \u0026#34;REDUX_STORE\u0026#34;, \u0026#34;uri\u0026#34;: \u0026#34;my-store\u0026#34; } ] "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/data-source/",
	"title": "データ ソース（Data source）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Data sources\nデータ ソース（Data source） データ ソースは、ウィジェットがどのようにデータにアクセスするかを定義します。例えば、データがリモートサーバーからのものである場合、ウィジェットはクライアント側にクエリーするために、データ ソース クラスを使用します。ウィジェットでデータが生成された場合、それ自身をデータ ソース クラスに入れることで、別のウィジェットで使用することができます。\n高レベルでは、データ ソースはスキーマといくつかのレコードを持ち、子/親データ ソースを持つ場合があります。さらに、すべてのデータ ソースは、それを識別するのに役立つ型、ID、ステータスがあります。 DataSource インターフェイスは jimu-core パッケージで定義されており、これは以下のメソッドとプロパティのいくつかを定義しています。\n id: データ ソースID。 type: どのタイプのデータ ソースを使っているかチェックするため、ウィジェットで使っているプロパティ。 fetchSchema: すべてのデータ ソースは、スキーマを返すためにこのメソッドを実装しなければなりません。これは、リモート データ サービスで定義されたスキーマです。例えば、ユーザーがExperience Builder でデータ ソースを追加した場合、データ ソースのスキーマはアプリ構成に保存されません。代わりに、最新のデータ ソース スキーマを取得するために fetchSchema メソッドが呼び出されます。 getSchema: ウィジェットがデータ ソースのスキーマとフィールドにアクセスするために使用するメソッドです。 getRecords: ウィジェットがデータ ソースのデータ レコードにアクセスするために使用するメソッドです。 getStatus: ウィジェットはこのメソッドを使用してデータ ソースのステータスを取得します。これらのステータスには、NotReady、Unloaded、Loading、Loaded および LoadError があります。NotReady はウィジェットの出力データ ソース専用です。出力データ ソースのインスタンスが作成されても、そのインスタンスは使用する準備ができていません。出力データ ソースを生成するウィジェットはデータ ソースを使用可能な状態にするアクション (DataSourceChanged) を送る必要があります。データ ソースのステータスが準備できていない場合、クエリーは空の結果を返します。その他のクエリー可能なデータ ソースでは、既定のステータスは Unloaded です。データが要求されると Loading に変更され、最後に Loaded または LoadError に変更されます。  データ ソースは DataSourceManager によって管理され、作成および取得できます。\nデータ ソースの使用を簡単にするために、DataSourceComponent コンポーネントが定義されています。これは useDataSource プロパティを受け取り、コールバックを通じてデータ ソース オブジェクトとそのステータス情報を返します。また、子要素として関数を受け取ることで、その関数を使ってデータ ソース オブジェクトとデータ ソース内のデータをレンダリングするための情報を取得することができます。DataSourceComponent コンポーネントは、オプションの query プロパティを受け入れることもでき、クエリーが変更されたときにデータを再読み込みします。\n多くの一般的なデータ サービスはデータのクエリーをサポートしているため、API では QueriableDataSource インターフェイスが定義されています。このインターフェイスには、url、load、query などのプロパティがあります。load と query の違いは、load はレコードのプロパティとデータ ソースのステータスを更新し、query はレコードのみをクエリーして返すことです。\n一部の ArcGIS サービスもデータのクエリーをサポートしており、同様のクエリー動作を持っています。そのため、これらのサービスの共通操作をサポートするために、ArcGISQueriableDataSource インターフェイスが定義されています。また、FeatureLayerDataSource、SceneLayerDataSource など、これらのサービスの特定の操作をサポートするためのサブ インターフェイスも定義されています。\nより具体的には、Experience Builder で FeatureLayerDataSource データ ソースを定義して、フィーチャ レイヤーにアクセスします。FeatureLayerDataSource を通じて ArcGIS Maps SDK for JavaScript の FeatureLayer オブジェクトを取得するには、createJSAPILayerByDataSource() メソッドを呼び出します。FeatureLayerDataSource の実際のデータは、リモート データベースからのものと、クライアント側のフィーチャのコレクションからのものがあり、どちらもクエリーをサポートしています。\n一般的にデータ ソースは 2 つの場所に保存されます。データ ソース オブジェクトは DataSourceManager に管理され、データ ソース情報は redux アプリ ストアに保存されます。DataSourceComponent を使う場合、コンポーネントは DataSourceManager を呼び出してオンデマンドでデータ ソースを作成し、コールバック プロップを使ってデータ ソース オブジェクトとdataSourceInfo を返します。dataSourceInfo では、データ ソースの instanceStatus, status, selectedIds などを返すことができます。\nArcGIS Server サービスの多くは、MapServiceDataSource、FeatureServiceDataSource など、アクセスしやすいようにデータ ソースにマッピングされています。 ArcGIS Maps SDK for JavaScript の WebMap と WebScene は、jimu-arcgis パッケージ内で WebMapDataSource と WebSceneDataSource としてラップされています。\nデータ ソース セット（Data Source Set） データ ソースは子データ ソースを持つことができます。そのため、使いやすいように複数のデータ ソースを含めることが可能です。このようなデータ ソースを DataSourceSet と呼ばれます。WebMapDataSource は DataSourceSet の一つです。DataSourceSet はデータ ソースの一種ですが、isDataSourceSet プロパティが true に設定されています。親データ ソースから子データ ソースを取得するには getChildDataSources を使用し、子データ ソースから親データ ソースを取得するには parentDataSource を使用します。子データ ソースは必要に応じて作成され、createDataSouceById(dsId) を使って ID に基づいて子 データ ソースを作成することもできます。\nデータ ビュー（Data View） 複数のウィジェットが 1 つのデータ ソースに接続している場合、ウィジェットがそのデータ ソースのローカル ビューを参照したい場合があります。このような場合には、データ ビューを使用します。データ ビューとデータ ソースの関係は、リレーショナル データベースのビューとテーブルの関係によく似ています。Experience Builder のデータ ソースは、クライアント側の実際のリモート データ ソースのビューですが、データ ソースはテーブル、データ ビューはビューと考えることができます。アプリ作成者は、データ ソースからデータ ビューを作成し、ビルダー内のデータビューにウィジェットを接続することができます。API レベルでは、データ ビューは DataSource クラスを使用して管理されているため、データ ビューは、いくつかのプロパティの違いがあるだけで、データ ソースと同じインターフェイスと動作を持っています。データ ビューのベースとなるデータ ソースはメイン データ ソースと呼ばれ、getMainDataSource を使ってデータ ビューからデータ ソースを取得したり、getDataViews を使ってメイン データ ソースのすべてのビューを取得することができます。\n選択状態は、メイン データ ソースとそのすべてのデータ ビューの間で共有されます。選択されたレコードはデータ ソースの選択ビューに保存され、選択されたレコード ID は redux app store のデータ ソース ID の下に保存されます。選択ビューは、メイン データ ソースの特別なデータビューで、${mainDataSourceId}-sclection で識別されます。\nローカル データ ソースとデータ ビュー（Local data source and data view） 複数のウィジェットが異なるデータを取得するために異なるデータ ビューを使用することは可能ですが、同じデータ ソースまたは同じデータ ビューに接続しながら、ウィジェット毎に異なるデータを取得する必要があるケースもあります。例えば、ウィジェット内のドロップ ダウン リストなどです。このような場合、ウィジェットはローカル データ ソースまたはデータ ビューを作成することができます。ローカル データ ソースまたはデータ ビューに適用されたフィルターは、関連する元のデータ ソースまたはデータ ビューに影響を与えません。ローカル データ ソースやデータ ビューを使用するには、DataSourceComponent を使用して localId を渡すか、DataSourceManager().getinstance().createLocalDataSource を使用します。\nデータ ソース内のソース レコード（Source records in data source） ほとんどの場合、データはリモート データベースにあるので、データ ソース インスタンスはリモートからデータを取得してデータ ソース インスタンスに保存するだけです。しかし、一部のデータ ソースでは、ウィジェットの出力データ ソースや選択ビューのデータ ソースのように、データがクライアント側で生成される場合があります。これらのシナリオでは、データ ソースのデータは、データ ソース インスタンスの DsourceRecords に格納されます。getSourceRecords と setSourceRecords を使用して、それを取得および更新することができます。\nウィジェット出力データ ソース（Widget output data source） ウィジェットはデータ ソースを使用するだけでなく、データ ソースを生成することもできます。生成されたデータ ソースをウィジェット出力データ ソースと呼びます。ウィジェットは、他のウィジェットがその出力データ ソースを使用できるように、設定ページで this.props.onSettingChange を呼び出して、出力データ ソースをアプリの設定に保存する必要があります。出力データ ソースは、アプリの設定の dataSources に保存されます。他のウィジェットは、出力データ ソースを使用する場合でも、ユーザーが追加したデータ ソースを使用する場合でも、違いを意識する必要はありません。\n内部的には、ウィジェットが出力データ ソースを生成し、ウィジェットがレンダリングされるときに、出力データ ソースと出力データ ビューが作成されます。出力データ ビューは ${outputDataSourceId}-output という ID で識別されます。出力データ ソースを使用するウィジェットは出力ビューを使用しています。出力データ ソースが作成されると、そのステータスは NotReady になります。出力データ ソースを生成するウィジェットは、データが準備できたらデータ ソースを更新し、データ ソースのステータスを Unloaded に変更して、他のウィジェットが使用できるようにする必要があります。出力データ ソースのデータを更新する方法は、出力データ ソースがどのように生成されたかによります。ウィジェットがリモート サービスに接続するサーバー サイドの出力データ ソースを生成する場合、outputDs.updateQueryParams(queryParams, widgetId)、outputDs.load(queryParams, { widgetId }) または \u0026lt;DataSourceComponent useDataSource={Immutable({ dataSourceId: outputDsId, mainDataSourceId: outputDsId })} query={queryParams}\u0026gt; を使用してデータ ソースを更新できます。ウィジェットがクライアント サイドにデータを保存するクライアント サイドの出力データ ソースを生成する場合、生成されたデータの種類に応じて、outputDs.setSourceFeatures(features, options) または outputDs.setSourceRecords(records) を使用してデータを更新できます。ウィジェットが生成したデータにジオメトリがある場合、setSourceFeatures を使用することをお勧めします。この方法では、フィーチャのレンダラーを指定できるためです。ウィジェットが生成したデータにジオメトリがない場合、どちらの方法でも問題ありません。\n出力データソース JSON の originDataSources は、元のデータ ソースと出力データ ソースの関係を維持するために使用されます。例えば、ウィジェットの出力データ ソースにスキーマが定義されていない場合、元のデータ ソースのスキーマが使用されます。ウィジェットは、このプロパティと id、type などの一般的なプロパティを更新する必要があります。クエリー ウィジェットとチャート ウィジェットの両方が出力データ ソースを生成します。これらのウィジェットの出力データ ソース JSON を参考にすると、出力データ ソース JSON に必要なプロパティを確認できます。\nデータのクエリーとフィルター（Query and filter data） ウィジェットがデータを読み込む必要がある場合、推奨される方法は \u0026lt;DataSourceComponent\u0026gt; コンポーネントまたは dataSource.load() を使用することです。なぜなら、データ ソース フレームワークはデータ キャッシュとページネーションの問題を管理するのに役立つからです。データを読み込むのではなく、フィルタリングしたいだけの場合は、dataSource.updateQueryParams() を使用できます。\nクエリー フィールド（Query fields） フィーチャ レイヤーには多くのフィールドが含まれている場合がありますが、ほとんどの場合、ウィジェットはそれらのフィールドのうちのいくつかのデータのみを必要とします。多くの場合、ウィジェットは多くのデータ レコードをクエリーして表示する必要があります。この種のウィジェットに推奨される方法は、設定で構成されたフィールドを onSettingChange メソッドを介して useDataSources に保存し、その後 \u0026lt;DataSourceComponent\u0026gt; を使用してデータをクエリーおよびレンダリングすることです。この方法を取ると、保存されたフィールドのみがクエリーされます。複数のウィジェットが同じデータ ソースを使用する場合、すべての保存されたフィールドが一緒にクエリーされます。しかし、一部のウィジェットは1つのレコードと多くのフィールドを表示する必要がある場合があります。この場合、推奨される方法は、record ID を使用して dataSource.query() を使用してレコードをクエリーし、複数のウィジェットが同じデータ ソースに接続する際に過剰なフィールドをクエリーしないようにすることです。dataSource.query(queryParam) を使用してデータをクエリーする場合、queryParam オブジェクトの outFields プロパティを設定してクエリーしたいフィールドを指定できます。\nクライアント サイド クエリー（Client-side query） URL から作成されたデータ ソースがデータをクエリーする必要がある場合、データ ソースはクエリーをリモート サーバーに送信します。しかし、データ ソースがマップ レイヤーから作成され、マップ ウィジェットがクライアント サイド クエリーを有効にしている場合、データソースはバックエンド サービスにクエリーを送信する代わりに、MapView からデータをクエリーしようとします。MapView または対応する LayerView がクライアント サイド クエリーの準備ができていない場合、データ ソースは依然としてクエリーをリモート サーバーに送信します。MapView または LayerView が準備できていない理由はいくつかあります。例えば、クエリー内のジオメトリが現在のマップ範囲にない場合や、LayerView にすべてのフィーチャが含まれていない場合です。クライアント サイド クエリーを実行する前に、LayerView はクエリー パラメーター内の outFields を LayerView のフィールドに追加し、その後クエリーを実行します。LayerView にフィールドを追加しすぎるとパフォーマンスの問題が発生する可能性があるため、notAddFieldsToClient を使用して LayerView にフィールドを追加しないようにすることができます。\nデータアクション（Data action） データアクションの参照\nリピート データ ソース（Repeated Data source） RepeatedDataSourceProvider が提供するデータ ソースをリピートデータ ソースと呼びます。データ ソースを提供するウィジェットのすべての子ウィジェットは、リピート データ ソースを受け取ります。これは React\u0026rsquo;s Context と似ています。ウィジェットは this.props.repetedDataSource でリピート データ ソースにアクセスできます。リピート データ ソースは、データ ソースの id、record、recordIndx を取得します。 どのウィジェットでも、RepeatedDataSourceProvider を使用してリピート データ ソースを提供することができます。Experience Builder の List ウィジェットは、リピート データ ソースを提供する良い例です。リピート データ ソースを使用するには、ウィジェットのマニフェストファイルに supportRepeat プロパティを追加します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/prosdk/",
	"title": "ArcGIS Pro SDK",
	"tags": [],
	"description": "ArcGIS Pro SDK の開発に役立つガイド集です。",
	"content": "ArcGIS Pro SDK の開発に役立つガイド集です。\n  ArcGIS Pro を使用した開発\n 概要  SDK の概要・コンポーネント、開発要件、リリースノート等を紹介します。   ArcGIS Pro Extensions Nuget  ArcGIS Pro Extensions Nuget の使用方法や導入の利点を紹介します。   ArcMap から ArcGIS Pro への移行  ArcMap のカスタマイズを ArcGIS Pro に移行する際のアプローチ、ベストプラクティス、および実装上の考慮事項の概要を説明します。   ArcGIS Pro 3.0 への移行  ArcGIS Pro 3.0 の変更点と 2.x から 3.0 への移行手順について説明します。   フレームワーク  開発フレームワークの詳細を説明します。   非同期プログラミング  アドイン開発で使用する非同期プログラミング手法について説明します。      アドイン開発\n インストールとアップグレード  SDK のインストール、アップグレード、およびアンインストール方法を説明します。   はじめてのアドイン作成  ArcGIS Pro アドインの開発方法をステップで説明します。   アドインの種類  開発できる UI コントロールの種類を説明します。   ジオデータベース  ジオデータベースの操作について説明します。   よくある問題  アドイン開発でよく遭遇する問題とその解決策を紹介します。      構成管理\n コンセプト  ArcGIS Pro のカスタマイズ方法のひとつである構成管理のコンセプトを説明します。   カスタマイズ方法  構成管理のカスタマイズ方法をステップで説明します。      "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-unreal-engine/",
	"title": "Unreal Engine",
	"tags": [],
	"description": "ArcGIS Maps SDK for Unreal Engine を用いたネイティブ地図アプリの作成方法を紹介します。",
	"content": "出典：ArcGIS Maps SDK for Unreal Engine - Tutorials - Display a map (UI)\nマップを表示する (UI) Modes Panel UI を使用したベースマップ、標高ソースの設定、データ レイヤーの追加、特定エリアの表示方法をご紹介します。\nこのチュートリアルでは、ベースマップ レイヤー サービスとデータ レイヤーを含むローカル シーンを Unreal Engine で作成します。\nArcGIS Map SDK for Unreal Engine は、現在 ESRIジャパンにおけるサポート対象外の製品です。\nESRIジャパンで提供する Esri 製品サポート サービスや開発者サポート サービスはご利用いただけませんので、予めご了承ください。\n\r前提条件 このチュートリアルを実施するには、以下が必要です。\n  ArcGIS サービスにアクセスするには、ArcGIS Location Platform アカウントまたは ArcGIS Online アカウントと API キーが必要です。アカウントをお持ちでない場合は、サインアップ (無料) してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。\nAPI キー ページが開発者ダッシュボードに表示されない場合は、アカウントを ArcGIS Location Platform アカウントにアップグレードする必要があります。\n\r  開発環境がシステム要件を満たしていることを確認してください。\n  インストールとセットアップの手順に従って、プラグインをインストールしてください。必ずサンプル アセットをインポートしてください。\n  シーン設定オプションのページ(英語)を確認してください。\n  Unreal Engine のインターフェースに慣れていない場合は、最も一般的なエディター パネルとその活用方法について、Unreal Editor のインターフェース を参照してください。\nステップ 新しいレベルを作成し、Modes Panel UI を開く   メニュー バーの [ファイル (File)] をクリックし、[新規レベル (New Level)] を選択します。\n  プロジェクトにゲーム カテゴリの ブランク テンプレートを使用する場合、ポップアップ ウィンドウで[空のレベル (Empty Level)] を選択します。 プロジェクトのシミュレーション カテゴリーのシミュレーション ブランク テンプレートを使用する場合は、ポップアップ ウィンドウで[シミュレーション ブランク (Simulation Blank)] を選択し、 含まれる Floor スタティック メッシュ アクターを[アウトライナー (Outliner)] ウィンドウから削除します。   メニュー バーの[ファイル (File)]をクリックし、[Save Level As] を選択します。 レベルに名前を付けて[保存 (Save)]をクリックします。\n  マップの作成   メイン ツールバーの[モード選択 (Select Modes)]ドロップダウンをクリックし、[ArcGIS Maps SDK] を選択します。\n  Unreal Editor インターフェースの左側に、Modes Panel UI が開きます。\n  Modes Panel UI の [Map] タブをクリックします。\n  [Map Type] で [Local] を選択します。\n  [Origin Position] セクションでは、GIS シーンの中心を座標と Spatial Reference Well-Known ID (WKID) で設定できます。チュートリアルでは、パラメーターをこれらの値に設定します：\n Longitude : 139.745723 Latitude : 35.659041 Altitude : 0 Spatial Reference WKID : 4326  spatial reference については、spatial references のページを参照してください。\n  [Enable Extent] チェック ボックスをオンにすると、[Map Extent] セクションが表示されます。\n  [Map Extent] で、マップの範囲をこれらの値に設定します :\n Longitude : 139.745723 Latitude : 35.659041 Shape : Circle Spatial Reference WKID : 4326 Shape Dimensions : (Radius) 5000 メートル  以下が、[Map] パネルに入力した画像です。\n  [Create] ボタンをクリックします。[アウトライナー (Outliner)] パネルに、ArcGISMapActor が作成されます。\n  カメラの作成と設定 ArcGIS Maps SDK for Unreal Engine は、カメラに近いエリアにはより高い解像度の LOD を表示し、カメラから遠いエリアにはより低い解像度の LOD を表示します。\n  [Camera] タブをクリックします。\n  [Camera Position] でカメラの初期視点を定義します。パラメーターをこれらの値に設定します：\n Longitude : 139.745723 Latitude : 35.659041 Altitude : 290 Spatial Reference WKID : 4326    [Camera Rotation] でカメラの角度を定義します。\n Heading : 270 Pitch : 93 Roll : 0  以下が、[Camera] パネルに入力した画像です。\n  [Create] ボタンをクリックします。[アウトライナー (Outliner)] パネルに、Default Pawn アクターが作成されます。\n  この時点では、レベルはまだ空です。これからのチュートリアル ステップで、マップ データがレベルに追加されます。\nベースマップと API キーの設定 このチュートリアルでは、API キーが必要なベースマップを選択します。\n  [Basemap] タブをクリックし、パネルの内容を表示します。\n  プリセットのベースマップ リストから [Imagery] ベースマップを選択します。プリセットのベースマップから [Imagery] に設定した結果です。\n  開発者ダッシュボードにアクセスし、API キーを取得してください。\n  [Auth] タブをクリックしてパネルの内容を表示します。\n  [API Key] セクションで API キーを設定します。\nAPI キーが、このスクリーンショットの [Paste your API key here] と表示されているフィールドに入力されていることを確認してください。API キーの取得方法については、UI の [API キーの取得]をクリックしてください。\n  [Basemap] タブに戻ると、以前はグレー表示だったベースマップ アイコンが有効になり、API キーが正常に登録されたことがわかります。\n  Unreal プロジェクト内の複数のレベルに対してグローバル API キーを設定するもう 1 つの方法は、プロジェクト設定を使用することです。API キーの詳細については、API キーのセクションを参照してください。\n標高の設定 このチュートリアルでは、デフォルトの標高を使って地形を定義します。\n  [Elevation] タブをクリックし、パネルの内容を表示します。\n  [Terrain 3D] が選択され、[Enable All] チェックボックスがチェックされていることを確認します。\n  以下が、[Elevation] パネルに入力した画像です。\nデータ レイヤーの追加 ArcGIS Online から使用できるデータを追加します。\n  ArcGIS Online Item : 東京都23区・八王子市南大沢 3D 都市モデル（Project PLATEAU）\n Layer name : Tokyo Model Type : ArcGIS 3DObject Scene Layer ArcGIS Online サービスの URL（ Source ）:  https://tiles.arcgis.com/tiles/wlVTGRSYTzAbjjiC/arcgis/rest/services/13100_13201_Tokyo-23ku_Minamiosawa_Building/SceneServer\r Opacity : 1.0    以下の手順でレイヤーを追加します。\n  [Layers] タブをクリックします。\n  [Add New Data] セクションで、[Type] のドロップダウン リストから適切なレイヤー タイプを選択します。\n  3D オブジェクト シーン レイヤーを追加するには、サービスの URL を [Source] フィールドに入力します。\n  [Name] にレイヤー名を入力します。\n  マップにレイヤーを追加するには、[Add] ボタンをクリックします。レイヤーが追加されると、[Layers] セクションに表示されます。\n  スライダーをドラッグして [Opacity] を設定します。\n  [Is Visible] チェックボックスを使用して、レイヤーの表示 / 非表示を切り替えます。\n  以下が、[Layers] パネルに入力した画像です。\n空とライティングの設定   [メイン ツールバー]の [作成 (Create)] ショートカットから、[ライト (Light)] \u0026gt; [Directional Light] を選択し、レベルにドラッグして Directional Light を作成します。Directional Light の詳細については、ライトのタイプを参照してください。\n  [アウトライナー (Outliner)] で Directional Light を選択し、[詳細パネル (Details)] の [トランスフォーム (Transform)] セクションを開きます。\n  [位置 (Location)] をリセットし、[回転 (Rotation)] を設定します：\n X: 0 Y: -28 Z: -28    [可動性 (Mobility)] を [ムーバブル (Movable)] に設定します。\n  [ライト (Light)] セクションで、[Intensity Value] を3.1416に変更します。\n  [カスケードシャドウマップ (Cascaded Shadow Maps)] セクションで、[Dynamic Shadow Distance MovableLight] を 2000000 に変更します。\n  [大気と雲 (Atmosphere and Cloud)] セクションで、[Atmosphere Sun Light] を有効にします。\n  [アクタ (Actor)] \u0026gt; [Spawn Collision Handling Method] セクションで、[Always Spawn, Ignore Collisions] を選択します。\n  [メイン ツールバー]の [Create (作成)] ショートカットから、[ライト (Light)] \u0026gt; [Sky Light] を選択し、レベルにドラッグして Sky Light を作成します。SkyLight の詳細については、ライトのタイプを参照してください。\n  [トランスフォーム (Transform)] セクションで、[位置 (Location)] をリセットし、[可動性 (Mobility)] を [ムーバブル (Movable)] に設定します。\n  [ライト (Light)] セクションで、[Real Time Capture] を有効にします。\n  [メイン ツールバー]の [Create (作成)] ショートカットから、[ビジュアルエフェクト (Visual Effects)] \u0026gt; [Sky Atmosphere] を選択し、レベルにドラッグして Sky Atmosphere を作成します。Sky Atmosphere の詳細については、フォグのエフェクトを参照してください。\n  [Planet] セクションで、[Ground Radius] を 6378.137207 に変更します。\n  この時点で、エクステントの設定で切り取られたマップ データが表示されるはずです。[アウトライナー (Outliner)] パネルで、Default Pawn をダブルクリックして、エディター カメラを設定されたカメラ位置に移動します。マウスの右ボタンを押しながら WASD キーを使って移動するか、マウスの左ボタンを押しながらエディター モード中に周囲を見回します。エディター モード中に [ビューポート (Viewport)] のカメラ移動速度を上げるには、[ビューポート (Viewport)] 右上の [カメラ速度 (Camera Speed)] アイコンをクリックし、スライダーをドラッグして値を上げます。\nDefault Pawn を ArcGIS Pawn に置き換える エディター モードでは、Unreal Engine の標準の ビューポート制御 を使用してシーンを自由に移動できます。プレイ モードでシーンを移動するには、Pawn 用の独自のコントローラー コンポーネントを作成するか、Default Pawn の移動コンポーネントを修正します。また、Default Pawn を Samples で使用されているサンプル ArcGIS Pawn に置き換えることもできます。サンプル ArcGIS Pawn については、 ArcGIS Pawn のセクションを参照してください。\n  [コンテンツ ドロワー (Content Drawer)] で以下の場所を開きます。\n\rプラグイン  ArcGIS Maps SDK for Unreal Engine C++ クラス  ArcGISSamples  Public\r\r  [ArcGIS Pawn] をクリックして選択します。選択されると背景色が青に変わります。\n  [アウトライナー (Outliner)] パネルで Default Pawn を右クリックします。\n  [選択中のアクタを置換 (Replaced Selected Actor with)] をクリックし、ArcGIS Pawn を選択します。\n  これで、Modes Panel UI を使用したローカル シーンの構成は完了です。\n[メイン ツールバー]の [プレイ (Play)] アイコンをクリックし、WASD キーで移動します。マウスの右ボタンを押したままカーソルを動かして周囲を見渡し、マウスの左ボタンを押したままカーソルを動かしてパンします。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/data-action/",
	"title": "データ アクション（Data action）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Data action\nデータ アクション（Data action） データ アクションは、データ レコードのコレクションを拡張可能な方法で処理する方法を提供します。\nデータ アクションは Data Action インターフェイスによって定義され、isSupported と onExecute という 2 つの重要なメソッドを持っています。\n isSupported が呼び出されると、アクションがデータを処理できるかがチェックされます。サポートされていないデータアクションは実行中は非表示になります。 onExecute メソッドはユーザーがデータ アクションをクリックしたときに呼び出されます。  どちらのメソッドも、データ ソース、オプションのデータ レコード配列およびフィールドを含む DataRecordSet インスタンスの配列を取得できます。これら 2 つのメソッドは、DataLevel と widgetId パラメーターも受け取ります。DataLevel は、DataRecordSet がすべてのレコードを含むか、レコードのサブセットを含むかを示すために使用されます。\nフレームワークは CSV へのエクスポートや JSON へのエクスポートなどのデータ アクションを提供します。ウィジェットもデータ アクションを提供できます。例えば、Map ウィジェットは \u0026ldquo;画面移動 (pan to)\u0026rdquo; と \u0026ldquo;ズーム (zoom to)\u0026rdquo; というデータアクションを提供します。ウィジェットにデータ アクションを実装するには、manifest.json でデータアクションを宣言し、AbstractDataAction を継承したクラスを作成します。\nデータ アクションによっては、アクションの動作を設定するための UI が必要な場合があります。これを実現するには、manifest.json で settingUri を宣言します。アクション設定の UI コンポーネントは、いくつかの差し込まれたプロパティを持つ React コンポーネントです。ユーザーが設定を変更したら、this.props.onSettingChange を呼び出して設定を保存し、onExecute メソッドで利用できるようにします。\n\u0026#34;dataActions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;showOnMap\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Show on map\u0026#34;, \u0026#34;uri\u0026#34;: \u0026#34;data-actions/show-on-map\u0026#34;, \u0026#34;settingUri\u0026#34;: \u0026#34;data-actions/show-on-map-setting\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;runtime/assets/icons/ds-map-view.svg\u0026#34; } ] データアクションを提供するだけでなく、ウィジェットはデータアクションを使用することもできます。ウィジェットでデータアクションを使用するには、ウィジェットのmanifest.json プロパティで canConsumeDataAction: true を宣言し、import {DataActionDropDown} from 'jimu-ui' をインポートして、ウィジェットの UI で DataActionDropDown をレンダリングする必要があります。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/",
	"title": "ArcGIS API for Python",
	"tags": [],
	"description": "ArcGIS API for Python の開発に役立つガイド集です。",
	"content": "ArcGIS API for Python の開発に役立つガイド集です。\n ArcGIS API for Python のコンセプト\nArcGIS API for Python のプロダクト コンセプトと動作要件について紹介します。\n\r ArcGIS API for Python のための基礎環境：Conda入門\nConda の基本について簡単に紹介します。\n\r インストール ガイド\nArcGIS API for Python の環境構築方法を紹介します。\n\r Jupyter Notebook を使ってみよう\nArcGIS API for Python の実行に便利な JupyterLab の初期設定方法と使用方法を簡単に紹介します。\n\r Jupyter Lab を使ってみよう\nArcGIS API for Python の実行に便利な Jupyter Notebook の基本的な起動と使用方法を簡単に紹介します。\n\r スクリプト実行の自動化\nタスクスケジューラや cron を使用した Python スクリプトの実行の自動化について紹介します。\n\r matplotlib での日本語利用について\nArcGIS API for Python で利用されているグラフ描画ライブラリの matplotlib で日本語を使う方法を説明します。\n\r アイテムのクローン\nWeb GIS のアイテムを他のアカウントに複製する方法を紹介します\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/message-action/",
	"title": "メッセージとアクション（Message and action）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Message and action\nメッセージとアクション（Message and action） メッセージ/アクションは、ウィジェットからウィジェット、ウィジェットからフレームワーク、フレームワークからウィジェットへの通信をサポートする方法です。 ウィジェット/フレームワークはメッセージを公開したり、メッセージを聞いたりすることができます。メッセージは jimu フレームワークによって定義される MessageType によって識別されます。jimu には ExtentChange や DataRecordsSelectionChange のようないくつかのメッセージタイプが定義されています。\nメッセージの発行（Publishing a message） ウィジェットは、MessageManager.getInstance().publishMessage(message) を呼び出してメッセージを発行します．例えば、List ウィジェットでは，リストアイテムがクリックされたときに DataRecordsSelectionChange メッセージを発行したり，Map ウィジェットでは，ビューが変更されたときに ExtentChange メッセージを発行して，List ウィジェットのコンテンツを更新したりします。以下の MessageTypes がサポートされています。\n StringSelectionChange ExtentChange DataRecordsSelectionChange DataRecordSetChange  各メッセージには、それを定義するクラスがあります。例えば、ExtentChange メッセージは ExtentChangeMessage クラスで定義され、このクラスはメッセージのペイロードである extent プロパティを定義します。\nメッセージを発行するために、ウィジェットは manifest.json ファイルで発行メッセージを宣言する必要があります。\n\u0026#34;publishMessages\u0026#34;: [ \u0026#34;DATA_RECORDS_SELECTION_CHANGE\u0026#34; ] メッセージ アクションの作成（Creating a message action） メッセージ アクションを作成するには、AbstractMessageAction クラスを継承する必要があります。メッセージ アクションの開発に役立つメソッドや関数がいくつかあります。\nfilterMessageType メソッドは、利用可能なアクションのフィルタリングに使用されます。\nexport default class QueryAction extends AbstractMessageAction{ filterMessageType(messageType: MessageType, messageWidgetId?: string): boolean{ return [MessageType.StringSelectionChange, MessageType.DataRecordsSelectionChange].indexOf(messageType) \u0026gt; -1; } } filterMessage メソッドは、メッセージ マネージャーでメッセージをフィルタリングするために使用されます。\nfilterMessage(message: Message): boolean{ return true; } アクションによっては、アクションの動作を設定するための設定 UI が必要な場合があります。これを実現するには、manifest.json で settingUri を宣言します。特定のケースでは、設定 UI を省略したい場合があります。これを実現するには、getSettingComponentUri メソッドをオーバーライドし、該当する場合は null を返します。\nアクション設定の UI コンポーネントはいくつかの差し込まれたプロパティを持つ React コンポーネントです。ユーザーが設定を変更したら、this.props.onSettingChange を呼び出して設定を保存し、onExecute メソッドで利用できるようにします。\nthis.props.onSettingChange({ actionId: this.props.actionId, config: {} // アクションの config 設定 }) onExecute メソッドは、メッセージ タイプに応じて発生させたいロジックを処理します。以下のスニペットでは、基本的にメッセージ タイプに基づいてアクションを選択し、dispatch プロパティを使用してアプリケーションから getAppStore() 関数を使用してストアに送信しています。これにより、redux アクションがディスパッチされ、ステートが更新されるようになります。Redux アクションと Redux でのストアの使用について詳しくはこちらをご覧ください。\nonExecute(message: Message, actionConfig?: any): Promise\u0026lt;boolean\u0026gt; | boolean{ let q = `${(actionConfig as ConfigForStringChangeMessage).fieldName}= \u0026#39;${message}\u0026#39;` switch(message.type){ case MessageType.StringSelectionChange: q = `${(actionConfig as ConfigForStringChangeMessage).fieldName}= \u0026#39;${(message as StringSelectionChangeMessage).str}\u0026#39;` break; case MessageType.DataRecordsSelectionChange: q = `${actionConfig.fieldName}= ` + `\u0026#39;${(message as DataRecordsSelectionChangeMessage).records[0].getFieldValue(actionConfig.fieldName)}\u0026#39;` break; } getAppStore().dispatch(appActions.widgetStatePropChange(this.widgetId, \u0026#39;queryString\u0026#39;, q)); return true; } Redux ストアに格納できるのは、プレーンな JSON オブジェクトだけです。複雑な JavaScript オブジェクトを渡す必要がある場合は、MutableStoreManager を使ってミュータブル ストアに格納できます。値を更新したら、ウィジェットも再レンダリングできます。アクション内で次のように記述します。\nMutableStoreManager.getInstance().updateStateValue(this.widgetId, \u0026#39;theKey\u0026#39;, theComplexObject) ウィジェットでは次のようにしてオブジェクトにアクセスできます。\nthis.props.mutableStateProps.theKey manifest.json には messageActions プロパティがあり、メッセージ アクション エクステンションの場所と情報を提供します。\n\u0026#34;messageActions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;query\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Query\u0026#34;, \u0026#34;uri\u0026#34;: \u0026#34;actions/query-action\u0026#34;, \u0026#34;settingUri\u0026#34;: \u0026#34;actions/query-action-setting\u0026#34; } ] 国際化対応（i18n support） メッセージ アクションの言語サポートは、ウィジェットと同じパターンですが、1 つ重要な違いがあります。メッセージ アクションには、ユーザーがアクションを選択するための Select an action パネルがあります。そのため、アクションのプロパティ名を記載した default.ts というファイルを runtime/translations フォルダーに用意する必要があります。フレームワークは、このパネルのアクションラベルの翻訳を処理します。そのため、ラベルのプロパティは、_action_\u0026lt;actionName\u0026gt;_label という命名規則を持つ必要があります。\nexport default { _widgetLabel: \u0026#39;Message subscriber\u0026#39;, _action_query_label: \u0026#39;Query\u0026#39; } "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/appstudio/",
	"title": "ArcGIS AppStudio",
	"tags": [],
	"description": "ArcGIS AppStudio を使用したアプリ作成に役立つガイド集です。",
	"content": "ArcGIS AppStudio を使用したアプリ作成に役立つガイド集です。\nArcGIS AppStudio は2025年1月末日でサポートが終了しました。ArcGIS AppStudio のサポートおよび移行に関する情報についてはこちらをご参照ください。\n\r  ガイド\n AppStudio の概要からアプリの作成・デプロイ、AppStudio Player を使用したモバイル デバイスでのテスト、カスタマイズ方法等を紹介したガイドです。    AppStudio Framework API リファレンス（英語）\n AppStudio Framework API は、ファイルパスの管理、ネットワーク インターフェース、画像操作などの、プラットフォーム共通の基本機能を提供しています。    ユースケース\n ギャラリー（英語）  全世界のユーザーによって作成されたアプリと利活用方法が紹介されています。   国内事例  日本国内での事例を紹介しています。      システム要件\n システム要件（米国Esri社）  AppStudio のデスクトップ用のアプリ、AppStudio Player のサポート OS 等のシステム要件が記載されています。   システム要件（Esriジャパン）  日本国内での固有のシステム要件を記載しています。      ライセンス\n AppStudio の 2 つのライセンス オプション（「ArcGIS AppStudio」と「ArcGIS AppStudio Developer Edition」）について紹介しています。    ダウンロード\n AppStudio のデスクトップ用のアプリ、AppStudio Player はこちらからダウンロード（無償）できます。    インストール\n AppStudio のデスクトップ用のアプリ、AppStudio Player のインストール方法を紹介しています。    チュートリアル\n アプリの作成からデプロイまでの手順を示したチュートリアルです。はじめての方はこちらのチュートリアルをお試しください。 コーディングによるカスタマイズのチュートリアルは、ハイカー向けアプリの構成 をお試しください。AppStudio の Nearby（近傍）テンプレートを使用したアプリ作成のチュートリアルで、最後にコーディングによるカスタマイズを行います。    その他\n  FAQ（米国Esri社）\n よくあるご質問とその回答が記載されています。    Esri Community（英語）\n 全世界のユーザーが投稿した製品に関する質問等の投稿を確認できます。    その他の Tips\n アプリ作成に関する技術的な情報を紹介しています。      "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/tutorials/create-starter-widget/",
	"title": "スターター ウィジェットの作成",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) のチュートリアルとして、カスタム ウィジェットの開発の基本的な実装方法について学びます。",
	"content": "出典：ArcGIS Experience Builder - Tutorials - Create Starter Widget\n[概要] ここでは、ウィジェットの基本実装の構築方法について学習します。\nArcGIS Experience Builder では、さまざまなウィジェットから選択し、対話形式でアプリケーションを構築できます。これらのアプリケーションはエクスペリエンスと呼ばれます。ユーザーにより多くのオプションを提供する場合は、独自のカスタム ウィジェットを作成し、ArcGIS Experience Builder に追加できます。作成するウィジェットのタイプは、求める機能によって異なります。マップと対話するウィジェットを作成することも、ArcGIS の外部で処理を実行するウィジェットを作成することもできます。ウィジェットを作成してインストールすると、ArcGIS Experience Builder によって自動的にウィジェットが検出され、ユーザーが使用できるようになります。\nこのチュートリアルでは、新しいウィジェットの作成に必要なフォルダーと主なファイルを作成します。これらのファイルは、他のウィジェット チュートリアルの開始点として使用されます。\n[前提条件] ArcGIS Experience Builder をダウンロード、インストール、および構成してください。\n[ステップ] [新しいフォルダーを作成する] 新しいウィジェットを作成する最初のステップは、ウィジェット ファイル用のフォルダーを作成することです。\n  ファイル ブラウザーで、ArcGIS Experience Builder を解凍したフォルダーに移動します。\nArcGIS Experience Builder の開発者向け追加機能のインストール方法の詳細については、インストールガイドを参照してください。\n  ArcGISExperienceBuilder フォルダーで、次のパスを展開します\n /client/your-extensions/widgets\r   widgets フォルダーに、starter-widget という新しいフォルダーを作成します。 パスは以下のようになります\n /client/your-extensions/widgets/starter-widget\r ウィジェット フォルダーにスペースを含めることはできません。ウィジェットの構築については、こちらのドキュメントを参照してください。\n  [マニフェスト ファイルの作成] ウィジェットのプロパティを定義するには、マニフェスト ファイルが必要です。これらは、ArcGIS Experience Builder のロード時に読み込まれます。\nstarter-widget フォルダーに、manifest.json という名前のファイルを作成します。以下の JSON オブジェクトを追加して、ウィジェットを定義します。\n{ \u0026#34;name\u0026#34;: \u0026#34;starter-widget\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;widget\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.17.0\u0026#34;, \u0026#34;exbVersion\u0026#34;: \u0026#34;1.17.0\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Your Name\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A hello world starter widget\u0026#34;, \u0026#34;copyright\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;properties\u0026#34;: {}, \u0026#34;translatedLocales\u0026#34;: [ \u0026#34;en\u0026#34; ], \u0026#34;defaultSize\u0026#34;: { \u0026#34;width\u0026#34;: 800, \u0026#34;height\u0026#34;: 500 } } [コンポーネントの実装] ウィジェットのメイン ロジックは、widget.tsx の React コンポーネントに実装します。このファイルは単一の関数 React コンポーネントをエクスポートします。\nArcGIS Experience Builder では、関数スタイルまたはクラス スタイルのコンポーネントを使用できます。この 2 つのタイプの詳細については、React ドキュメントを参照してください。\n  starter-widget フォルダーに、src という新しいフォルダーを作成します。このフォルダーの中に、runtime という別のフォルダーを作成します。\n  Runtime フォルダーに、widget.tsx という名前のファイルを作成します。以下のコードを追加して、React コンポーネントを作成します。\n最初の行は、jimu-core モジュールから Reactをインポートしている。\nウィジェットを実装するには、React コンポーネントとなる関数を作成する必要がある。この関数は、ユーザーに表示される JSX（この例では、div 要素といくつかのテキスト）、HTML のような構文を返します。\n  import { React, type AllWidgetProps } from \u0026#39;jimu-core\u0026#39; const Widget = (props: AllWidgetProps\u0026lt;any\u0026gt;) =\u0026gt; { return \u0026lt;div className=\u0026#34;widget-starter jimu-widget\u0026#34;\u0026gt;This is your starter widget!\u0026lt;/div\u0026gt; } export default Widget ターミナルで、client フォルダーで実行中の npm start スクリプトを停止（ctrl + c）し、再スタートします。  ウィジェットをテストする フォルダーとメイン ファイルを配置したら、ArcGIS Experience Builder を実行して新しいページにウィジェットを追加して、ウィジェットをテストできます。ビルダーは自動的にウィジェットを検出し、利用可能にします。\n  Web ブラウザーで ArcGIS Experience Builder にアクセスします。例： https://localhost:3001\n  ArcGIS Experience Builder で [新規作成] をクリックして、新しいエクスペリエンス ページを作成します。\n  空白のスクロール テンプレートの [作成] ボタンをクリックします。\n  ウィジェットの挿入パネルが開きます。そこから、新しいスターター ウィジェットをエクスペリエンスにドラッグしてください。\nウィジェットは、ウィジェット一覧の下部にある「カスタム」セクションに配置されます。作成したウィジェットには無効を示すアイコンが表示されているかもしれませんが、まだアイコンを作成していないため、それは問題ありません。ウィジェットが表示されない場合、元のセットアップ手順に従って、client フォルダーで npm start を実行したか再確認してください。\n  マップ ウィジェットをエクスペリエンスにドラッグします。\n  ツールバーで、[保存] をクリックし、次に [プレビュー] をクリックすると、カスタム ウィジェットを含むエクスペリエンスが新しいブラウザ タブで開きます。\n  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/deployment/",
	"title": "デプロイ",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) のデプロイついて説明しています。",
	"content": "ArcGIS Experience Builder (Developer Edition) のデプロイ方法について紹介します。\n デプロイ パターン\nArcGIS Experience Builder (Developer Edition) で作成したアプリやウィジェットのデプロイ パターンを紹介します。\n\r デプロイ\nArcGIS Experience Builder (Developer Edition) で作成したアプリケーションをダウンロードし、独自のサーバーにホストする手順を紹介します。\n\r ウィジェットとテーマのデプロイ\nカスタム ウィジェットとカスタム テーマのデプロイについて紹介しています\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/map-scene-view/",
	"title": "マップ/シーン ビュー（Map/Scene View）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Map/Scene View\nマップ/シーン ビュー（Map/Scene View） ビューの概念は ArcGIS Maps SDK for JavaScript と同じですが、Experience Builder では、ウィジェットやメッセージ/アクションなどを作成する際に一貫した拡張性モデルを確保するために、ビューは JimuMapView としてラップされます。JimuMapView オブジェクトを作成するには、ウィジェットは JimuMapViewManager.createJimuMapView() メソッドを使用します。JimuMapView オブジェクトは、主に以下のプロパティを持っています。\n view: マップ/シーン ビュー オブジェクト datasourceId: ビューを作成するデータソース (webmap/webscene) mapWidgetId: オブジェクトを作成するビュー jimuLayerViews: レイヤー ビュー オブジェクトのラッパー  Experience Builder では、マップ ウィジェットが JimuMapView オブジェクトを作成します。ウィジェットが JimuMapView オブジェクトを使用する必要がある場合、設定ページの MapWidgetSelector コンポーネントを使用して マップ ウィジェットを選択することができます。マップ ウィジェットの ID を取得した後、ウィジェットは \u0026lt;JimuMapViewComponent\u0026gt; を使って、作成された JimuMapView オブジェクトを取得することができます。JimuMapView オブジェクトを選択するには、設定ページの JimuMapViewSelector コンポーネントを利用します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/tutorials/",
	"title": "チュートリアル",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) のチュートリアルでは、カスタム ウィジェットの作成方法について説明しています。",
	"content": "ArcGIS Experience Builder (Developer Edition) のチュートリアルでは、カスタム ウィジェットの作成方法について説明しています。各チュートリアルの完了には、約 15 分かかります。カスタム ウィジェットの作成方法と API の使用方法について理解することができます。\n スターター ウィジェットの作成\nArcGIS Experience Builder (Developer Edition) のチュートリアルとして、カスタム ウィジェットの開発の基本的な実装方法について学びます。\n\r マップの座標を取得\nArcGIS Experience Builder (Developer Edition) のチュートリアルとして、カスタム ウィジェットで地図の緯度経度、縮尺、ズーム レベルを表示する方法を学びます。\n\r マップにレイヤーを追加\nArcGIS Experience Builder (Developer Edition) のチュートリアルとして、カスタム ウィジェットでマップにレイヤーを追加する方法を学びます。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/deployment/deploy-pattern/",
	"title": "デプロイ パターン",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) で作成したアプリやウィジェットのデプロイ パターンを紹介します。",
	"content": "トピック  概要 Web アプリケーションをデプロイ ウィジェットをデプロイ  概要 ArcGIS Experience Builder (Developer Edition) (以下 Developer Edition) では ArcGIS Experience Builder を拡張して、独自の Web アプリケーションやウィジェットを作成することが可能です。エンド ユーザーの利用形態や要件により最適なデプロイは異なりますが、このページでは以下の 2 つの主要なデプロイ パターンと、それぞれのデプロイ方法についてご紹介します。\n Web アプリケーションをデプロイ 全体像  Web アプリケーションを作成し、独自のサーバーでホストすることができます。特定の業務で継続的に利用されるアプリ等、ユーザーによる設定変更が不要な場合や、ユーザーに設定変更をさせたくない場合等に活用できます。   必要なコンポーネント  開発時  Node.js Developer Edition   運用時  ArcGIS Enterprise または ArcGIS Online Web サーバー (ArcGIS Enterprise の Web サーバーと併用も可)    手順概要 以下は Web アプリケーション作成から、デプロイ、実際の運用までの流れの概要です。\n カスタム ウィジェットを含む Web アプリケーションを作成  Developer Edition を用いたウィジェットの開発や Web アプリケーションの作成には Node.js が必要です。 詳しくはインストールガイドをご覧下さい。 カスタム ウィジェットを開発する際は、カスタム ウィジェット開発ガイドをご覧ください。   作成した Web アプリケーションを自身で用意した Web サーバーに配置  ArcGIS Enterprise で使用している Web サーバーと併用することも可能です。 ※ ArcGIS Online を使用してホストすることはできません。 詳しくは、アプリケーションのデプロイをご覧ください。   ユーザーが作成された Web アプリケーションを利用  ユーザーが Web アプリケーションにアクセスして利用します。 ArcGIS Enterprise や ArcGIS Online のポータルにアイテムとして表示させたい場合はアプリの URL をアイテムに登録する必要があります。  詳細は「アプリの追加」及びその後の「アプリの登録」をご覧ください。   内部的には、アプリは ArcGIS Online もしくは ArcGIS Enterprise の Web マップを参照してアプリ上に地図を表示します。     ウィジェットをデプロイ  ArcGIS Enterprise 11 以降では、Experience Builder で使用できるウィジェットのみを開発し、独自のサーバーでホストすることも可能です。ユーザーが ArcGIS Online や ArcGIS Enterprise を使用して独自に Web アプリケーションを作成することを想定しているものの、デフォルトの Experience Builder のウィジェットには無い機能を拡張したい場合に活用できます。   必要なコンポーネント  開発時  Node.js Developer Edition   運用時  ArcGIS Enterprise Web サーバー (ArcGIS Enterprise の Web サーバーと併用も可)    手順概要 以下はカスタムウィジェットの作成から、デプロイ、実際の運用までの流れの概要です。\n カスタムウィジェットを作成  Developer Edition を用いたウィジェットの作成には Node.jsが必要です。 詳しくはインストールガイドをご覧下さい。 カスタムウィジェット開発の詳細については、カスタム ウィジェット開発ガイドをご覧下さい。   作成したカスタムウィジェットを自身で用意した Web サーバーに配置  ArcGIS Enterprise で使用している Web サーバーと併用することも可能です。 ※ ウィジェットを配置するサーバーが自己署名証明書を使用している場合、Portal for ArcGIS に証明書をインポートする必要があります。詳しい方法はポータルへの証明書のインポートをご覧ください。 Web サーバーに配置後、ArcGIS Enterprise に組み込まれている Experience Builder にカスタムウィジェットを追加します。  詳しくは、カスタム ウィジェットの追加をご覧ください。 ※ ArcGIS Online に追加することはできません。     ウィジェットを使った Web アプリケーションの作成・利用  ユーザーが ArcGIS Enterprise に組み込まれている Experience Builder を利用してカスタムウィジェットを使用した Web アプリケーションを作成・利用します。 内部的には、アプリは Web サーバーでホストされているカスタムウィジェットを参照して動作します。     --\r2 つのデプロイ パターンの総括表    パターン 開発時に必要なコンポーネント 運用時に必要なコンポーネント ArcGIS Online での利用可否 ArcGIS Enterprise での利用可否     Web アプリケーションをデプロイ Node.js、Developer Edition Web サーバー、ArcGIS Online もしくは ArcGIS Enterprise 〇 〇   ウィジェットをデプロイ Node.js、Developer Edition Web サーバー、 ArcGIS Enterprise × 〇    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/tutorials/get-map-coordinates/",
	"title": "マップの座標を取得",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) のチュートリアルとして、カスタム ウィジェットで地図の緯度経度、縮尺、ズーム レベルを表示する方法を学びます。",
	"content": "出典：ArcGIS Experience Builder - Guide - Get map coordinates\n概要 学習内容：カスタム ウィジェットでマップの緯度と経度、縮尺、ズーム レベルを表示する方法\nArcGIS Experience Builder 標準のマップ ウィジェットには、ArcGIS Maps SDK for JavaScript の View インスタンスが含まれています。View はマップと対話し、位置情報を取得する方法を提供します。View のプロパティとイベント ハンドラーを使用して、マップ画面上の任意のポイントの位置に関する現在の空間参照の情報、緯度と経度、縮尺、ズーム レベルを確認することができます。確認した情報は、カスタム ウィジェットに表示したり、地球上の他の場所に移動したり、エクスペリエンスの開始時にマップの初期表示範囲を設定したりするために使用できます。\nこのチュートリアルでは、マップ ウィジェットにアクセスし、カスタム ウィジェットでマウス カーソルが地図上にある時の緯度と経度を表示します。\n前提条件 ArcGIS Experience Builder のインストール ガイドを参照して、ArcGIS Experience Builder (Developer Edition) のダウンロード、インストール、設定を行います。\nステップ スターター ウィジェットの入手  スターター ウィジェット テンプレートをこちらからダウンロードします。 すでに、スターター ウィジェットの作成 チュートリアルを完了している場合は、それを使用して開始できます。/client/your-extensions/widgets 内のウィジェット フォルダーをコピーしてください。 手順 1 でテンプレートをダウンロードした場合は ArcGIS Experience Builder フォルダー内で、zip ファイルを以下のパスに展開してください。 /client/your-extensions/widgets  ウィジェット名の変更  ArcGIS Experience Builder の client フォルダーで npm start が実行されたターミナルがある場合、ctrl + c を押してスクリプトを停止します。 ファイル ブラウザーで Experience Builder が展開されたフォルダーに移動します。 Experience Builder フォルダー内で以下のパスを開きます。 /client/your-extensions/widgets widgets フォルダー内で、starter-widget フォルダーの名前を get-map-coordinates に変更します。 新しく名前を変更した get-map-coordinates フォルダー内で、manifest.json ファイルをコード エディターで開きます。 コード エディターで、name プロパティを get-map-coordinates に変更します。 manifest.json の name プロパティがウィジェットのフォルダー名と一致することが重要です。この時点で、ウィジェットの説明、作成者など manifest.json ファイル内の他のメタデータも更新できます。  { // *** 更新 *** // \u0026#34;name\u0026#34;: \u0026#34;starter-widget\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;get-map-coordinates\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;widget\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.17.0\u0026#34;, ・・・ manifest.json の version プロパティの後に jimu-arcgis 依存関係を追加します。これを宣言することで、ウィジェット内で ArcGIS Maps SDK for JavaScript モジュールを使用できるようになります。  { \u0026#34;name\u0026#34;: \u0026#34;get-map-coordinates\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;widget\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.17.0\u0026#34;, // *** 追加 *** \u0026#34;dependency\u0026#34;: [\u0026#34;jimu-arcgis\u0026#34;], 設定パネルの実装 設定パネルを実装することで、エクスペリエンスの作成者がウィジェットをカスタマイズできるようになります。設定パネルは、ArcGIS Experience Builder でウィジェットが選択された時に右側のサイドバーに表示されます。パネルを作成するには、React コンポーネントを作成します。\n ウィジェットのルート フォルダーに、空のオブジェクトを含む config.json ファイルを作成します。 後で、ウィジェットの設定値を保存するために、このオブジェクトにウィジェットの構成パラメーターを追加できます。  {} src フォルダーに、setting という名前のフォルダーを作成します。 setting フォルダー内に、setting.tsx ファイルを作成します。 setting/setting.tsx ファイルを開き、以下の import 文を記述します。  import { React } from \u0026#39;jimu-core\u0026#39; import { type AllWidgetSettingProps } from \u0026#39;jimu-for-builder\u0026#39; コンポーネントを実装するためのコードを追加します。  const Setting = (props: AllWidgetSettingProps\u0026lt;any\u0026gt;) =\u0026gt; { return \u0026lt;div className=\u0026#34;widget-setting-demo\u0026#34;\u0026gt;ここはスターター ウィジェットの設定パネルです\u0026lt;/div\u0026gt; } export default Setting ArcGIS Experience Builder の client フォルダーで npm start が実行されたターミナルがある場合、ctrl + c を押してスクリプトを停止します。その後、client フォルダーで npm start スクリプトを開始します。  マップ ビューのデータ ソースを選択できるようにする ArcGIS Experience Builder では、ページに複数のマップ ウィジェットを配置することができます。そのため、カスタム ウィジェットには、作成者が使用するマップ ウィジェットを選択するためのセクションが必要です。\n setting/setting.tsx ファイルに、jimu ライブラリーから MapWidgetSelector モジュールを記述します。  import { MapWidgetSelector } from \u0026#39;jimu-ui/advanced/setting-components\u0026#39; コンポーネント内で onMapWidgetSelected 関数を定義します。  // *** 追加 *** const onMapWidgetSelected = (useMapWidgetIds: string[]) =\u0026gt; { props.onSettingChange({ id: props.id, useMapWidgetIds: useMapWidgetIds }) } return \u0026lt;div className=\u0026#34;widget-setting-demo\u0026#34;\u0026gt;ここはスターター ウィジェットの設定パネルです\u0026lt;/div\u0026gt;; return() 文内に、MapWidgetSelector を表すタグを追加します。  return ( \u0026lt;div className=\u0026#34;widget-setting-demo\u0026#34;\u0026gt; \u0026lt;MapWidgetSelector useMapWidgetIds={props.useMapWidgetIds} onSelect={onMapWidgetSelected} /\u0026gt; \u0026lt;/div\u0026gt; ) マップにアクセスする これまでのステップでは、設定パネルに機能を追加し、マップ ウィジェットを選択できるようになりました。Map オブジェクトは JimuMapViewComponent を使用してアクセスできます。\n widget.tsx ファイルに、jimu-arcgis ライブラリーから JimuMapViewComponent と JimuMapView の型を追加し、React 変数をデストラクチャリング (分割代入) して getState import にアクセスします。  import { React, type AllWidgetProps } from \u0026#39;jimu-core\u0026#39; /** 追加 **/ import { JimuMapViewComponent, type JimuMapView } from \u0026#39;jimu-arcgis\u0026#39; const { useState } = React マウスの位置の緯度と経度のプロパティを表示するには、マウス ポインターの状態を追跡する必要があります。これにはコンポーネント内で、useState() を使用し state として追跡できるように設定します。  const { useState } = React const Widget = (props: AllWidgetProps\u0026lt;any\u0026gt;) =\u0026gt; { // *** 追加 ***//  const [latitude, setLatitude] = useState\u0026lt;string\u0026gt;(\u0026#39;\u0026#39;) const [longitude, setLongitude] = useState\u0026lt;string\u0026gt;(\u0026#39;\u0026#39;) return ( return 文で、JimuMapViewComponent を JSX マークアップに追加します。 追加されたコードの最初の 2 行 ({props.useMapWidgetIds \u0026amp;\u0026amp;...)は、JSX で条件を使用する方法です。これは基本的に「エクスペリエンス作成者が設定パネルで有効なマップ ウィジェットを選択した場合にのみ JimuMapViewComponent を追加する」という意味です。  return ( \u0026lt;div className=\u0026#34;widget-starter jimu-widget\u0026#34;\u0026gt; {props.useMapWidgetIds \u0026amp;\u0026amp; props.useMapWidgetIds.length === 1 \u0026amp;\u0026amp; ( \u0026lt;JimuMapViewComponent useMapWidgetId={props.useMapWidgetIds?.[0]} onActiveViewChange={activeViewChangeHandler} /\u0026gt; )} \u0026lt;/div\u0026gt; ) widget.tsx の上部に、次のステップで使用する Point クラスをインポートします。  import Point from \u0026#39;esri/geometry/Point\u0026#39; useState コマンドのすぐ下に activeViewChangeHandler 関数を定義します。この関数は、マップが準備完了した時に一度だけ呼び出されます。この関数内で、pointer-move イベントがトリガーされる度に緯度と経度の state を更新するリスナーを設定します。 マウスの x 座標と y 座標を使用して Point オブジェクトを作成し、view.toMap() 関数を使用して座標を地理座標に変換します。緯度と経度の state を設定して、座標値を表示します。  /** 追加 **/ const activeViewChangeHandler = (jmv: JimuMapView) =\u0026gt; { if (jmv) { // ポインターが移動したら、ポインターの位置を取得し、Point オブジェクトを作成  // view.toMap() 関数を使用してジオメトリを取り出し、state を更新  jmv.view.on(\u0026#39;pointer-move\u0026#39;, (evt) =\u0026gt; { const point: Point = jmv.view.toMap({ x: evt.x, y: evt.y }) setLatitude(point.latitude.toFixed(3)) setLongitude(point.longitude.toFixed(3)) }) } } 緯度と経度の座標を表示する コンポーネントの state に緯度と経度が保存されたので、関数コンポーネントから返される JSX に値を簡単に表示できます。\n return() 文内で (先ほど配置した JimuMapViewComponent のすぐ後に)、緯度と経度を表示するための JSX を追加します。  return ( \u0026lt;div className=\u0026#34;widget-starter jimu-widget\u0026#34;\u0026gt; {props.useMapWidgetIds \u0026amp;\u0026amp; props.useMapWidgetIds.length === 1 \u0026amp;\u0026amp; ( \u0026lt;JimuMapViewComponent useMapWidgetId={props.useMapWidgetIds?.[0]} onActiveViewChange={activeViewChangeHandler} /\u0026gt; )} {/* *** 追加 *** */} \u0026lt;p\u0026gt; 緯度 / 経度: {latitude} {longitude} \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); ウィジェットのテスト コードの変更が完了したら、ArcGIS Experience Builder を実行してエクスペリエンスを表示することでウィジェットをテストできます。\n Web ブラウザーで、Experience Builder にアクセスします。 例：https://localhost:3001 Experience Builder タブが開かなかった場合は、https://localhost:3001 にアクセスしてください。「無効な SSL 証明書」の問題が発生した場合は「続行」をクリックします。 Experience Builder で [新規作成] をクリックして新しいエクスペリエンス ページを作成します。 [空白のスクロール] の [作成] ボタンをクリックします。 [ウィジェットの挿入] パネルが開きます。そこから、マップ ウィジェットと新しく作成した「Get Map Coordinates」ウィジェットをエクスペリエンスにドラッグします。 作成したウィジェットには無効を示すアイコンが表示されているかもしれませんが、まだアイコンを作成していないため、それは問題ありません。 ウィジェットの設定パネルで、マップを選択するドロップダウンから「Map」を選択します。 Experience Builder のツールバーで [保存] をクリックし、[プレビュー] をクリックすると、カスタム ウィジェットとマップを含むエクスペリエンスが新しいブラウザー タブで開きます。マップ上にマウスを移動させると、カーソルの位置の緯度と経度が表示されます。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/extension-points/",
	"title": "拡張ポイント（Extension points）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Extension points\n拡張ポイント（Extension points） Jimu ライブラリーを使用すると、ArcGIS Experience Builder を拡張することができます。多くの場合、カスタム ウィジェットやテーマを作成することで Experience Builder を拡張します。また、Jimu エクステンションにより、より深いカスタマイズを行うことができます。\nJimu ライブラリーでは、特定の拡張ポイントが定義されています。拡張ポイントとは、エクステンションが準拠すべきインターフェイスを定義したものです。エクステンションとは、拡張ポイントのインターフェイスを実装したクラスのことです。このインターフェイスは、jimu-core からエクスポートされた extensionSpec です。ウィジェットでエクステンションを提供するには、ウィジェットの manifest.json ファイルでエクステンションを宣言する必要があります。\n\u0026#34;extensions\u0026#34;: [ { \u0026#34;point\u0026#34;: \u0026#34;\u0026lt;拡張ポイント名\u0026gt;\u0026#34;, \u0026#34;uri\u0026#34;: \u0026#34;\u0026lt;拡張される URI、関連するソース フォルダー\u0026gt;\u0026#34; } ] Jimu では、API ドキュメントで定義されている様々な拡張ポイントが定義されています。よく使われる拡張ポイントは以下の 2 つです。\n  AppConfigProcessor - この拡張ポイントのエクステンションは、AppConfig を受け取り、処理された app config を解決するプロミスを返す必要があります。これは、文字列の翻訳（Translation サンプルを参照）のように、app config を実行時に修正するために使用できます。この処理は、app config がロードされた直後に起動されます。\n  DependencyDefine - この拡張機能を使用すると、初期化が必要なサード パーティーのライブラリーを使用できます。\n  ReduxStore - この拡張機能を使用すると、ウィジェットの Redux 状態の actions と reducers を定義できます。\n  サンプル 拡張機能の作成例として、Translation サンプルをご紹介します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/appconfig/",
	"title": "AppConfig",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - AppConfig\nAppConfig とは ArcGIS Experience Builder における AppConfig オブジェクトは、エクスペリエンスの構成を定義する JSON ベースの設定ファイルです。アプリケーションの動作、レイアウト、外観、データ接続などを定義するための、すべての重要な設定や要素が含まれています。これには、ページ、レイアウト、ウィジェット、データ ソースなどを管理するためのプロパティも含まれます。\nAppConfig は、エクスペリエンスに関連するすべての設定のリポジトリーとして機能し、開発者がアプリケーションを簡単に、管理、カスタマイズできるようにします。新しいエクスペリエンスが初期化されると作成され、アプリケーションの state の appConfig プロパティに保存されます。\nAppConfig を更新する方法 AppConfig はイミュータブル (不変) なオブジェクトです。設定値を更新するには、更新された設定を含む新しい appConfig インスタンスをプログラムで作成する必要があります。\n以下は、ウィジェットの実行時に jimu-core ライブラリーを使用して appConfig を更新する方法の例です。プログラムで appConfigChanged() アクションを割り当てることで、appConfig を更新できます。\nimport { appActions, ReactRedux } from \u0026#34;jimu-core\u0026#34; // get the appConfig const appConfig = ReactRedux.useSelector((state: IMState) =\u0026gt; state.appConfig) // modify the appConfig const newAppConfig = appConfig.setIn([\u0026#34;pages\u0026#34;, pageId, \u0026#34;label\u0026#34;], theNewLabel) dispatch(appActions.appConfigChanged(newAppConfig)) appConfig を更新する最も一般的な方法は、ウィジェット構成画面でウィジェットの設定を更新することです。このとき、プログラムで props.onSettingChange() を呼び出します。この関数はウィジェット設定の変更をハンドリングし、パラメーターとしてウィジェットの ID と新しいウィジェットの config を含むオブジェクトを受け取ります。\nprops.onSettingChange({ id: widgetId, config: newWidgetConfig }) AppConfig の構造 AppConfig オブジェクトは、エクスペリエンス全体の構造と動作を定義する包括的な JSON ベースの構成ファイルです。主なプロパティには以下のようなものがあります。\n   プロパティ 説明     dataSources エクスペリエンス内で使用されるすべてのデータ ソースの指定   layouts エクスペリエンスで使用されるレイアウトの定義   pages エクスペリエンス内のすべてのページの設定   theme エクスペリエンスに適用されるテーマの URI   views エクスペリエンス内のビューの設定   widgets すべてのウィジェット設定    以下は、基本的な AppConfig の構造の例です。\n{ \u0026#34;connections\u0026#34;: [], \u0026#34;controllerPanels\u0026#34;: [], \u0026#34;dataSources\u0026#34;: {}, \u0026#34;dialogs\u0026#34;: {}, \u0026#34;exbVersion\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;footer\u0026#34;: {}, \u0026#34;forBuilderAttributes\u0026#34;: {}, \u0026#34;header\u0026#34;: {}, \u0026#34;historyLabels\u0026#34;: {}, \u0026#34;layouts\u0026#34;: {}, \u0026#34;mainSizeMode\u0026#34;: \u0026#34;desktop\u0026#34;, \u0026#34;messageConfigs\u0026#34;: {}, \u0026#34;name\u0026#34;: \u0026#34;My Experience\u0026#34;, \u0026#34;originExbVersion\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;pages\u0026#34;: [], \u0026#34;pageStructure\u0026#34;: {}, \u0026#34;preloadWidgets\u0026#34;: [], \u0026#34;publishTimestamp\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;screenGroups\u0026#34;: [], \u0026#34;screens\u0026#34;: [], \u0026#34;sections\u0026#34;: {}, \u0026#34;template\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;theme\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;useAutoSortInFixedLayout\u0026#34;: true, \u0026#34;useCachedManifest\u0026#34;: true, \u0026#34;views\u0026#34;: [], \u0026#34;widgets\u0026#34;: {}, \u0026#34;widgetsManifest\u0026#34;: {} } AppConfig オブジェクトのプロパティや構造についての詳細は、AppConfig API ドキュメントをご参照ください。\n\rドラフト版と公開版 ArcGIS Experience Builder では、AppConfig オブジェクトはエクスペリエンスのドラフト版と公開版の両方を管理するために使用されます。ドラフト版は通常、アプリ作成者が変更を加える作業用のバージョンであり、公開版はユーザーが操作する最終バージョンです。\nArcGIS Online および ArcGIS Enterprise では、AppConfig のドラフト版はアプリ アイテムのリソースに保存され、公開版はアイテム データに保存されます。これにより、アプリ作成者は実行環境に影響を与えることなく変更作業を行い、準備が整った段階で公開することができます。\nExperience Builder Developer Edition ではドラフト版は public/apps/\u0026lt;appid\u0026gt;/resources/config/config.json ファイルに保存され、公開版は public/apps/\u0026lt;appid\u0026gt;/config.json ファイルに保存されます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/migrating-from-web-appbuilder/",
	"title": "Web AppBuilder からの移行",
	"tags": [],
	"description": "Web AppBuilder から ArcGIS Experience Builder (Developer Edition) への移行方法について説明しています。",
	"content": "出典：ArcGIS Experience Builder - Guide - migrating-from-web-appbuilder\nはじめに ArcGIS Experience Builder は、Web AppBuilder とはさまざまな点で異なります。これらの違いから、Web AppBuilder から Experience Builder へカスタム ウィジェットやテーマを直接変換することはできません。手動のプロセスですが、Experience Builder 用にウィジェットやテーマを再構築する際に考慮すべきヒント、テクニック、および推奨プラクティスを紹介します。\nこれは網羅的なものではありませんし、開発者が手動で書き直す作業であることに変わりはありません。これらの手順は、Experience Builder 内でウィジェットを再ビルドする際の準備と計画に役立つように提供されます。\n\rスタートアップ まず、Experience Builder のドキュメントを確認し、ウィジェット開発のスタート ドキュメントに従って TypeScript、React、JSX、Jimu を学びます。\nウィジェットの新規作成 コア技術の概念に慣れたら、ブランク/スターターの Experience Builder のウィジェットを作成し、ビルド環境が正しく設定されていることを確認します。次に、Web AppBuilder のカスタム ウィジェットから新しい Experience Builder のカスタム ウィジェットにコードを移動し、次の点に注意してください。\n  どちらのウィジェットにも manifest.json がありますが、Experience Builder のものは若干異なりますので、新しい manifest.json の形式を確認し、適宜更新してください。\n  dojo 固有のモジュールはすべて置き換える必要があります。 - たとえば、dojo/domClass モジュールの domClass 関数を次のように使用する場合\ndomClass.contains(domNode, \u0026#34;myClassName\u0026#34;); この場合、Dojo 以外の選択肢でそれを書き直す必要があります。\ndomNode.classList.contains(\u0026#34;myClassName\u0026#34;);   Dojo はブラウザのサポートを標準化してくれますが、ネイティブの JavaScript の機能を使うことはできませんので、MDN や CanIUse などのサイトで、使用する機能のブラウザ サポートを確認する必要があります。この場合、例えば CanIUse によると、classList はすべての主要なブラウザでサポートされていると述べています。\n\r ウィジェットのライフサイクル メソッドは、同じようには動作しません。一般的に、ウィジェット起動時に発生するウィジェットのライフサイクル メソッド (constructor、postMixinProperties、buildRendering、postCreate) は、おそらく componentDidMount() 関数(またはフックを使用する場合は同等の useEffect())に移動できます。\n  今まで widget.html にあったテンプレートは、Experience Builder のカスタムウィジェット (React コンポーネント) の render() 関数で JSX に変換されるようになります。\n DOM ノードに data-dojo-attach-point で名前を付けている場合、React でそれに相当するものは Refs です。 国際化/翻訳に NLS を使用している場合、テンプレート（例：\u0026lt;div\u0026gt;${nls.label1}.\u0026lt;/div\u0026gt; では、「translations folder」パターンを使用するようになります）。    Map/Scene オブジェクトへのアクセス - this.map を使用している場合、Experience Builder では 1 つのエクスペリエンスに複数のマップまたはシーンを持つことができるようになったため、このパターンはまったく同じようには動作しません（Web AppBuilder アプリごとに 1 つのマップしか持つことができませんでした）。MapWidgetSelector と JimuMapViewComponent を参照してください。\n  カスタム設定パネル（/setting フォルダ内）がある場合、それに相当するのは Experience Builder カスタムウィジェットの src/setting 内です。設定 UI の作成に関する詳細情報\n  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/deployment/experience-deployment/",
	"title": "デプロイ",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) で作成したアプリケーションをダウンロードし、独自のサーバーにホストする手順を紹介します。",
	"content": "ArcGIS Experience Builder で作成したエクスペリエンスは、ダウンロードして Web サーバーにホストすることができます。プライベート コンテンツを使用しているエクスペリエンスは、ArcGIS Online または ArcGIS Enterprise にアプリを登録する必要があります。エンド ユーザーに最適なユーザー エクスペリエンスを提供するために、エクスペリエンスを展開する前にシステム要件を参照してください。\nエクスペリエンスのダウンロード エクスペリエンス ギャラリーのホームページでエクスペリエンスをダウンロードするには、以下のように ● (3 つのドット) をクリックして ダウンロード をクリックします。ZIP ファイルが作成され、ローカル ドライブにダウンロードされます。ZIP ファイルは、お使いのブラウザ用に定義されたダウンロード ディレクトリにあります。\nアプリケーションをダウンロードするには事前にアプリケーションを公開する必要があります。ダウンロードされたエクスペリエンスには Web サーバーのいくつかのデフォルトの設定を構成する web.config ファイルが付属しており、このデフォルト web.config に ArcGIS Maps SDK for JavaScript の設定が含まれるようになりました。\nダウンロードに失敗した場合は、お使いのマシンでアンチウイルス ソフトがオンになっているか確認してください。アンチウイルス ソフトをオフにして、もう一度試してください。\n\rエクスペリエンスのデプロイ エクスペリエンスを Web サーバーにデプロイするには、次の手順を実行します。\n ダウンロードしたエクスペリエンスを解凍し、フォルダーを Web サーバーにコピーします。 アプリにプライベート コンテンツがある場合は、手順 3 ～ 6 を完了し、そうでない場合はエクスペリエンスのデプロイは完了です。 アプリを追加して登録します。詳細については、ArcGIS Online/ArcGIS Enterprise を使用した Client ID の作成 を参照してください。 AppID をコピーし、Experience アプリのルート ディレクトリ (例：\u0026lt;.zip ファイル ルート\u0026gt;\\cdn\\0\\config.json) にある config.json ファイルを開きます。 attributes オブジェクトの下に clientId プロパティを作成します。 config.json ファイルの clientId プロパティに AppID を貼り付けます。再度ファイルを保存します。  \u0026#34;attributes\u0026#34;: { \u0026#34;portalUrl\u0026#34;: \u0026#34;https://exb.maps.arcgis.com\u0026#34;, \u0026#34;clientId\u0026#34;: \u0026#34;EXBAPPsag0XSRtpj\u0026#34; }, server/app name/index.html にアクセスすることでアプリを利用することができます。\nデプロイの自動化 Experience Builder サーバーを実行せずにターミナルからアプリの ZIP エクスポートを自動で生成するには、zipApp コマンドを使用します。これは自動デプロイのための DevOps ワークフローでよく使用されます。\nターミナルで Experience Builder (Developer Edition) がインストールされた解凍済みのルート ディレクトリ (\u0026ldquo;client\u0026rdquo; フォルダーと \u0026ldquo;server\u0026rdquo; フォルダーが含まれるディレクトリ) を参照し、次のコマンドを実行します。\nnode -e \u0026#34;require(\u0026#39;./server/src/middlewares/dev/apps/app-download.js\u0026#39;).zipApp(\u0026#39;0\u0026#39;, \u0026#39;app.zip\u0026#39;, \u0026#39;my_client_id\u0026#39;);\u0026#34;  \u0026lsquo;0\u0026rsquo; はエクスポートしたいアプリの ID に置き換えてください。 \u0026lsquo;app.zip\u0026rsquo; は生成したい ZIP ファイルの名前に置き換えてください。 my_client_id を ArcGIS Online または ArcGIS Enterprise の有効な AppID で置き換えます。詳細については、ArcGIS Online/ArcGIS Enterprise を使用した Client ID の作成 を参照してください。 環境変数 NODE_ENV が production に設定されていることを確認し、最小化された (より小さな) ファイルを生成する production ビルドを作成します。  バージョン 1.15 から、zipApp 関数はオプションの第 4 パラメーターをサポートします。このパラメーターは、locales または configModifier のプロパティを持つオブジェクトです。\n locales プロパティは、エクスポートするロケールを指定するために使用できます。これが設定されていない場合、すべてのロケールがエクスポートされます。 configModifier プロパティは、アプリをエクスポートする前に config.json ファイルを変更するために使用できます。これは関数またはオブジェクトを指定できます。  関数の場合、config オブジェクトを引数として呼び出され、変更された config オブジェクトが返されます。 オブジェクトである場合、以下の例のように更新値を指定することができます。    {\rconfigModifier: {\r'attributes.portalUrl': 'new-portal-url'\r}\r}\rdownload-app.js ファイルには、さらに多くの例があります。\nサービス ワーカー キャッシュ Experience Builder ではサービス ワーカーを使用してアセットのキャッシュ先読みし、アプリケーションのロード時間を改善します。デプロイ済みのアプリケーションのソース コード、config.json、またはその他の変更の更新が必要な場合は、Experience Builder (Developer Edition) で更新を行い、アプリケーションを再ダウンロードしてデプロイできます。ただし、ダウンロード パッケージを直接更新する必要がある場合は、次の手順を実行してサービス ワーカー キャッシュを更新する必要があります。\n app ディレクトリで、cdn/0 を cdn/1 にリネームします。 アプリに必要なソース コードの修正や変更を行います。 アプリケーションのルート フォルダーで index.html を開きます。  \u0026lt;base href=\u0026quot;./cdn/0/\u0026quot;/\u0026gt; を \u0026lt;base href=\u0026quot;./cdn/1/\u0026quot;/\u0026gt; に変更します。 buildNumber = '0' を buildNumber = '1' に変更します。    より良いパフォーマンスのためのキャッシュ ヘッダーの推奨設定は以下のとおりです。\n index.html を 1 分など非常に短い期間キャッシュするか、キャッシュしない。 cdn フォルダーを 1 年間など長期間キャッシュする。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/tutorials/add-layers-to-a-map/",
	"title": "マップにレイヤーを追加",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) のチュートリアルとして、カスタム ウィジェットでマップにレイヤーを追加する方法を学びます。",
	"content": "出典：ArcGIS Experience Builder - Tutorials - Add layers to a map\n概要 学習内容：カスタムウィジェットからマップにレイヤーを追加する方法\nArcGIS Experience Builder のマップ ウィジェットは、ロードするように構成されている Web マップに基づいてレイヤーを自動的にロードします。ワークフローによっては、ウィジェットとのユーザー インタラクションに基づいてマップに動的にレイヤーを追加するカスタム ウィジェットが必要な場合があります。\nこのチュートリアルでは、マップにフィーチャ レイヤーを追加するためのボタンをウィジェットに追加します。\n前提条件  ArcGIS Experience Builder のインストール ガイドを参照して、 ArcGIS Experience Builder (Developer Edition) をダウンロード、インストール、設定を行います。  ステップ スターター ウィジェットの取得   スターター ウィジェットのテンプレートをこちらからダウンロードします。 すでにスターター ウィジェットの作成チュートリアルを完了している場合は、それを使用して開始できます。client/your-extensions/widgets 内のウィジェット フォルダーをコピーしてください。\n  手順 1 でテンプレートをダウンロードした場合は ArcGIS Experience Builder フォルダー内で、zip ファイルを以下のパスに展開してください。\n/client/your-extensions/widgets\n  ウィジェット名の変更  ArcGIS Experience Builder の client フォルダーで npm start が実行されたターミナルがある場合、ctrl + c を押してスクリプトを停止します。 ファイル ブラウザーで、Experience Builder を展開されたフォルダーに移動します。 Experience Builder フォルダーで、以下のパスを展開します。\n/client/your-extensions/widgets widgets フォルダー内で starter-widget フォルダーの名前を add-layers-to-a-map に変更します。 新しく名前を変更した add-layers-to-a-map フォルダーの、manifest.json ファイルをコード エディターで開きます。 コード エディターで、name プロパティを add-layers-to-a-map に変更します。\nmanifest.json の name プロパティがウィジェットのフォルダー名と一致することが重要です。この時点で、ウィジェットの説明、作成者など manifest.json ファイル内の他のメタデータも更新できます。  { // *** 更新 *** // \u0026#34;name\u0026#34;: \u0026#34;starter-widget\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;add-layers-to-a-map\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;widget\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.17.0\u0026#34;, manifest.json の version プロパティの後に、jimu-arcgis の依存関係を追加します。 これを宣言することで、ウィジェット内で ArcGIS Maps SDK for JavaScript モジュールを使用できるようになります。  { \u0026#34;name\u0026#34;: \u0026#34;add-layers-to-a-map\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;widget\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.17.0\u0026#34;, // *** 追加 *** \u0026#34;dependency\u0026#34;: [\u0026#34;jimu-arcgis\u0026#34;], 設定パネルの実装 設定パネルを実装することで、エクスペリエンスの作成者がウィジェットをカスタマイズできるようになります。設定パネルは、ArcGIS Experience Builder でウィジェットが選択された時に右側のサイドバーに表示されます。パネルを作成するには、React コンポーネントを作成します。\n ウィジェットのルート フォルダーに、空のオブジェクトを含む config.json ファイルを作成します。\n後で、ウィジェットの設定値を保存するために、このオブジェクトにウィジェットの構成パラメーターを追加できます。  {} src フォルダーに、setting という名前のフォルダーを作成します。 setting フォルダー内に、setting.tsx ファイルを作成します。 setting/setting.tsx ファイルを開き、以下の import 文を記述します。  import { React } from \u0026#39;jimu-core\u0026#39; import { type AllWidgetSettingProps } from \u0026#39;jimu-for-builder\u0026#39; コンポーネントを実装するためのコードを追加します。  const Setting = (props: AllWidgetSettingProps\u0026lt;any\u0026gt;) =\u0026gt; { return \u0026lt;div className=\u0026#34;widget-setting-demo\u0026#34;\u0026gt;ここはスターター ウィジェットの設定パネルです\u0026lt;/div\u0026gt; } export default Setting ArcGIS Experience Builder の client フォルダーで npm start が実行されたターミナルがある場合、ctrl + c を押してスクリプトを停止します。その後、client フォルダーで npm start スクリプトを開始します。  マップ ビューのデータ ソースを選択できるようにする ArcGIS Experience Builder では、ページに複数のマップ ウィジェットを配置することができます。そのため、カスタム ウィジェットには、作成者が使用するマップ ウィジェットを選択するためのセクションが必要です。\n setting/setting.tsx ファイルに、jimu ライブラリから MapWidgetSelector モジュールを記述します。  import { MapWidgetSelector } from \u0026#39;jimu-ui/advanced/setting-components\u0026#39; コンポーネント内で onMapWidgetSelected 関数を定義します。  // *** 追加 *** const onMapWidgetSelected = (useMapWidgetIds: string[]) =\u0026gt; { props.onSettingChange({ id: props.id, useMapWidgetIds: useMapWidgetIds }) } return \u0026lt;div className=\u0026#34;widget-setting-demo\u0026#34;\u0026gt;ここはスターター ウィジェットの設定パネルです\u0026lt;/div\u0026gt;; return() 文内に、MapWidgetSelector を表すタグを追加します。  return ( \u0026lt;div className=\u0026#34;widget-setting-demo\u0026#34;\u0026gt; \u0026lt;MapWidgetSelector useMapWidgetIds={props.useMapWidgetIds} onSelect={onMapWidgetSelected} /\u0026gt; \u0026lt;/div\u0026gt; ) マップにアクセスする これまでのステップでは、設定パネルに機能を追加し、マップ ウィジェットを選択できるようになりました。Map オブジェクトは JimuMapViewComponent を使用してアクセスできます。\n widget.tsx ファイルに、jimu-arcgis ライブラリから JimuMapViewComponent と JimuMapView の型を追加し、React 変数をデストラクチャリング (分割代入) して getState import にアクセスします。  import { React, type AllWidgetProps } from \u0026#39;jimu-core\u0026#39; /** 追加 **/ import { JimuMapViewComponent, type JimuMapView } from \u0026#39;jimu-arcgis\u0026#39; const { useState } = React レイヤーをマップに追加するには、マップへの参照をコンポーネントの状態を保存する必要があります。これにはコンポーネント内で、useState() を使用し state として保存できるように設定します。  const { useState } = React const Widget = (props: AllWidgetProps\u0026lt;any\u0026gt;) =\u0026gt; { // *** 追加 ***//  const [jimuMapView, setJimuMapView] = useState\u0026lt;JimuMapView\u0026gt;() return ( return 文で、JimuMapViewComponent を JSX マークアップに追加します。\n追加されたコードの最初の 2 行 ({props.useMapWidgetIds \u0026amp;\u0026amp;...)は、JSX で条件を使用する方法です。これは基本的に「エクスペリエンス作成者が設定パネルで有効なマップ ウィジェットを選択した場合にのみ JimuMapViewComponent を追加する」という意味です。  return ( \u0026lt;div className=\u0026#34;widget-starter jimu-widget\u0026#34;\u0026gt; {props.useMapWidgetIds \u0026amp;\u0026amp; props.useMapWidgetIds.length === 1 \u0026amp;\u0026amp; ( \u0026lt;JimuMapViewComponent useMapWidgetId={props.useMapWidgetIds?.[0]} onActiveViewChange={activeViewChangeHandler} /\u0026gt; )} \u0026lt;/div\u0026gt; ) setState コマンドのすぐ下に activeViewChangeHandler 関数を定義します。 この関数は、マップの準備ができたときに一度だけ呼び出され、この関数で jimuMapView の状態を更新します。  /** 追加 **/ const activeViewChangeHandler = (jmv: JimuMapView) =\u0026gt; { if (jmv) { setJimuMapView(jmv) } } ボタンの追加 クリックするとレイヤーをマップに追加するボタンをウィジェットの UI に追加します。\n コード エディターで、render 関数内の既存の div に form と input タグ要素を追加します。  return ( \u0026lt;div className=\u0026#34;widget-starter jimu-widget\u0026#34;\u0026gt; {props.useMapWidgetIds \u0026amp;\u0026amp; props.useMapWidgetIds.length === 1 \u0026amp;\u0026amp; ( \u0026lt;JimuMapViewComponent useMapWidgetId={props.useMapWidgetIds?.[0]} onActiveViewChange={activeViewChangeHandler} /\u0026gt; )} {/* *** ADD: *** */} \u0026lt;form onSubmit={formSubmit}\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button\u0026gt;Add Layer\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; ) コンポーネント内で、formSubmit という名前の新しい関数を作成します。 この関数はユーザーが Add Layer ボタンをクリックした時に呼び出されます。\nevt.preventDefault は、フォームが送信された際にページをリロードしないようにします。  レイヤーの追加 ボタンをクリックしたとき、マップにレイヤーを追加します。\n widget.tsx ファイルの先頭で、 FeatureLayer クラスをインポートします。  import FeatureLayer from \u0026#39;esri/layers/FeatureLayer\u0026#39; formSubmit 関数の内に、Trailheads（ポイント）のフィーチャ レイヤーを作成し、そのレイヤーをマップに追加するコードを追加します。\njimuMapView.view は MapView のインスタンスのため、ここで使用する add() メソッドのように、MapView で定義されているメソッドやプロパティも使うことができます。  const formSubmit = (evt) =\u0026gt; { evt.preventDefault() // *** 追加 ***  // 新しい FeatureLayer を作成  const layer = new FeatureLayer({ url: \u0026#39;https://services3.arcgis.com/GVgbJbqm8hXASVYi/arcgis/rest/services/Trailheads_Styled/FeatureServer/0\u0026#39; }) // マップにレイヤーを追加 (Experience Builder の JimuMapView データ・ソースからアクセスできます。)  jimuMapView.view.map.add(layer) } ウィジェットのテスト コードの変更が完了したら、ArcGIS Experience Builder を実行してエクスペリエンスを表示することでウィジェットをテストできます。\n Web ブラウザーで、Experience Builder にアクセスします。\n例：https://localhost:3001\nExperience Builder タブが開かなかった場合は、https://localhost:3001 にアクセスしてください。「無効な SSL 証明書」の問題が発生した場合は「続行」をクリックします。 Experience Builder で [新規作成] をクリックして新しいエクスペリエンス ページを作成します。 [空白のスクロール] の [作成] ボタンをクリックします。  [ウィジェットの挿入] ボタンをクリックし、マップ ウィジェットをエクスペリエンスにドラッグします。 [プレビュー エリア]のマップ ウィジェットをクリックし、[ウィジェット設定パネル]の[マップの選択]をクリックします。 [データの選択パネル]の[新しいデータの追加]ボタンをクリックします。 [データの追加]モーダルで、[ArcGIS Online] タブを選択し、Web マップの eb1be6543e304b4d81ed55439c412c2c を検索します。検索結果をクリックして選択し、[終了]をクリックします。 (この Web マップには意図的に操作するレイヤーがないことに注意してください。) [Select data パネル]に新しく追加された [LA Parks and Trails Map] をクリックして、Web マップを選択してください。   [ウィジェットの挿入] パネルが開きます。そこから、新しく作成した [add layers to a map]ウィジェットをエクスペリエンスにドラッグします。\n作成したウィジェットには無効を示すアイコンが表示されているかもしれませんが、まだアイコンを作成していないため、それは問題ありません。 ウィジェットの設定パネルで、マップを選択するドロップダウンから「Map」を選択します。 Experience Builder のツールバーで [保存] をクリックし、[プレビュー] をクリックすると、カスタム ウィジェットとマップを含むエクスペリエンスが新しいブラウザー タブで開きます。[Add Layer]ボタンをクリックするとレイヤーをマップに追加されます。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/deployment/widget-and-theme-deployment/",
	"title": "ウィジェットとテーマのデプロイ",
	"tags": [],
	"description": "カスタム ウィジェットとカスタム テーマのデプロイについて紹介しています",
	"content": "ウィジェットとテーマのデプロイ ウィジェットのデプロイ カスタム ウィジェットを配置できる場所は以下の 2 つあります。\n ArcGIS Experience Builder Developer Edition ArcGIS Enterprise 版 ArcGIS Experience Builder  これらの場所にデプロイするガイドラインはこちらになります。\n開発者向けエディション ArcGIS Experience Builder アプリケーション内でカスタム ウィジェットとテーマをデプロイするには、まずエクスペリエンスをダウンロードし、そのエクスペリエンスを Web サーバーにデプロイします。デプロイに関する詳細な手順は、エクスペリエンスのデプロイページをご参照ください。\nArcGIS Enterprise エディション ArcGIS Enterprise にカスタム ウィジェットをホストすることで、ArcGIS Enterprise 内で直接作成されたエクスペリエンスまたは Developer Edition（同 ArcGIS Enterprise 環境に接続されているもの）経由で作成されたエクスペリエンスが、カスタム ウィジェットを使用できるようになります。ArcGIS Enterprise 内にカスタム ウィジェットをホストするには、カスタムウィジェットの追加 ページをご覧ください。このパターンでサポートされている ArcGIS Enterprise のバージョンは 11.0 以降です。\nテーマのデプロイ 現在、カスタムテーマは Developer Editon にのみデプロイ可能です。テーマの開発に関する詳細情報は、Theme developementページをご確認ください。\nArcGIS Online 版について ArcGIS Online へのカスタム ウィジェットとテーマのデプロイは、現在サポートされていません。\n考慮事項 カスタム ウィジェットとテーマをデプロイする適切な場所は、ご自身の目標と ArcGIS infrastructure によって異なります。これらの点を考慮し、ArcGIS Experience Builder の開発を開始する前にデプロイメント プランを作成することをおすすめします。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/create-startup-app-wab/",
	"title": "スタートアップ ガイド",
	"tags": [],
	"description": "",
	"content": "ArcGIS Web AppBuilder とは？ ArcGIS Web AppBuilder（以下、Web AppBuilder）は、コーディング不要、インタラクティブな操作で Web アプリを作成可能なアプリケーション ビルダーです。\nWeb AppBuilder は、Web マップと呼ばれる、さまざまなデータを地図上に重ね合わせ、表示スタイルやポップアップを定義したマップをもとにアプリを作成します。\nアプリの外観を決めるテーマと、機能を提供するウィジェットを選択していくことで、独自のアプリを作成していきます。\nWeb アプリの作成   Web マップの作成\nハッカソン向け資料 - 地図にデータを可視化する を参考に、アプリで使用する Web マップを作成します。\n  Web AppBuilder の起動\n作成した Web マップを保存したら、[共有] をクリックします。[Web アプリの作成] から [Web AppBuilder] を選択、[開始] をクリックして Web AppBuilder を起動します。   テーマの選択\nアプリの外観は、テーマと呼ばれるテンプレートによって決められます。テーマには、色を設定するスタイルや、ウィジェットの配置を定義するレイアウトなどが含まれます。\n  ウィジェットの追加\nアプリの機能は、ウィジェットを選択することで追加していきます。追加したい機能を持つウィジェットを選択して、アプリ固有の設定は構成パネルで決めます。ウィジェットを組み合わせることで、さまざまな目的に適したアプリを作成することができます。   アプリの保存、起動\nアプリを作成できたら保存して起動してみましょう。   ArcGIS Web AppBuilder (Developer Edition) ポータルサイトに組み込まれた Web AppBuilder を利用してアプリを作成するほかに、開発者向けに Developer Edition が提供されています。\nDeveloper Edition は、テーマやウィジェットを開発可能で、Web AppBuilder に独自の機能を追加することができます。 Web AppBuilder が提供するテーマやウィジェットを活用したアプリを作成できるので、コストを抑えたアプリ開発を実現します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/arcade/",
	"title": "Arcade",
	"tags": [],
	"description": "ArcGIS プラットフォーム標準で利用できる条件式のためのスクリプト言語 Arcade について紹介します。",
	"content": "出典：ArcGIS Maps SDK for JavaScript - Arcade\nArcade とは ArcGIS プラットフォームで使用するために作られた軽量でセキュアな条件式のためのスクリプト言語です。 他の一般的な式言語のように、数学的な計算や評価ロジックの命令語を利用できます。 ArcGIS プラットフォームにおける独自のデータ可視化とラベル表現の作成のためにデザインされており、独自の命令語を ArcGIS Pro や ArcGIS Online、ArcGIS Runtime SDK、ArcGIS Maps SDK for JavaScript で編集・共有・実行することができます。\nArcade が他のスクリプト言語に比べてユニークなのは、ジオメトリ関数を含んでいるところです。 ジオメトリ関数は、面積や長さの計算、トポロジ リレーションシップのテスト、そしてシンプルなオーバーレイの実行を可能にします。 現在のリリースでは、ジオメトリの作成と参照が可能です。 しかし、Arcade バージョン 1.3 で導入されたジオメトリの操作は、4.x 系の ArcGIS Maps SDK for JavaScript ではサポートされていません。\nArcade バージョン 1.3 で導入されたジオメトリ関数は、4.x 系の ArcGIS Maps SDK for JavaScript ではサポートされていません。3.x 系の API では、バージョン 3.23 以上で使用できます。将来的には、4.x でのサポートを予定しています。\nシンタックス Arcade のシンタックスは JavaScript ライクに変数の宣言やロジックの実行、関数の記述などができます。 しかし、二つの言語間にはいくつか異なる部分があります。 記述方法の詳細については、Arcade ドキュメント（英語）をご参照ください。 また、ArcGIS Arcade Playground では独自のスクリプトをテスト実行するための環境を提供していますので、アクセスしてみてください。\nArcade には外部データにアクセスするためのグローバル変数が用意されています。 $feature というグローバル変数は、フィーチャ レイヤー内のフィーチャが持つフィールド値にアクセスするために使用します。 以下のシンタックスを使用することでフィールド値を参照できます。\n$feature.fieldName このように、ランタイムでフィールド値を使用したシンプルな計算を容易に実行できます。\n// 民主党候補者に投票した人の割合（%）を計算 ($feature.DEM_VOTES / $feature.TURNOUT ) * 100 Arcade はコンテクスト内、または Arcade が理解されるプロファイル内でのみ実行可能です。JavaScript アプリでは、式は常に文字列の値として参照されます。Arcade は、シンプルな一行の式、または、より複雑な複数行からなる式として書かれます。\n一行の式を書くとき、シンプルにダブルまたはシングル クォーテーションで囲みます。\nrenderer.valueExpression = \u0026#34;Round( ($feature.AGE_18UP / $feature.TOTAL_POP) * 100 )\u0026#34;; 複数行に渡る式を書くとき、JavaScript の外に \u0026lt;script\u0026gt; タグを分け、タイプを text/plain に設定し、JavaScript から参照できるようユニークな ID を付与して配置することが推奨されます。\n\u0026lt;script type=\u0026#34;text/plain\u0026#34; id=\u0026#34;adult-population\u0026#34;\u0026gt; // 複数行の式を記述 \u0026lt;/script\u0026gt; そして、JavaScript は、document.getElementById() メソッドを呼ぶことで、文字列として参照します。\nrenderer.valueExpression = document.getElementById(\u0026#34;adult-population\u0026#34;).text; 下記のスニペットや Create a custom visualization using an Arcade expression サンプルを参照ください。\nプロファイル Arcade はいくつかのプロファイルにおける使用のためにデザインされました。プロファイルとは、理解し使用される命令語のコンテクストです。ArcGIS API 4.5 for JavaScript では、ビジュアライゼーション、ポップアップ、ラベリング（3D のみサポート）の３つのプロファイルをサポートしています。3D では、Arcade を使用することにより、フィーチャの標高を計算することも可能です。\nビジュアライゼーション ビジュアライゼーション プロファイルにおいて、Arcade を使ってランタイムで FeatureLayer (フィーチャ レイヤー) あるいは SceneLayer (シーン レイヤー) 内の各フィーチャが持つ値を計算することができます。 また、データドリブンな可視化のための基盤として、それらの値を使用することができます。 これは、レイヤー内の単一フィールド値をもとにしたデータ ビジュアライゼーションを作成するための別のアプローチになります。 これによって、Arcade 命令語は field/normarizationField あるいは JavaScript 関数の代わりに ClassBreaksRenderer (数値分類) や UniqueValueRenderer (個別値分類)、その他の可視化変数 (color, size, opacity, rotation) の valueExpression プロパティに渡されます。\nArcade は FeatureLayer と SceneLayer におけるビジュアライゼーションの作成のみサポートします。 ClassBreaks と UniqueValueRenderer を利用できる他のレイヤー (例えば、MapImageLayer) は Arcade をサポートしていません。\nClassBreaksRenderer あるいはその他の可視化変数を使用する際、命令語は必ず数値を評価してください。 UniqueValueRenderer は文字列と数値のいずれも評価して構いません。\n以下の例では、Arcade 命令語が UniqueValueRenderer の valueExpression プロパティを使用しています。 アメリカの州を表すフィーチャ レイヤーのためにビジュアライゼーションを作成します。 このサービスは各州における共和党、民主党、無所属に対する得票数という 3 つのフィールドを持ちます。 そこで、得票数で勝った党を各州で可視化したいとします。 サービスには優勢な党を示すフィールドが含まれていません。 したがって、Arcade を使ってその党を明らかにしましょう。\n// まず、各フィールドの属性値の参照と変数宣言を記述しています。 // Max() 関数を使って最大数を算出し、 // 最大数を持つ党を判定するために Decode() 関数を使います。  var arcade = \u0026#34;var republican = $feature.MP06025a_B;\u0026#34; + \u0026#34;var democrat = $feature.MP06024a_B;\u0026#34; + \u0026#34;var independent = $feature.MP06026a_B;\u0026#34; + \u0026#34;var parties = [republican, democrat, independent];\u0026#34; // Decode() と Max() は Arcade 組み込みの関数です。  + \u0026#34;Decode( Max(parties),\u0026#34; + \u0026#34; republican, \u0026#39;republican\u0026#39;,\u0026#34; + \u0026#34; democrat, \u0026#39;democrat\u0026#39;,\u0026#34; + \u0026#34; independent, \u0026#39;independent\u0026#39;,\u0026#34; + \u0026#34; \u0026#39;n/a\u0026#39;);\u0026#34;; // `valueExpression` プロパティに Arcade で記述した式を割り当て、 // Decode() で処理された値をもとに個別値の情報を設定します。  var renderer = new UniqueValueRenderer({ valueExpression: arcade, valueExpressionTitle: \u0026#34;Counties by dominant party among registered voters\u0026#34;, uniqueValueInfos: [{ value: \u0026#34;democrat\u0026#34;, symbol: createSymbol(\u0026#34;#00c3ff\u0026#34;), label: \u0026#34;Democrat\u0026#34; }, { value: \u0026#34;republican\u0026#34;, symbol: createSymbol(\u0026#34;#ff002e\u0026#34;), label: \u0026#34;Republican\u0026#34; }, { value: \u0026#34;independent\u0026#34;, symbol: createSymbol(\u0026#34;#faff00\u0026#34;), label: \u0026#34;Independent/non-affiliated\u0026#34; }] }); また、各州における優勢な党の相対的な力を示すために renderer に対して opacity の可視化変数を追加します。 より多くの人々が特定の党に投票している州を高い透過率でし、各党に対する得票数が拮抗している州は低い透過率で描画してみましょう。\n// まず、各フィールドの属性値の参照と変数宣言を記述しています。 // Max() 関数を使って最大数を、 // Sum() 関数ですべての党の得票数の合計値を算出します。 // 合計値に対するもっとも多くの投票を得た党の得票数の割合をパーセントで返します。  var opacityArcade = \u0026#34;var republican = $feature.MP06025a_B;\u0026#34; + \u0026#34;var democrat = $feature.MP06024a_B;\u0026#34; + \u0026#34;var independent = $feature.MP06026a_B;\u0026#34; + \u0026#34;var parties = [republican, democrat, independent];\u0026#34; + \u0026#34;var total = Sum(parties);\u0026#34; + \u0026#34;var max = Max(parties);\u0026#34; + \u0026#34;return (max / total) * 100;\u0026#34;; // `valueExpression` プロパティに Arcade で記述した式を割り当て、 // 返り値であるパーセントに応じて透過率を設定します。  var opacityVV = { type: \u0026#34;opacity\u0026#34;, valueExpression: opacityArcade, stops: [ { value: 33, opacity: 0.1 }, { value: 50, opacity: 1.0 } ] }; // 先に作成したレンダラーに透過率による可視化変数を追加します。  renderer.visualVariables = [ opacityVV ]; 実際にビジュアライゼーションを行った結果はサンプル アプリ (Create a custom visualization using Arcade) で確認してみてください。\nポップアップ Arcadeを PopupTmplate のコンテンツ  内で参照することもできます。ビジュアライゼーション プロファイルと同様に、 FeatureLayer  インスタンスに属性値として存在しないデータを表示する場合に便利です。 例えば、サンプルアプリ （ Reference Arcade expressions in PopupTemplate ）では、各米国郡の労働統計を含むレイヤーを表示します。いくつかの属性には、失業率、人口、および労働人口が含まれます。労働参加率の属性は含まれていません。 Arcade を使用して、実行時に算出することができます。\n// 労働参加率を計算 Round(($feature.CIVLBFR_CY / $feature.POP_16UP)*100,2) この式から返された値を使用して、レイヤーを視覚化したり、レイヤーの PopupTmplate に表示したりすることができます。ポップアップで値を表示するには、PopupTmplate の expressioninfo プロパティで値を参照し、 name と title を割り当てる必要があります。\nlayer.popupTemplate = {　expressionInfos: [{　name: \u0026#34;participation-rate\u0026#34;,　title: \u0026#34;% of population 16+ participating in the labor force\u0026#34;,　expression: \u0026#34;Round(($feature.CIVLBFR_CY / $feature.POP_16UP)*100,2)\u0026#34;　}],　content: \u0026#34;In {NAME} county, {expression/participation-rate}% of the population\u0026#34;　+ \u0026#34; participates in the labor force.\u0026#34;　};　式が expressionInfos プロパティに存在すると、 PopupTemplate のコンテンツ内の{expession/expression-name} プレースホルダー テンプレートを使用して式から返された値を参照できます。 ポップアップのコンテンツは、ユーザーが Greenlee , AZ を表現しているフィーチャーをクリックした後に次のように表示されます。\nまた、PopupTmplate　のコンテンツ の fieldinfos　プロパティの中で Arcade から返された値を参照できるため、表形式で表示することもできます。オブジェクトの fieldName プロパティで式の名前を参照するだけです。なお、 expression/expression-name シンタックスを使用してください。\nlayer.popupTemplate = { expressionInfos: [{ name: \u0026#34;participation-rate\u0026#34;, title: \u0026#34;% of population 16+ participating in the labor force\u0026#34;, expression: \u0026#34;Round(($feature.CIVLBFR_CY / $feature.POP_16UP)*100,2)\u0026#34; }], content: [{ type: \u0026#34;fields\u0026#34;, fieldInfos: [{ fieldName: \u0026#34;expression/participation-rate\u0026#34; }] }] }; ポップアップには以下のように表示されます。\nPopupTmplate の fieldinfos プロパティの書式設定オプションを利用して、式から返された数値を書式設定することもできます。 このワークフローはサンプルアプリ（PopupTemplate Reference Arcade）でご覧ください。\nラベリング ラベリングは、現在、3D SceneView のみサポートしています。2D MapView でのラベリングは将来のリリースで追加される予定です。\nArcade は、FeatureLayer または SceneLayer に含まれるフィーチャのラベルの式を作成するためにも使用されます。バージョン 4.5 からは、フィーチャをラベリングするためにサポートされた唯一の方法です。\n少なくともひとつの LabelClass をレイヤーの LabelingInfo プロパティへ追加し、labelsVisible プロパティを true へ設定する必要があります。式は、LabelClass の labelExpressionInfo オブジェクトの expression プロパティへ文字列として渡します。\n// レイヤーのフィールド値を返す // フィールド値は各フィーチャのラベルに使用される var arcade = \u0026#34;$feature.STATION_NAME\u0026#34;; // new LabelClass() の autocast オブジェクト var labelClass = { // 式を labelExpressionInfo の `expression` プロパティに設定する  labelExpressionInfo: { expression: arcade }, labelPlacement: \u0026#34;below-right\u0026#34;, minScale: 2500000, symbol: { type: \u0026#34;label-3d\u0026#34;, symbolLayers: [{ type: \u0026#34;text\u0026#34;, material: { color: \u0026#34;white\u0026#34; }, halo: { color: \u0026#34;black\u0026#34;, size: 1 }, size: 8 }] } }; // LabelClass を FeatureLayer へ設定 featureLayer.labelingInfo = [ labelClass ]; featureLayer.labelsVisible = true; Arcade で書かれたラベル式は、数学的で論理的な操作を実行する複数行に渡るもっと複雑な式になるかもしれません。例えば、Label features using Arcade expressions サンプルは、より複雑な複数行に渡るラベル式を示しています。この式は２つの数値フィールドの値を変数に入れ、評価し、文字列を返します。Arcade の When() は、風向き（0 - 360 度）を評価し、N、NE、E、SE、S、SW、W または NW のいずれかの関連する方角を返します。風力が 0 のとき、方角は返されません。式の最後で、ラベル（WIND 変数の値）を返します。\n\u0026lt;script type=\u0026#34;text/plain\u0026#34; id=\u0026#34;wind-direction\u0026#34;\u0026gt; var DEG = $feature.WIND_DIRECT; var SPEED = $feature.WIND_SPEED; var DIR = When( SPEED == 0, \u0026#39;\u0026#39;, (DEG \u0026lt; 22.5 \u0026amp;\u0026amp; DEG \u0026gt;= 0) || DEG \u0026gt; 337.5, \u0026#39;N\u0026#39;, DEG \u0026gt;= 22.5 \u0026amp;\u0026amp; DEG \u0026lt; 67.5, \u0026#39;NE\u0026#39;, DEG \u0026gt;= 67.5 \u0026amp;\u0026amp; DEG \u0026lt; 112.5, \u0026#39;E\u0026#39;, DEG \u0026gt;= 112.5 \u0026amp;\u0026amp; DEG \u0026lt; 157.5, \u0026#39;SE\u0026#39;, DEG \u0026gt;= 157.5 \u0026amp;\u0026amp; DEG \u0026lt; 202.5, \u0026#39;S\u0026#39;, DEG \u0026gt;= 202.5 \u0026amp;\u0026amp; DEG \u0026lt; 247.5, \u0026#39;SW\u0026#39;, DEG \u0026gt;= 247.5 \u0026amp;\u0026amp; DEG \u0026lt; 292.5, \u0026#39;W\u0026#39;, DEG \u0026gt;= 292.5 \u0026amp;\u0026amp; DEG \u0026lt; 337.5, \u0026#39;NW\u0026#39;, \u0026#39;\u0026#39; ); var WIND = SPEED + \u0026#39; mph \u0026#39; + DIR; return WIND; \u0026lt;/script\u0026gt; そのほかにも、テキスト整形のロジックを提供するテキスト関数を含む、ラベリングに役立つ多くの関数が用意されています。詳細は Arcade をご参照ください。\nその他のケース 標高 3D SceneView では、Arcade を使用してフィーチャごとに独自の標高を設定できます。フィーチャは Z 値を持つことができますが、属性値や Z 値を使用した計算式をもとに高さを演算したい場合に有効です。さらに、Z 値を含まないが、属性フィールドに Z 値に関連する情報を持つデータの場合、featureExpressionInfo.expression プロパティに式を設定できます。例として、Elevation options サンプルは Arcade を使用してポイント シンボルの高さがどのように変化するのかを示しています。\nlayer.elevationInfo = { mode: \u0026#34;absolute-height\u0026#34;, featureExpressionInfo: { expression: \u0026#34;Geometry($feature).z + $feature.HEIGHT\u0026#34; }, unit: \u0026#34;meters\u0026#34; }; 上記の例では、独自の HEIGHT 属性がジオメトリの Z 値として、グラフィックの標高に設定されます。ラインまたはポリゴン フィーチャにおいて、すべてのフィーチャの頂点は expression の戻り値の標高を持ちます。\nプレイグラウンドでは、入力フィーチャ サービスからインポートしたフィールド値をもとに、ブラウザーから式をビルド、デバッグ、テストできます。Console() 機能を使い、複雑なスクリプトをデバッグすることも可能です。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/create-startup-app-js3/",
	"title": "スタートアップ ガイド（3.x）",
	"tags": [],
	"description": "",
	"content": "サンプル プロジェクトのダウンロード このリポジトリ（arcgis-dev-resources）には開発を試してみたい方向けのサンプル コードが含まれています。ダウンロードする際の方法は 2 通りあります。\n リポジトリをご自身のアカウントに Fork（複製）   GitHub にログインして、arcgis-dev-resources ページを開いて [Fork] をクリックすると、ご自身のアカウントに同じリポジトリが作成されます。 Fork 後はご自身のローカル マシンにクローンを作成します。   zip ファイルでダウンロード（※GitHub アカウントをお持ちでない方向け）  arcgis-dev-resources ページを開いて [Download ZIP] をクリックするとプロジェクト ファイル一式が手に入ります。\n地図の表示 まずはダウンロードしたサンプル コードを実行してみましょう。\n  ダウンロードしたサンプル コード（arcgis-dev-resources/startup/javascript/3.x/map/index.html）を Web ブラウザーにドラッグ＆ドロップします。 Web サーバーをお持ちの方はサンプル コードを Web サーバーにホストしてアクセスすることを推奨します。http://localhost/arcgis-samples-js/simple/map.html のように localhost を指定してアクセスできます。\n  この状態では地図は表示されません。サンプル コードをテキスト エディターで開いてみましょう。\n  map.html 29 行目にある以下のコードの \u0026lt;Web マップ ID\u0026gt; と記載されている箇所に Web マップの作成で作成した Web マップ ID を上書きします。\n  var mapDeferred = arcgisUtils.createMap(\u0026#34;\u0026lt;Web マップ ID\u0026gt;\u0026#34;, \u0026#34;mapDiv\u0026#34;); まだ Web マップを作成しておらず、すぐに試してみたい方はサンプル Web マップをご利用ください。\n Web アプリを実行すると、以下のように地図が表示されます。   検索機能の追加 検索機能の実装方法はいくつかありますが、ここではもっとも簡単な方法をご紹介します。検索機能の実装には esri/dijit/Search モジュール（検索ウィジェット）を使用します。検索ソースにはサンプル Web マップに含まれる東京都 23 区のデータを使用します。\n検索ウィジェットは住所検索/属性検索機能を組み込んだ文字入力フォームの UI を提供します。\n ArcGIS Maps SDK for JavaScript から使用したいモジュールを追加します。モジュールのインポートは require 関数の第一引数に入力される配列内で行います。配列内に検索機能の実装に必要なモジュールを追加します。  require([\u0026#34;esri/arcgis/utils\u0026#34;, \u0026#34;esri/dijit/Search\u0026#34;, \u0026#34;esri/layers/FeatureLayer\u0026#34;, \u0026#34;esri/InfoTemplate\u0026#34;, \u0026#34;dojo/domReady!\u0026#34;], function(arcgisUtils, Search, FeatureLayer, InfoTemplate) { ... }); 以下は検索機能に必要なモジュール一覧です。\n * `\u0026quot;esri/dijit/Search\u0026quot;`: 検索ウィジェット\r* `\u0026quot;esri/layers/FeatureLayer\u0026quot;`: フィーチャ レイヤー（オプション）\r* `\u0026quot;esri/InfoTemplate\u0026quot;`: 情報テンプレート（オプション）\rフィーチャ レイヤーは検索ソース、情報テンプレートは検索結果の属性表示を設定するために利用します。\r ここで以下の点に注意してください。\n * 配列の一番最後のモジュールは必ず `\u0026quot;dojo/domReady!\u0026quot;` になるようにしてください\r* `require` 関数の第ニ引数の無名関数の引数にはモジュールに対応したクラス名（任意）を定義しますが、これは配列内のモジュールの順序と対応している必要があります\r  検索ウィジェット用の DOM 要素を作成します。  \u0026lt;div id=\u0026#34;searchDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ここで指定した DIV の ID は検索ウィジェットを作成する際に、JavaScript 側で使用します。\n 検索ウィジェットの表示位置を CSS で記述します。  #searchDiv { display: block; position: absolute; z-index: 2; top: 20px; left: 74px; }  mapDeffered.then の関数内で検索ウィジェット作成のスクリプトを記述します。  mapDeferred.then(function(response) { map = response.map; var search = new Search({ map: map, sources: [] }, \u0026#34;searchDiv\u0026#34;); }); \u0026quot;esri/dijit/Search\u0026quot; モジュールが定義する Search クラスは require 関数内でのみ動作します。\nマップのオブジェクトは `mapDeffered.then` の処理完了後の `Deferred` で取得できます。検索ウィジェットはマップのオブジェクトを使用するため、この位置に記述する必要があります。\r対応するマップを指定するための `map` プロパティにはマップのオブジェクトを、検索ソースを指定するための `sources` プロパティには空の配列を定義します。検索ソースがない状態でも ArcGIS のクラウド サービスが提供する住所検索サービスが標準で含まれています。\r  検索ソースに検索対象とするフィーチャ レイヤーを定義します。  var sources = search.get(\u0026#34;sources\u0026#34;); sources.push({ featureLayer: new FeatureLayer(\u0026#34;https://services.arcgis.com/wlVTGRSYTzAbjjiC/arcgis/rest/services/tokyo_23/FeatureServer/0\u0026#34;), // 検索ソースとなるフィーチャ レイヤー  placeholder: \u0026#34;検索キーワードの入力\u0026#34;, // プレースホルダー  enableLabel: false, // 検索結果ラベルの表示  searchFields: [\u0026#34;\u0026lt;フィールド名\u0026gt;\u0026#34;], // 検索対象となる属性フィールド  displayField: \u0026#34;\u0026lt;フィールド名\u0026gt;\u0026#34;, // 検索結果のポップアップに表示する属性フィールド  outFields: [\u0026#34;*\u0026#34;], // 結果として返す属性フィールド  name: \u0026#34;東京都\u0026#34;, // 検索ソースの名前  infoTemplate: new InfoTemplate(\u0026#34;東京都\u0026#34;, \u0026#34;市区町村: ${Name}\u0026#34;), // 検索結果のポップアップ表示構成  enableSuggestions: true // 検索結果の候補リスト表示  }); // 検索ソースを検索ウィジェットに設定  search.set(\u0026#34;sources\u0026#34;, sources); search.startup(); sources.featureLayer には検索ソースとなるレイヤーを定義しますが、必ずしも地図上に表示されているレイヤーを使う必要はありません。サンプルはマップ オブジェクトに存在しない別のレイヤーを検索ソースとして利用します。\nフィールド名の確認は次の手順で紹介します。\r   検索対象とするレイヤーの詳細ページにて、[レイヤー] の項目から対象とするレイヤーをクリックして [サービスの URL] を選択します。   [Fields] という項目にレイヤーのフィールド情報のリストが表示されているので、検索対象とするフィールド名をコピーして searchFields の配列に追加します。 検索結果のポップアップに表示する属性情報として利用したい場合は displayField にも入力してください。\n  Web アプリを実行すると、以下のように地図上に検索ウィジェットが表示され、設定した検索ソースでの検索が可能になります。   "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/migrate-to-components/",
	"title": "マップ コンポーネントへの移行ガイド",
	"tags": [],
	"description": "マップ コンポーネントへの移行ついて紹介します。",
	"content": "マップ コンポーネントへの移行ついて紹介します。  移行のヒント\nマップ コンポーネントへの移行のヒントについて紹介します。\n\r 移行計画\nウィジェットからマップ コンポーネントへの移行計画について紹介します。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/migrate-to-components/tips-for-migrating/",
	"title": "移行のヒント",
	"tags": [],
	"description": "マップ コンポーネントへの移行のヒントについて紹介します。",
	"content": "出典：ArcGIS Maps SDK for JavaScript - Tips for migrating\n移行のヒント バージョン 4.30 で ArcGIS Maps SDK for JavaScript に Web コンポーネントが追加されました。 これらのコンポーネントはカスタム HTML 要素として構築されているため、最新のブラウザーで標準的に使用でき、フレームワークに依存しません。 SDKでは、コンポーネントは、API の定型コードの多くをカプセル化することにより、一般的なコーディングパターンを簡素化します。\nGetting started Web コンポーネントが初めての方、あるいはこのトピックのブラッシュアップが必要な方には、役立つさまざまなリソースがあります\n  すぐにコーディングを始めたい場合は、コンポーネントのチュートリアルや GitHub にあるコードサンプルを調べてみましょう。\n  属性やプロパティの扱い方、変更の監視などについては、プログラミング パターンのガイド・トピックをお読みください。\n  プロパティ、メソッド、イベントを確認するには、リファレンスページをご覧ください。\n  JavaScript Maps SDK コンポーネントでアプリを構築するブログ (Build GIS Web Apps with the JavaScript Maps SDK components) をご覧ください。\n  MDN Web Components リソースページをご覧ください。\n  基本的な実装 コンポーネントを使用することで、JavaScript Maps SDK でアプリケーションを実装するたびに繰り返し必要になるコードを減らすことができます。 例えば、SDK の AMD モジュールを使用したシンプルなマップの JavaScript コードを以下に示します。\nrequire([\u0026#34;esri/Map\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;], (Map, MapView) =\u0026gt; { const map = new Map({ basemap: \u0026#34;streets-vector\u0026#34; }); const view = new MapView({ container: \u0026#34;viewDiv\u0026#34;, map: map, zoom: 14, center: [8.5, 47.37] }); }); 以下は、Map コンポーネントを使った HTML での同等のコードです。 このスニペットは、コンポーネントに直接属性を設定することを示しています\n\u0026lt;arcgis-map zoom=\u0026#34;14\u0026#34; center=\u0026#34;8.5,47.37\u0026#34; basemap=\u0026#34;streets-vector\u0026#34;\u0026gt;\u0026lt;/arcgis-map\u0026gt; カスタム機能の実装 Map コンポーネントがロードされた後に実行される機能を実装するには、HTML 要素をクエリし、その要素のオブジェクトを使用してイベント リスナーを設定したり、プロパティを取得または設定したり、コンポーネントに直接メソッドを実装したりします。\n以下は、ビューの準備ができたことを検知し、いくつかのプロパティを設定し、コンソールにマップのズームレベルを書き込むスニペットです。 この単純な例では、require() ステートメント (AMD) や import モジュール (ESM) を実装する必要はありません。\n\u0026lt;arcgis-map\u0026gt;\u0026lt;/arcgis-map\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; // Query for the HTML element const map = document.querySelector(\u0026#34;arcgis-map\u0026#34;); // Set map properties programmatically map.zoom = 14; map.center = [8.5, 47.37]; map.basemap = \u0026#34;streets-vector\u0026#34;; // Listen for the map\u0026#39;s view to be ready map.addEventListener(\u0026#34;arcgisViewReadyChange\u0026#34;, (event) =\u0026gt; { // Get or set map properties  console.log(`Zoom level is ${map.zoom}`); }); "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/migrate-to-components/translation-plan/",
	"title": "移行計画",
	"tags": [],
	"description": "ウィジェットからマップ コンポーネントへの移行計画について紹介します。",
	"content": "出典：ArcGIS Maps SDK for JavaScript - Transition plan: widgets to components\n移行計画：ウィジェットからコンポーネントへ JavaScript Maps SDK のコア API の \u0026lt;arcgis-map\u0026gt;\u0026lt;/arcgis-map\u0026gt; などの再利用可能なカスタム HTML 要素に拡張する標準ベースの Web コンポーネントへの置き換えが進められています。\nこれは、ArcGIS 製品の内部開発にも、JavaScript Maps SDK の一部として提供されるビルド済みの UI コンポーネントにも当てはまります。 現在、SDK を使用した Web アプリの構築では、コンポーネントを使用することが推奨されています。\nコンポーネントのメリット このアーキテクチャーの転換は、フロントエンド Web 開発の生産性を最大化します。 カスタム 要素は、使い慣れた（HTML、CSS、JS）プログラミング エクスペリエンスを提供し、アプリケーション フレームワークとのシームレスな統合を可能にします。 さらに、ArcGIS のエクスペリエンスを Esri 製品の Web コンポーネントとしてカプセル化しているため、実績のあるワークフローを SDK の設定によって変更が可能なコンポーネントとして提供できます（すでにリリースされている Arcade Editor や チャート コンポーネントなど）。 SDK の上位レベルのコンポーネント 群は、時間の経過とともに増え続ける予定です。\nウィジェットからマップ コンポーネントへ SDK が最初に作られたとき、Web コンポーネントの規格はまだ成熟しておらず、ブラウザーに広く採用されていませんでした。 同時に、JS の状況は常に変化しているため、特定の JS フレームワークに積極的ではありませんでした。 そのため、私たちはウィジェット アーキテクチャーを開発し、開発者が Web アプリケーションで使用できるよう、時間をかけて 60 以上のウィジェットを作成しました。 Web コンポーネントの標準がすべての主要なブラウザーでサポートされるようになった今、（SDK の多くの内部でそうしているように）私たちはブラウザーとともに技術を進化させることができます。\n移行の過程によってコンポーネントは非常に進歩しました。 実際、ウィジェットとして利用可能なすべての機能は、コンポーネントとしても利用可能です。 当初、ウィジェットは Web コンポーネントとしてラップされていましたが、時間の経過とともに、ウィジェットは標準の Web コンポーネントとして再実装されるようになりました。 バージョン 4.32 でこの移行が完了したコンポーネントの一覧は、4.32 リリースノートを参照してください。 コンポーネントの再実装が完了したら、スロットのサポートを追加します。これにより、コンポーネントのエクスペリエンス内にカスタム コントロールや機能を統合できるようになります。\nSDK Web サイトと関連リソースの移行 SDK の多くのリソースは、すでにコンポーネント ベースになっています。 これには、スタートガイド、プログラミング パターン、チュートリアル、サンプル集、コンポーネント プレイグラウンドとAPI リファレンスの統合などの新しいリソースや更新されたリソースが含まれます。 しかし、SDK の Web サイトには 8 年以上取り組んできたリソースが含まれているため、完全な移行には複数のリリースが必要になります。 移行期間中は、推奨されるコーディング パターンをまだ反映していない（コンポーネント ベースではない）サンプルやコード スニペットが Web サイト全体に表示されます。 リリースのたびに、注目すべき進歩がもたらされるでしょう。\nウィジェット ロードマップ 最終的には、すべてのウィジェットは非推奨となり、後に削除されます。 しかし、コンポーネントへの移行にはアプリケーションの書き換えは必要ありませんが、相応の労力がかかり、計画と優先順位付けが必要であることを認識しています。 多くの Esri 製品チームが同じ移行作業を行うことになります。ウィジェットのロードマップは、コンポーネント開発のロードマップと同様に、この必要な作業を織り込んでいます。 コンポーネントへの完全移行のために、以下のマイルストーンが目標とされています。\n  @arcgis/map-components パッケージのコンポーネントが実装を更新してウィジェットのコードをラップしなくなると、同等のウィジェットは非推奨となります。 非推奨は、API リファレンス、サンプル コード、およびコンソール メッセージで通知されます。\n 4.32 では、Basemap Gallery、Basemap Toggle、Compass、Directional Pad、Fullscreen、Home、Locate、Navigation Toggle、Scale Bar、Swipe、Track、Zoom の 12 のマップコンポーネントに適用されます。    すべてのウィジェットは、早ければ 2026 年第 1 四半期に非推奨となります。\n  すべてのウィジェットは、早ければ 2027 年第 1 四半期に SDK から削除されます。\n  コンポーネントによるアプリ構築の詳細 コンポーネントを使ったアプリの作り方を学ぶためのリソースは以下のようにたくさんあります。\n  コンポーネントへのアクセス方法（CDNとnpm）、React や Angular などのフレームワークとの統合についてのガイドを含む、スタートアップのためのリソース。\n  コンポーネントの概要\n  チュートリアル\n  コンポーネントを使用したサンプルコード\n  プログラミング パターン\n  Core API と Maps SDK コンポーネントのリファレンス\n  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/",
	"title": "ArcGIS Developers 開発リソース集",
	"tags": [],
	"description": "",
	"content": "\r\rArcGIS Developers 開発リソース集 本サイトは、ArcGIS の API / SDK を利用して開発する方向けに、開発をよりスムーズにスタートしていただけるよう、ArcGIS Location Platform を利用した開発、開発環境の構築から簡単なアプリケーション作成までのガイド、開発に役立つ 技術 Tips 集を紹介しています。\nArcGIS Location Platform は、ロケーション サービスを提供する PaaS（Platform as a Service）です。サービスの詳細は ESRIジャパン製品ページをご覧ください。\nArcGIS Developers が提供するサービスの詳細は ESRIジャパン製品ページをご覧ください。\n目次\r  スタートアップガイド\n 開発を始める方のために必要なアカウントの作成、API キーの取得、ロケーション サービスの利用、各 API / SDK を使った開発の基本的な流れからセキュリティ、デプロイまでと ArcGIS Location Platform を利用した開発手順にそって学べる情報をまとめています。    もっと学ぶ\n スタートアップガイドをひととおり学び終えた方は、次のステップとして、何を見て学習すれば良いのか、より深く学べるように情報をまとめています。米国 Esri 社が無償で提供している学習素材や、ESRIジャパンのスタッフが作成したサンプル プログラム、過去に実施したセミナーやハンズオンの資料、ブログ記事など、多くの情報をまとめています。    技術 Tips 集\n 各 API / SDK を使用した開発をサポートするドキュメント（インストール ガイド、アプリケーションの配布など）や、データの可視化に関する技術 Tips をまとめています。    \r\rプライバシーポリシー  ESRIジャパン Web サイトポリシー  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]
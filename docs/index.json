[
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/python-api-concepts/",
	"title": "ArcGIS API for Python のコンセプト",
	"tags": [],
	"description": "ArcGIS API for Python のプロダクト コンセプトと動作要件について紹介します。",
	"content": "ArcGIS API for Python のコンセプト ArcGIS API for Python (以下、Python API) は、Web GIS (ArcGIS Online / ArcGIS Enterprise) を活用してマップと地理空間データを扱うための Python ベースの API です。\nPython のベスト プラクティスに基づき、標準的なイディオムやデータ構造を用いた、シンプルで使いやすい設計になっており、GIS データの可視化や解析の実行だけでなく、ユーザー、グループ、アイテムなどを管理するためのシンプルで使いやすいツールを提供します。 さらに、自身が所有しているデータだけでなく、Esri 等が提供するすぐに使えるマップやデータにアクセスすることも可能です。 また、Pandas や Jupyter Notebook といった、他の Python 向けのライブラリやツールとの連携で、より豊富な機能を活用することが可能です。\n\rArcGIS API for Python がどのようなモジュールから成り立っているのかを解説します。\r* [動作要件](#動作要件)\rOS などシステム要件と推奨する開発環境をご紹介します。\r* [ガイドページとサンプルコード](#ガイドページとサンプルコード)\r用途別に、初めの一歩として有用なサンプルをご紹介します。 --\r Python API のアーキテクチャ Python API は、Web GIS プラットフォームを使用する目的で実装されています。 Python API には、ArcGIS プラットフォーム上で利用するデータやユーザの認証情報など、各オブジェクトを管理して作業するためのモジュール、クラス、関数、およびタイプがあります。\nPython API は arcgis パッケージとして配布されています。 このパッケージの中には、最も基本になる gis モジュールを中心に、Web GIS で使用できる機能がさまざまなモジュールとして編成されています。\nPython API のモジュールを表したダイアグラム\n\rgisは最も重要なモジュールで、Web GIS への入口となり、ユーザー、グループ、およびコンテンツを管理 (作成、読み込み、更新、削除) する機能を提供します。Web GIS の管理者権限をもつユーザーは、自身の組織のメンバー、グループなどの管理にこのモジュールを使用します。\n緑色のモジュールは、さまざまな空間解析に用いる地理情報データセットにアクセスするために使用します。これらのモジュールには、特定のタイプの空間データを操作するための関数、ジオプロセシング処理、ArcGIS で使用できる様々なデータに対応したクラス、およびそれらを補助するようなヘルパー クラスなどが含まれています。\n青色のモジュールは、GIS のワークフローをサポートする追加的な機能を提供します。住所から緯度経度を特定するジオコーディング モジュール、フィーチャのジオメトリを表すモジュール、そしてサード パーティーのジオプロセシング ツールをインポートして使用するためのジオプロセシング モジュール等が含まれています。\nオレンジ色のモジュールは、GIS データの分析結果を可視化して共有することを可能にします。 widgets モジュールには、Jupyter Notebook でマップとレイヤーを可視化する機能を実装しています。 mapping モジュールには、Web マップと Web シーンに対応し、それぞれのレイヤーを操作するためのタイプと関数があり、apps モジュールは ArcGIS で構築された Web アプリケーションの作成と管理に役立ちます。\n各モジュールの詳しい内容は、米国Esri ガイドページ（英語）をご覧ください。\n 動作要件 Python API は次の環境と動作要件が必要です。\n  オペレーティング システム\n Windows (32 /64 ビット) /macOS/ Linux ※macOS/Linux は国内サポート対象外となります    Python バージョン 3.9.x - 3.11\n  開発環境\n Jupyter Notebook※ Jpyter Lab※ 他、Python 開発環境/テキスト エディター    ※ Jupyter Notebook および Jupyter Lab はオープンソースとして利用できる開発環境のひとつです。 Python API はこれらの開発ツールでの地図出力をサポートしてます。利用可能なブラウザは次の通りですが、詳細については Jupyter Notebook のシステム要件をご覧ください。\n Google Chrome FireFox Safari  サポートする最新の動作環境につきましては米国Esri システム要件（英語）または、動作環境もご参照ください。\n Esri サンプル ガイド ページ\n\r* [`gis`を使って、ユーザー情報やコンテンツを検索してみる](https://developers.arcgis.com/python/guide/using-the-gis/#Using-the-GIS)\r* [【開発者向け】:ノートブックをはじめる](https://developers.arcgis.com/python/sample-notebooks/your-first-notebook/)\r* [【管理者向け】:グループをバッチで作成する](https://developers.arcgis.com/python/sample-notebooks/batch-creation-of-groups/)\r* [【GISデータ解析者向け】:自然現象を解析する](https://developers.arcgis.com/python/sample-notebooks/chennai-floods-analysis/)\r* [【コンテンツ公開者向け】:シェープファイルや CSV からコンテンツを作成する](https://developers.arcgis.com/python/sample-notebooks/publishing-sd-shapefiles-and-csv/) --\r次は、Python API を利用するArcGIS API for Python のための基礎環境：conda入門についてご紹介します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-js/",
	"title": "ArcGIS Maps SDK for JavaScript",
	"tags": [],
	"description": "ArcGIS Maps SDK for JavaScript を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。",
	"content": "マップを表示する このチュートリアルでは ArcGIS Maps SDK for JavaScript を使用して、マップとベースマップ レイヤーを表示する方法を紹介します。\nマップには、地理データのレイヤーが含まれています。マップには、ベースマップ レイヤーと、オプションで1つ以上のデータレイヤーを追加できます。マップビューを使用し、場所とズームレベルを設定することで、マップの特定の領域を表示できます。\nこのチュートリアルでは、地形ベースマップレイヤーを使用して、富士山付近を表示する地図を作成します。\n前提条件 このチュートリアルを実施するには、以下が必要です。\n API キーにアクセスするための ArcGIS 開発者アカウント。アカウントをお持ちでない場合は、サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。  ステップ 新しい Pen の作成 CodePen にアクセスして、マッピングアプリケーション用の新しい Pen を作成します。\nHTML の作成 HTML ページを定義して、Web ブラウザのウィンドウの幅と高さをフル利用してマップを作成します。\n  CodePen ＞ HTML で、HTML と CSS を追加し、viewDiv 要素を持つページを作成します。viewDiv は地図を表示する要素で、その CSS はブラウザの設定をリセットして、ブラウザの幅と高さをフルに利用できるようにしています。\nCodePenでは、\u0026lt;!DOCTYPE html\u0026gt; タグは必要ありません。他のエディタを使用している場合や、ローカルサーバでページを実行している場合は、必ずこのタグを HTML ページの先頭に追加してください。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;ArcGIS Maps SDK for JavaScript Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   API の参照   \u0026lt;head\u0026gt; タグ内に、CSS ファイルと JS ライブラリへの参照を追加します。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;ArcGIS Maps SDK for JavaScript Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;!-- CSS ファイルと JS ライブラリへの参照を追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.29/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.29/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   モジュールの追加 ArcGIS JS API には AMD モジュールが含まれています。require ステートメントで Map モジュールと MapView モジュールを参照します。\n  \u0026lt;head\u0026gt; タグ内に、\u0026lt;script\u0026gt; タグと AMD の require ステートメントを追加して、Map モジュールと MapView モジュールを読み込みます。\nJavaScript のコードを HTML パネルではなく、CodePen ＞ JS パネルに追加することもできます。その場合は、\u0026lt;script\u0026gt; タグを削除してください。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;ArcGIS Maps SDK for JavaScript Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;!-- CSS ファイルと JS ライブラリへの参照を追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.29/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.29/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;!-- モジュールの追加 --\u0026gt; \u0026lt;script\u0026gt; require([\u0026#34;esri/config\u0026#34;,\u0026#34;esri/Map\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;], function (esriConfig,Map, MapView) { }); \u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   API キーの取得 ArcGIS サービスにアクセスするには、API キーが必要です。\n developer dashboardにアクセスして、API キーを取得します。 次のステップで使用しますので、キーをコピーしてください。  マップの作成 Map を使ってベースマップレイヤーを設定し、API キーを適用します。\n  CodePen に戻ります。\n  require 文の中で、新しい Map を作成し、basemap プロパティに arcgis/topographic を参照するベースマップ スタイルの情報を設定します。ベースマップ スタイル サービスへのアクセスを可能にするために、Map の apiKey() プロパティを設定します。\n  マップには、データ レイヤとベースマップ レイヤがあります。ベースマップ スタイル サービスからベースマップ レイヤーにアクセスするためには、API キーが必要です。キーは、Map の作成時に前のステップから設定できます。\n  マップおよびマップ ビューが Map（2D）でどのように機能するかについては、マッピングとロケーションサービス を参照してください。\n  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;ArcGIS Maps SDK for JavaScript Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;!-- CSS ファイルと JS ライブラリへの参照を追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.29/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.29/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;!-- モジュールの追加 --\u0026gt; \u0026lt;script\u0026gt; require([\u0026#34;esri/config\u0026#34;,\u0026#34;esri/Map\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;], function (esriConfig,Map, MapView) { // API キーの追加  esriConfig.apiKey = \u0026#34;YOUR-API-KEY\u0026#34;; // マップの作成  const map = new Map({ basemap:{ style:{ id:\u0026#34;arcgis/topographic\u0026#34;, // 地形図ベースマップ レイヤー  language:\u0026#34;ja\u0026#34; } } }); }); \u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   マップ ビューの作成 MapView クラスを使って、表示する地図の位置を設定します。\n  MapView を作成し、map プロパティを設定します。マップビューを中央に表示するために、center プロパティを 138.727363, 35.360626 に、zoom プロパティを 13 に設定します。マップの内容を表示するために、container のプロパティを viewDiv に設定します。\n  MapView は、地図の内容を表示します。center と zoom のプロパティは、ロード時にマップの位置と表示されるズームレベルを決定する。\n  zoom プロパティは、マップのズームレベルを設定します。値の範囲は通常 0〜20 で、0 が地表から最も遠く、20 が最も近くなります。ベースマップ レイヤーの中には、さらに 23 までのズーム・レベルをサポートするものもあります。\n  MapView は、クリックやダブルクリックなどのいくつかのタッチイベントもサポートしています。これらのイベントを利用して、マップの位置を変更したり、レイヤー内のフィーチャーを探したりすることができます。\n  Maps（2D）でのマップとマップビューの仕組みについては、マッピング API とロケーションサービス のガイドを参照してください。\n  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;ArcGIS Maps SDK for JavaScript Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;!-- CSS ファイルと JS ライブラリへの参照を追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.29/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.29/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;!-- モジュールの追加 --\u0026gt; \u0026lt;script\u0026gt; require([\u0026#34;esri/config\u0026#34;,\u0026#34;esri/Map\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;], function (esriConfig, Map, MapView) { // API キーの追加  esriConfig.apiKey = \u0026#34;YOUR-API-KEY\u0026#34;; // マップの作成  const map = new Map({ basemap:{ style:{ id:\u0026#34;arcgis/topographic\u0026#34;, // 地形図ベースマップ レイヤー  language:\u0026#34;ja\u0026#34; } } }); // マップ ビューの作成  const view = new MapView({ map: map, center: [138.727363, 35.360626], // 経度、緯度  zoom: 13, // ズーム レベル  container: \u0026#34;viewDiv\u0026#34; // MapView を表示する HTML 上の Div 要素の ID  }); }); \u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   アプリを実行する CodePen で、作成したコードを実行して地図を表示します。\nマップには、富士山を中心とした地形ベースマップレイヤーが表示されます。\nWeb マップを表示する 「Web マップの作成」のガイドで Web マップを作成している場合は、作成した Web マップも基本的に同じステップで表示できます。\n  require ステートメントにて、WebMap モジュールを追加で読み込みます。\n\u0026lt;!-- モジュールの追加 --\u0026gt; \u0026lt;script\u0026gt; require([\u0026#34;esri/config\u0026#34;,\u0026#34;esri/Map\u0026#34;, \u0026#34;esri/WebMap\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;], function (esriConfig, Map, WebMap, MapView) { // .....  }); \u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt;   Map オブジェクトを下記のように書き換えます。\n// Web マップの参照  const map = new WebMap({ portalItem: { id: \u0026#34;\u0026lt;Web マップ ID\u0026gt;\u0026#34; //id: \u0026#34;d3ffea931f4a455f9c3b6c2102e66eda\u0026#34;  } });   Web マップに置き換えた全体のコードは下記の通りです。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;ArcGIS Maps SDK for JavaScript Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;!-- CSS ファイルと JS ライブラリへの参照を追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.29/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.29/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!--追加終了 --\u0026gt; \u0026lt;!-- モジュールの追加 --\u0026gt; \u0026lt;script\u0026gt; require([\u0026#34;esri/config\u0026#34;, \u0026#34;esri/Map\u0026#34;, \u0026#34;esri/WebMap\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;], function (esriConfig, Map, WebMap, MapView) { // API キーの追加  esriConfig.apiKey = \u0026#34;YOUR-API-KEY\u0026#34;; // マップの作成  /* const map = new Map({ basemap:{ style:{ id:\u0026#34;arcgis/topographic\u0026#34;, // 地形図ベースマップ レイヤー language:\u0026#34;ja\u0026#34; } } }); */ // Web マップの参照  const map = new WebMap({ portalItem: { id: \u0026#34;\u0026lt;Web マップ ID\u0026gt;\u0026#34; //id: \u0026#34;d3ffea931f4a455f9c3b6c2102e66eda\u0026#34;  } }); // マップ ビューの作成  const view = new MapView({ map: map, center: [138.727363, 35.360626], // 経度、緯度  zoom: 13, // ズーム レベル  container: \u0026#34;viewDiv\u0026#34; // MapView を表示する HTML 上の Div 要素の ID  }); }); \u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;    アプリの動作が確認できたら ArcGIS の セキュリティと認証について学びましょう！\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/",
	"title": "ArcGIS Maps SDK for JavaScript",
	"tags": [],
	"description": "ArcGIS Maps SDK for JavaScript の開発に役立つガイド集です。",
	"content": "ArcGIS Maps SDK for JavaScript の開発に役立つガイド集です。\n インストールおよびセットアップ方法\nインストールおよびセットアップの方法を紹介します。\n\r 開発の手順\nArcGIS Maps SDK for JavaScript の開発におけるインストールとセットアップからの手順について紹介します。\n\r インストール ガイド\nArcGIS Maps SDK for JavaScript ライブラリのインストール方法を紹介します。\n\r バージョン 3.x から 4.x への移行\nバージョン 3.x の API で作成した既存のアプリケーションを 4.x に移行するために必要な情報を紹介します。\n\r カスタム フォント\n独自のフォントを使用する手順を紹介します。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/learn/github/",
	"title": "Esri Japan GitHub",
	"tags": [],
	"description": "Esri Japan GitHub",
	"content": "各 API や SDK のサンプルプログラムに加えて、ハンズオンや開発者セミナーで実施内容を GitHub で共有しています。\nワークショップ  workshops  過去のウェビナーやセミナー、ハンズオンで使用した資料をまとめています。    ArcGIS Maps SDK for JavaScript   maps-app-javascript\n このリポジトリでは、ArcGIS API for JavaScript にて構築された地図アプリをすぐに使用できる Maps App というアプリを提供します。 Maps App をそのまま使うことや、ArcGIS API for JavaScript を使用して拡張することができます。    arcgis-samples-4.0-js\n ArcGIS API 4.x for JavaScript のサンプル集です。Esri Community などで紹介したサンプルなどもございます。    arcgis-samples-js\n ArcGIS API for JavaScript のサンプル集です。    webmap-startup-template-js\n Web マップを使用した開発手法を伝えるためのアプリケーション テンプレートのサンプルです。    ArcGIS Maps SDKs for Native Apps   nearby-android\n このリポジトリでは、Android SDK で構築された Android デバイス用の Nearby Places というサンプル アプリを提供しています。そのまま使用したり、多少のカスタマイズで、表示する場所の種類を変更することができます。    find-route-ios\n 宮蘭航路フェリーハッカソン用に作成したオフラインで観光ルート検索を行う iOS アプリケーションです。写真から行ってみたい観光スポットを選択すると、最短時間で周れる最適ルートと移動時間を検索・表示します。検索したルートはお気に入りに登録して、後から確認することもできます。    startup-sample-dotnet\n .NET SDK をはじめて使用される方に、開発キットの基本的な使い方や主要な機能を紹介するためのサンプル アプリケーションです。    enc-viewer-dotnet\n ENC (Electronic Navigational Charts: 航海用電子海図) を表示するビューアーです。 S-57 形式の ENC のセルをサポートしています。    flightsim-game-monitor-dotnet\n Web Socket を利用した双方向通信によりマルチユーザー プレイを実現したフライト シミュレーター ゲームのスコア モニター用アプリです。 フライト シミュレーター ゲームの機体を動かしてゲームをプレイできるコントローラー用のWeb アプリと連携します。    webmap-startup-template-dotnet\n Web マップを使用した開発手法を伝えるためのサンプル アプリケーションです。    ArcPy   arcgis-samples-py\n ArcPy サイト パッケージのサンプル集です。ArcMap 用と ArcGIS Pro 用のサンプルがあります。個々のサンプル リポジトリに tbx ファイルがある場合は、ArcMap や ArcGIS Pro でジオプロセシング ツールとしてそのまま利用することが可能です。    ejpyconv-py\n EJPyConv ツールは ArcPy で書かれた ArcGIS Pro 用の複数の便利なツールが含まれている「サンプル ジオプロセシング ツールボックス」です。 ArcGIS Pro へツールボックスを追加することで、各種ジオプロセシング ツールとして利用が可能です。    arcpy-resources\n ArcGIS ユーザーのための Python/ArcPy を用いた基礎的な学習用の資料を公開しています。    gcf2018-arcpy-demo\n これは第14回 GISコミュニティフォーラムのプレフォーラム・セミナー「Python で始める自動化処理」で行ったデモのソースコードです。    gdb-archived-data-copy\n 履歴管理が有効なフィーチャクラスの過去の一時点の状態を、シェープファイルとして出力します。    gcf2015sde-demo\n これは第11回 GISコミュニティフォーラムのプレフォーラム・セミナー「Python でエンタープライズ ジオデータベースを管理しよう！」で行ったデモのソースコードです。    ArcGIS API for Python   arcgis-samples-python-api\n ArcGIS API for Python のサンプル集です。    arcgis-python-api\n Esri が提供している ArcGIS API for Python リポジトリをフォークし、Esri Community で投稿した記事と、guide 下にある一部のノートブックをローカライズしたものを置いてあります。    ArcGIS Pro SDK   arcgis-samples-pro-sdk\n ArcGIS Pro SDK for .NET のサンプル集です。    arcgis-pro-sdk\n ArcGIS Pro SDK for .NET で ArcGIS Pro を拡張します。ArcGIS Pro SDK for .NET は、アドインおよび構成の拡張性パターンに基づいています。タスク非同期プログラミング（TAP）、LINQ、WPF バインディング、MVVM などの最新の .NET 機能およびパターンを活用し、Pro の新しい API を使用して統合された 2D/3D アドインを記述します。    arcgis-pro-sdk-community-samples\n このリポジトリには、ArcGIS Pro 2.7 SDK for Microsoft .NET Framework 用の ArcGIS Pro Add-In Samples が含まれています。    arcgis-pro-sdk-tools\n ArcGIS Pro SDK を使用したツールを公開しています。ArcGIS Pro SDK の様々な API を使用しているので、開発時の参考リソースとしてもご使用ください。    ArcObjects  maps-app-gislight  Maps App GISLight10 は、ArcObjects SDK for .NETとWindows フォームを使用した、スタンドアロン アプリケーションの実装およびセットアップのサンプルを提供しています。    ArcGIS 全般  arcgis-install-batch  ダウンロード形式で提供されている製品本体（exe）を解凍し、フォルダ階層にパッチファイルを含めて再整理後、大量のPCに一括でインストールを行うためのバッチファイルのサンプル、およびインストールしたものをアンインストールを行うためのバッチファイルのサンプルです。    その他   3D-CityModel-ConversionTools-for-ArcGIS\n 「3D 都市モデルデータ変換ツール for ArcGIS」 は、PLATEAU で整備し、G 空間情報センターで公開している 3D 都市モデル（CityGML）のデータを、ArcGIS で利用可能なファイル ジオデータベース へ変換するツールです。    gsi-wmts\n 地理院地図の layers.txt に含まれるレイヤーのうち、WMTS で配信可能なレイヤーのみを取得したメタデータです。「地理院タイル目録」より情報が取得可能なレイヤーには範囲を指定するエクステント情報を付加しています。    developer-support\n ここは、Esri の開発者ライブラリを使用している GIS 開発者を共同でサポートする場所です。    i3s-spec\n この GitHub リポジトリでは、シーンレイヤーの仕様を公開しています。    arcgis-enterprise-sdk-resources\n このリポジトリでは、10.8.1 ArcGIS Enterprise SDK で構築されたサーバ オブジェクト エクステンション（SOE）およびサーバ オブジェクト インターセプター（SOI）のサンプルおよびコード スニペットを提供しています。    arcgis-saml-samples\n ArcGIS Online / ArcGIS Enterprise は、エンタープライズ ログインのアカウント構成に SAML (Security Assertion Markup Language) 2.0 をサポートしています。SAML は、認証サーバーである ID プロバイダーとサービスを提供するアプリケーションであるサービス プロバイダーとの間で認証/認可データを安全に交換するためのオープン規格です。    sdgs-sample\n Esri が提供する SDGs に関連する以下のプロジェクトを日本語にし、集約しました。    tokyochallenge\n リアルタイム列車遅延マップは第1回 東京公共交通オープンデータチャレンジ向けに開発した Web アプリです。このリポジトリでは、開発したソース コードおよび設定用の必要なデータを公開しています。    gcf2018-geoevent-twitter\n GISコミュニティフォーラム2018年 GeoEvent デモ用    gcf2018-webappbuilder-demo\n 本リポジトリでは、第14回 GISコミュニティフォーラムのプレフォーラム・セミナー「プログラミングゼロ！ ～Web GIS アプリ 3 分メイキング～ 」で紹介したアプリの作成手順を公開しています。    data-visualization-lab\n ArcGIS のオープンなプラットフォームを基盤とした様々なデータ ビジュアライゼーションとそれを支えるオープンなテクノロジーを紹介します。    resas2arcgis\n このサービスは RESAS API から取得できるデータを ArcGIS へ簡単に入力できるようにした開発したサービスです。    photospot-finder\n 室蘭市の2016年11月14日に開催された企業・団体対抗 観光ハッカソン向けに作成したアプリです。    esri-leaflet-tips\n Esri Leaflet のサンプルです。    arcgis-d3-components\n ArcGIS API for JavaScript で作成した地図との連携のための D3 コンポーネントです。    flightsim-game-controller-js\n Web Socket を利用した双方向通信によりマルチユーザー プレイを実現したフライト シミュレーター ゲームの操作アプリです。 全機の位置とスコア ランキングを管理するモニター用のネイティブ アプリと連携します。    data-visualization-js\n ArcGIS API for JavaScript を用いてデータ ビジュアライゼーションの手法とそれを実現する機能について紹介していく「JavaScript で始めるデータ ビジュアライゼーション」シリーズにおいて使用しているサンプル コード集です。    esri-react-components-js\n ArcGIS API for JavaScript の Web アプリ開発に利用可能なモジュールとして React で実装したコンポーネントを集約します。    esrijapan.github.io\n ESRIジャパンあるいは Esri が公開しているオープンソース プロジェクトのランディング ページです。    contributing\n ESRIジャパン GitHub アカウントにおけるオープンソースへの貢献について    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/calcite-design-system/get-started/",
	"title": "はじめに",
	"tags": [],
	"description": "次の手順に従って、すぐに Calcite Components を使い始めることができます。",
	"content": "出典：Calcite Design System - Get Started\nはじめに Calcite Components は、Web アプリケーションを構築するための、柔軟でフレームワークに依存しない Web コンポーネントの豊富なライブラリです。Web コンセプトのページ では、Calcite Design System の構成要素について説明しています。\n例題、プロパティ、スロット、スタイル、イベント、モードなどの API リファレンスについては、コンポーネント ドキュメントをご覧ください。以下の手順で、Calcite Components を使い始めることができます。\nまず、Calcite Components を使用するには、ArcGIS アカウントが必要です。アカウントをお持ちでない場合は、無料で作成することができます。\n作成方法は、開発者アカウントの作成をご覧ください。\n次に、CDN（Content Delivery Network）または NPM（Node Package Manager）ライブラリを使用して、Calcite Components を読み込みます。\nCDN で利用する Calcite Components を読み込むための最も一般的な方法は、ArcGIS CDN でホストされているバージョンを使用する方法です。コンポーネントは、HTML ドキュメントの先頭にある script および link タグを使用して読み込むことができます。\n\u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;https://js.arcgis.com/calcite-components/1.11.0/calcite.esm.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;https://js.arcgis.com/calcite-components/1.11.0/calcite.css\u0026#34; /\u0026gt; これらのタグを追加すると、他の HTML 要素と同様にコンポーネントを使用することができます。アプリケーションで使用されるコンポーネントのみが読み込まれます。\nNPM パッケージで利用する Calcite Components は、NPM パッケージとしても提供されています。使い始めるには、まずパッケージをインストールし、以下のステップに従います。また、様々なフレームワークやビルドツールを使用したサンプルはこちらでご覧いただけます。\nnpm install @esri/calcite-components アセットの読み込み calcite-icon や calcite-date-picker のような幾つかのコンポーネントは、特定のパスで利用可能なアセットに依存しています。前述したように NPM パッケージでは、ローカルパスか CDN でホストされているアセットの URL を提供するオプションがあります。CDN でホストされているアセットを使うことで、ディスクのビルドサイズを減らすことができます。\nローカルでアセットを使用するには、ビルドツールや NPM スクリプトを使用してコピーする必要があります。ローカル アセットのディレクトリは assets という名前にする必要があります。例えば、/public/calcite/assets は動作しますが、/public/calcite-assets は動作しません。\nCalcite Components のサンプル集では、様々な JavaScript フレームワークやビルド ツールでローカル アセットを使用する方法を示しています。各例には、フレームワークやビルド ツール固有の説明を含む README があります。\ncp -r node_modules/@esri/calcite-components/dist/calcite/assets/* ./public/assets/ スタイルのインポート 最後に、カスケーディング スタイル シート（CSS）を読み込みます。これもフレームワークやビルド ツールに依存しますが、多くの場合、JavaScript で読み込むことができます。\nimport \u0026#34;@esri/calcite-components/dist/calcite/calcite.css\u0026#34;; ビルドの選択 最後に、Calcite Components が提供する 2 つのビルドから 1 つを選択する。\nカスタム要素 カスタム要素 は、フロントエンド フレームワークを利用する場合に推奨されるビルドです。このビルドを使用するには、Calcite Components のアセットへのパスを設定する必要があります。次のステップで説明するローカルのアセットを使用するか、CDN でホストされているアセットを使用することができます。\nimport { setAssetPath } from \u0026#34;@esri/calcite-components/dist/components\u0026#34;; // CDN hosted assets setAssetPath(\u0026#34;https://js.arcgis.com/calcite-components/1.11.0/assets\u0026#34;); // ローカル アセット // setAssetPath(PATH); // PATH はフレームワークによって異なります。 次に、カスタム要素ビルドから、使用する各コンポーネントをインポートする必要があります。これにより、ウィンドウにカスタム要素が自動的に定義されます。\nimport \u0026#34;@esri/calcite-components/dist/components/calcite-button\u0026#34;; import \u0026#34;@esri/calcite-components/dist/components/calcite-icon\u0026#34;; import \u0026#34;@esri/calcite-components/dist/components/calcite-slider\u0026#34;; ディストリビューション ディストリビューション ビルドを使用する場合、ウィンドウ上でカスタム要素を定義する必要があります。また、ローカルと CDN にホストされたアセットのどちらかを選択することができます。\nimport { defineCustomElements } from \u0026#34;@esri/calcite-components/dist/loader\u0026#34;; // CDN hosted assets defineCustomElements(window, { resourcesUrl: \u0026#34;https://js.arcgis.com/calcite-components/1.11.0/assets\u0026#34; }); // Local assets // defineCustomElements (window); カスタム要素をウィンドウ上で定義したので、個々のコンポーネントをインポートする必要はありません。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/android/install-android-200.x/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Maos SDK for Kotlin のインストールとセットアップ手順を紹介します。",
	"content": "出典：ArcGIS Maps SDK for Kotlin - Guide - Install and set up\nこのインストール ガイドでは、ArcGIS Maps SDK for Kotlin (バージョン 200.x) のインストールとセットアップ手順を紹介します。マップを表示する方法については「アプリの作成」のチュートリアルをご覧ください。\nArcGIS Developers のダッシュボードから各インストーラーやデータをダウンロードするには、ArcGIS 開発者アカウントでログインする必要があります。アカウントをお持ちでない場合は、サインアップ (無料) してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。\nArcGIS Maps SDK for Kotlin をインストールする前に、開発マシンが 動作環境 を満たしていることを確認してください。アプリを実行するすべてのターゲット デバイスには、Android API レベルの最小バージョンが必要です。詳細については、システム要件を参照してください。\nGradle を使用してインストールすることをお勧めします。これにより、Esri の Maven リポジトリから必要な依存関係と SDK バイナリがインストールされます。\nGradle で API を取得する Android Studio で [New Project] ウィザードを実行する際、[Phone and Tablet]、[Empty Activity] の順に選択します。Empty Activity オプションは Compose 対応アプリを作成するために必要な Android からの Jetpack Compose 依存関係を提供します。\n以下の手順では、Android Studio Iguana 2023.2.1 Patch 1 を使用します。最適な結果を得るには、このバージョン以降の Android Studio を使用してください。\n\rAndroid Studio の [New Project] ウィザードで作成したプロジェクトで、次のセットアップ手順を実行します。\n  settings.gradle.kts ファイルの repositories ブロック (dependencyResolutionManagement 内にネストされています) で、Esri の Maven リポジトリ URL を指定して maven ブロックを追加します。Esri のリポジトリはオープンソースではないため、google() や mavenCentral() からは使用できないため、この URL を指定する必要があります。\nsettings.gradle.kts\ndependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { google() mavenCentral() // Esri の Maven リポジトリを追加  maven { url = uri(\u0026#34;https://esri.jfrog.io/artifactory/arcgis\u0026#34;) } } }   module レベルの build.gradle.kts (Module :app) ファイルの dependencies ブロック内で、ArcGIS Maps SDK for Kotlin の依存関係をアプリに追加します。\nこの依存関係を、ArcGIS Maps SDK for Kotlin を使用する各モジュールに追加する必要があります。\n\rbuild.gradle.kts (Module: app)\ndependencies { ... // ArcGIS Maps SDK for Kotlin の依存関係を追加  implementation \u0026#39;com.esri:arcgis-maps-kotlin:200.4.0\u0026#39; }   Esri が公開しているすぐに使用できる Compose コンポーネントを提供する依存関係を追加します。ArcGIS Maps SDK for Kotlin Toolkit で定義されているこれらの Compose コンポーネントは、ArcGIS Maps SDK for Kotlin の標準 API のクラスにアクセスします。Toolkit は、Compose ベースで ArcGIS Maps SDK for Kotlin と互換性のあるテスト済みの UI 要素を含めるための最も効率的な方法です。 geoview-compose という名前の Toolkit モジュールへの依存関係を宣言します。このモジュールには、マップ ビューとシーン ビューを実相するためのコンポーザブルな関数が含まれています。Toolkit には、他にもいくつかの便利な Compose ベースのモジュールが含まれています。使用する他の Toolkit モジュールを dependency ブロックに追加します。\nbuild.gradle.kts (Module: app)\ndependencies { . . . // ArcGIS Maps SDK for Kotlin の依存関係を追加  implementation(\u0026#34;com.esri:arcgis-maps-kotlin:200.4.0\u0026#34;) // ツールキットの依存関係を追加  implementation(\u0026#34;com.esri:arcgis-maps-kotlin-toolkit-geoview-compose:200.4.0\u0026#34;) // 追加のツールキットのモジュールが必要な場合、以下のように記述します  // implementation(\u0026#34;com.esri:arcgis-maps-kotlin-toolkit-authentication:200.4.0\u0026#34;) } アーティファクトのバージョン管理 (代替方法) これまでのコードでは、ツールキットの依存関係でアーティファクトのバージョンを指定しています。この方法の他に、ツールキットの BOM (Bill of Materials), に依存することもできます。BOM には、互いに互換性のある個々のツールキット コンポーネントのバージョンが指定されています。これらのバージョン番号は、BOM の .pom ファイルをから確認できます。詳細は、ツールキット リポジトリのトップ レベルの README を参照してください。Toolkit BOM 自体にもバージョン番号があることに注意してください。\nGradle バージョン カタログは、依存関係のバージョンを管理する最先端の方法です。gradle/libs.versions.toml ファイルでは、各依存関係の Maven 名の変数とバージョン番号の変数を宣言します。ここには、Toolkit BOM、Toolkit モジュール、ArcGIS Maps SDK for Kotlin、Kotlin ライブラリ、Android ライブラリなど、すべての依存関係を宣言できます。Android Studio の最近のリリースでは、[New Project] ウィザードによってこのファイルが作成されます。\nToolkit BOM を使用するように変更すると、build.gradle.kts コードは以下のようになります。libs.arcgis.map.kotlin.toolkit.bom や libs.arcgis.maps.kotlin.toolkit.geoview.compose などの変数は、gradle/libs.versions.toml がバージョンを管理しているため、バージョンを指定しないことに注意してください。\nbuild.gradle.kts (Module: app)\ndependencies { ・・・ // ArcGIS Maps SDK for Kotlin の SDK 依存関係  implementation(libs.arcgis.maps.kotlin) // Toolkit の依存関係  implementation(platform(libs.arcgis.maps.kotlin.toolkit.bom)) implementation(libs.arcgis.maps.kotlin.toolkit.geoview.compose) // 追加のツールキットのモジュールが必要な場合、以下のように記述します  // implementation(libs.arcgis.maps.kotlin.toolkit.authentication) }   Android Studio の [New Project] ウィザードで生成されるモジュール レベルの build.gradle.kts ファイルには、Android と Kotlin のツール バージョンが宣言されています。Compose Compiler と Kotlin Compiler のオプションは互換性がなければなりません。互換性は、Android のCompose と Kotlin の互換性マップ を参照することで確認できます。\nbuild.gradle.kts (Module: app)\nandroid { . . . kotlinOptions { jvmTarget = \u0026#34;1.8\u0026#34; } buildFeatures { compose = true // このプロジェクトで Jetpack Compose を有効にします  } composeOptions { kotlinCompilerExtensionVersion = \u0026#34;1.5.11\u0026#34; } . . . }   必要な権限と機能 Android は、権限が分離されたオペレーティング システムです。アプリで使用する ArcGIS の機能によっては、マニフェストに権限を追加する必要がある場合があります。アプリに含まれていない機能の権限を含めないようにしてください。\nアプリが Android API バージョン 22 以前で実行されている場合、インストール時にすべての権限が要求されます（許可または拒否）。アプリが Android API バージョン 23 以降で実行されている場合、アクセス許可が要求され、インストール時に自動的に付与されます。ただし、潜在的に危険な権限は実行時にリクエストする必要があり、そのためにはアプリにコードを追加する必要があります。まだ許可されていない場合は、Android フレームワークまたは Android サポート ライブラリが、権限を確認して要求するために使用されます。詳細については、アプリの権限を宣言するとアプリの権限をリクエストするをご覧ください。\nアクセス許可が必要な ArcGIS Maps SDK for Kotlin の機能  インターネットへのアクセス（ほとんどのアプリはこれを必要とします）：Android API 23 以降の標準の権限 デバイスの GPS にアクセスするための FINE_LOCATION の権限：Android API 23 以降での危険な権限  次のコード例（AndroidManifest.xml ファイルの場合）には、これらの権限が含まれています。\nAndroidManifest.xml\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_COARSE_LOCATION\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_FINE_LOCATION\u0026#34; /\u0026gt; Android のストレージと権限 Android API Level 30 では、すべてのアプリは Android デバイスのファイルシステムにアクセスするために対象範囲別ストレージを使用します。対象範囲別ストレージを使用すると、アプリは (1) 自身のファイル、および (2) メディア ストア内の共有ファイルにアクセスすることができます。下記のパーミッションの宣言は、サポートされていません。\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.WRITE_EXTERNAL_STORAGE\u0026#34; /\u0026gt; Android のストレージは、API レベル 29 以降、劇的に変化しています。Android のストレージとパーミッションの詳細については、次のリンクを参照してください。\n データ ストレージとファイル ストレージの概要 Android ストレージのユースケースとおすすめの方法 共有ストレージからメディア ファイルにアクセスする ストレージ デバイスのすべてのファイルを管理する  OpenGL ES バージョンの宣言 Android マニフェストに uses-feature 要素を追加すると、Play ストアでアプリを正しいタイプのデバイスで利用できるようになります。\nMapView（2D）を使用するアプリには、最小でも OpenGL ES 2.x が必要です。\n\u0026lt;uses-feature android:glEsVersion=\u0026#34;0x00020000\u0026#34; android:required=\u0026#34;true\u0026#34; /\u0026gt; SceneView（3D）を使用するアプリには、OpenGL ES 3.x が必要です。\n\u0026lt;uses-feature android:glEsVersion=\u0026#34;0x00030000\u0026#34; android:required=\u0026#34;true\u0026#34; /\u0026gt; 追加のダウンロード 開発プロジェクトを強化するために、サンプル コードとデータの追加リソースを利用できます。このガイドを、スタンドアロンの開発者ドキュメントとしてダウンロードすることもできます。\nサンプル コード ドキュメントでサンプルの包括的なリストを参照するか、GitHub リポジトリからサンプル コードをダウンロードしてください。\nまた、Google Play ストアからサンプル ビューアー アプリをダウンロードし、お使いのデバイスでライブ サンプルをご覧いただくこともできます。\nArcGIS Maps SDK for Kotlin Toolkit ArcGIS Maps SDK for Kotlin Toolkit には、アプリ開発を簡素化する Compose に対応したコンポーネント (コントロールとユーティリティ) が含まれています。MapView と SceneView のコンポーザブル関数を使用するには、モジュール レベルの build.gradle.kts に次の依存関係を含めます。\n GeoView-Compose：MapView と SceneView クラスのコンポーザブルな実装を提供します。  Toolkit には、Compose に対応した他の特別なコンポーネントも含まれています。\n Authenticator：ネットワークおよび ArcGIS 認証の必要なリクエストが発生すると、ユーザー インターフェイスが表示されます。 Compass：地図が回転するとコンパスがその方向を示します。地図が北を指している場合は自動的に非表示になります。 FeatureForm：外部から設定された FeatureForm API を使用して、レイヤーのフィーチャのフィールド値を編集できるようにします。 FloorFilter：GeoView で、敷地、敷地内の建物、または建物内のフロアでフロア プラン データをフィルタリングできます。  スタンドアロンの開発者向けドキュメント ダウンロード ページ から、開発者向けドキュメントをアーカイブとしてダウンロードできます。アーカイブには、ローカル Web サーバからドキュメントを提供する手順が含まれているため、インターネットに接続しなくてもドキュメントにアクセスできます。スタンドアロン ドキュメントには、開発者ガイド、API リファレンス、チュートリアル、およびサンプル ドキュメントが含まれています。このドキュメントは、ローカルのスタンドアロン コンピューターまたは内部ネットワーク上で実行するように設計されており、パブリックなインターネット上では実行できません。\nローカルでドキュメントを公開する方法：\n 使用する ArcGIS Runtime SDK のドキュメントをダウンロードします。ダウンロードしたファイルは、.zip アーカイブ形式になっています。 アーカイブをローカル フォルダに解凍します。解凍されたアーカイブには、public と install という 2 つのサブフォルダがあります。 install フォルダ内の README.md ファイルを開き、選択した Web サーバーの指示に従います。  ライブ ドキュメント サイトはリリース時及びリリースの間に定期的に更新されますが、スタンドアロン ドキュメントは静的で、最初のリリース後は更新されません。\n\r追加のデータ Projection Engine データ 測地系変換は、ある空間基準から別の空間基準へジオメトリを投影する際に、2つの空間基準の基礎となる測地系に違いがある場合に使用されます。測地系変換は、数学的に定義する（方程式ベースの変換）ことも、外部のサポート ファイルに依存する（グリッド ベースの変換）ことも可能です。アプリでグリッドベースの変換を使用する場合、Projection Engine ファイルが存在する必要があります。API は、必要なファイルがローカルのファイルシステムで利用可能かどうかを検出することができます。Projection Engine ファイルが無い状態で変換をしようとすると、エラーが発生します。API は、必要なファイルがローカル ファイル システムで利用可能かどうかを検出できます。\nグリッド ベースの変換を使用している場合は、ダウンロード ページからサポートする Projection Engine ファイルをダウンロードしてください。座標系、投影法、測地系変換の操作の詳細については、Spatial references のトピックを参照してください。\nElectronic Navigational Charts (ENC) 航海用電子海図（ENC）は、水路や海上の情報を可視化し、分析するためのジオリファレンスされたベクター データセットです。SDK は、国際水路機関（IHO）の S-57 規格 に準拠した ENC をサポートしています。\n航海用電子海図 (ENC) を使用する場合は、ダウンロード ページから hydrography データをダウンロードします。ENC データの操作の詳細については、Display electronic navigational charts のトピックを参照してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/dotnet/install-dotnet-200.x/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for .NET のインストールとセットアップ手順を紹介します。",
	"content": "出典：ArcGIS Maps SDK for .NET - Guide - Install and set up\nこのインストール ガイドでは、ArcGIS Maps SDK for .NET (バージョン 200.x) のインストールとセットアップ手順を紹介します。マップを表示する方法については「アプリの作成」のチュートリアルをご覧ください。\nインストールとセットアップ ArcGIS Maps の機能を .NET アプリケーションに組み込むには、1 つ以上の ArcGIS Maps SDK for .NET NuGet パッケージ への参照を Visual Studio プロジェクト内に追加します。ArcGIS Maps SDK for .NET がサポートするアプリケーション プラットフォームおよび UI フレームワークのそれぞれに対応するプロジェクト テンプレート セットは、Visual Studio 拡張機能 として提供されています。\nプロジェクトでの ArcGIS Maps SDK for .NET の参照 ArcGIS Maps SDK for .NET NuGet パッケージは、NuGet.org でホストされています。NuGet を使用して Visual Studio でパッケージを使用するには、Microsoft のドキュメントにある Visual Studio にパッケージをインストールして使用する (Windows) または Visual Studio にパッケージをインストールして使用する (Mac) を参照してください。\n  [Visual Studio Solution Explorer] ウィンドウで、[Project] を右クリックし、[Manage NuGet Packages] を選択します。\n  [Browse] タブを選択し、パッケージソースとして [nuget.org] を選択します。\n  検索テキスト ボックスに「Esri」と入力します。ArcGIS Maps SDK for .NET がサポートするさまざまなフレームワークが表示されます。\n  インストールする NuGet パッケージを選択し、[インストール] ボタンをクリックします。NuGet パッケージ マネージャーの詳細については、Microsoft ドキュメントの NuGet パッケージ マネージャーを使用して Visual Studio にパッケージをインストールして管理する を参照してください。\n  [変更のプレビュー] ダイアログで内容を確認し、[OK] を選択してインストールを進めてください。\n  インストールが完了すると、NuGet パッケージ マネージャーの [インストール済み] タブに追加したパッケージが表示され、ArcGIS Maps SDK for .NET を使用して開発できるようになります。\n  Toolkit ArcGIS Maps SDK for .NET Toolkit には、ユーザー インターフェイス（UI）コントロールとコンポーネントが含まれており、すぐに使用したり、アプリ用にカスタマイズしたりできます。Toolkit は、NuGet パッケージとしてプロジェクトに含めることも、GitHub リポジトリからソース コードを入手して自分でビルドすることもできます。\nVisual Studio プロジェクト テンプレートのインストール（オプション） 拡張機能のインストール Visual Studio（Windows）用の ArcGIS Maps SDK for .NET プロジェクト テンプレート 拡張機能は、Android、iOS、および Windows 用のアプリケーション プロジェクト テンプレートを提供します。プロジェクト テンプレートは、各プラットフォームに適した NuGet パッケージを参照し、Model-View-ViewModel（MVVM）デザイン パターンを使用します。拡張機能の使用方法の詳細については、Microsoft のドキュメントの Visual Studio の機能拡張を管理する のトピックを参照してください。\nWPF、WinUI、.NET MAUI プロジェクト テンプレートには、Visual Studio 17.8 以降が必要です。Visual Studio for Mac はサポートされなくなりました。Windows では Visual Studio からテンプレートを使用して ArcGIS Maps SDK for .NET アプリを作成できます。MacOS では、コマンド ライン インターフェイスからテンプレートを使用してアプリを作成します。\n\r.NET Framework プロジェクト テンプレートなど、すぐに使用できる Visual Studio テンプレートの一部は PackageReference をサポートしていますが、現在、プロジェクトによって参照されるパッケージのリストを維持するために packages.config が既定になっています。packages.config を使用すると、バージョンをアップグレードするときに問題が発生する可能性があります。このような状況を軽減するには、Microsoft の推奨に従って、packages.config から PackageReference に移行 することを検討してください。\n\r  Visual Studio で、[拡張機能] メニュー \u0026gt; [拡張機能の管理] を選択して、[拡張機能の管理] ダイアログを表示します。\n  [検索] テキスト ボックスに、「ArcGIS」と入力します。\n  [ArcGIS Maps SDK for .NET Project Templates] 拡張機能を選択し、[ダウンロード] を選択します。この拡張機能のインストールがスケジュールされて、Visual Studio のすべてのインスタンスが終了した後にインストールされます。\n  [拡張機能の管理] ダイアログを閉じます。\n  Visual Studio を閉じ、拡張機能をインストールします。\n  Visual Studio を閉じた時に表示される [VSIX インストーラー] ダイアログで [変更] をクリックします。\n  インストールが完了したら、インストーラー ダイアログで [閉じる] をクリックします。\n  次回、Visual Studio で [新しいプロジェクトの作成] を選択すると、使用可能なすべてのプラットフォームの ArcGIS のプロジェクト テンプレートが表示されます。\n  ArcGIS Maps SDK App, Packaged (WinUI 3 in Desktop) テンプレートでは、Single-project MSIX Packaging Tools for VS 2022 もインストールされている必要があります。\n\rNuget パッケージからインストールする nuget.org で公開されている Esri.ArcGISRuntime.ProjectTemplates NuGet パッケージは .NET MAUI（iOS、Android、WinUI）、WPF、WinUI、および UWP 用のアプリケーション プロジェクト テンプレートを提供します。\n以下の手順に従って、コマンドライン インターフェイスを使用してプロジェクト テンプレートをインストールします：\n  コマンドプロンプトを開きます。\n  以下のコマンドを使用して、新しいテンプレートをインストールします：\ndotnet new --install Esri.ArcGISRuntime.ProjectTemplates   テンプレートがインストールされたら、Visual Studio を開き、ArcGIS Maps SDK .NET MAUI App の新しくインストールした .NET MAUI テンプレートを選択します。または、次のコマンドを使用して、新しい ArcGIS Maps SDK .NET MAUI App を作成します。\ndotnet new mauimap   追加のダウンロード サンプルコード、データ、コンポーネント の追加のリソースを利用できます。また、ガイドを ダウンロード して、オフラインで利用することも可能です。\nサンプル コード アプリケーションに追加できるさまざまな ArcGIS Maps の強力な機能を説明するサンプル コードを入手できます。サンプルを検索し、サンプル ドキュメント で関連するコードを参照するか、サンプル リポジトリ からソース コードをダウンロードして、サンプルをローカルに構築および実行できます。\nコンパイル済みのサンプル ビューアー アプリ (WPF 版) は、Microsoft ストア から入手できます。 アプリを実行する前に、システム要件を参照して、正常に実行できることを確認してください。\nLocal Server ArcGIS Maps SDK for Local Server では、オフラインでジオプロセシング タスクを実行して、アプリケーションで高度な空間解析とデータ操作を行うことができます。これらのタスクは、ArcGIS Enterprise で実行されるジオプロセシング タスクと同じように動作します。 アプリケーションでオフラインでジオプロセシング タスクを実行する場合は、Local Server のトピックの手順に従って Local Server をインストールします。\n追加のデータ Projection Engine データ 測地系変換は、ある空間基準から別の空間基準へジオメトリを投影する際に、2つの空間基準の基礎となる測地系に違いがある場合に使用されます。測地系変換は、数学的に定義する（方程式ベースの変換）ことも、外部のサポート ファイルに依存する（グリッド ベースの変換）ことも可能です。アプリでグリッドベースの変換を使用する場合、Projection Engine ファイルが存在する必要があります。API は、必要なファイルがローカルのファイルシステムで利用可能かどうかを検出することができます。Projection Engine ファイルが無い状態で変換をしようとすると、エラーが発生します。API は、必要なファイルがローカル ファイル システムで利用可能かどうかを検出できます。\nグリッド ベースの変換を使用している場合は、ダウンロード ページからサポートする Projection Engine ファイルをダウンロードしてください。座標系、投影法、測地系変換の操作の詳細については、Spatial references のトピックを参照してください。\nElectronic Navigational Charts (ENC) 航海用電子海図（ENC）は、水路や海上の情報を可視化し、分析するためのジオリファレンスされたベクター データセットです。SDK は、国際水路機関（IHO） の S-57 規格に準拠した ENC をサポートしています。\n航海用電子海図 (ENC) を使用する場合は、Esri.ArcGISRuntime.Hydrography NuGet パッケージをアプリに追加するか、ダウンロード ページから hydrography データをダウンロードします。ENC データの操作の詳細については、Display electronic navigational charts のトピックを参照してください。\nArcGIS Maps SDK for .NET を使用したオフライン環境での開発 NuGet パッケージとプロジェクト テンプレート オンライン アクセスが制限された環境でアプリを開発している場合は、ローカルの NuGet パッケージ フィードから ArcGIS Maps SDK for .NET を参照することができます。 NuGet.org で公開されている NuGet パッケージのサブセットを含む、追加の Visual Studio (Windows) 拡張機能を利用できます。 この拡張機能をインストールすると、ユーザー プロファイルの %localappdata%\\Esri\\NuGet の下にローカル NuGet パッケージ ソースが構成されます。 詳細については、Microsoft のドキュメントの ローカル NuGet パッケージ フィード を参照してください。\nこのリリースでは、WPF、WinUI、.NET MAUI プロジェクト テンプレートには Visual Studio 17.8 以降が必要です。\n\rVisual Studio 拡張機能をダウンロードしてインストールする プロジェクト テンプレート拡張機能と NuGet パッケージ拡張機能の両方を、ダウンロードページ からダウンロードできます。\n  開発マシンからアクセスできる場所にファイルを保存します。\n  ダウンロードした Visual Studio 拡張機能をインストールするには、.vsix ファイルをダブルクリックします (またはファイルを選択して Enter キーを押します)。\n  複数のバージョンの Visual Studio がインストールされている場合、VSIX インストーラー ダイアログには、拡張機能をインストールするために使用できる Visual Studio 製品 (Visual Studio Enterprise 2022 など) のリストが表示されます。 ターゲットの Visual Studio インスタンスを選択し、ライセンス条項を確認して [インストール] を選択します。\n  インストールが完了すると、選択した製品の確認が表示されます。 [閉じる] を選択して、インストールを終了します。 インストールしたら、Visual Studio の [拡張機能の管理] ダイアログを使用して、拡張機能を有効化、無効化、またはアンインストールします。 詳細については、Microsoft ドキュメントのトピック [拡張機能の管理] ダイアログ ボックスを使用しないインストール を参照してください。\n  ローカルの Esri パッケージ ソースから NuGet パッケージをインストールする ローカルの Esri パッケージ ソースから NuGet パッケージをインストールするには、次の手順に従います。\n  Visual Studio ソリューション エクスプローラー ウィンドウで、[プロジェクト] を右クリックし、[NuGet パッケージの管理] を選択します。\n  [参照] タブを選択し、パッケージ ソースとして [Esri] を選択します。\n  ArcGIS Maps SDK for .NET でサポートされているさまざまなフレームワーク用の NuGet パッケージがいくつか表示されます。\n  インストールする NuGet パッケージを選択し、[インストール] ボタンをクリックします。 NuGet パッケージ マネージャーの詳細については、Microsoft ドキュメントの NuGet パッケージ マネージャーを使用して Visual Studio にパッケージをインストールして管理する を参照してください。\n  [変更のプレビュー] ダイアログの内容を確認し、[OK] を選択してインストールを続行します。\n  インストールが完了すると、追加されたパッケージが NuGet パッケージ マネージャーの [インストール済み] タブに表示され、ArcGIS Maps SDK for .NET を使用して開発できるようになります。\n  スタンドアロンの開発者向けドキュメント ダウンロード ページ から、開発者向けドキュメントをアーカイブとしてダウンロードできます。アーカイブには、ローカル Web サーバからドキュメントを提供する手順が含まれているため、インターネットに接続しなくてもドキュメントにアクセスできます。スタンドアロン ドキュメントには、開発者ガイド、API リファレンス、チュートリアル、およびサンプル ドキュメントが含まれています。このドキュメントは、パブリックなインターネット上ではなく、ローカルのスタンドアロン コンピューターまたは内部ネットワーク上で実行するように設計されています。\nローカルでドキュメントを公開する方法：\n 使用する SDK のドキュメントをダウンロードします。ダウンロードしたファイルは、.zip アーカイブ形式になっています。 アーカイブをローカル フォルダに解凍します。解凍されたアーカイブには、public と install という 2 つのサブフォルダがあります。 install フォルダ内の README.md ファイルを開き、選択した Web サーバーの指示に従います。  ライブ ドキュメント サイトはリリース時及びリリースの間に定期的に更新されますが、スタンドアロン ドキュメントは静的で、最初のリリース後は更新されません。\n\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/ios/install-ios-200.x/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for Swift のインストールとセットアップ手順を紹介します。",
	"content": "出典：ArcGIS Maps SDK for Swift - Guide - Install and set up\nこのインストール ガイドでは、ArcGIS Maps SDK for Swift (バージョン 200.x) のインストールとセットアップ手順を紹介します。マップを表示する方法については「アプリの作成」のチュートリアルをご覧ください。\nSwift Package Manager Swift Package Manager を使用して Xcode プロジェクトに簡単に統合できます。\nXcode 15 での手順\n Xcode プロジェクトを開きます。メニューバーで、[File] \u0026gt; [Add Package Dependencies\u0026hellip;] を選択します。   パッケージ リポジトリの URL として https://github.com/esri/arcgis-maps-sdk-swift を入力します。\n  オプションとして、正確なバージョンまたは使用するバージョンの範囲を指定したい場合は、Dependency Rule オプションを選択します。\n  [Add Package] をクリックします。\n  [Add to Target] リストからアプリを選択します。[Add Package] をクリックします。\n  ターゲットでアプリを選択します。[Frameworks, Libraries, and Embedded Content] で + 記号をクリックし、\u0026ldquo;ArcGIS\u0026rdquo; がまだ存在しない場合は追加します。  ArcGIS の API を使用するには、次のインポートステートメントを任意の Swift コード（.swift）ファイルに追加します。\nimport ArcGIS 追加のダウンロード 開発プロジェクトを強化するために、サンプル コードとデータ、ツール の追加リソースを利用できます。このガイドを、スタンドアロンの開発者ドキュメントとしてダウンロードすることもできます。\nサンプル コード 独自のアプリケーションに追加できるさまざまな強力な機能を紹介する実践的なサンプル コードを入手してください。サンプルを検索し、サンプル ドキュメントで関連するコードを参照するか、サンプル リポジトリからコードをダウンロードしてローカルで実行できます。\nArcGIS Maps SDK for Swift Toolkit ArcGIS Maps SDK for Swift Toolkit は、ArcGIS Maps SDK for Swift チームによって管理されているオープン ソース プロジェクトであり、アプリ開発を簡素化するためのコントロールとユーティリティが含まれています。 Examples プロジェクトでこれらのコンポーネントの動作を確認するか、ドキュメントを読んで詳細を確認できます。\nスタンドアロンの開発者向けドキュメント ダウンロード ページ から、開発者向けドキュメントをアーカイブとしてダウンロードできます。アーカイブには、ローカル Web サーバからドキュメントを提供する手順が含まれているため、インターネットに接続しなくてもドキュメントにアクセスできます。スタンドアロン ドキュメントには、開発者ガイド、API リファレンス、チュートリアル、およびサンプル ドキュメントが含まれています。このドキュメントは、ローカルのスタンドアロン コンピューターまたは内部ネットワーク上で実行するように設計されており、パブリックなインターネット上では実行できません。\nローカルでドキュメントを公開する方法：\n 使用する SDK のドキュメントをダウンロードします。ダウンロードしたファイルは、.zip アーカイブ形式になっています。 アーカイブをローカル フォルダに解凍します。解凍されたアーカイブには、public と install という 2 つのサブフォルダがあります。 install フォルダ内の README.md ファイルを開き、選択した Web サーバーの指示に従います。  ライブ ドキュメント サイトはリリース時及びリリースの間に定期的に更新されますが、スタンドアロン ドキュメントは静的で、最初のリリース後は更新されません。\n\r追加のデータ Projection Engine データ 測地系変換は、ある空間基準から別の空間基準へジオメトリを投影する際に、2つの空間基準の基礎となる測地系に違いがある場合に使用されます。測地系変換は、数学的に定義する（方程式ベースの変換）ことも、外部のサポート ファイルに依存する（グリッド ベースの変換）ことも可能です。アプリでグリッドベースの変換を使用する場合、Projection Engine ファイルが存在する必要があります。Projection Engine ファイルが無い状態で変換をしようとすると、エラーが発生します。API は、必要なファイルがローカル ファイル システムで利用可能かどうかを検出できます。\nグリッド ベースの変換を使用している場合は、ダウンロード ページからサポートする Projection Engine ファイルをダウンロードしてください。座標系、投影法、測地系変換の操作の詳細については、Spatial references のトピックを参照してください。\nElectronic Navigational Charts (ENC) 航海用電子海図（ENC）は、水路や海上の情報を可視化し、分析するためのジオリファレンスされたベクター データセットです。SDK は、国際水路機関（IHO）の S-57 規格 に準拠した ENC をサポートしています。\n航海用電子海図 (ENC) を使用する場合は、ダウンロード ページから hydrography データをダウンロードします。ENC データの操作の詳細については、Display electronic navigational charts のトピックを参照してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/install-guide/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Web AppBuilder (Developer Edition) をインストールする手順を紹介します。",
	"content": "ArcGIS Web AppBuilder は ArcGIS Online あるいは Portal for ArcGIS に組み込まれた機能として提供されており、ウィジェット（機能）やテーマ（デザイン）を組み合わせることにより、GIS やプログラミングなどの専門知識がなくても誰でも簡単に Web アプリケーションを作成できるソフトウェアです。 Developer Edition（開発者向けエディション）はこれらの機能に加え、開発者のためにウィジェットやテーマを独自に開発するためのフレームワークを提供します。また、作成したアプリケーションをダウンロードし、独自のサーバーにホストすることも可能です。\nここでは、ArcGIS Web AppBuilder (Developer Edition) (以下 Web AppBuilder) のインストール手順を説明します。\n インストール Web AppBuilder の起動 ポータル URL の指定 アプリケーション ID の設定 インストールの確認  インストール  Web AppBuilder の ZIP ファイルをローカルにダウンロードし、解凍します。\nサインイン ページが表示される場合は、ArcGIS Developers 開発者アカウント（あるいは ArcGIS Online 組織向けプランのアカウント）のユーザー名およびパスワードを入力しサインインします。 Web AppBuilder は Node.js 上で動作するため、インストールする端末に Node.js が必要です。Web AppBuilder のインストール ファイルには Windows バージョンの Node.js が含まれていますが、Mac や Linux など他の OS をお使いの場合は Web AppBuilder を起動する前に Node.jsをインストールする必要があります。  ArcGIS API for JavaScript の参照先を変更する（オプション） Web AppBuilder はデフォルトでは Esri の CDN で配信されている ArcGIS API for JavaScript を参照します。そのため、インターネットに接続できない環境で Web AppBuilder を使用する場合、ArcGIS API for JavaScript の参照先を変更する必要があります。ここでは Portal for ArcGIS に内蔵されている ArcGIS API for JavaScript へ参照先を変更する手順を説明します。\n \u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\client\\stemapp\\env.js ファイルをテキストエディターで開きます。 //apiUrl を検索します。   API のバージョンは Web AppBuilder のバージョンにより異なります。通常、Web AppBuilder がリリースされた時点の最新バージョンの API が使われています。  apiUrl= \u0026quot;https://\u0026lt;ポータル URL\u0026gt;/jsapi/jsapi/\u0026quot; に書き換え、上書き保存します。   Portal for ArcGIS が内蔵する API を使用する際は、内蔵されている API のバージョンに注意が必要です。Web AppBuilder が使用する API のバージョンと異なるバージョンの API の利用はサポートされません。\nWeb AppBuilder のバージョンと API のバージョンの関係については About release versions を参照ください。  Web AppBuilder の起動  Web AppBuilder を起動します。   Windows 端末\nWindows をお使いの場合、解凍したフォルダーにある startup.bat ファイルをダブルクリックします。このバッチファイルはコマンド プロンプト上で Node.js サーバーを起動します。 その他の端末 Windows 以外のマシンにインストールする場合は、直接 Node.js サーバーを起動するコマンドを実行します。\nコマンド プロンプトを開き、\u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\server のパスを指定します。続けて node server.js と入力します。\nWeb AppBuilder は Web ブラウザーで http://[マシン名]:3344/webappbuilder にアクセスすると起動します。コマンド プロンプト上で Node.js が起動している間はいつでも、どの Web ブラウザーからでも Web AppBuilder を開くことができます。利用するマシンがドメインに参加しているとき、Web AppBuilder へのアクセスにドメインを含める必要がある場合があります。その際は、http://[マシン名].[ドメイン]:3344/webappbuilder のようにドメインを含めてアクセスしてください。  Node.js がデフォルトで使用するポート番号は 3344 です。パラメーターを追加したり、他のポート番号を割り当てたり、Windows サービスとして起動したりしたい場合は、以下の手順を参照してください。    パラメーターを追加し、他のポート番号を割り当てる\n コマンド プロンプトを開き、Web AppBuilder のサーバー ディレクトリ（\u0026lt;Web AppBuilderのインストール ディレクトリ\u0026gt;\\server）へ移動します。割り当てたいポート番号と必要に応じてプロキシの URL を入力します。  64 ビット版 Windows\nnode_x64.exe server.js [-port=value] [-proxy=value] 32 ビット版 Windows\nnode_x32.exe server.js [-port=value] [-proxy=value] その他のマシン\nnode server.js [-port=value] [-proxy=value]   Web ブラウザーを開き、上記で設定したポート番号を指定し、Web AppBuilder を起動します。\nhttp://[マシン名]:[ポート番号]/webappbuilder    Windows サービスとして起動する\nWeb AppBuilder は、startup.bat ファイルをクリックして起動させるほかに、Windows サービスとして起動させることもできます。\n Windows プラットフォームに Node.js をインストールします。 管理者としてコマンドプロンプトを開きます。 Web AppBuilder のサーバー ディレクトリ（\u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\server）へ移動します。 npm install コマンドを実行します。 npm run-script install-windows-service コマンドを実行します。 Windows の [サービス] ウィンドウを開き、ArcGISWebAppBuilder サービスを起動します。 ArcGISWebAppBuilder サービスを削除するには、npm run-script uninstall-windows-service コマンドを実行します。 プロキシを利用したい場合は、/~server/package.json ファイルを開き、\u0026quot;start\u0026quot;: \u0026quot;node server.js\u0026quot; を \u0026quot;start\u0026quot;: \u0026quot;node server.js -proxy=\u0026lt;http://your proxy\u0026gt;\u0026quot; に変更してください。    ポータル URL の指定   Web AppBuilder で使用するアカウントに紐づく ArcGIS Online またはPortal for ArcGIS の URL を指定します。開発者アカウントをご利用の方は、ArcGIS for Developers の [Account Settings] ページにて URL をご確認ください。\n  [続行] をクリックします。Web 層認証を使用している場合、次のセクションはスキップしてください。ログイン後、インストールの確認をしてください。\nArcGIS Online または Portal for ArcGIS で OAuth2 認証を使用する場合は、次のセクションでアプリケーション ID を設定する必要があります。\n  アプリケーション ID の設定 上記で指定した ArcGIS Online または Portal for ArcGIS ではじめて Web AppBuilder を使用する場合、OAuth2 認証を利用できるようにするため、アプリケーション ID を設定する必要があります。\nアプリケーション ID を入手するには ArcGIS Online または Portal for ArcGIS に Web AppBuilder をアイテムとして追加します。\n  指定したポータルへログインします。\n  コンテンツ ページの[マイコンテンツ] を開きます。[新しいアイテム] をクリックし、[アプリケーション] を選択します。\n  ダイアログボックスで、[アプリケーションタイプ] に Web マッピング、[URL] オプションに Web AppBuilder の URL を入力し [次へ] をクリックします。\n   任意のタイトル、保存先のフォルダー、タグとサマリーを設定し、 [保存] をクリックします。これで Web AppBuilder はアイテムとしてポータルに追加されました。\n  アイテムの追加が完了すると、追加したアイテムの詳細情報のページが表示されます。\n ArcIGS Online：[設定] タブをクリックします。[アプリケーションの登録] セクションまでスクロールし、[登録] をクリックします。 Portal for ArcGIS：[アプリケーションの登録] セクションまでスクロールし、[登録] をクリックします。    [登録] ダイアログが表示されます。[リダイレクト URI] オプションに http://[マシン名] または https://[マシン名] を入力して、[追加] をクリックします。HTTP と HTTPS プロトコルは異なる URI として認識されることに注意してください。リダイレクトに関する問題を避けるため、両方のプロトコルを登録することを推奨しています。\n  [登録] をクリックします。これでアプリケーションの登録は完了です。\n  Web AppBuilder の起動画面に戻ります。[アプリケーション ID] オプションに入手したアプリケーション ID を入力し、[続行] をクリックします。\nInvalid redirect_uri エラー ページが表示される場合は、以下の手順に従ってください。\nアプリケーション ID を入手する際に登録したリダイレクト URI に誤りがある場合、アプリケーション ID オプションにアプリケーション ID を入力し、[続行] をクリックすると、エラー ページが表示されることがあります。この場合、登録したアプリケーションの情報を修正する必要があります。\n Web AppBuilder のサーバー ディレクトリ（\u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\server）を開き、signininfo.json ファイルを削除します。 手順 3 に戻り、入力したリダイレクト URI を更新するか、アプリケーションを新しく登録して、新しいアプリケーション ID を入手します。 起動中の Web AppBuilder のページを再読み込みします。 [アプリケーション ID] オプションにアプリケーション ID を入力し、[続行] をクリックします。    [権限のリクエスト] ダイアログが表示されます。表示されたアカウント情報が正しいことを確認し [承認] をクリックします。\n  アプリケーション ID は OAuth2 認証に必要です。詳細は 認証をご参照ください。ログインに関する問題は、FAQs および アプリの追加とアプリの登録をご参照ください。\nWeb AppBuilder は、デフォルトで HTTPS をサポートするために Node.js で自己署名証明書を使用しています。\n独自に用意した証明書を使用したい場合は、Web AppBuilder のサーバー ディレクトリ（\u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\server）にある cakey.pem と cacert.pem を置き換えてください。\nアプリケーション ID の登録手順の説明は以上です。これで 登録先のポータルへ OAuth2 認証を使用してサインインできるようになりました。次回からは Web AppBuilder を起動すると直接 Web AppBuilder のトップページが表示されます。\nこれで Web AppBuilder のインストールは終了です。\nインストールの確認 ここでは Web AppBuilder が正常にインストールされていることを確認するために、アプリケーションの起動確認を行います。\n Web AppBuilder を起動します。 トップページが表示されたら [新規作成] をクリックします。 [デフォルト（2D）] を選択し、[次へ] をクリックします。 新しい Web アプリの作成ページが開きます。任意のタイトルと説明を入力して [OK] をクリックします。 アプリケーションの作成のページが表示されたらインストールの確認は完了です。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/install-and-setup/",
	"title": "インストールおよびセットアップ方法",
	"tags": [],
	"description": "インストールおよびセットアップの方法を紹介します。",
	"content": "出典：ArcGIS Maps SDK for JavaScript - Install and set up\nインストールおよびセットアップ API へのアクセス ArcGIS Maps SDK for JavaScript をアプリに導入するには、複数のオプションがあります。AMD および ES モジュールの詳細については、Introduction to Tooling を参照してください。\nArcGIS CDN による AMD モジュール API にアクセスする最も一般的な方法は、ホスト型のバージョンを使用することです。Esri の CDN から API と CSS を参照して、アプリでの API の使用を開始してください。\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.29/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.29/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; NPM による ES モジュール JavaScript API は、npm（JavaScriptのパッケージマネージャー）を使っても利用できます。ローカルに API をインストールして、React や Angular などの JavaScript フレームワークや、webpack や rollup.js などのモジュールバンドラーで利用することができます。\nインストール方法：\nnpm install @arcgis/core モジュールのインポート：\nimport Map from \u0026#34;@arcgis/core/Map.js\u0026#34;; CSS のインポート：\n/* URL 文字列を使用した CSS */ @import \u0026#34;https://js.arcgis.com/4.29/@arcgis/core/assets/esri/themes/light/main.css\u0026#34;; 詳細については、以下のガイドを参照してください。\n ツールの紹介 ES モジュールの構築  CDN による ES モジュール ※ この方法は、現在のところ、開発やプロトタイピングにのみ推奨されています。\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.29/@arcgis/core/assets/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import Map from \u0026#34;https://js.arcgis.com/4.29/@arcgis/core/Map.js\u0026#34;; // Use the Map class \u0026lt;/script\u0026gt; ローカルにホストされる AMD モジュール 場合によっては、ArcGIS CDN を介して AMD モジュールのローカルにホストされたバージョンを使用する必要があります。この例は、インターネットにアクセスできない制限されたネットワーク環境で作業している場合です。また、API リファレンス、チュートリアル、およびサンプルを含むドキュメントをダウンロードしてインストールすることもできます。ダウンロード可能なドキュメントは、バージョン 4.29 のリリース日からのスナップショットであり、最新のサンプル アップデートやドキュメントの修正などは含まれていません。\nArcGIS Maps SDK for JavaScript およびそのドキュメントをダウンロードするには、ArcGIS Maps SDK for JavaScript のダウンロード ページに移動し、Esri グローバル アカウントでログインします。\nWeb サーバーのホスティング設定 ArcGIS Maps SDK for JavaScript をホストする Web サーバのホスティング構成では、以下の MIME/type 登録が必要です。\n   エクステンション MIME/type 説明     .ttf application/octet-stream True Type フォント   .wasm application/wasm WebAssembly   .woff application/font-woff Web Open Font Format   .woff2 application/font-woff2 WOFF File Format 2.0   .wsv application/octet-stream Scene View の星の可視化に対応   .pbf application/x-protobuf 一部のレイヤーの MapView ラベル用のフォント    なお、HTTPS をサポートする Web サーバーでは、SSL Web サーバー証明書を使用する必要があります。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/unity/install-and-set-up/",
	"title": "インストールガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for Unity のインストールとセットアップ手順を紹介します。",
	"content": "出典：ArcGIS Maps SDK for Unity - Guide - Install and set up\nこのインストール ガイドでは、ArcGIS Maps SDK for Unity のインストールとセットアップ手順を紹介します。マップを表示する方法については「アプリの作成」のチュートリアルをご覧ください。\nインストールおよびセットアップ方法 ArcGIS Maps SDK for Unity は Unity 用のプラグインです。ArcGIS Maps SDK for Unity を使用して ArcGIS の実世界のマップや 3D コンテンツを使用した 3D GIS アプリケーションを作成するには、Unity プロジェクトを準備する必要があります。作業を開始する前に、必ずプラグインをダウンロードしてください。\nUnity のインストール このプラグインは Unity 2021.3.x と 2022.3.x LTS でサポートしています。インストールされていない場合は、Unity をインストールしてください。\nプラグインのインストール ArcGIS Maps SDK for Unity を使用するには、新規プロジェクトまたは既存プロジェクト (英語) のいずれかにプラグインをインストールします。\nシーン設定オプションの選択 プラグインには、シーン内で ArcGIS データやその他の地理空間コンテンツを使用するための 3 つのオプションが用意されています：\n Map Creator UI では、コードを記述せずにシーンを作成できます。 Components では、シーン内のゲームオブジェクトにアタッチできます。 C# API では、プラグインのソース コードを変更することでカスタマイズ オプションを提供します。  追加のダウンロード ダウンロードページから、開発者向けドキュメントをアーカイブ形式としてダウンロードできます。ドキュメントには、開発者ガイド、API リファレンス、チュートリアル、サンプルドキュメントが含まれています。アーカイブには、インターネットに接続しなくてもドキュメントにアクセスできるように、ローカルのウェブ サーバーからドキュメントにアクセスする手順が記述されています。このドキュメントは、ローカルのコンピュータまたは内部ネットワーク上で実行するように設計されており、公共のインターネット上では実行できません。\nローカルでドキュメントを使用するには:\n ArcGIS Maps SDK for Unity のドキュメントをダウンロードします。ダウンロードしたファイルは zip アーカイブ形式です。 アーカイブをローカル フォルダーに解凍1します。解凍したアーカイブには、public と install という 2 つのサブ フォルダーがあります。 install フォルダー内の README.md ファイルを開き、選択した Web サーバーの指示に従います。    パスが長いため、そのままだと Windows の標準機能で解凍できません。他のフリーソフトを用いるかフォルダーやファイルの名前を変更して解凍を行ってください。 \u0026#x21a9;\u0026#xfe0e;\n   "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/unreal-engine/install-and-set-up/",
	"title": "インストールガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for Unreal Engine のインストールとセットアップ手順を紹介します。",
	"content": "出典：ArcGIS Maps SDK for Unreal Engine - Guide - Install and set up\nこのインストール ガイドでは、ArcGIS Maps SDK for Unreal Engine のインストールとセットアップ手順を紹介します。マップを表示する方法については「アプリの作成」のチュートリアルをご覧ください。\nインストールおよびセットアップ方法 ArcGIS Maps SDK for Unreal Engine は Unreal Engine 用のプラグインです。ArcGIS Maps SDK for Unreal Engine を使用して ArcGIS の実世界のマップや 3D コンテンツを使用した 3D GIS アプリケーションを作成するには、Unreal プロジェクトを準備する必要があります。作業を開始する前に、必ずプラグインをダウンロードしてください。\nUnreal Engine のインストール このプラグインは、Unreal Engine 5.0、5.1、5.2、および 5.3 をサポートしています。インストールされていない場合は、Unreal Engine をインストールしてください。Visual Studio for Unreal Engine の設定については、Unreal Engine 5 のドキュメントを参照してください。\nプラグインのインストール ArcGIS Maps SDK for Unreal Engine を使用するには、新規プロジェクトまたは既存プロジェクト (英語) のいずれかにプラグインをインストールします。\nシーン設定オプションを選択する SDK には、シーン内で ArcGIS データやその他の地理空間コンテンツを使用するための 4 つのオプションが用意されています：\n Modes Panel UI は、コードを記述せずにシーンを作成できます。 Components は、Modes Panel UI の背後にあり、コードを記述せずにシーンを作成できます。 BluePrints は、Unreal Engine で提供されているノードベースのビジュアルスクリプトインターフェイスを使用してシーンを作成するオプションを提供します。 C++ API は、プラグインのソースコードを変更することでカスタマイズオプションを提供します。  追加のダウンロード ダウンロードページから、開発者向けドキュメントをアーカイブ形式としてダウンロードできます。ドキュメントには、開発者ガイド、API リファレンス、チュートリアル、サンプル ドキュメントが含まれています。アーカイブには、インターネットに接続しなくてもドキュメントにアクセスできるように、ローカルのウェブ サーバーからドキュメントにアクセスする手順が記述されています。このドキュメントは、ローカルのコンピュータまたは内部ネットワーク上で実行するように設計されており、公共のインターネット上では実行できません。\nローカルでドキュメントを使用するには:\n ArcGIS Maps SDK for Unreal Engine のドキュメントをダウンロードします。ダウンロードしたファイルは zip アーカイブ形式です。 アーカイブをローカル フォルダーに解凍します。解凍したアーカイブには、public と install という 2 つのサブ フォルダーがあります。 install フォルダー内の README.md ファイルを開き、選択した Web サーバーの指示に従います。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/",
	"title": "スタートアップ ガイド",
	"tags": [],
	"description": "開発を始める方のために必要なアカウントの作成、API キーの取得、ロケーションサービスの利用、各 API / SDK を使った開発の基本的な流れからセキュリティ、運用（ライセンス認証）まで手順にそって学べる情報をまとめています。",
	"content": "ArcGIS Developers の更新に伴い、本ページも近日更新予定です。 開発者アカウントの新規作成については、新しい Esri Developer サイトの Get Started (英語) をご参照ください。\n\r開発を始める方のために「開発者アカウントの作成、API キーの取得、ロケーションサービスの利用、API / SDK を利用したアプリ開発、セキュリティ、運用（ライセンス認証）」と ArcGIS Platform を利用した開発の基本的な流れを紹介しています。\n 開発者アカウントの作成\nArcGIS Developers の利用を開始するために新規アカウントを作成する手順を紹介します。\n\r\r\r API キーの取得\nアプリケーションを公開するために必要な API キーを取得する手順について紹介します。\n\r\r\r ロケーションサービスの利用\nArcGIS Platform をはじめて使う方向けにロケーションサービスの紹介やフィーチャ サービス、Web マップを作成する方法について紹介します。\n\r\r フィーチャサービスの作成\nデータの検索や編集が可能な地図サービス (REST API) の配信方法を紹介します。\n\r Web マップの作成\nさまざまなフォーマットのデータを 1 つのマップとして集約し、それを可視化する方法を紹介します。\n\r ルートの検索\nマッピングAPI＆ロケーションサービス内のルーティング＆ディレクションズについて紹介します\n\r ベースマップ\nマッピングAPI＆ロケーションサービス内のベースマップについて紹介します\n\r\r アプリ開発\nシンプルな地図アプリの作成方法を紹介します。\n\r\r ArcGIS Maps SDK for JavaScript\nArcGIS Maps SDK for JavaScript を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。\n\r Esri Leaflet\nEsri leaflet を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。\n\r MapLibre GL JS\nMapLibre GL JS を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。\n\r OpenLayers\nOpenLayers を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。\n\r CesiumJS\nCesiumJS を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。\n\r Android\nArcGIS Maps SDK for Kotlin を用いたネイティブ地図アプリの作成方法を紹介します。\n\r iOS\nArcGIS Maps SDK for Swift を用いたモバイル地図アプリの作成方法を紹介します。\n\r .NET\nArcGIS Maps SDK for .NET を用いたネイティブ地図アプリの作成方法を紹介します。\n\r Unity\nArcGIS Maps SDK for Unity を用いたネイティブ地図アプリの作成方法を紹介します。\n\r Unreal Engine\nArcGIS Maps SDK for Unreal Engine を用いたネイティブ地図アプリの作成方法を紹介します。\n\r\r セキュリティと認証の紹介\nAPI キー、ユーザー認証、アプリ認証を使用して、サービスやセキュアなリソースに認証済みのリクエストを行う方法について説明します。\n\r\r\r デプロイの紹介\n開発したアプリをデプロイするために必要なライセンスや利用規約などについて紹介します。\n\r\r\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/visualization/workflow-with-arcgis/",
	"title": "データ可視化のワークフロー",
	"tags": [],
	"description": "マップ ビューアーを使用した地図上でのデータ可視化のプロセスを紹介します。",
	"content": "ArcGIS 開発者向けクラウド サービス（ArcGIS for Developers）で提供されているビジュアライゼーション ツール（マップ ビューアー）を使用した地図上でのデータ可視化のプロセスを紹介します。最終的には地図作成にとどまらず、サードパーティのチャートなどのコンポーネントを組み合わせたアプリ開発をゴールとしています。\n本ワークフローで伝える方法はあくまで作成済みのデータに簡単な加工を施して可視化を行うことをクラウド上で実施することを前提としています。よって、デスクトップ GIS ソフトウェアなどを使ったデータ編集は除外しています。\nワークフロー ５ステップをベースに、各ステップで使用するツールやプラットフォームとその簡単な使用方法を以下で紹介していきます。\n データ取得   データ可視化のテーマとなるデータを取得します。  データ加工   取得したデータを地図上にプロットします。必要に応じてデータ変換を行います。  データ処理   必要に応じてテーマとなるデータをもとに解析処理を施します。  グラフィック表現   可視化対象であるデータをテーマに従って表現を加えます。  アプリ作成/ページ埋め込み   ステップ４までに作成した Web マップをページ上に表示し、データ可視化によるテーマを伝えるためにページの編集を行います。  以下は上記５ステップをチャートで表現した図です。必ずしもすべてのステップを踏む必要はなく、また柔軟なアウトプットを行うために開発が担う作業範囲を大きくすることも考えられますが、ここでは、もっとも簡易で効率的な手段として、ステップ４までのプロセスをクラウド上で完了できるようなフローを紹介します。\nデータ取得 ArcGIS のクラウド サービスが提供するビジュアライゼーション ツールではさまざまなデータ形式をサポートしており、異なる形式のデータをインポートし、地図上に可視化することができます。\nサポートするデータ形式は以下の通りです。\n ArcGIS Server サービス（GeoServices） シェープファイル GeoJSON CSV TXT GPX GeoRSS KML OGC  上記の形式で座標情報あるいは住所情報があればお好きなデータ カタログから取得したデータをすぐに地図上に可視化できます。特に ArcGIS Web サービスを使うことで、動的な属性/空間検索が可能な API を経由したデータ可視化が可能なため、より柔軟な可視化に対応できます。\n以下は、ArcGIS Web サービスを配信しているデータ元の参考です。\n ArcGIS Online ArcGIS Open Data Koop  データ加工 ここで紹介するデータ加工はさまざまなデータ形式を１つの地図上に重ねて可視化する作業にあたります。前のステップで取得したデータをデータ ビジュアライゼーション ツールを使って地図上に可視化します。\n  Web サービス（ArcGIS Server サービス、GeoRSS、KML、OGC）の場合\n  静的ファイル（シェープファイル、CSV、TXT、GPX）の場合\n  ArcGIS Online で全世界に配信されているデータの検索および可視化\rデータ処理 可視化したデータをもとに GIS の空間解析を実施することで、より高度な分析結果を２次データとしてそのまま地図上で扱うことができます。\n例：ポイントの集約 たとえば、喫茶店の場所を示すポイント フィーチャと区のエリア フィーチャがあり、喫茶店の売上を区別にまとめるとします。喫茶店に TOTAL_SALES 属性情報があれば、区ごとの TOTAL_SALES の合計値、各区の TOTAL_SALES の最小値または最大値、各区における総売上の標準偏差を取得できます。\nこのプロセスは必須ではないので、必要に応じて行ってください。\nArcGIS の解析サービスの利用については「解析の実行 | ArcGIS Online ヘルプ」を参照してください。\nグラフィック表現 可視化対象であるデータをテーマに従って表現を加えます。データ ビジュアライゼーション ツールには直感的な操作で地図上のデータの表現を操作するための機能が備わっています。主な表現方法は以下の通りです。\n 場所（単一シンボル）   単一シンボルを使用してデータを描画すると、フィーチャの分布状態 (クラスター化されているか分散されているか) を把握し、隠れているパターンを明らかにできます。\n ヒート マップ   ヒート マップはレイヤー内のポイントを使用して、マップ上のポイントの相対的な密度を計算し、寒色 (ポイントの密度が低い) から暖色 (ポイントの密度が高い) まで滑らかに変化する一連の色の配列で表示します。\n 種類（個別値シンボル）   個別値シンボルを使用すると、数値測定の数ではなく、さまざまな種類 (カテゴリ データ) を表示できます。たとえば、さまざまな色を使用して、レストランが提供する料理の種類を表すことができます。レイヤーに表示するカテゴリを 10 種類未満にするのが理想的です。\n 数と量（色）   数値データが存在する場合、色のグラデーションによってフィーチャを区別できます。使用できる色のグラデーションには、さまざまな種類があります。たとえば、薄い色から濃い色に変化する単純な方式は、年齢や収入など、高低を表すデータ値の表示に適しています。\n 数と量（サイズ）   数値データまたはランク付けされたカテゴリを表すために、順序付けできる異なるサイズの並びを使用します。この方法を使用して、ポイント、ライン、およびエリアをすべて描画できます。この比例シンボル マップでは、シンボルが大きいほど大きい数値を表すという直感的な論理を使用します。伝えたい内容を明確に表すようにシンボルのサイズを調整します。たとえば、等級シンボルを使用して、各都市の相対的な人口密度を表示できます。\n 色とサイズ   データ内の 2 つの属性を選択し、マップ上のポイント シンボルの色とサイズを完了します。または、同じ属性を 2 回使用して、強調するデータの部分に基づき、シンボルのサイズを設定し、色を設定できます。これは、一人親の世帯数などの数情報を、貧困率などの比率で陰影処理して表示する場合に適したスタイルです。\n 個別値シンボルとサイズ   学士号を持つ人などの数属性を表示し、郡名など別のフィールドの値ごとに一意の色を使用する場合に使用します。一意の値を持つテキストまたは数値フィールドと、数値フィールドを選択し、必要に応じて、各属性のマップ シンボル設定を調整します。\n A を B と比較   2 つの数値の比率をマッピングして、その関係をパーセンテージまたは単純な比率で表現できます。たとえば、総人口に対する大学の学位を持つ人の比率をマッピングできます。\nスタイリング機能を使った地図データにもとづくグラフィック表現\rアプリ作成/ページ埋め込み 上記ステップまでに作成した Web マップは１つの完結した地図データとして管理が可能です。Web マップには対応する一意の ID が割り当てられており、JavaScript API を使って ID を参照するだけで可視化した地図をそのまま Web ページ上に表示することができます。\nvar webmap = new WebMap({ portalItem: { id: \u0026#34;\u0026lt;Web マップ ID\u0026gt;\u0026#34; } }); var view = new MapView({ map: webmap, container: \u0026#34;viewDiv\u0026#34; }); \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 参照した地図上のデータをスクリプトで取得し、D3.js などのサードパーティのチャート コンポーネントと容易に連携が可能です。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/get-started/",
	"title": "開発の手順",
	"tags": [],
	"description": "ArcGIS Maps SDK for JavaScript の開発におけるインストールとセットアップからの手順について紹介します。",
	"content": "出典：ArcGIS Maps SDK for JavaScript - Get Started\n1 インストールとセットアップ\n2 API キーの取得\n3 チュートリアルの開始\n1.インストールとセットアップ ArcGIS Maps SDK for JavaScript をアプリケーションに読み込むには複数の方法があります。最も一般的な方法は、ArcGIS CDN 経由でAMD モジュールを使用する方法でローカルビルドにも対応しています。\nAMD モジュールの場合は、以下のスクリプト タグを使用します。\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.29/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.29/\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; ES モジュールの場合は、ターミナル ウインドウ上で npm を用いてモジュールをインストールします\nnpm install @arcgis/core CSSには@import urlを用います\n\u0026lt;* CSS url as a string *\u0026gt; \u0026lt;@import \u0026#34;https://js.arcgis.com/4.29/@arcgis/core/assets/esri/themes/light/main.css\u0026#34;;\u0026gt; \u0026lt;/script\u0026gt; 詳しくは、インストールとセットアップをご覧ください。\n2.API キーの取得 アプリケーションで認証に ArcGIS Identities のみを使用している場合は、この手順を省略できます。詳細については、セキュリティと認証をご覧ください。\n\rベースマップ、ジオコーディング、ルーティングなどの ArcGIS サービスにアクセスするには、API キーが必要です。ダッシュボードにアクセスしてデフォルトの API キーをコピーするか、特定のニーズに合わせてカスタム スコープとリファラを設定してください。チュートリアルやサンプルの説明で必要な場合は、API キーを含めてください。グローバルAPIキーだけでなく、特定のクラスでより細かい API キーを使用することもできます。\n１ ダッシュボードにログインする\n２ デフォルトの API キーをコピーするか、新しいキーを生成する\n3.チュートリアル マップの表示(2D)\n現在地の表示(英語)\nポイント、ライン、ポリゴンの表示(英語)\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/get-dev-account/",
	"title": "開発者アカウントの作成",
	"tags": [],
	"description": "ArcGIS Developers の利用を開始するために新規アカウントを作成する手順を紹介します。",
	"content": "ArcGIS Developers の更新に伴い、本ページも近日更新予定です。 開発者アカウントの新規作成については、新しい Esri Developer サイトの Get Started (英語) をご参照ください。\n\rArcGIS Developers とは ArcGIS Developers は、開発者が ArcGIS アプリケーションを構築してデプロイするために必要なリソースを集めた Web サイトです。API および SDK のドキュメントやチュートリアル、ロケーションサービスの概要、価格、ヘルプなどが用意されています。このサイトに開発者としてアカウントを作成することで、開発キット（SDK）をダウンロードして ArcGIS アプリケーションの開発を開始することができます。\nArcGIS Developers に開発者アカウントを作成すると ArcGIS Developer Subscription が有効になり、開発キットのダウンロードとアプリの開発を無償で開始することができます。また、ArcGIS Platform が提供するロケーションサービスであるベースマップの利用やジオコーディング サービス（住所⇄緯度経度）、ネットワーク サービス（ルート検索、到達圏解析）などの様々な GIS サービスを利用したり、お手持ちのデータを GIS サービスとして配信したりすることが、無料枠/月の範囲で利用可能です。\nArcGIS Developer Subscription の各プランの詳細や提供しているサービスについては ESRIジャパン製品ページをご参照ください。\nアカウントの作成 ArcGIS Developers 開発者アカウントの作成 以下の手順で ArcGIS Developers に新規アカウントを作成します。アカウントの作成中に問題が発生した場合は、ESRI ジャパンまでお問い合わせください。\n  ArcGIS Developers のサイト（英語）にアクセスし、[Sign Up For Free] をクリックします。\n  名前（※名前には半角英字のみを使用してください）、E メールアドレス、組織名（任意）、ユーザー名、パスワード、秘密の質問を入力します。\n  利用規約とプライバシー ポリシーに同意する場合は、同意欄にチェックを入れ、[Create developer account] をクリックします。\n  手順 2 で入力したユーザ名にて ArcGIS Developers にログインされ、登録確認の E メール（Confirmation email）を確認する旨のメッセージが表示されます。また、受信ボックスに Esri から登録の確認メールが届きます（メールが届くまで時間がかかる場合があります）。\n  手順 2 にて入力した、Eメールアドレスの受信ボックスに届いた Esri からのメールを開き、メール本文にある [Confirm your email] をクリックします。\n  以上で ArcGIS Developers の開発者アカウントの作成は完了です。 また、GitHub、Facebook、Google および Apple アカウントと連携することで、ArcGIS Developers を利用することができます。各種アカウントとの連携方法に関しましては、それぞれの連携先の手順に従い行ってください。\n従量制プラン ArcGIS Platform では、お手持ちのデータを GIS サービスとして配信したりすることが、無料枠/月の範囲で利用可能です。それを超えてサービスを利用する場合に、従量制プラン（Pay as you go） の有効化が必要となります。\n※ 従量制プラン（Pay as you go）を有効化する際には、クレジットカードの情報が必要になります。\n従量制プランの有効化 以下の手順で従量制プランを有効化します。\n ArcGIS Developers（https://developers.arcgis.com/） のサイトで、開発者アカウントでログインします。アカウントのメニューから [Billing] をクリックします。  Pay as you go の欄で、[Enable pay as you go] をクリックします。  ポップアップで表示される画面で、クレジットカード情報等の必要な情報を入力し、[Continue] ボタンをクリックします。  table {\rborder-collapse: collapse;\rwidth: 60%;\rmargin-left:auto;\rmargin-right:auto;\r}\rtable, th, td {\rborder: 1px solid black;\r}\r\r   項目 入力内容      Name on Card（カード名義） カード記載の名義人   Credit Card Number（クレジットカード番号） \u0026mdash;- \u0026mdash;- \u0026mdash;- \u0026mdash;- 形式   Expiration Date（有効期限） mm/yy（月/年）形式   CVV（セキュリティコード：カード裏面の右端３ケタ） \u0026mdash; 形式   Street Address（住所） 例：2-7-1 Hirakawa-Cho   City（市区町村） 例：Chiyoda-Ku   Country（国） 選択形式   Region（都道府県） 選択形式   Postal Code（郵便番号） 例：1020093    表示されている内容を確認し、「I have read agree to the terms and conditions of this license」のチェックボックスにチェックを入れ、[Enable pay as you go] をクリックします。  Pay as you go が有効化されていることを確認します。  以上で従量制プランの有効化は完了です。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/get-api-key/",
	"title": "API キーの取得",
	"tags": [],
	"description": "アプリケーションを公開するために必要な API キーを取得する手順について紹介します。",
	"content": "API キーとは すぐに使える特定のサービスやプライベート コンテンツへのアクセスを公開アプリケーションに許可範囲と許可を定義する永続的なアクセストークンです。\n既に ArcGIS アカウントを持っている場合は、サインインしてデフォルトの API キーを表示したり、新しい API キーを作成したりすることができます。API キーは、ArcGIS 開発者アカウントにサインアップしたときに作成されます。\n詳細は API keys のサイト（英語）をご覧ください。\nAPI キーの取得方法 以下の手順で新規の API キーを取得します。API キーの取得中に問題が発生した場合は、ESRI ジャパンまでお問い合わせください。\n  ArcGIS Developers のサイト（英語）にアクセスし、ご自身のアカウントでサインインをします。\n  サインインしたアカウントの専用ページに遷移したら、ヘッダー部にある [API keys] タブまたは、メイン コンテンツ内の API keys にある [Manage] をクリックします。   API keys ページに遷移したらページ上部にある [+ New API key] をクリックします。   入力フォームが出力されたらタイトルと説明を入力して [Create API key] をクリックします。   以上で API キーの取得は完了です。\n取得した API キーは、専用ページの Overview タブページの上方に表示されているため、コピーをしてご利用ください。\nまた、API キーを各種開発キットで利用するためのコードも用意されていますので併せてご利用ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/python-api-conda/",
	"title": "ArcGIS API for Python のための基礎環境：conda入門",
	"tags": [],
	"description": "conda の基本について簡単に紹介します。",
	"content": "ArcGIS API for Python (以下、Python API) を使用する際、conda を利用すると Python の環境やパッケージを管理することが容易になります。 ここでは、conda の基本について簡単に説明します。conda について基本的な事項を把握しておきますと、この後のインストールガイドでの環境作成を行いやすくなります。\n\rconda の基本 conda の基本について説明します。conda は Python と Python で使用できるライブラリのインストールやバージョンを管理するためのツールです。 conda を使用する場合、次の 2 つの選択肢があります。\n Anaconda Distribution : Python とデータサイエンス向けの Python パッケージなどを提供するプラットフォームです (以下、Anaconda)。 Miniconda : Anaconda をコンパクトにしたもので、Python、conda、それらの依存パッケージ、その他の最小限のパッケージをインストールします。ArcGIS Pro をインストールした場合、Miniconda も同時にインストールされます。  Anaconda と Miniconda の詳しい違いは Anaconda or Miniconda (英語) のページをご覧ください。 ※ pip でも Python API をインストールすることができますが、初心者には conda が推奨されています。参考: ArcGIS API for Python - Install and set up (英語)\nconda をより深く理解したい方は Getting Started with Conda (英語) チュートリアルをご覧ください。\n conda の環境 conda をインストールすると、Python のインタープリターと環境にインストールしたパッケージを隔離するディレクトリが作成されます。これにより、Python を含む異なるバージョンのソフトウェアを持つ複数の環境を作成することが可能になります。新しい環境は簡単に作成することができ、他の環境に影響を与えることなくそれらを切り替えて使用することができます。詳細な説明と手順については、環境の管理に関する conda のドキュメント (英語)を参照してください。\nインストール手順は次章で詳しくご説明しますが、以降では ArcGIS Pro を通じて conda をインストールした場合と、Anaconda でインストールした場合のデフォルトの環境について説明します。\nAnaconda 上の仮想環境イメージ\n --\rデフォルトの環境 conda をどのようにインストールしたか (ArcGIS Pro 経由か Anaconda 経由か) によってデフォルトの環境は異なります。 コマンド プロンプト等で conda env list とコマンドを入力することで作成されている環境の一覧を確認することができます。\nArcGIS Pro の場合 ArcGIS Pro をインストールした後で環境を確認すると、以下の 2 つが作成されています。\n  arcgispro-py3 この環境には、Python、ArcPy の機能を含む arcgispro パッケージが含まれています。\n  root この環境には、必要最小限の conda、Python、依存するパッケージなどが含まれる Miniconda がインストールされています。\n  ArcGIS Pro の conda 上の初期環境\n\rconda の環境を ArcGIS Pro で管理する ArcGIS Pro の conda の環境は、次の 3 つの方法を使用して管理できます。どの方法でも、それぞれパッケージのインストール、更新、削除などを行うことができます。\n  Python パッケージ マネージャー ArcGIS Pro プロジェクトタブからアクセス可能な GUI ツール。\n  Python コマンド プロンプト 上述した arcgispro-py3 の環境に直接アクセスしアクティブにするコマンドライン ショートカット。\n  コマンド プロンプト (windows) 標準の MS-DOS Windows コマンドライン アプリケーション。\n  (左) Python パッケージ マネージャー、(中) Python コマンド プロンプト、(右) コマンド プロンプト (windows)\r\rAnaconda の場合 Anaconda をインストールすると Python、conda、その他多数のパッケージが base という 1 つの環境にインストールされます。\nAnaconda Prompt 初期の環境\r\rconda の環境を Anaconda で管理する 主に以下の 2 つの方法で conda の環境を管理することができます。\n ターミナル アプリケーション  標準的なコマンドラインターミナルアプリケーション。\n※ Anaconda をインストールすると Anaconda Prompt が一緒にインストールされます。Anaconda Prompt を使用すると環境変数を操作せずに conda のコマンドを利用できます。\n Anaconda Navigator conda の環境を包括的に管理するための GUI アプリケーション。  Anaconda Navigator (左) と Anaconda Prompt (右)\r\r 環境をアクティベートする 環境を利用するためには、対象となる環境をアクティベートする必要があります。以下のコマンドを実行することで対象の環境をアクティベートできます。\n activate \u0026lt;環境名\u0026gt;  ArcGIS Pro と共にインストールした場合は、Python コマンド　プロンプトから以下のコマンドで環境を切り替えることができます。\n proswap \u0026lt;環境名\u0026gt;  ` --\rその他のコマンドの詳細については、環境のアクティブ化 (英語)を参照してください。\n 新しいパッケージを追加する アクティベートした環境に新しいパッケージを追加したい場合は次のコマンドを使用します。\nconda install \u0026lt;package_name\u0026gt;\nまた、--name や --channel オプションを使用して、特定の環境およびチャネルを指定することもできます。\nconda install --name \u0026lt;environment_name\u0026gt; --channel \u0026lt;channel_name\u0026gt; \u0026lt;package_name\u0026gt;\nconda コマンドや 他オプションの使用方法の詳細についてはパッケージの管理 (英語)を参照してください。\n 参考：conda からパッケージをインストールできる仕組み\nConda は、プラットフォームに依存しないパッケージ マネージャー アプリケーションで、Python パッケージをインストール、更新、および削除できます。 パッケージは、チャネルと呼ばれるさまざまなリポジトリのいずれかに格納されているソフトウェアおよびサポートファイルのバンドルです。 チャネルは、Anaconda クラウドなどの既定のクラウド ロケーションのセット、または個人または組織によって作成されたプライベートレポジトリである場合があります。 condaは、パッケージのリスト表示またはインストール時にデフォルトのチャネルセットを検索します。\narcgis パッケージを格納するために esri という名前のチャネルに conda リポジトリが作成されています。 conda install コマンドは、チャネルにアクセスし、特定の conda 環境にパッケージをインストールしています。\nAnaconda クラウド上の esri チャネル\r\r このページの内容の詳細については 米国Esri ガイドページ：Understanding Conda (英語)をご覧ください。\n次の章では、ArcGIS API for Python の環境構築方法を紹介します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/",
	"title": "ArcGIS Experience Builder (Developer Edition)",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) の開発に役立つガイド集です。",
	"content": "ArcGIS Experience Builder (Developer Edition) の開発に役立つガイド集です。\n コア コンセプト\nArcGIS Experience Builder (Developer Edition) のコア コンセプトについて紹介します。\n\r インストール ガイド\nArcGIS Experience Builder (Developer Edition) をインストールする手順を紹介します。\n\r カスタム ウィジェット開発ガイド\nカスタム ウィジェットを開発する手順を紹介します。\n\r デプロイ パターン\nArcGIS Experience Builder (Developer Edition) で作成したアプリやウィジェットのデプロイ パターンを紹介します。\n\r デプロイ\nArcGIS Experience Builder (Developer Edition) で作成したアプリケーションをダウンロードし、独自のサーバーにホストする手順を紹介します。\n\r チュートリアル\nArcGIS Experience Builder (Developer Edition) のチュートリアルでは、カスタム ウィジェットの作成方法について説明しています。\n\r Web AppBuilder からの移行\nWeb AppBuilder から ArcGIS Experience Builder (Developer Edition) への移行方法について説明しています。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/",
	"title": "ArcGIS Web AppBuilder (Developer Edition)",
	"tags": [],
	"description": "ArcGIS Web AppBuilder (Developer Edition) の開発に役立つガイド集です。",
	"content": "ArcGIS Web AppBuilder (Developer Edition) の開発に役立つガイド集です。\nArcGIS Web AppBuilder (Developer Edition) は、ArcGIS API for JavaScript バージョン 3.x のサポート終了と同時に 2024 年 7 月にサポートが終了されます。現在 Web AppBuilder でアプリを開発している方は、ArcGIS Experience Builder に移行することを検討してください。\r開発者は、Experience Builder で新しいアプリ プロジェクトを開始することを強くお勧めします。詳細および移行については、ArcGIS Web AppBuilder のサポート終了についてを参照してください。\n\r インストール ガイド\nArcGIS Web AppBuilder (Developer Edition) をインストールする手順を紹介します。\n\r カスタム ウィジェット開発ガイド\nカスタム ウィジェットを開発する手順を紹介します。\n\r デプロイ パターン\nArcGIS Web AppBuilder (Developer Edition) で作成したアプリやウィジェットのデプロイ パターンを紹介します。\n\r Web アプリケーションのデプロイ\nArcGIS Web AppBuilder (Developer Edition) で作成したアプリケーションをダウンロードし、独自のサーバーにホストする手順を紹介します。\n\r ウィジェット一覧表\nArcGIS Web AppBuilder で提供されているウィジェットの一覧表です。\n\r\rカスタム ウィジェットのサンプル集（外部サイト）  ArcGIS Web AppBuilder (Developer Edition) を使用して開発されたカスタム ウィジェットのサンプルを確認できるサイトです。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/learn/developer-community/",
	"title": "ArcGIS 開発者コミュニティ",
	"tags": [],
	"description": "ArcGIS 開発者コミュニティ",
	"content": "ESRIジャパンのスタッフが Esri Community 上で開発者、SIer (エスアイヤー)、ポータル管理者向けの技術ブログを発信しています。毎年多くの記事を配信していますので、初めての方は欲しい情報を探す時間が長くなりがちです。年代別にイベント資料やブログ記事を中心に、API/SDK などのカテゴリー別にまとめていますので、参考にしていただければと思います。紹介している内容のレベルの目安として、【基礎】、【応用】 のフラグを付けています。\n2024 年  最新の記事についてはこちらから確認していただけます。  2023 年  マッピング \u0026amp; ロケーション開発 (ArcGIS Developers) 2023 振り返り  2022 年  マッピング \u0026amp; ロケーション開発 (ArcGIS Developers) 2022 振り返り  2021 年  マッピング \u0026amp; ロケーション開発 (ArcGIS Developers) 2021 振り返り  2020 年  マッピング \u0026amp; ロケーション開発 (ArcGIS for Developers) 2020 振り返り  2019 年  マッピング \u0026amp; ロケーション開発 (ArcGIS for Developers) 2019 振り返り  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-esrileaflet/",
	"title": "Esri Leaflet",
	"tags": [],
	"description": "Esri leaflet を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。",
	"content": "マップを表示する このチュートリアルでは、Esri Leaflet と ベースマップ レイヤー サービス を使用して、マップを表示する方法を紹介します。\nマップには、ベースマップ レイヤー サービスのベクター タイル ベースマップ レイヤーを使用しています。ベクター タイル ベースマップ レイヤーには、レイヤーをレンダリングするためのスタイル、レイヤー、フォントグリフ(Font Glyphs)、およびアイコンが含まれています。\nこのチュートリアルでは、ベースマップ レイヤー サービスの地形ベースマップ レイヤーを使用して、富士山周辺の地図を作成します。\nマップとレイヤーの詳細については、Mapping APIs and services のガイドをご覧ください。\n前提条件 このチュートリアルを実施するには、以下が必要です。\n 開発者ダッシュボードにアクセスして API キーを作成するには、ArcGIS アカウントが必要です。アカウントの作成手順については「開発者アカウントの作成」を参照してください。  ステップ 新しい Pen の作成 CodePen にアクセスして、マッピング アプリケーション用の新しい Pen を作成します。\nHTML の作成と各 JS ライブラリへの参照を追加する Leaflet、Esri Leaflet への参照を含む HTML ページを作成します。 これらは、ベクター タイル ベースマップ レイヤーにアクセスして表示するために必要です。\n \u0026lt;head\u0026gt;の中に、ライブラリを参照するための\u0026lt;script\u0026gt;要素を追加します。 \u0026lt;head\u0026gt;に，ページとマップのスタイルを決めるための\u0026lt;style\u0026gt;要素も追加します。 \u0026lt;body\u0026gt;の中に、マップ用の\u0026lt;div\u0026gt;要素を追加します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1,maximum-scale=1,user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Esri Leaflet\u0026lt;/title\u0026gt; \u0026lt;!-- Leaflet の jsライブラリ と css ファイルの参照を追加--\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\u0026#34; integrity=\u0026#34;sha512-BwHfrr4c9kmRkLw6iXFdzcdWV/PGkVgiIyIWLLlTSXzWQzxuSg4DiQUCpauz/EWjgk5TYQqX/kvn9pG1NpYfqg==\u0026#34; crossorigin=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\u0026#34; integrity=\u0026#34;sha512-Zcn6bjR/8RZbLEpLIeOwNtzREBAJnUKESxces60Mpoj+2okopSAcSUIUOseddDm0cxnGQzxIR7vJgsLZbdLE3w==\u0026#34; crossorigin=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;!-- Esri Leaflet の js ライブラリ と ベクタータイル対応の js ライブラリへの参照を追加--\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/esri-leaflet@3.0.12/dist/esri-leaflet.js\u0026#34; integrity=\u0026#34;sha512-G4+fuKc1B96F0sUG7eKtgiJr0JM3iQC4bfc8WtYvmm7msHES0Hst2mLWASPb8zZk91tqMG86AjP0tgXIEFPPUA==\u0026#34; crossorigin=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/esri-leaflet-vector@4.2.3/dist/esri-leaflet-vector.js\u0026#34; integrity=\u0026#34;sha512-/H7f4mjvCB73Rsi7cWCW0Z3Zl1InqvtGOQsipk5ClXhAxfrw6GSjEnPz2VVTuh7dE29ws8tS3OGHowmkEae2/A==\u0026#34; crossorigin=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; body { margin:0; padding:0; } #map { position: absolute; top:0; bottom:0; right:0; left:0; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; マップの表示 \u0026lt;body\u0026gt;要素に、コードを含む\u0026lt;script\u0026gt;要素を追加してマップを作成します。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1,maximum-scale=1,user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Esri Leaflet\u0026lt;/title\u0026gt; \u0026lt;!-- Leaflet の jsライブラリ と css ファイルの参照を追加--\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\u0026#34; integrity=\u0026#34;sha512-BwHfrr4c9kmRkLw6iXFdzcdWV/PGkVgiIyIWLLlTSXzWQzxuSg4DiQUCpauz/EWjgk5TYQqX/kvn9pG1NpYfqg==\u0026#34; crossorigin=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\u0026#34; integrity=\u0026#34;sha512-Zcn6bjR/8RZbLEpLIeOwNtzREBAJnUKESxces60Mpoj+2okopSAcSUIUOseddDm0cxnGQzxIR7vJgsLZbdLE3w==\u0026#34; crossorigin=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;!-- Esri Leaflet の js ライブラリ と ベクタータイル対応の js ライブラリへの参照を追加--\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/esri-leaflet@3.0.12/dist/esri-leaflet.js\u0026#34; integrity=\u0026#34;sha512-G4+fuKc1B96F0sUG7eKtgiJr0JM3iQC4bfc8WtYvmm7msHES0Hst2mLWASPb8zZk91tqMG86AjP0tgXIEFPPUA==\u0026#34; crossorigin=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/esri-leaflet-vector@4.2.3/dist/esri-leaflet-vector.js\u0026#34; integrity=\u0026#34;sha512-/H7f4mjvCB73Rsi7cWCW0Z3Zl1InqvtGOQsipk5ClXhAxfrw6GSjEnPz2VVTuh7dE29ws8tS3OGHowmkEae2/A==\u0026#34; crossorigin=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; body { margin:0; padding:0; } #map { position: absolute; top:0; bottom:0; right:0; left:0; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- Leaflet でのマップの作成 --\u0026gt; \u0026lt;script\u0026gt; const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; const basemapEnum = \u0026#34;arcgis/topographic\u0026#34;; const map = L.map(\u0026#39;map\u0026#39;, { minZoom: 2 }).setView([35.362752, 138.729858], 12); L.esri.Vector.vectorBasemapLayer(basemapEnum, { apiKey: apiKey, language: \u0026#34;ja\u0026#34; }).addTo(map); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; API キーの設定 ロケーションサービスにアクセスするには、API キーまたは OAuth2.0 アクセストークンが必要です。API キーの作成手順については「API キーの取得」を参照してください。\n認証方法とアクセストークンの取得方法の詳細については、「セキュリティと認証」を参照してください。\n  開発者ダッシュボードにアクセスして、API キーを取得します。このチュートリアルで使用するサービスにアクセスするには API キーのスコープを設定する必要があります。\n  CodePen で、キーを使用するため、apiKey を更新します。\n  \u0026lt;script\u0026gt; const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; const basemapEnum = \u0026#34;arcgis/topographic\u0026#34;; const map = L.map(\u0026#39;map\u0026#39;, { minZoom: 2 }).setView([35.362752, 138.729858], 12); L.esri.Vector.vectorBasemapLayer(basemapEnum, { apiKey: apiKey }).addTo(map); \u0026lt;/script\u0026gt; アプリを実行する CodePen で、コードを実行してマップを表示します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/learn/",
	"title": "もっと学ぶ",
	"tags": [],
	"description": "ArcGIS の開発に役立つ情報を配信しています。",
	"content": "　開発に役立つ情報 GitHub   Esri GitHub\n 米国 Esri 社のスタッフが作成したサンプル プログラムを GitHub で共有しています。    Esri Japan GitHub\n 各 API や SDK のサンプルプログラムに加えて、ハンズオンや開発者セミナーで実施内容を GitHub で共有しています。    Esri Community   Esri Community\n 米国 Esri 社が運営する ArcGIS ユーザー コミュニティ サイトです。世界中のユーザーと ArcGIS に関する技術情報を探索・共有することができます。    ArcGIS 開発者コミュニティ\n ESRIジャパンのスタッフが Esri Community 上で開発者、SIer (エスアイヤー)、ポータル管理者向けの技術ブログを発信しています。    Esri Video、Event、Webinar   Esri Video\n 米国 Esri 社のイベント動画サイトもあり、毎年開催されている開発者向けイベント「ESRI Developer Summit」のテクニカルセッションの動画なども公開されています。    GeoDev Events, Webinars, and Meetups\n 米国ESRI の開発者がお届けする Webinar 等も定期的に開催されています。    Learn ArcGIS  Learn ArcGIS  Esri が提供している無償の自習用コンテンツで、実世界の様々な事例をもとにしたレッスンが多数用意されています。    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/android/distribution-android-200.x/",
	"title": "アプリケーション配布ガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for Kotlin を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を紹介します。",
	"content": "ArcGIS Maps SDK for Kotlin (バージョン 200.x) を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を説明します。\nAPI キーの設定 ArcGIS Location Platform のロケーションサービスを使用する場合は、アプリで API キーを設定する必要があります。API キーの詳細はAPI キーの取得を、APIキーの設定方法はアプリの作成のAPI キーを設定するをご覧ください。\nライセンス認証のステップ 開発したアプリケーションのライセンス認証のステップは以下の通りです。\n  使用するライセンスの選択\n  ライセンスの認証方法\n Lite ライセンスの認証方法 Basic ライセンスの認証方法 Standard ライセンスの認証方法 Analysis Extension ライセンスの認証方法 Advanced Editing Extension ライセンスの認証方法    ライセンスの認証\n Lite ライセンスキーを使用した認証 配布パックのライセンスキーを使用した認証 指定ユーザー アカウントを使用した認証    使用するライセンスの選択 ArcGIS Maps SDK for Kotlin には Lite、Basic、Standard の 3 つのライセンス レベルと Analysis エクステンションがあります。開発したアプリケーションが使用する機能に応じて、適切なライセンス レベルを選択してください。\n各ライセンスで利用可能な機能の概要は以下の表をご参照ください。\n   ライセンス 利用できる機能     Lite ・地図表示（2D/3D）\n・フィーチャの表示/検索\n・フィーチャのオンライン/オフライン編集（ArcGIS Online/ArcGIS Enterprise のパブリックなフィーチャ サービス、ArcGIS Location Platform のフィーチャサービス）\n・ルート検索/到達圏解析/最寄り施設検索\n・住所検索/リバース ジオコーディング\n・ユーティリティ ネットワークのトレース   Basic ・Lite ライセンスで利用できるすべての機能\n・フィーチャのオンライン/オフライン編集（ArcGIS Online/ArcGIS Enterprise のセキュアなフィーチャ サービス）\n・モバイル ジオデータベースの編集\n・ArcGIS Online/Portal for ArcGIS のコンテンツの編集   Standard ・Basic ライセンスで利用できるすべての機能\n・シェープファイルの表示/編集\n・GeoPackage の表示/編集\n・KML（ローカル ファイル）の表示/編集\n・ラスター データの表示/解析\n・航海用電子海図（ENC）の表示\n・3D 解析   Analysis Extension ・Standard ライセンスで利用可能なエクステンション\n・オフラインでの到達圏解析/最寄り施設検索   Advanced Editing Extension ・Basic ライセンス以上で利用可能なエクステンション・ブランチ バージョン ジオデータベースに新しいバージョンの作成・ブランチ バージョン ジオデータベースのバージョンのフィーチャ/テーブルの編集・ユーティリティ ネットワークのネットワーク フィーチャの編集・ユーティリティ ネットワークのトポロジーの検証    ライセンスの詳細はESRIジャパン製品ページをご参照ください。\nライセンスの認証方法 ライセンスの認証は次の2つの方法があります。\n  ライセンスキーを使用した認証\n ライセンスキーを使用した認証は、ArcGIS Runtime の配布パックを購入し、取得したライセンスキーを利用して、アプリケーションを認証します。    指定ユーザーによるアカウント認証\n 指定ユーザーによるアカウント認証とは、ArcGIS Online または ArcGIS Enterprise の組織のメンバーである ArcGIS 組織アカウントを使用してログイン認証を行います。 ログインを行う指定ユーザーアカウントのタイプによって関連付けられたライセンスのレベルが異なります。    指定ユーザーのユーザータイプとライセンスレベルの対比表 ArcGIS Online のユーザータイプの場合\n   ユーザータイプ ライセンスレベル     Viewer Lite   Contributor / Mobile Worker Basic   Creator Standard   Professional / Professional Plus Advanced ※1    ArcGIS Enterprise のユーザータイプの場合\n   ユーザータイプ ライセンスレベル     Viewer Lite   Editor / Mobile Worker Basic   Creator / GIS Professional Basic Standard   GIS Professional Standard / GIS Professional Advanced Advanced ※1    ※1 ArcGIS Maps SDK for Kotlin には Advanced ライセンスはありません。\nLite ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Lite のライセンスキーを取得する必要があります 認証の方法は、Lite ライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Lite ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Basic ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Basic の配布パックを購入する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Basic ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Standard ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Standard の配布パックを購入する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、Portal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Standard ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Analysis Extension ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Analysis Extension の配布パックを購入する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、Portal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Analysis アドオン ライセンスを割り当てられた）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Advanced Editing Extension ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Advanced Editing Extension の配布パックを購入する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    Portal for ArcGIS へのログインによる認証\n注意：この認証は、ArcGIS Enterprise 11.1 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに Portal for ArcGIS の指定ユーザー アカウント（Advanced Editing ユーザー タイプ エクステンションを割り当てられた）が必要です アプリケーションが少なくとも 30 日に 1 回は Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    ライセンスの認証 以下の認証に応じた作業を行ってください。\nLite ライセンスキーを使用した認証 ArcGIS Runtime Lite のライセンスキーを Esri Developer のサイトから取得し、取得したライセンスキーを利用して、アプリケーションを Lite ライセンスで認証することができます。 最初に以下の手順で Lite レベルのライセンスキーを取得します。\n  Get a license ページにアクセスします\n ArcGIS Location Platform アカウント、または、ArcGIS Online アカウントにサインインしてない場合は、いずれかのアカウントでサインインします。 いずれかのアカウントもお持ちでない場合は、ArcGIS Location Platform アカウントに サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。    表示されたライセンスキーをコピーします   次に、アプリケーションのコードにおいて SDK の機能が呼び出される前に、以下のコードを使用してアプリケーションにコピーしたライセンスキーを設定します。\n// 取得したライセンス文字列でアプリのライセンスを設定します val licenseKey = LicenseKey.create(\u0026#34;runtimelite,1000,rud#########,day-month-year,####################\u0026#34;) ?: return showError(\u0026#34;Null license key. \u0026#34;) val licenseResult = ArcGISEnvironment.setLicense(licenseKey)   配布パックのライセンスキーを使用した認証 ArcGIS Runtime の配布パックを購入し、取得したライセンスキーを利用して、アプリケーションを認証することができます。\nArcGIS Runtime の配布パックの購入についてはESRIジャパンにお問合せください。ArcGIS Runtime の配布パックをご購入頂いた場合、ESRIジャパンよりライセンスキーをメールにてお送りします。\nアプリケーションのコードにおいて ArcGIS Runtime SDK の機能が呼び出される前に、以下のコードを使用して配布パックのライセンスキーを設定します。\n// 取得したライセンス文字列でアプリのライセンスを設定します val licenseKey = LicenseKey.create(\u0026#34;runtimestandard,1000,rud#########,day-month-year,####################\u0026#34;) ?: return showError(\u0026#34;Null license key. \u0026#34;) val licenseResult = ArcGISEnvironment.setLicense(licenseKey) Extension ライセンスを認証する場合は以下のコードを使用します。\n// 基本ライセンスとエクステンション ライセンスのリストを設定します val licenseKey = LicenseKey.create(\u0026#34;runtimestandard,1000,rud#########,day-month-year,####################\u0026#34;) ?: return showError(\u0026#34;Null license key. \u0026#34;) val licenseExtensions = listOf( LicenseKey.create(\u0026#34;runtimeanalysis,1000,rud#########,day-month-year,####################\u0026#34;) ?: return showError(\u0026#34;Null license key. \u0026#34;) ) val licenseResult = ArcGISEnvironment.setLicense(licenseKey, licenseExtensions) 指定ユーザー アカウントを使用した認証 アプリケーションの実行時に、アプリケーションを利用するユーザーが保有する ArcGIS Online 組織向けプランもしくは Portal for ArcGIS の指定ユーザー アカウントを使用して ArcGIS Online / Portal for ArcGIS にログインすることで、ライセンスを取得することができます。\nアプリケーションのコードにおいて SDK の機能が呼び出される前に、ライセンスを取得・設定します。以下のコードは、ArcGIS Online の指定ユーザーのライセンスを取得する方法を示しています。\n認証方法の詳細については、「How to use named user login in your app（英語）」や「Security and authentication（英語）」も併せてご覧ください。\n// クレデンシャルを使用してポータル（ArcGIS Online）に接続します。 val portal = Portal.arcGISOnline(Portal.Connection.Authenticated) lifecycleScope.launch { portal.load().getOrElse { error -\u0026gt; return@launch showError(\u0026#34;Error loading portal: ${error.message}\u0026#34;) } // ポータルから LicenseInfo を取得します  val licenseInfo:LicenseInfo = portal.fetchLicenseInfo().getOrElse { error -\u0026gt; return@launch showError(\u0026#34;Error fetching licenseInfo: ${error.message}\u0026#34;) } // ライセンス情報を使用してアプリのライセンスを認証します  val licenseResult = ArcGISEnvironment.setLicense(licenseInfo) showLicenseResult(licenseResult) } ライセンス情報をローカルストレージに保存した場合、保存したライセンス情報を使用して、オフライン環境でアプリを起動してライセンスを取得できます。ストレージからライセンスを取得し、アプリを認証します。\n// LicenseInfo を JSON 形式のテキストとして取得します val licenseJson = licenseInfo.toJson() // ... テキスト文字列をローカルに保存します ...  // (起動時) ... デバイスに保存されているライセンス JSON を取得します ... // 保存した JSON 文字列からライセンス情報を設定します val licenseInfoFromJson = LicenseInfo.fromJsonOrNull(licenseJson) "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/dotnet/distribution-dotnet-200.x/",
	"title": "アプリケーション配布ガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for .NET を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を紹介します。",
	"content": "ArcGIS Maps SDK for .NET (バージョン 200.x) を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を説明します。\nAPI キーの設定 ArcGIS Location Platform のロケーションサービスを使用する場合は、アプリで API キーを設定する必要があります。API キーの詳細はAPI キーの取得を、APIキーの設定方法はアプリの作成のAPI キーを設定するをご覧ください。\nライセンス認証のステップ 開発したアプリケーションのライセンス認証のステップは以下の通りです。\n  使用するライセンスの選択\n  ライセンスの認証方法\n Lite ライセンスの認証方法 Basic ライセンスの認証方法 Standard ライセンスの認証方法 Advanced ライセンスの認証方法 Analysis Extension ライセンスの認証方法 Advanced Editing Extension ライセンスの認証方法    ライセンスの認証\n Lite ライセンスキーを使用した認証 配布パックのライセンスキーを使用した認証 指定ユーザー アカウントを使用した認証    使用するライセンスの選択 ArcGIS Maps SDK for .NET には Lite、Basic、Standard、Advanced の 4 つのライセンス レベルと Analysis エクステンションがあります。開発したアプリケーションが使用する機能に応じて、適切なライセンス レベルを選択してください。\n各ライセンスで利用可能な機能の概要は以下の表をご参照ください。\n   ライセンス 利用できる機能     Lite ・地図表示（2D/3D）\n・フィーチャの表示/検索\n・フィーチャのオンライン/オフライン編集（ArcGIS Online/ArcGIS Enterprise のパブリックなフィーチャ サービス、ArcGIS Location Platform のフィーチャサービス）\n・ルート検索/到達圏解析/最寄り施設検索\n・住所検索/リバース ジオコーディング\n・ユーティリティ ネットワークのトレース   Basic ・Lite ライセンスで利用できるすべての機能\n・フィーチャのオンライン/オフライン編集（ArcGIS Online/ArcGIS Enterprise のセキュアなフィーチャ サービス）\n・モバイル ジオデータベースの編集\n・ArcGIS Online/Portal for ArcGIS のコンテンツの編集   Standard ・Basic ライセンスで利用できるすべての機能\n・シェープファイルの表示/編集\n・GeoPackage の表示/編集\n・KML の表示/編集（ローカル ファイル）\n・ラスター データの表示/解析\n・航海用電子海図（ENC）の表示\n・3D 解析\n・ローカル サーバーの標準的な機能   Advanced ・Standard ライセンスで利用できるすべての機能\n・ローカル サーバーの高度な機能   Analysis Extension ・Standard ライセンス以上で利用可能なエクステンション・オフラインでの到達圏解析/最寄り施設検索\n・ArcGIS Desktop（Spatial/3D/Network エクステンション）で利用可能なジオプロセシング ツールの一部   Advanced Editing Extension ・Basic ライセンス以上で利用可能なエクステンション・ブランチ バージョン ジオデータベースに新しいバージョンの作成・ブランチ バージョン ジオデータベースのバージョンのフィーチャ/テーブルの編集・ユーティリティ ネットワークのネットワーク フィーチャの編集・ユーティリティ ネットワークのトポロジーの検証    ライセンスの詳細はESRIジャパン製品ページをご参照ください。\nライセンスの認証方法 ライセンスの認証は次の2つの方法があります。\n  ライセンスキーを使用した認証\n ライセンスキーを使用した認証は、ArcGIS Runtime の配布パックを購入し、取得したライセンスキーを利用して、アプリケーションを認証します。    指定ユーザーによるアカウント認証\n 指定ユーザーによるアカウント認証とは、ArcGIS Online または ArcGIS Enterprise の組織のメンバーである ArcGIS 組織アカウントを使用してログイン認証を行います。 ログインを行う指定ユーザーアカウントのタイプによって関連付けられたライセンスのレベルが異なり、また認証はアプリにコードを含める必要があります。    指定ユーザーのユーザータイプとライセンスレベルの対比表 ArcGIS Online のユーザータイプの場合\n   ユーザータイプ ライセンスレベル     Viewer Lite   Contributor / Mobile Worker Basic   Creator Standard   Professional / Professional Plus Advanced    ArcGIS Enterprise のユーザータイプの場合\n   ユーザータイプ ライセンスレベル     Viewer Lite   Editor / Mobile Worker Basic   Creator / GIS Professional Basic Standard   GIS Professional Standard / GIS Professional Advanced Advanced    Lite ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Lite のライセンスキーを取得する必要があります 認証の方法は、Lite ライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Lite ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Basic ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Basic の配布パックを購入する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Basic ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Standard ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Standard の配布パックを購入する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、Portal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Standard ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Advanced ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Advanced の配布パックを購入する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、Portal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Advanced ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Analysis Extension ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Analysis Extension の配布パックを購入する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、Portal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Analysis アドオン ライセンスを割り当てられた）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Advanced Editing Extension ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Advanced Editing Extension の配布パックを購入する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    Portal for ArcGIS へのログインによる認証\n注意：この認証は、ArcGIS Enterprise 11.1 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに Portal for ArcGIS の指定ユーザー アカウント（Advanced Editing ユーザー タイプ エクステンションを割り当てられた）が必要です アプリケーションが少なくとも 30 日に 1 回は Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    ライセンスの認証 以下の認証に応じた作業を行ってください。\nLite ライセンスキーを使用した認証 ArcGIS Runtime Lite のライセンスキーを Esri Developer のサイトから取得し、取得したライセンスキーを利用して、アプリケーションを Lite ライセンスで認証することができます。 最初に以下の手順で Lite レベルのライセンスキーを取得します。\n  Get a license ページにアクセスします\n ArcGIS Location Platform アカウント、または、ArcGIS Online アカウントにサインインしてない場合は、いずれかのアカウントでサインインします。 いずれかのアカウントもお持ちでない場合は、ArcGIS Location Platform アカウントに サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。    表示されたライセンスキーをコピーします   次に、アプリケーションのコードにおいて SDK の機能が呼び出される前に、以下のコードを使用してアプリケーションにコピーしたライセンスキーを設定します。\n// 取得したライセンス文字列でアプリのライセンスを設定します string licenseKey = \u0026#34;runtimelite,1000,rud#########,none,####################\u0026#34;; ArcGISRuntimeEnvironment.SetLicense(licenseKey);   配布パックのライセンスキーを使用した認証 ArcGIS Runtime の配布パックを購入し、取得したライセンスキーを利用して、アプリケーションを認証することができます。\nArcGIS Runtime の配布パックの購入についてはESRIジャパンにお問合せください。ArcGIS Runtime の配布パックをご購入頂いた場合、ESRIジャパンよりライセンスキーをメールにてお送りします。\nアプリケーションのコードにおいて SDK の機能が呼び出される前に、以下のコードを使用して配布パックのライセンスキーを設定します。\n// 取得したライセンス文字列でアプリのライセンスを設定します string licenseKey = \u0026#34;runtimelite,1000,rud#########,day-month-year,####################\u0026#34;; ArcGISRuntimeEnvironment.SetLicense(licenseKey); Analysis Extension ライセンスを認証する場合は以下のコードを使用します。\n// 基本ライセンスとエクステンション ライセンスのリストを設定します string licenseKey = \u0026#34;runtimelite,1000,rud#########,day-month-year,####################\u0026#34;; string[] extensions = { \u0026#34;runtimeanalysis,1000,rud#########,day-month-year,####################\u0026#34; }; Esri.ArcGISRuntime.ArcGISRuntimeEnvironment.SetLicense(licenseKey, extensions); 指定ユーザー アカウントを使用した認証 アプリケーションの実行時に、アプリケーションを利用するユーザーが保有する ArcGIS Online 組織向けプランもしくは Portal for ArcGIS の指定ユーザー アカウントを使用して ArcGIS Online / Portal for ArcGIS にログインすることで、ライセンスを取得することができます。\nアプリケーションのコードにおいて SDK の機能が呼び出される前に、ライセンスを取得・設定します。以下のコードは、ArcGIS Online の指定ユーザーのライセンスを取得する方法を示しています。コードの前半で、ArcGIS Online ポータルを登録し、チャレンジ ハンドラーと OAuth 認証ハンドラーを設定することによって、AuthenticationManager を構成します。（Authentication Manager の使用を参照）\n認証方法の詳細については、「How to use named user login in your app（英語）」や「Security and authentication（英語）」も併せてご覧ください。\n// ポータルの認証情報をユーザーに要求します (arcgis.com の OAuth 認証情報のリクエスト) CredentialRequestInfo loginInfo = new CredentialRequestInfo(); // OAuth の暗黙的なグラントフローを使用します loginInfo.GenerateTokenOptions = new GenerateTokenOptions { TokenAuthenticationType = TokenAuthenticationType.OAuthImplicit }; // 認証する URL（ポータル）を指定します（ArcGIS Online） loginInfo.ServiceUri = new Uri(\u0026#34;http://www.arcgis.com/sharing/rest\u0026#34;); try { // AuthenticationManager の GetCredentialAsync を呼び出し、チャレンジハンドラを起動します  Credential cred = await AuthenticationManager.Current.GetCredentialAsync(loginInfo, false); AuthenticationManager.Current.AddCredential(cred); // 認証情報を使用してポータル（ArcGIS Online）に接続します  ArcGISPortal arcgisPortal = await ArcGISPortal.CreateAsync(loginInfo.ServiceUri); // ポータルから LicenseInfo を取得します  LicenseInfo licenseInfo = await arcgisPortal.GetLicenseInfoAsync(); // ... アプリをオフラインにするためにライセンス（JSON 文字列）を保存したり、すぐにアプリを認証するためにコードをここに記述します ...  // ライセンス情報を使ってアプリを認証します  ArcGISRuntimeEnvironment.SetLicense(licenseInfo); } catch (Exception ex) { // 例外処理を記述します。  Console.WriteLine(\u0026#34;ライセンス認証中の例外:\u0026#34; + ex); } ライセンス情報をローカルストレージに保存した場合、保存したライセンス情報を使用して、オフライン環境でアプリを起動してライセンスを取得できます。ストレージからライセンスを取得し、アプリを認証します。\n// LicenseInfo を JSON 形式のテキストとして取得します string licenseJson = licenseInfo.ToJson(); // ... テキスト文字列をローカルに保存します ...  // (起動時) ... デバイスに保存されているライセンス JSON を取得します ... // 保存した JSON 文字列からライセンス情報を設定します LicenseInfo license = LicenseInfo.FromJson(licenseJson); "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/ios/distribution-ios-200.x/",
	"title": "アプリケーション配布ガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for Swift を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を紹介します。",
	"content": "ArcGIS Maps SDK for Swift (バージョン 200.x) を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を説明します。\nAPI キーの設定 ArcGIS Location Platform のロケーションサービスを使用する場合は、アプリで API キーを設定する必要があります。API キーの詳細はAPI キーの取得を、APIキーの設定方法はアプリの作成のAPI キーを設定するをご覧ください。\nライセンス認証のステップ 開発したアプリケーションのライセンス認証のステップは以下の通りです。\n  使用するライセンスの選択\n  ライセンスの認証方法\n Lite ライセンスの認証方法 Basic ライセンスの認証方法 Standard ライセンスの認証方法 Analysis Extension ライセンスの認証方法 Advanced Editing Extension ライセンスの認証方法    ライセンスの認証\n Lite ライセンスキーを使用した認証 配布パックのライセンスキーを使用した認証 指定ユーザー アカウントを使用した認証    使用するライセンスの選択 ArcGIS Maps SDK for Swift には Lite、Basic、Standard の 3 つのライセンス レベルと Analysis エクステンションがあります。開発したアプリケーションが使用する機能に応じて、適切なライセンス レベルを選択してください。\n各ライセンスで利用可能な機能の概要は以下の表をご参照ください。\n   ライセンス 利用できる機能     Lite ・地図表示（2D/3D）\n・フィーチャの表示/検索\n・フィーチャのオンライン/オフライン編集（ArcGIS Online/ArcGIS Enterprise のパブリックなフィーチャ サービス、ArcGIS Location Platform のフィーチャサービス）\n・ルート検索/到達圏解析/最寄り施設検索\n・住所検索/リバース ジオコーディング\n・ユーティリティ ネットワークのトレース   Basic ・Lite ライセンスで利用できるすべての機能\n・フィーチャのオンライン/オフライン編集（ArcGIS Online/ArcGIS Enterprise のセキュアなフィーチャ サービス）\n・モバイル ジオデータベースの編集\n・ArcGIS Online/Portal for ArcGIS のコンテンツの編集   Standard ・Basic ライセンスで利用できるすべての機能\n・シェープファイルの表示/編集\n・GeoPackage の表示/編集\n・KML（ローカル ファイル）の表示/編集\n・ラスター データの表示/解析\n・航海用電子海図（ENC）の表示\n・3D 解析   Analysis Extension ・Standard ライセンスで利用可能なエクステンション・オフラインでの到達圏解析/最寄り施設検索   Advanced Editing Extension ・Basic ライセンス以上で利用可能なエクステンション・ブランチ バージョン ジオデータベースに新しいバージョンの作成・ブランチ バージョン ジオデータベースのバージョンのフィーチャ/テーブルの編集・ユーティリティ ネットワークのネットワーク フィーチャの編集・ユーティリティ ネットワークのトポロジーの検証    ライセンスの詳細はESRIジャパン製品ページをご参照ください。\nライセンスの認証方法 ライセンスの認証は次の2つの方法があります。\n  ライセンスキーを使用した認証\n ライセンスキーを使用した認証は、ArcGIS Runtime の配布パックを購入し、取得したライセンスキーを利用して、アプリケーションを認証します。    指定ユーザーによるアカウント認証\n 指定ユーザーによるアカウント認証とは、ArcGIS Online または ArcGIS Enterprise の組織のメンバーである ArcGIS 組織アカウントを使用してログイン認証を行います。 ログインを行う指定ユーザーアカウントのタイプによって関連付けられたライセンスのレベルが異なります。    指定ユーザーのユーザータイプとライセンスレベルの対比表 ArcGIS Online のユーザータイプの場合\n   ユーザータイプ ライセンスレベル     Viewer Lite   Contributor / Mobile Worker Basic   Creator Standard   Professional / Professional Plus Advanced ※1    ArcGIS Enterprise のユーザータイプの場合\n   ユーザータイプ ライセンスレベル     Viewer Lite   Editor / Mobile Worker Basic   Creator / GIS Professional Basic Standard   GIS Professional Standard / GIS Professional Advanced Advanced ※1    ※1 ArcGIS Maps SDK for Swift には Advanced ライセンスはありません。\nLite ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Lite のライセンスキーを取得する必要があります 認証の手順は、Lite ライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Lite ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Basic ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Basic の配布パックを購入する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Basic ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Standard ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Standard の配布パックを購入する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、Portal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Standard ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Analysis Extension ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Analysis Extension の配布パックを購入する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、Portal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Analysis アドオン ライセンスを割り当てられた）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Advanced Editing Extension ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Advanced Editing Extension の配布パックを購入する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    Portal for ArcGIS へのログインによる認証\n注意：この認証は、ArcGIS Enterprise 11.1 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに Portal for ArcGIS の指定ユーザー アカウント（Advanced Editing ユーザー タイプ エクステンションを割り当てられた）が必要です アプリケーションが少なくとも 30 日に 1 回は Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    ライセンスの認証 以下の認証に応じた作業を行ってください。\nLite ライセンスキーを使用した認証 ArcGIS Runtime Lite のライセンスキーを Esri Developer のサイトから取得し、取得したライセンスキーを利用して、アプリケーションを Lite ライセンスで認証することができます。 最初に以下の手順で Lite レベルのライセンスキーを取得します。\n  Get a license ページにアクセスします\n ArcGIS Location Platform アカウント、または、ArcGIS Online アカウントにサインインしてない場合は、いずれかのアカウントでサインインします。 いずれかのアカウントもお持ちでない場合は、ArcGIS Location Platform アカウントに サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。    表示されたライセンスキーをコピーします。   次に、アプリケーションのコードにおいて SDK の機能が呼び出される前に、以下のコードを使用してアプリケーションにコピーしたライセンスキーを設定します。\n// 取得したライセンス文字列でアプリのライセンスを設定します guard let licenseKey = LicenseKey(\u0026#34;runtimelite,1000,rud#########,none,####################\u0026#34;) else { return } do { let result = try ArcGISEnvironment.setLicense(with: licenseKey) print(\u0026#34;License Result : \\(result.licenseStatus)\u0026#34;) } catch { print(error) }   配布パックのライセンスキーを使用した認証 ArcGIS Runtime の配布パックを購入し、取得したライセンスキーを利用して、アプリケーションを認証することができます。\nArcGIS Runtime の配布パックの購入についてはESRIジャパンにお問合せください。ArcGIS Runtime の配布パックをご購入頂いた場合、ESRIジャパンよりライセンスキーをメールにてお送りします。\nアプリケーションのコードにおいて SDK の機能が呼び出される前に、以下のコードを使用して配布パックのライセンスキーを設定します。\n// 取得したライセンス文字列でアプリのライセンスを設定します guard let licenseKey = LicenseKey(\u0026#34;runtimestandard,1000,rud#########,day-month-year,####################\u0026#34;) else { return } do { let result = try ArcGISEnvironment.setLicense(with: licenseKey) print(\u0026#34;License Result : \\(result.licenseStatus)\u0026#34;) } catch { print(error) } Extension ライセンスを認証する場合は以下のコードを使用します。\n// 基本ライセンスとエクステンション ライセンスのリストを設定します let licenseKey = LicenseKey(\u0026#34;runtimestandard,1000,rud#########,day-month-year,####################\u0026#34;)! let extensions = [ LicenseKey(\u0026#34;runtimeanalysis,1000,rud#########,day-month-year,####################\u0026#34;)! ] do { let result = try ArcGISEnvironment.setLicense( with: licenseKey, extensions: extensions ) } catch { print(error) } 指定ユーザー アカウントを使用した認証 アプリケーションの実行時に、アプリケーションを利用するユーザーが保有する ArcGIS Online 組織向けプランもしくは Portal for ArcGIS の指定ユーザー アカウントを使用して ArcGIS Online / Portal for ArcGIS にログインすることで、ライセンスを取得することができます。\nアプリケーションのコードにおいて SDK の機能が呼び出される前に、ライセンスを取得・設定します。以下のコードは、ArcGIS Online の指定ユーザーのライセンスを取得する方法を示しています。\n認証方法の詳細については、「How to use named user login in your app（英語）」や「Security and authentication（英語）」も併せてご覧ください。\n// Portal クラスを構築し、指定ユーザーが認証情報を提供することを確認します。 let url = URL(string: \u0026#34;https://myportal.com\u0026#34;)! // 指定ユーザーが認証情報でログインすることを要求します。 let portal = Portal(url: url, connection: .authenticated) // ポータルをロードします。 do { try await portal.load() // ポータルからユーザーのライセンス情報を取得します。 let licenseInfo = try await portal.licenseInfo // 指定ユーザーの licenseInfo を使用してライセンスを設定します。 let result = try ArcGISEnvironment.setLicense(from: licenseInfo) // これでアプリはライセンス認証されました。 // キーチェーン アイテムを作成し、ライセンス情報を保存して、アプリをオフラインで起動してライセンスを取得できるようにします。 let licenseInfoData = licenseInfo.toJSON().data(using: .utf8)! let label = \u0026#34;com.your_org.your_app_name\u0026#34;.data(using: .utf8)! let keychainItem: [String: Any] = [kSecClass as String: kSecClassKey, kSecAttrLabel as String: label, kSecValueData as String: licenseInfoData, kSecUseDataProtectionKeychain as String: true] let status = SecItemAdd(keychainItem as CFDictionary, nil) } catch { print(error) } "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/install-jsapi/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for JavaScript ライブラリのインストール方法を紹介します。",
	"content": "ArcGIS Maps SDK for JavaScript のライブラリを Windows® Server の IIS（インターネット インフォメーション サービス）上に配置して Web アプリからアクセスできる環境を作るまでの流れを紹介します。API の詳細についてはインストールおよびセットアップ方法を参照してください。なお、IIS 以外の Web サーバーや Linux 上の Web サーバー（Apache Tomcat® など）へインストールする場合も基本的な流れは変わりません。\nEsri がホストしている CDN にインターネット経由で参照する場合には、ライブラリをインストールする必要はありません。\nライブラリのダウンロード ライブラリとヘルプ ドキュメントは ArcGIS Maps SDK for JavaScript リファレンスの Downloads ページからダウンロードできます。ダウンロードしたいバージョンの [API] ボタンをクリックするとダウンロードが開始します。\n※ バージョンによってはインストール方法が本手順とは異なる場合があります。詳しくはダウンロード フォルダ内にあります install.html をご参照ください。\n [Documentation] ボタンをクリックすると https://developers.arcgis.com/javascript/ で公開されているヘルプ ドキュメントとサンプル一式をダウンロードできます。\n Web サーバー（IIS）に配置  ダウンロードしたライブラリの zip ファイルを解凍します。 \\arcgis_js_v429_api\\arcgis_js_api\\javascript\\4.29\\ とすべてのコンテンツをコピーして Web サーバー上に配置します。例 : (C:\\inetpub\\wwwroot\\javascript\\api\\4.29\\)  必要条件 ArcGIS Maps SDK for JavaScript ライブラリおよびドキュメントのデフォルトのホスティング構成は、いずれも HTTPS です。\n  HTTPS では、Web サーバーに Web サーバー証明書を使用する必要があります。\n  IIS には、以下の MIME タイプの登録が必要です。\n   拡張 MIME/type 説明     .ttf application/octet-stream True Typeフォント   .wasm application/wasm WebAssembly   .woff application/font-woff Web Open Font Format   .woff2 application/font-woff2 WOFF File Format 2.0   .wsv application/octet-stream SceneViewの星の可視化に対応   .pbf application/x-protobuf 一部のレイヤーの MapView ラベル用のフォント      Google: HTTPSが重要な理由\n  Google: HTTPS でサイトを保護する\n  インストールのテスト 以下のサンプルは、ArcGIS Maps SDK for JavaScript のダウンロード版に含まれています。 ArcGIS Maps SDK for JavaScript のダウンロード版から /arcgis_js_v429_api/arcgis_js_api/javascript/4.29/ およびそのすべてのコンテンツを Web サーバにコピーした後、サポートされている Web ブラウザでアプリケーション https://www.example.com/javascript/4.29/index.html を開くことにより、API をテストすることができます。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1,maximum-scale=1,user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Test local installation of ArcGIS Maps SDK for JavaScript\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 93%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./esri/themes/light/main.css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;./init.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; require([\u0026#34;esri/Basemap\u0026#34;, \u0026#34;esri/layers/TileLayer\u0026#34;, \u0026#34;esri/Map\u0026#34;, \u0026#34;esri/views/SceneView\u0026#34;], function ( Basemap, TileLayer, Map, SceneView ) { // --------------------------------------------------------------------  // If you do not have public internet access, change the layer URL to  // point to your own locally accessible cached service.  // --------------------------------------------------------------------  const layer = new TileLayer({ url: \u0026#34;https://services.arcgisonline.com/arcgis/rest/services/World_Street_Map/MapServer\u0026#34; }); const customBasemap = new Basemap({ baseLayers: [layer], title: \u0026#34;My Basemap\u0026#34; }); const myMap = new Map({ basemap: customBasemap }); const view = new SceneView({ container: \u0026#34;viewDiv\u0026#34;, map: myMap }); checkThisOne(\u0026#34;./esri/views/3d/environment/resources/stars.wsv\u0026#34;, \u0026#34;wsv mimetype\u0026#34;); checkThisOne(\u0026#34;./esri/t9n/basemaps.json\u0026#34;, \u0026#34;json mimetype\u0026#34;); checkThisOne(\u0026#34;./esri/themes/base/icons/fonts/CalciteWebCoreIcons.ttf\u0026#34;, \u0026#34;ttf mimetype\u0026#34;); checkThisOne(\u0026#34;./esri/themes/base/icons/fonts/CalciteWebCoreIcons.woff\u0026#34;, \u0026#34;woff mimetype\u0026#34;); function checkThisOne(url, desc) { fetch(url, { method: \u0026#34;HEAD\u0026#34; }) .then(function (response) { if (response.ok) { logDiv.innerHTML += \u0026#34;* OK: \u0026#34; + desc + \u0026#34;\u0026lt;br/\u0026gt;\u0026#34;; if (response.status !== 200) { logDiv.innerHTML += \u0026#34;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;status: \u0026#34; + response.status + \u0026#34;\u0026lt;br/\u0026gt;\u0026#34;; } return response.blob(); } else { // response not ok  logDiv.innerHTML += \u0026#34;* HTTP error \u0026#34; + response.status + \u0026#39; for \u0026lt;a href=\u0026#34;\u0026#39; + url + \u0026#39;\u0026#34;\u0026gt;\u0026#39; + url + \u0026#34;\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt;\u0026#34;; alert(\u0026#34;Problem accessing \u0026#34; + desc); } }) .catch(function (error) { logDiv.innerHTML += \u0026#39;* BAD: \u0026lt;a href=\u0026#34;\u0026#39; + url + \u0026#39;\u0026#34;\u0026gt;\u0026#39; + url + \u0026#34;\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt;\u0026#34;; }); } }); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;logDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 以下のスクリーンショットのような結果が表示されます。(X.YZの部分は4.29となります。) "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/development-guide/",
	"title": "カスタム ウィジェット開発ガイド",
	"tags": [],
	"description": "カスタム ウィジェットを開発する手順を紹介します。",
	"content": "はじめに このガイドについて このガイドは ArcGIS Web AppBuilder (Developer Edition) （以下、Web AppBuilder）で使用するカスタム ウィジェットを作成する方法を説明します。\nWeb AppBuilder のインストール方法に関しては、ArcGIS Web AppBuilder (Developer Edition) インストールガイドをご参照ください。\nまた Esri Japan GitHub では、Web AppBuilder のカスタム ウィジェット/テーマが共有されています。このガイドで作成するウィジェットの完成版も公開されています。\n既成ウィジェットのソースコードの確認 Web AppBuilder で使われる全てのウィジェットは \u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\client\\stemapp\\widgets に格納されていて、ソースコードを確認できます。開発したカスタム ウィジェットも同様にこのディレクトリに配置します。\n上記ディレクトリにある samplewidgets フォルダーには簡易機能のサンプル ウィジェットが用意されています（本ガイドではウィジェット作成の雛形となるコードが記述されたテンプレートである CustomWidgetTemplate を使用します）。\nウィジェットのフォルダー構成 カスタム ウィジェットを作成する際に使用するファイルは以下です。全ファイルが必須ではなく、ウィジェットの UI を設ける、ウィジェットをローカライズする、設定画面を設ける等の目的に応じてファイルを準備します。\nカスタム ウィジェットの開発 1. ウィジェット ボタンを配置する Web AppBuilder のウィジェットは2 種類に分けられます。1 つは「描画」ウィジェットのようなパネルを表示して使用するウィジェットです（Web AppBuilder では In-Panel ウィジェットと呼びます）。もう 1 つは、「現在位置」ウィジェットのように画面上にボタンのみを配置するパネルを表示しないウィジェットです（Off-Panel ウィジェットと呼びます）。\n本ガイドでは簡単なバッファー検索を行う In-Panel ウィジェットを開発していきます。ウィジェットを追加するには \u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\client\\stemapp\\widgets にウィジェットのフォルダーを配置します。\n`\\client\\stemapp\\widgets\\samplewidgets` にある `CustomWidgetTemplate` フォルダーを `\\client\\stemapp\\widgets` にコピーします。\r`CustomWidgetTemplate` フォルダーの名前を `Buffer` に変えます。\nフォルダー名は半角英数字である必要があります。\n\r`Buffer` フォルダー直下にある `manifest.json` ファイルを開きます。\r`name` 属性の値を `Buffer` に変更します。\r文字コードに UTF8 を指定して、`manifest.json` ファイルを保存します。 以降で紹介する手順においてもファイルを保存する際は、文字コードを UTF8 に指定して保存するようにしてください。\r\rmanifest.json ウィジェットの名前やバージョンなどのウィジェットの属性を設定するファイルです。properties 属性でカスタム ウィジェットのプロパティを構成できます。inPanel を false に設定すると Web AppBuilder のウィジェットの追加画面に表示されなくなります。ウィジェットのプロパティについてはWidget manifestをご参照ください。\nWeb AppBuilder のウィジェットの追加画面で表示されるウィジェット名をローカライズします。ウィジェットのローカライズは `Buffer` フォルダーの直下にある `nls` フォルダーで設定します。`Buffer\\nls` フォルダーにある `strings.js` ファイルを開き、以下のコードを入力し保存します。 define({\rroot: ({\r_widgetLabel: \"Buffer\"\r}),\r\"ja\": 1\r});\r\r`nls` フォルダー直下に `ja` フォルダーを作成します。\r`ja` フォルダーに `strings.js` ファイルを作成し、以下のコードを入力し保存します。 define({\r_widgetLabel: \"バッファー検索\"\r});\r\rWeb AppBuilder を起動してアプリケーションを作成すると、ウィジェットの追加画面に「バッファー検索」というウィジェットが新しく表示されます。\n※ 作成する Web アプリに表示するウィジェット名は Web AppBuilder のウィジェット構成画面で変更可能です。\r\r\rnls フォルダー カスタム ウィジェットを多言語化する場合に使用します（アクセスするブラウザーのロケールにより該当する言語が表示されます）。_widgetLabel はウィジェット追加時に表示されるラベルをローカライズするための固有の属性です。\n使用例\n nls\\strings.js：「Widget.html」でローカライズするストリングを指定  define({ root: ({ label1: \u0026#34;Hello\u0026#34; }), \u0026#34;ja\u0026#34;: 1 // 日本語ロケールを使用する場合に 1 と設定 });  nls\\ja\\strings.js：各言語フォルダーにある strings.js ファイルで表示する文字を設定  define({ label1: \u0026#34;こんにちは\u0026#34; });  Widget.html：文字を表示  \u0026lt;label\u0026gt;${nls.label1}\u0026lt;/label\u0026gt; images\\icon.png カスタム ウィジェットのボタンのアイコンを変更したい場合は、このファイルを置き換えます。\n2. ウィジェットの構成画面を作成する Web AppBuilder でウィジェットの構成を行う画面を作成します。ここでは検索に使用するバッファーの距離単位を設定する画面を作成します。\n  Buffer フォルダーに setting フォルダーを作成します。\n  setting フォルダーに Setting.html ファイルを作成し、以下のコードを入力します。\n  \u0026lt;div\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;td\u0026gt;距離単位\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;div\u0026gt; \u0026lt;select data-dojo-attach-point=\u0026#34;selectLengthUnit\u0026#34; data-dojo-type=\u0026#34;dijit/form/Select\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;kilometers\u0026#34; selected=\u0026#34;selected\u0026#34;\u0026gt;キロメートル\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;meters\u0026#34;\u0026gt;メートル\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; setting フォルダーに Setting.js ファイルを作成し、以下のコードを入力します。  define([ \u0026#39;dojo/_base/declare\u0026#39;, \u0026#39;dijit/_WidgetsInTemplateMixin\u0026#39;, \u0026#39;jimu/BaseWidgetSetting\u0026#39;, \u0026#39;esri/units\u0026#39;, \u0026#39;dijit/form/Select\u0026#39; ], function(declare, _WidgetsInTemplateMixin, BaseWidgetSetting, esriUnits) { return declare([BaseWidgetSetting, _WidgetsInTemplateMixin], { baseClass: \u0026#39;jimu-widget-buffer-setting\u0026#39;, startup: function() { this.inherited(arguments); if (!this.config.measurement) { this.config.measurement = {}; } this.setConfig(this.config); }, setConfig: function(config) { this.config = config; if (this.config.measurement.LengthUnit) { this.selectLengthUnit.set(\u0026#39;value\u0026#39;, this.config.measurement.LengthUnit); } else { // デフォルトで表示される単位をキロメートルに設定  this.selectLengthUnit.set(\u0026#39;value\u0026#39;, \u0026#39;kilometers\u0026#39;); this.config.measurement.UnitLabel = \u0026#39;キロメートル\u0026#39;; } }, getConfig: function() { // ユーザーが単位を変更した時に config.json にその値を格納  this.config.measurement.LengthUnit = this.selectLengthUnit.value; // ウィジェットのパネルに表示する単位ラベルに使用  if (this.config.measurement.LengthUnit === \u0026#39;kilometers\u0026#39;) { this.config.measurement.UnitLabel = \u0026#39;キロメートル\u0026#39;; } else { this.config.measurement.UnitLabel = \u0026#39;メートル\u0026#39;; } return this.config; } }); }); Buffer フォルダーの config.json ファイルを開き、以下のコードを入力します。  { \u0026#34;measurement\u0026#34;: {} } Buffer\\manifest.json を開き hasSettingLocale と hasSettingStyle 属性を false にします。\nsetting フォルダーに css や nls フォルダーを作成することで、構成画面用のスタイル定義、ローカライズが可能ですが、ここでは使用しないため false にします。 ブラウザーを更新して、バッファー検索ウィジェットを追加すると、ウィジェットの構成画面が表示されます。\n変更を反映するために Web AppBuilder を再起動（Node.js の再起動およびブラウザーで Web AppBuilder を更新）する必要がある場合があります。   Setting\\Setting.html Web AppBuilder でウィジェットの設定を行う画面を作成します。\nSetting\\Setting.js Web AppBuilder でウィジェットの設定を行う際の処理を実装します。jimu/BaseWidgetSetting の子クラスを作成し、baseClass に jimu-widget-\u0026lt;ウィジェット名\u0026gt;-setting を指定します。以下のイベントが用意されています。\n setConfig：設定画面の初期化時 getConfig：設定変更時（変更内容を config.json のオブジェクトに格納）  config.json JSON 形式のオブジェクト格納ファイルです。Web AppBuilder でウィジェットの設定を行う場合は、config.json に用意した空のオブジェクトに値を格納して、 Widget.html や Widget.js からそのオブジェクトを取得します。 3. ウィジェットの処理を実装する   Buffer フォルダーにある Widget.html ファイルを開き編集します。バッファーの半径（inputNode）とマップ上にあるレイヤーから検索対象のレイヤーを選択（layerSelectNode）する画面を作成します。\n\u0026lt;div\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;半径を入力（${config.measurement.UnitLabel}）\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;input class=\u0026#34;jimu-input\u0026#34; data-dojo-attach-point=\u0026#34;inputNode\u0026#34; value=\u0026#34;1000\u0026#34;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;検索レイヤーを選択\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;div data-dojo-attach-point=\u0026#34;layerSelectNode\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt;   Buffer フォルダーにある Widget.js ファイルを開き編集します。\n  define([ \u0026#39;dojo/_base/declare\u0026#39;, \u0026#39;dojo/_base/lang\u0026#39;, \u0026#39;jimu/BaseWidget\u0026#39;, \u0026#39;jimu/LayerStructure\u0026#39;, \u0026#39;esri/geometry/geometryEngine\u0026#39;, \u0026#39;esri/symbols/SimpleMarkerSymbol\u0026#39;, \u0026#39;esri/symbols/SimpleLineSymbol\u0026#39;, \u0026#39;esri/symbols/SimpleFillSymbol\u0026#39;, \u0026#39;esri/Color\u0026#39;, \u0026#39;esri/graphic\u0026#39;, \u0026#39;esri/tasks/query\u0026#39;, \u0026#39;dijit/form/Select\u0026#39; ], function(declare, lang, BaseWidget, LayerStructure, geometryEngine, SimpleMarkerSymbol, SimpleLineSymbol, SimpleFillSymbol, Color, Graphic, Query, Select) { return declare([BaseWidget], { baseClass: \u0026#39;jimu-widget-buffer\u0026#39;, ckickfunction: null, layerList: null, layerId: null, // スタートアップ時に実行されるメソッド  startup: function() { this.inherited(arguments); // マップ上のレイヤーを取得し、レイヤー一覧を作成  var options = []; var layerStructure = LayerStructure.getInstance(); layerStructure.traversal(function(layerNode) { layerNode.getLayerType() .then(function(type) { if (type === \u0026#39;FeatureLayer\u0026#39;) { var option = { value: layerNode.id, label: layerNode.title }; options.push(option); } }) .catch(function(err) { console.log(err); }); }); this.layerList = new Select({ options: options }, this.layerSelectNode); this.layerList.startup(); // レイヤー一覧を変更したときのイベント  this.layerList.on(\u0026#34;change\u0026#34;, lang.hitch(this, function(val) { this.layerId = val; })); }, // ウィジェットのパネルを開くときに実行されるメソッド  onOpen: function() { this.inherited(arguments); // マップをクリックしたときのイベント ハンドラ  this.ckickfunction = this.map.on(\u0026#34;click\u0026#34;, lang.hitch(this, this._clickHandler)); }, // ウィジェットのパネルを閉じるときに実行されるメソッド  onClose: function() { this.inherited(arguments); // マップに表示されているグラフィックを削除  this.map.graphics.clear(); // マップのクリック イベントを削除  this.ckickfunction.remove(); }, // マップのクリック イベント  _clickHandler: function(evt) { // マップ コンストラクタを取得  var map = this.map; // マップに表示されているグラフィックを削除  map.graphics.clear(); // inputNode に入力された半径の値を取得  var distance = this.inputNode.value; // ウィジェット構成時に設定した半径の単位を config.json から取得  var unit = this.config.measurement.LengthUnit; // クリック地点から指定した半径のバッファーを作成  var bufferGeometry = geometryEngine.buffer(evt.mapPoint, distance, unit); // 作成したバッファーをマップに表示  var sfs = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASHDOT, new Color([255, 0, 0]), 2), new Color([255, 255, 0, 0.25])); var graphic = new Graphic(bufferGeometry, sfs); map.graphics.add(graphic); // バッファー内のフィーチャを検索  var query = new Query(); query.geometry = graphic.geometry; query.spatialRelationship = Query.SPATIAL_REL_CONTAINS; // マップからレイヤー ID を指定してフィーチャ レイヤーを取得  var layer = map.getLayer(this.layerId); // フィーチャ レイヤーに対してクエリを実行  layer.queryFeatures(query) .then(function(featureSet) { // ポイント、ライン、ポリゴンごとにシンボルを設定  var highlightSymbol; if (layer.geometryType == \u0026#34;esriGeometryPoint\u0026#34;) { highlightSymbol = new SimpleMarkerSymbol(); highlightSymbol.setColor(new Color(\u0026#34;#f00\u0026#34;)); highlightSymbol = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE, 16, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([255, 0, 0]), 1), new Color([255, 0, 0, 0.5])); } else if (layer.geometryType == \u0026#34;esriGeometryPolyline\u0026#34;) { highlightSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([255, 0, 0, 0.5]), 6); } else { highlightSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([255, 0, 0]), 3), new Color([125, 125, 125, 0.5])); } // 結果を表示  featureSet.features.forEach(function(feature) { var queryGraphic = new Graphic(feature.geometry, highlightSymbol); map.graphics.add(queryGraphic); }); }); } }); }); Web AppBuilder で新しくアプリケーションを作成します。 Web AppBuilder でフィーチャ サービスをレイヤーとして追加した Web マップを表示します（このウィジェットはフィーチャ レイヤーに対してバッファー検索を行います）。 バッファー検索ウィジェットを追加し、バッファー検索ウィジェットのボタンをクリックして、半径とレイヤーを設定します。\n マップ上をクリックすると、バッファー内にあるフィーチャがハイライト表示されます。\n  Widget.html ウィジェットの画面を作成します。Web AppBuilder には、デフォルトでいくつかの css クラスが含まれており、アプリのデザインを統一させることができます。各クラスの詳細は css ファイル（jimu.js/css/jimu.css）を参照ください。\n使用例：\n\u0026lt;input class=\u0026#34;jimu-input\u0026#34; data-dojo-attach-point=\u0026#34;inputNode\u0026#34; value=\u0026#34;10000\u0026#34;\u0026gt;\u0026lt;/input\u0026gt; css\\style.css Widget.html のスタイル定義ファイルです。\n使用例：\njimu-widget-\u0026lt;ウィジェット名\u0026gt; div:first-child { color: red; } Widget.js ウィジェットの機能を実装するファイルです。jimu/BaseWidget の子クラスを作成し、\u0026quot;baseClass\u0026quot; に jimu-widget-\u0026lt;ウィジェット名\u0026gt; を指定します。\n\u0026quot;baseClass\u0026quot; は、ウィジェットの css クラスとして適用されるためスタイルの競合を避けることができ、スタイルを定義する際に役立ちます。\nウィジェットのプロパティ Web AppBuilder で表示しているマップには map プロパティを使用してアクセスします。\n使用例：\n Widget.js：  this.mapIdNode.innerHTML = \u0026#39;マップのID：\u0026#39; + this.map.id;  Widget.html：  \u0026lt;div data-dojo-attach-point=\u0026#34;mapIdNode\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; その他に利用可能なプロパティは以下です。\n id label icon uri position config（config.json のオブジェクト） appConfig（アプリの構成ファイルのオブジェクト） folderUrl state（ウィジェットの状態：\u0026quot;opened\u0026quot;、\u0026quot;closed\u0026quot; または \u0026quot;active\u0026quot;） windowState（ウィジェット ウィンドウの状態：\u0026quot;normal\u0026quot;、\u0026quot;minimized\u0026quot; または \u0026quot;maximized\u0026quot;） started（ウィジェットの起動状態） name baseClass templateString  ウィジェットのメソッド ウィジェットは、読み込みやウィジェットの開閉などのイベントの発生で実行されるメソッドが定義されています（ウィジェット ライフサイクル）。このメソッド内に処理を追加することで、ウィジェットをカスタマイズしていきます。\n例えば、ウィジェットが開かれた時に処理を実行するには onOpen メソッドを使用します。\n使用例：\nonOpen: function() { var map = this.map; // ... } その他に利用可能なメソッドは以下です。\n onOpen onClose onNormalize onMinimize onMaximize onActive onDeActive onSignIn onSignOut onPositionChange  利用可能な Dojo のウィジェット Web AppBuilder では Dojo Toolkit が提供しているウィジェット（dijit）を使用することができます。\nさらに、Web AppBuilder 独自のウィジェット（jimu.js/dijit）も提供されています。\nヘルプに使用方法は記載されていませんが、Web AppBuilder に含まれている以下のウィジェットも使用できます。\n CheckBox RadioBtn DrawBox ColorPicker Popup ImageChooser TabContainer ExtentChooser Message LayerFieldChooser PopupConfig SymbolChooser  nls ウィジェットで表示されるメニューを多言語化する場合に使用します。ウィジェット名をローカライズした方法と同様の手順でローカライズできます。\nウィジェットの更新 Web AppBuilder に追加する場合 \u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\client\\stemapp\\widgets にフォルダーを配置します。ウィジェットの構成用ファイルを更新した場合は、ブラウザーで Web AppBuilder を更新することで、更新内容が Web AppBuilder に反映されます。\n※ 更新前に作成したアプリケーションには更新内容は反映されません。新たに設置したカスタム ウィジェットを利用したい場合は、新たにアプリケーションを作成する必要があります。\nダウンロードした Webアプリケーションに追加する場合 ダウンロードしたアプリケーションの widgets フォルダーの直下にカスタム ウィジェットのフォルダーを配置し、アプリケーションのルート フォルダーにある config.json の widgetOnScreen（マップ上に表示）または widgetPool（ツールバー上に表示）セクションの widgets 属性にウィジェットの参照先等を設定します。\nwidgetPool にウィジェットを追加する例：\n{ \u0026#34;name\u0026#34;: \u0026#34;\u0026lt;ウィジェット名\u0026gt;\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;\u0026lt;アプリで表示する名前\u0026gt;\u0026#34;, \u0026#34;uri\u0026#34;: \u0026#34;widgets/\u0026lt;ウィジェット名\u0026gt;/Widget\u0026#34; } ウィジェット開発時の Tips Web AppBuilder では新規にアプリケーションを作成するときに、\u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\client\\stemapp\\widgets フォルダーに配置されたウィジェットが読み込まれます。作成済みの既存アプリケーションには、ウィジェットの更新内容は反映されないため、ウィジェットを更新する度に新規にアプリケーションを作成する作業が発生してしまい、非常に面倒です。\n開発段階でウィジェットの更新や動作確認を行うには、以下の手順が便利です。\n Web AppBuilder で新規にアプリケーションを作成します。 \u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\server\\apps フォルダーを開きます。このフォルダーには Web AppBuilder で作成したアプリケーションが配置されています。\nフォルダー名にはアプリケーションの作成順に数字が割り当てられます。\n 手順1で作成したアプリケーションのフォルダーを開き、ウィジェットの構成ファイルを更新します。アプリケーション名は、各アプリケーションのルート フォルダーにある config.json ファイルに記載された JSON の title 属性で確認できます。\n Web AppBuilder で該当するアプリケーションを開きます。既に開いている場合はブラウザーを更新します。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/calcite-design-system/core-concepts/",
	"title": "コア コンセプト",
	"tags": [],
	"description": "Web コンポーネントを活用するための基本的な概念とパターンを学びます。",
	"content": "出典：Calcite Design System - core concepts\nCalcite Components は、Stencil.js を使用して構築された、再利用可能な Web コンポーネントのライブラリです。Calcite Components を使用すると、ブランド力のある、軽量でアクセスしやすい Web アプリケーションをすばやく構築できます。\nWeb コンポーネントはブラウザのネイティブ規格であり、Calcite Components で開発するために必要な技術的概念の多くは、このライブラリに固有のものではありません。このページでは、効果的な開発を行うために必要な、Web の主要コンセプトを紹介しています。さらに詳しい情報について、このページにあるすべての概念は、MDN Web Docs やその他の Web 標準ドキュメントのソースで見つけることができます。\nカスタム要素 カスタム要素は、Web コンポーネント標準の一部であり、HTML と任意の JavaScript ライブラリまたは Web フレームワークを使用して、モダン ブラウザ全体で動作します。カスタム要素は機能をカプセル化するため、他のコードとのコンフリクトを防ぐことができます。\nCalcite Components はカスタム要素であり、ネイティブの HTML 要素と同様に使用することができます。\n\u0026lt;calcite-tip heading=\u0026#34;Platypus\u0026#34;\u0026gt;\u0026lt;/calcite-tip\u0026gt;  スロット スロットはプレースホルダー要素であり、スロットの名前を参照することで独自のコンテンツを追加することができます。スロットは一般的な Web コンポーネントの概念であり、あなたもすでに使用している可能性があります。例えば、次のような HTML を考えてみましょう。\n\u0026lt;select\u0026gt; \u0026lt;option value=\u0026#34;platypus\u0026#34;\u0026gt;Platypus\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;sloth\u0026#34;\u0026gt;Sloth\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;armadillo\u0026#34;\u0026gt;Nine-banded armadillo\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; Web コンポーネントの用語で、option 要素は select のデフォルト スロットに配置されます。また、「Platypus」、「Sloth」、「Nine-banded」のテキストは、それぞれの option のデフォルト スロットに配置されます。\nまた、多くの Calcite Components は、デフォルトのスロットを利用しています。例えば、下の calcite-tip では、デフォルトのスロットに p コンテンツが追加されています。\n\u0026lt;calcite-tip heading=\u0026#34;Platypus\u0026#34;\u0026gt; \u0026lt;img slot=\u0026#34;thumbnail\u0026#34; src=\u0026#34;platypus.jpg\u0026#34; alt=\u0026#34;A platypus sensing its prey using electrical fields.\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;A platypus is a mammal with a bill, similar to a duck. They use their bill to sense prey via electrolocation.\u0026lt;/p\u0026gt; \u0026lt;/calcite-tip\u0026gt; 多くの場合、デフォルトのスロットがあれば十分です。しかし、コンポーネントが複雑になればなるほど、子要素の位置やスタイルを変える必要が出てきます。そこで活躍するのがネームドスロットです。上の例では、チップの thumbnail スロットに画像が配置されています。これは、画像がデフォルトスロットの要素とは異なる方法で処理されるべきであることをコンポーネントに通知するものです。\nもしコンポーネントにスロットがあれば、slots for calcite-card のように、ドキュメントに記載されます。また詳細については、slots on MDN で学ぶこともできます。\n Shadow DOM カスタム要素はカプセル化され、そのマークアップ構造、スタイル、動作はページ上の他のコードから隠され、分離された状態に保たれます。Shadow DOM は、カスタム要素をカプセル化する仕組みです。その結果、Shadow DOM は Web コンポーネントの DOM 要素を隠して分離するため、ブラウザでレンダリングされますが、他のコードとぶつかることはありません。\nShadow DOM のカプセル化により、アプリケーション間で永続的なスタイルと機能を実現し、ユーザーに一貫したユーザー エクスペリエンスを提供することができます。\n CSS 変数 Calcite Components は、スタイルを上書きするための CSS 変数を提供しています。Web コンポーネントの Shadow DOM のため、CSS 変数がないと簡単にスタイルを変更することができません。トークンには CSS 変数があり、color や typography など、デザインシステム全体で使用されます。\nさらに、一部の Calcite Components には、コンポーネント固有のスタイルを変更するための独自の CSS 変数があります。これらの CSS 変数は、CSS variables for cacite-loader のように、コンポーネントのドキュメントで見つけることができます。\n使用例としては、CSS 変数を使用して、calcite-notice の前景色と文字色を入れ替えることができます。\ncalcite-notice { --calcite-ui-foreground-1: #151515; --calcite-ui-text-1: #ffffff; } CSS variable MDN documentation に、機能の詳細が説明されています。\n コンポーネント ロード Web コンポーネントはプレーンな HTML 要素として始まり、その実装がブラウザで定義されると同時にアップグレードされます。Calcite Components は、インポートされ、アプリケーションで使用されると、自動的に定義されます。しかし、特定のコードを実行する前に、コンポーネントが定義されるまで待つ必要がある場合があります。\nハイドレーション Stencil.js では、コンポーネントとそのすべての子コンポーネントのハイドレーションが終了したときに、フラグを追加するオプションが用意されています。これにより、様々なコンポーネントのダウンロードとレンダリングが非同期に行われるため、FOUC（Flash of Unstyled Content）を防止することができます。Calcite Components では、一度ハイドレーションされたコンポーネントに calcite-hydrated というCSSクラスが追加され、アプリケーションをデバッグする際に便利です。\n定義されたとき customElementRegistry インターフェースの whenDefined() メソッドは、指定された要素が定義されたときに満たされる Promise を返します。\nPromise が満たされると、次のようにコンポーネントの定義を必要とするコードを実行できるようになります。\ncustomElements.whenDefined(\u0026#34;calcite-button\u0026#34;).then(() =\u0026gt; document.querySelector(\u0026#34;calcite-button\u0026#34;).setFocus()); コンポーネントの準備 コンポーネントがいつレンダリングされるかを決定するには、Stencilの componentOnReady() メソッドを使用します。このメソッドは、componentDidLoad() ライフサイクルメソッドが起動した後に解決される Promise を返します。これは、コンポーネントのメソッドを使用する前にコンポーネントがロードされていることを確認する場合や、あるコンポーネントが他のコンポーネントに依存している場合に便利です。\n例えば、他のコンポーネントのレンダリングが終了するまで、calcite-loader を表示させたい場合があります。\n(async () =\u0026gt; { await customElements.whenDefined(\u0026#34;calcite-alert\u0026#34;); await document.querySelector(\u0026#34;calcite-alert\u0026#34;).componentOnReady(); document.querySelector(\u0026#34;calcite-loader\u0026#34;).hidden = true; })(); requestAnimationFrame  のコールバックとしてコンポーネントのメソッドを呼び出すことで、コンポーネントの状態でユーザー インターフェースが更新されます。例えば、ユーザーの閲覧履歴に基づいて、calcite-stepper の現在のステップを設定したい場合、goToStep()メソッドを使うことができます。\n(async () =\u0026gt; { await customElements.whenDefined(\u0026#34;calcite-stepper\u0026#34;); const el = await document.querySelector(\u0026#34;calcite-stepper\u0026#34;).componentOnReady(); requestAnimationFrame(() =\u0026gt; el.goToStep(3)); })();  イベント Calcite Components は、CustomEvent() コンストラクターを使用してイベントの作成とトリガーを行います。\nCustomEvent は Event と似たような振る舞いをします。これは button をクリックしたときなどの HTML 要素から放出されます。例えば、イベント ペイロードの target プロパティで要素にアクセスすることは可能です。また、一部の CustomEvent のペイロードは、detail プロパティにイベント固有の情報を含みます。\nコンポーネントのドキュメント ページを表示すると、calcite-pagination event のようなイベントを持つかどうかを確認することができます。\ndocument.addEventListener(\u0026#34;calcitePaginationChange\u0026#34;, event =\u0026gt; { console.log(`Starting item number on the page: ${event.target.startItem}`); });  フォーム フォーム送信時に適切に値を渡すためには、フォーム内の各コンポーネントに name 属性を設定する必要があります。例えば、Input Date Picker と Text Area に name 属性を追加します。\n\u0026lt;form\u0026gt; \u0026lt;calcite-label\u0026gt; Observation date: \u0026lt;calcite-input-date-picker name=\u0026#34;observation-date\u0026#34;\u0026gt;\u0026lt;/calcite-input-date-picker\u0026gt; \u0026lt;/calcite-label\u0026gt; \u0026lt;calcite-label\u0026gt; Observation notes: \u0026lt;calcite-text-area name=\u0026#34;observation-notes\u0026#34; placeholder=\u0026#34;Observation notes\u0026#34; max-length=\u0026#34;250\u0026#34;\u0026gt;\u0026lt;/calcite-text-area\u0026gt; \u0026lt;/calcite-label\u0026gt; \u0026lt;calcite-button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/calcite-button\u0026gt; \u0026lt;/form\u0026gt; フォームに関するその他の考慮事項については、フォームのアクセシビリティを参照してください。\n モード Calcite Components には明暗モードがあり、対応する CSS クラス calcite-mode-light と calcite-mode-dark を使って変更できる。calcite-mode-auto クラスもあり、ブラウザのprefers-color-scheme CSS メディアクエリに従うことで、明るいモードと暗いモードのどちらを使用するかを決定します。\n要素に モード クラスを設定すると、その子ノードもすべて変更されます。したがって、アプリケーション全体を明るい状態から暗い状態に切り替えるには、次のようにします。\n\u0026lt;body class=\u0026#34;calcite-mode-dark\u0026#34;\u0026gt; \u0026lt;!-- Your application content --\u0026gt; \u0026lt;/body\u0026gt; "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/",
	"title": "コア コンセプト",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) のコア コンセプトについて紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Core concepts\nはじめに Experience Builder は、カスタム ウィジェットの作成、カスタム テーマの作成、カスタム データソース、メッセージ/アクションの作成を通じて拡張することが可能です。これらはすべて、以下のコンポーネントで構成されているjimu と呼ばれる Experience Builder の拡張フレームワークを使用することで可能になります。\n ArcGIS Maps SDK for JavaScript 4.x React + Redux フレームワーク Bootstrap 4 （UI用） HTML5  Experience Builderでウィジェットやテーマなどを開発するには、TypeScript が必要になります。TypeScript を利用するのは、次のようなメリットがあります。\n 型宣言によるエラー検出 よりよい IDE 体験 セルフ-ドキュメント コード より読みやすく、わかりやすい  Experience Builder アプリケーションは多くのパーツで構成されています。これらのコンセプトは、アプリケーションの構造を理解するのに役立ちます。\n ページ（Page） \n ウィンドウ（Window） \n セクションとビュー（Section and view） \n 画面グループ（Screen groups） \n レイアウト（Layout） \n テーマ（Theme） \n ウィジェット（Widget） \n Jimu \n データ ソース（Data source） \n データアクション（Data action） \n メッセージ と アクション（Message and action） \n マップ/シーン ビュー（Map/Scene View） \n 拡張ポイント（Extension points） \n\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/visualization/data-visualization-procedure/",
	"title": "データ可視化の手順",
	"tags": [],
	"description": "ArcGIS Online 上のデータを可視化するための方法を紹介します。",
	"content": "ArcGIS Online 上のデータを可視化するための方法  マップを作成したい シンボルを変更したい ラベルを変更したい  マップを作成したい マップ ビューアー → [追加] → [保存]\n緯度経度の情報を持ったCSV ファイルなどを、レイヤーとしてマップに追加し、様々なレイヤーを組み合わせてマップを作成することができます。マップの保存には、コンテンツを作成する権限が必要です（権限を持っていない場合でもマップは作成できますが、保存することはできません）。\n  マップ ビューアーを開きます。マップ ビューアーを開いた時点でベースとなる背景地図(ベースマップ)は自動的に表示されます。\n  [追加] をクリックします。\n  [レイヤーの検索]、[Living Atlas レイヤーの参照]、[Web からレイヤーを追加]、[ファイルからレイヤーを追加]、[マップ メモの追加] いずれかのレイヤーの追加方法を選択します。\n  それぞれのレイヤー追加方法は、以下の通りです。\nレイヤーの検索   [検索] ボックスにキーワードを入力し、[検索] をクリックします。 [検索先] ドロップダウン リストでは、検索する場所を限定することができ、また、[マップ エリア内] のチェックボックスをオンにすると、マップ ビューアーの表示範囲にあるレイヤーを検索することができます。\n  検索結果は下部のボックス内に表示され、レイヤー名の右にある [追加] をクリックするか❶、レイヤー名をクリックしたのちに❷、[マップに追加] ❸をクリックします。\n  [レイヤーの追加を完了] をクリックし、レイヤーの追加を終了します。\n  Living Atlas レイヤーの参照 米国 Esri 社やほかのユーザーが提供する高品質マップ レイヤーをマップに追加します。レイヤーの詳細は、アイテム説明で確認できます。レイヤーによっては、組織向けアカウントでのサイン インが必要であったり、クレジットを消費するものがあります。\nWeb からレイヤーの追加 URL を指定して、ArcGIS Server Web サービス、OGC WMS Web サービス、OGC WMTS Web サービス、Web サーバー上にあるタイル レイヤー、KML ファイル、GeoRSS ファイル、および CSV ファイルのレイヤーを追加することができます。\nファイルからレイヤーを追加  [ファイルを選択] をクリックして、コンピューター上のファイル（区切りテキスト ファイル（.csv または .txt）、GPS Exchange Format（.gpx）ファイル、またはシェープファイル（.zip に圧縮済み））を選択します。  この方法で追加できるレイヤーのフィーチャ数の上限は、1,000フィーチャです。\r1,000フィーチャ以上のデータを持つファイルを追加する場合、[マイ コンテンツ] ページの [アイテムの追加] で行う方法があります。\r[レイヤーのインポート] をクリックします。 [CSV レイヤーの追加] ダイアログが表示された場合は、緯度/経度あるいは住所の情報を含んでいるフィールドを選択します。[レイヤーの追加] をクリックして、レイヤーの追加を終了します。  マップ メモの追加   [マップ メモの追加] ダイアログで、[名前] フィールドでレイヤー名を、[テンプレート] ドロップダウン リストから任意のマップ メモのテンプレートを選択します。\n  [マップ メモの追加] ダイアログで、名前を入力し、テンプレートをドロップダウン リストから選択して、[作成] をクリックします。\n  フィーチャの追加パネルが表示されるので、マップに追加するシンボルを選択します。\n  マップの任意の位置をクリックすると、その位置にシンボルが表示されると同時にポップアップが開き、タイトルや説明などを入力することができます。\n  コンテンツ パネルでレイヤーが追加されたことを確認し、追加されたレイヤー名にマウス オンするかレイヤー名をクリックし、から [レイヤーの保存] をクリックします。\n  [アイテムの作成] ダイアログでレイヤーのタイトル、タグ、サマリー（説明）を入力し、保存するフォルダーを選択して [アイテムの作成] をクリックします。\n~~~~\rタグを入力して、Enter キーを押すと、入力文字を確定できます。\r~~~~\r  マップを保存するために、[保存] → [保存] をクリックします。\nマップの保存では、マップ ビューアー上で参照しているレイヤーやその表示設定などが保存されます。\rマップ上で設定したレイヤーのシンボルなどは、レイヤー自体には保存されないため、他のマップでそのレイヤーを追加したときには、\r再度、シンボルの設定等を行う必要があります。\r  タイトル、タグ、サマリー（説明）を入力し、保存するフォルダーを選択し、[マップの保存] をクリックします。\n  [マイ コンテンツ] ページに移動し、マップが のような地図のアイコンで保存されていることを確認できます。\n緯度経度、または住所情報を含むテキスト ファイル（ *.txt、 *.csv）であれば、マップ表示エリアにファイルをドラッグ \u0026amp; ドロップすることで、ポイント フィーチャ レイヤーとしてマップに追加できます。フィールドはカンマ、セミコロン、またはタブで区切る必要があり、その他の区切り文字はサポートされていません。また、緯度経度は、10進度である必要があります。Google Chrome、Mozilla Firefox、Internet Explorer 10以降で利用可能です。\n 日本語を含むテキストファイルを使用するためには、Windows の「メモ帳」でファイルを開き、[ファイル] メニュー → [名前を付けて保存] をクリックし、[名前を付けて保存] ダイアログの下部に表示される [文字コード] ドロップダウン リストから [UTF-8] を指定して [保存] ボタンをクリックします。  保存したファイルを、マップ ビューアー上にドラッグ \u0026amp; ドロップします。  [CSV レイヤーの追加] 画面が表示されます。住所が入力されている場合は、[使用しているフィーチャの特定] では [住所] を指定し、[国] ドロップダウン リストから 「日本」 を選択します。 住所が入力されているフィールド名をクリックし、[場所フィールド] で [住所/大字町丁目以降] を選択します。 [レイヤーの追加] ボタンをクリックします。    シンボルを変更したい マップ ビューアー → [詳細] → [コンテンツ] → レイヤー名にマウス オン / クリック → [スタイルの変更]\nシンボルの色や形を変更します。コンテンツを作成する権限を持っている場合に可能です。\n  マップ ビューアーの [詳細] が選択されていることを確認し、[コンテンツ] をクリックします。\n  シンボルを変更したいレイヤー名にマウス オン / クリックし、[スタイルの変更] のアイコンをクリックします。\n  [スタイルの変更] パネルが表示されます。\n  [①表示する属性を選択] ドロップダウン リストから、シンボルの設定をする属性フィールドを選択します。 属性値でシンボル設定をしない場合は、[場所のみ表示] を選択します。\n  [②描画スタイルの選択] で、変更したい描画方法の [選択] をクリックします。既に選択されている描画スタイルは [オプション] と表示されます。\n一種類の属性フィールドによるシンボル設定 場所（単一シンボル） すべてのフィーチャを同じシンボルで表現します。\n種類 (個別値シンボル) 樹木の種類、道路クラス、都道府県名など、属性のカテゴリごとにシンボルを割り当てて描画します。\n数と量（サイズ） 数値またはランク付けされたデータをシンボルの大きさで表現します。データの数値が大きいほど、シンボルの大きさも大きく表示されます。\n数と量（色） 数値またはランク付けされたデータを色の濃淡で表現します。データの数値が大きいほど濃い色で、小さいほど淡い色で表示することなどができます。\nヒート マップ ポイントが集中しているエリアを一目で確認できるような表現ができます。\n日付データによるシンボル設定 属性フィールドに日付データを含むフィールドを選択すると、時系列データのスタイルの変更が提示されます。\n連続タイムライン（サイズ） 日付データをシンボルの大きさで表現します。新しい日付から古い日付をシンボルの大きさで表示することができます。\n連続タイムライン（色） 日付データを色の濃淡で表現します。新しい日付から古い日付を濃い色から薄い色で表示することなどができます。また、特定の日付の前後で色を変えることもできます。\n期間（サイズ） 設定した開始と終了日の期間の長さをシンボルの大きさで表現します。期間が長いほどシンボルの大きさも大きく表示されます。\n期間（色） 設定した開始と終了日の期間の長さを色の濃淡で表現します。期間の長さを濃淡で表現したり、所定日の前後で色を変える設定ができます。\n※レイヤーが持つ属性フィールドのタイプに応じて選択できる種類が異なります。例えば、文字列型のフィールドのみで構成されるレイヤーでは、[種類] ドロップダウン リストでサイズや色の指定はできません。\n  [オプション] をクリックすると、シンボルの詳細な設定をすることができます。\n  場所（単一シンボル）の場合 [シンボル] をクリックし、形状や大きさ、塗りつぶし色、アウトラインの設定などを行います。\n種類（個別値シンボル）の場合  ❶ 各シンボルの形状や大きさ、塗りつぶし色、アウトラインの設定などを行うことができます。 ❷ 凡例で表示するラベル名を直接入力して変更することができます。 ❸ ドラッグし、目的の位置でドロップすることで、各シンボルの順序を変更できます。 ❹ チェックボックスをオンにすると、シンボルが設定されている値以外の図形（例えば、属性値が入力されていない図形）が「その他」として表示されます。\n※個別値が11種類以上ある場合は、一部のデータが「その他」にグループ化されます。ラベル欄の「その他」の右にある をクリックすると、一括してグループ化を解除できます。また、「その他」の中にはグループ化された個別値が表示され、各個別値の をクリックすることで、個々にグループから除外することもできます。  数と量（サイズ）の場合 - ❺ スライダーの上部、下部のバーを動かして、最大 / 最小クラスの閾値を変更できます。また、数値をクリックして、直接入力することもできます。 - ❻ ポイントのシンボルを変更できます。 - ❼ 最小/最大クラスのポイントのサイズを変更できます。 - ❽ チェックボックスをオンにすると、クラスの分類数や分類方法、各クラスの閾値を設定することができます。各クラスの閾値は、スライダーを動かして変更するか、クラスの閾値の数値をクリックして、直接、入力することもできます❾。\r数と量（色）の場合  ❿ スライダーの上部、下部のバーを動かして、最小/ 最大クラスの閾値を変更できます。また、数値をクリックして、直接入力することもできます。 ⓫ ここをクリックすることで、色のパターンなどを変更できます。 ⓬ チェックボックスをオンにすると、クラスの分類数や分類方法、各クラスの閾値を設定することができます。設定方法は「数と量（サイズ）（16ページ）」をご参照ください。  ヒートマップの場合  ⓭ スライダーの上部、下部のバーを動かして、密集度の高いエリアや低いエリアを変更できます。 ⓮ 色のパターンを選択できます。 ⓯ スライダーを左右に動かして、影響範囲を変更できます。  二種類の属性フィールドによるシンボル設定 各パネルにおいて [OK] をクリックし、[完了] をクリックします。 一つ目の属性フィールドを選択すると表示される、[属性の追加] をクリックします。\n※数値型および文字列型のフィールド タイプを持つレイヤーに対してのみ、 [属性の追加] が表示されます。ここで、二つ目の属性フィールドを選択します。（一つ目に選択する属性フィールドを A、二つ目に選択する属性フィールドは B とします。）  [②描画スタイルの選択] で、変更したい描画方法の [選択] をクリックします。既に選択されている描画スタイルは [オプション] と表示されます。  色とサイズ Ａの属性は、色の濃淡で数値を表現し、Bの属性に対してはシンボルのサイズで数値を表現します。 選択した属性フィールドが日付型の場合は、時系列表示のシンボル設定がおこなえます。\n色 (期間) とサイズ A の属性は、期間を色の濃淡で表現し、B の属性に対しては日付の新旧をシンボルのサイズで表現します。\n色とサイズ (期間) A の属性は、日付の新旧をシンボルのサイズで表現し、B の属性に対しては期間を色の濃淡で表現します。\nA を B と比較 Bの属性に対し、Ａの属性の比率や割合を表現します。また、二つの属性の合計に対するAの属性の割合を表示します。\nタイプとサイズ 一意のシンボル（個別値）をサイズで表現します。A、B どちらかが文字列型の属性である場合は、文字列型の属性の方に個別値シンボルが自動的に適用され、他方の属性にサイズが適用されます。 選択した属性フィールドが日付型の場合は、時系列表示のシンボル設定がおこなえます。\nタイプとサイズ (期間) 一意のシンボル（個別値）ごとに期間の長さをシンボルの大きさで表現します。 A、B どちらかが文字列型の属性である場合は、その属性の方に個別値シンボルが自動的に適用され、日付型の属性にサイズが適用されます。\n主要カテゴリ 複数の属性フィールドの値を比較して、一番高い値を持つ属性フィールドに設定した色を表示します。同時に、他の値と比べてどれほど優位かを透過で表現します。\n主要カテゴリおよびサイズ 上記の「主要カテゴリ」に加え、複数の属性値の合計を円の大きさで表します。 10.\t[オプション] をクリックすると、シンボルの詳細な設定をすることができます。 11.\t設定後、各パネルにおいて [OK] をクリックし、[完了] をクリックします。\n※独自のシンボルを表示したい場合は、シンボルとして表示させたい画像をあらかじめWeb 上にアップロードしておき、[スタイルの変更] パネル → [場所（単一シンボル）] あるいは [種類（個別値シンボル）] → [選択] → [オプション] で、シンボルをクリックし、[画像の使用] をクリックします。参照する URL をボックス内に入力し、プラスマークをクリックすると、独自のシンボルとして利用することができます。 ラベルを変更したい マップ ビューアー → [詳細] → [コンテンツ] → レイヤー名にマウス オン / クリック → [その他のオプション] → [ラベルの作成]\nマップ上のフィーチャに簡単にテキストを追加することができます。ラベルのテキスト文字列はフィーチャの属性情報を利用して設定することができます。コンテンツを作成する権限を持っている必要があります。\n  マップ ビューアーの [詳細] が選択されていることを確認し、[コンテンツ] をクリックします。\n  ラベルを変更したいレイヤー名にマウス オン / クリックし、[その他のオプション] から [ラベルの作成] を選択します。\n  [ラベル フィーチャ] パネルが表示されます。[ラベル フィーチャ] チェックボックスをオンにして、ラベルを表示します❶。\n  [テキスト] フィールドに、ラベルとして表示したい属性を持つフィールドを入力します。複数の属性を表示したい場合は、右の ボタンで任意のフィールドを追加することができます❷。｛｝(中かっこ)でフィールド名を囲むと各フィーチャの属性が表示されます。\n  テキストのサイズ、太字、斜体、アンダーライン、色を変更することができます❸。\n  [整列] で、ラベル配置を指定します❹。\n  [OK] をクリックし、ラベルの設定を終了します。\n  ラベルの設定をした状態でレイヤーを保存することで、他のマップでもラベルが設定された状態でレイヤーを利用することができます。そのためには、レイヤー名にマウス オン / クリックし、[その他のオプション] から [レイヤーの保存] を選択します。\n  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/services/create-feature-service/",
	"title": "フィーチャサービスの作成",
	"tags": [],
	"description": "データの検索や編集が可能な地図サービス (REST API) の配信方法を紹介します。",
	"content": "配信可能な地図サービス ArcGIS Platform では、お手持ちの地図データや、住所・緯度経度を含む CSV などのテキスト データをもとに地図 (GIS) サービスを配信することが可能です。ArcGIS の地図サービスはさまざまな機能ごとに種類が分かれています。配信可能な基本的な地図サービスは以下の 2 種類です。\n フィーチャ サービス (レイヤー)   緯度経度および属性情報をフィーチャ (文字列) として配信 (クライアントでベクター データのグラフィックとして描画されます)\n  クライアント側でクエリを実行してデータを取得したり、編集したりする場合に利用\n\n機能 : 表示 (地図と属性) / 検索 / 作成 / 更新 / 削除    タイル サービス (レイヤー)  あらかじめ作成しておいたタイル状に分割された地図画像を配信 (クライアントで画像として描画されます) 描画速度が速く、背景地図などの広範囲のデータを利用したい場合に最適 機能 : 表示 (地図のみ)    Esri は無償で利用できるタイル サービスとして、全世界の背景地図サービス (道路地図、地形図、衛星画像 など) を配信しています。 なお、自分でタイル サービスを生成する場合は、10,000 タイルにつき 1 クレジットを消費して生成できます。 生成したタイル サービスを公開する方法は ArcGIS Online ヘルプのホスト タイル レイヤーの公開をご覧ください。\n以下では、主題データとして利用頻度のもっとも高いフィーチャ サービスの公開および配信方法をご紹介します。\nフィーチャ サービスの作成・公開 フィーチャ サービスの公開には以下の 2 つの方法があります。\n 空のフィーチャ サービスを公開  データがない状態のフィーチャ サービスを公開し、マップ ビューアーを使って手動でデータを追加していきます。    地図データおよび住所データを使ってフィーチャ サービスを公開   地図データが持つ座標情報や住所情報をもとにフィーチャ サービスを公開します。ArcGIS Developers のサイトを使用して公開が可能なデータは以下の通りです。\n CSV Excel (*.xlsx または *.xls) Google Sheets GeoJSON シェープファイル (Zip 形式に圧縮) ファイル ジオデータベース (Zip 形式に圧縮)  詳細は ArcGIS Online ヘルプのホスト フィーチャ レイヤーの公開をご覧ください。\n    以下は空のフィーチャ サービスを公開するまでのステップを紹介します。\n地図データや住所データを使ってフィーチャ サービスを公開する方法は「Import data as a feature layer」をお読みください。\n1. フィーチャ サービスの作成を開始する  ArcGIS Developers のサイト上で [Dashboard] をクリックし、[Layers] を選択します。 [+ Create Data] をクリックし、[New Hosted Layer (Feature Layer)] を選択します。   2. フィーチャ サービスのデータ構造を設定   [Data Structure] 画面で、以下の情報を設定します。\n Geometry Type: Point Fields:  フィールド 1:  Name: ID Display name (alias): ID Type: Integer   フィールド 2:  Name: NAME Display name (alias): 名前 Type: String   フィールド 3:  Name: ADDRESS Display name (alias): 住所 Type: String     Coordinate System: Latitude/Longitude (WGS 84/EPGS 4326)    入力が完了したら、[Next] をクリックして次へ進みます。   各データ構造の詳細は以下をご覧ください。\n  Geometry Type (ジオメトリ タイプ)\n フィーチャの図形の種類で、ポイント、ライン、ポリゴンの三種類から構成されています。  ポイント: 地物を点のデータで表し、観測地点などを表示するために使われます ライン: 地物を線のデータで表し、河川や道路などのフィーチャを表示するために使用されます ポリゴン: 地物を面のデータで表し、建物などを表示するために使用されます。   1 つのフィーチャ サービスに対して選択できるジオメトリ タイプはいずれか 1 つです。    Fields (属性情報)\n フィーチャに関する様々な情報のことで、属性テーブルと呼ばれるデータベースに保存することができます。属性テーブルの列のことを属性フィールドと呼びます。例えば、公共施設の属性には名称や所在地、分類、電話番号などを含めることができます。この属性情報をもとにシンボルやラベルを表示したり、フィーチャを検索したりすることが可能です。   Field Name (フィールド名)\n フィールドの名前をコンピューター用に定義したものです。コンピューターが理解しやすいように英数字で記載するなど使用できる文字に制限があります (スペースや特殊文字は使用できません) 。    Display name (エイリアス)\n フィールドの名前を人間にもわかりやすく定義したものです。例えば、人口の情報であれば Field Name を「POP」、Display name を「Population」や「人口数」と使い分けます。    Type (データ型)\n 格納する情報の種類によって以下の 4 つのデータ型から選択します。属性フィールドに設定されたデータ型と異なるデータ型の値を格納することはできません。  String: 文字型。文字列を格納します。 Integer: 整数型。自然数を格納します。 Double: 倍精度浮動小数点型。小数点を持つ有理数やパーセント値などを格納します。 Date: 日付型。日付、または日付と時間を格納します。          Coordinate System (座標系)\n 地球上の特定の位置を座標で表すための原点や座標の単位などの取り決めのことです。 フィーチャ レイヤーの ID (WKID) を入力します。  「4326 (WGS 84 緯度経度)、「3857 (Web メルカトル)」が推奨されています。      3. フィーチャ サービスの基本情報を設定   [Item Details] 画面で、以下の情報を設定します。\n Title: customerpoint Tags: customer Description: 顧客情報のポイント    入力が完了したら、[Next] をクリックして次へ進みます。\n\n  各情報の詳細は以下をご覧ください。\n  Title (タイトル)\n 新しく作成するフィーチャ サービスのタイトルを入力します。    Tags (タグ)\n ArcGIS Developers のサイト上でフィーチャ サービスを検索する際に利用します。作成するフィーチャー サービスのキーワードとなる語句を入力し、Enter キー を押すとタグが作成されます。    Description (説明)\n 新しく作成するフィーチャ サービスの説明を入力します。    4. 設定した情報の確認   [Review] 画面で、ここまで設定した内容を確認します。\n  問題がなければ、[Create Layer] をクリックしてフィーチャ サービスを公開します。\n  公開が完了すると、ArcGIS Developers のサイト上にフィーチャ サービスのアイテム ページが作成され、フィーチャ サービスの URL などが確認できます。\n\n  5. フィーチャ サービスの詳細情報を設定   作成したフィーチャ サービスのアイテム ページから、サービスの共有・編集権限を設定します。\n  ページ上部の [Settings] をクリックして以下にチェックを入れます。\n Layer access (sharing): Private (authentication required) Editing settings:  Allow editting (編集の有効化) Track new features and updates (作成および更新されたフィーチャを記録) Track authors of new features and updates (フィーチャの作成者および最終更新者を記録)      [Save setting] をクリックし、設定した内容を保存します。\n\n  ### 2. フィーチャ サービスの編集\r1. [編集] をクリックして、[フィーチャの追加] ウィンドウから追加するデータのシンボルを選択します。\r1. 選択後に、地図上の任意の場所をクリックすることで新しいデータが追加されます。\r1. フィーチャを追加すると、ポップアップが自動で開き、フィーチャの属性情報を編集することが可能です。\r--\rここまで作成してきたフィーチャ サービスは「Web マップの作成」で 1 レイヤーとして扱うことができます。自身が複数のデータをお持ちで、複数のレイヤーとして地図に表示したい場合でも、自由に追加して独自の地図をデザインすることが可能です。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/page/",
	"title": "ページ（Page）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - page\nページ（Page） エクスペリエンスの中のページは、物理的な HTML Web ページでなく、概念的なページですが、実際のHTML Web ページのように振る舞います。これは div HTMLタグを使って実装されます。エクスペリエンスは少なくとも1つのページを持たなければならず、複数のページを持つこともできます。Experience Builder のページレイアウトにはフルスクリーンのアプリページと直線的なスクロールページの2種類があり、前者はアプリのように見え、後者はウェブページのように見えます。\nページの内容（ウィジェット/セクション/スクリーン）は、固定レイアウトやフローレイアウトなどのレイアウトルールで整理されています。異なる画面サイズでもページが反応するようにするために、Experience Builderはサイズモードによるレイアウトの設定をサポートしています。これらは Large, Medium, Small で定義されています。各レイアウトの設定はエクスペリエンスの適応であり、アプリケーションをよりカスタマイズし、画面サイズをより有効に利用できるようにすることで、より大きな柔軟性を提供します。このデザインの良い例としては、City Explorerのテンプレートがあります。アプリケーションを大・中画面で見た場合、地図は表示され、構成に含まれていますが、モバイルデバイスで見た場合、地図ウィジェットは最初のページから削除され、ユーザーがリストウィジェットで機能を選択した後、2番目のページにのみ表示されるようになります。\napp config では、ページは pages で定義され、ページ構造は pageStructure で定義されます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/unity/add-the-plugin-to-a-new-project/",
	"title": "新規プロジェクトにプラグインを追加",
	"tags": [],
	"description": "ArcGIS Maps SDK for Unity を新規プロジェクトに導入する手順を紹介します 。",
	"content": "出典：ArcGIS Maps SDK for Unity - Guide - Add the plugin to a new project\nArcGIS Maps SDK for Unity は、ソースコードとサンプルアセットを含む Unity プラグインです。このページを始める前に、必ずプラグインをダウンロードしてください。\n新規プロジェクトの作成   新しいプロジェクトを作成するには、Unity Hub を開いて プロジェクト (Projects) タブを選択し、新しいプロジェクト (New project) ボタンをクリックします。\n  ポップアップウィンドウで、以下を定義します：\n エディターバージョン：ArcGIS Maps SDK for Unity は Unity 2021.3.x および 2022.3.x LTS をサポートしています。複数の Unity エディターバージョンがインストールされている場合は、ポップアップウィンドウの上部でサポートされているエディターバージョンを選択してください。 テンプレート：プラグインは High Definition Render Pipeline (12.x) と Universal Render Pipeline (12.x) の両方をサポートしています。初めて使用する場合は、Download template ボタンをクリックして、これらのテンプレートをダウンロードする必要があります。HDRP または URP テンプレート以外のテンプレートを選択した場合は、レンダーパイプラインパッケージを手動でインストールします。(レガシービルトインレンダーパイプラインはサポートされていません。) プロジェクト名：プロジェクトに関連するアセット、シーン、その他のファイルを保存するメインプロジェクトフォルダーの名前を設定します。 場所：プロジェクトの保存場所を設定します。デフォルトのプロジェクトの場所は、コンピューターのホームフォルダーに設定されています。    プラグインのインストール Unity パッケージ マネージャー (Package Manager) を使用してプラグインをインストールします。Unity パッケージ マネージャー (Package Manager) の詳細については、Unity ドキュメントのトピック Unity の Package Manager を参照してください。\nマイアセット (My Asset) からプラグインをインストール  エディターでプロジェクトを開きます。 トップメニューで、ウィンドウ \u0026gt; パッケージ マネージャー (Window \u0026gt; Package Manager) を展開し、パッケージ マネージャー (Package Manager) ウィンドウを開きます。  Unity ドキュメントのトピック Asset Store パッケージのインポートに従います。  プラグインがプロジェクトにインポートされると、パッケージ (Package) メニューから プロジェクト内 (In Project) を選択したときに、プロジェクト ウィンドウの パッケージ (Packages) セクションに ArcGIS Maps SDK for Unity フォルダーが表示されます。\nローカルの .tgz(tarball) ファイルからプラグインをインストール  パッケージをインポートするプロジェクトをエディターで開きます。 トップメニューで、ウィンドウ \u0026gt; パッケージ マネージャー (Window \u0026gt; Package Manager) を展開し、パッケージ マネージャー (Package Manager) ウィンドウを開きます。  パッケージ マネージャー (Package Manager) ウィンドウの + アイコンをクリックします。 リストから .tgz ファイルからパッケージを加える… (Add package from tarball) を選択し、ファイルブラウザーを表示します。  .tgz(tarball) ファイルを保存したフォルダーに移動します。  プラグインがプロジェクトにインポートされると、パッケージ (Package) メニューから プロジェクト内 (In Project) を選択したときに、プロジェクト ウィンドウの パッケージ (Packages) セクションに ArcGIS Maps SDK for Unity フォルダーが表示されます。\nサンプルアセットのインポート ArcGIS Maps SDK for Unity には、シーンに機能とビジュアルフィデリティを追加するために使用できる追加のサンプルとツールが付属しています。\nUnity 2021 でプラグインに付属するサンプルアセットをインポートするには、次の手順に従います：\n トップメニューで、ウィンドウ \u0026gt; パッケージ マネージャー (Window \u0026gt; Package Manager) を展開し、パッケージ マネージャー (Package Manager) ウィンドウを開きます。 左側のリストから ArcGIS Maps SDK for Unity を選択します。 右側のパネルで サンプル (Samples) をクリックし、セクションを展開します。 Sample Content の隣にある インポート (Import) ボタンをクリックします。   Unity 2022 でプラグインに付属するサンプルアセットをインポートするには、次の手順に従います：\n トップメニューで、ウィンドウ \u0026gt; パッケージ マネージャー (Window \u0026gt; Package Manager) を展開し、パッケージ マネージャー (Package Manager) ウィンドウを開きます。 左側のリストから ArcGIS Maps SDK for Unity を選択します。 右側のパネルで サンプル (Samples) タブをクリックします。 Sample Content の隣にある インポート (Import) ボタンをクリックします。   サンプルアセットがプロジェクトにインポートされると、プロジェクト (Project) ウィンドウの Assets \u0026gt; Samples の下にフォルダーとそのコンテンツが表示されます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/unreal-engine/add-the-plugin-to-a-new-project/",
	"title": "新規プロジェクトにプラグインを追加",
	"tags": [],
	"description": "ArcGIS Maps SDK for Unreal Engine を新規プロジェクトに導入する手順を紹介します。",
	"content": "出典：ArcGIS Maps SDK for Unreal Engine - Guide - Add the plugin to a new project\nArcGIS Maps SDK for Unreal Engine は、ソースコードとサンプルアセットを含む Unreal Engine プラグインです。このページを始める前に、必ずプラグインをダウンロードしてください。\n新規プロジェクトの作成   Unreal Engine を起動するには、Epic Games ランチャー を開き、ライブラリ (Library) をクリックします。サポートされているバージョンを選択し、起動 (Launch) をクリックします。Unreal Engine を起動すると、Unreal プロジェクトブラウザ (Project Browser) が自動的に開きます。\n  最近利用したプロジェクト (Recent Project) で、業種に最も適した開発カテゴリーを選択してください。どのカテゴリーを選べばよいかわからない場合は、ゲーム (Games) カテゴリーを選択してください。\n  リストからプロジェクトのテンプレートを選択します。プラグインを初期化するには、ブランク (Blank) のテンプレートを使用することをお勧めします。\n  プロジェクトを C++ プロジェクトに設定します。これにより、Visual Studio プロジェクトが作成され、ソースコード フォルダーに空の C++ クラスが 1 つ以上あるという条件が満たされます。品質 / パフォーマンス レベル、ターゲット プラットフォーム、スターター コンテンツを含めるかどうかなどを選択できます。詳細については、Deployment のページを参照してください。\n  ウィンドウの下部で、プロジェクトを保存する場所を選択し、プロジェクト名を付けます。作成 (Create) をクリックして終了します。\n  プロジェクト設定の詳細については、Unreal Engine 5 ドキュメント の 新規プロジェクトを作成する を参照してください。\nプラグインのインストール ArcGIS Maps SDK for Unreal Engine をプロジェクトディレクトリにインストールする必要があります。\n  Unreal Engine を終了し、Visual Studio を終了します。次に、メインのプロジェクト ディレクトリに Plugins フォルダーを作成します。\n作成したフォルダーの名前は必ず Plugins にしてください。\n\r  .zip ファイルから ArcGISMapsSDK フォルダーを解凍し、新しい Plugins フォルダーにコピーします。 プロジェクトの再構築に関する警告メッセージが表示された場合は、[Yes] をクリックして続行できます。\n\r  プロジェクトを開いたら、メニューバーの 編集 -\u0026gt; プラグイン (Edit -\u0026gt; Plugins) に移動し、ArcGIS Maps SDK for Unreal Engine プラグインが正しくインストールされていることを確認します。\nmacOS をお使いの場合は、プライバシーとセキュリティでプラグインをホワイトリストに登録する必要があります。\n\r  Unreal Engine 5.0 をお使いの方向け 以下の手順は、 Unreal Engine 5.0 用です。Unreal Engine 5.1 以降を使用している場合は省略できます。\n  メニューバーの ウィンドウ \u0026gt; ワールドセッティング (Window -\u0026gt; World Settings) を開きます。ワールドセッティング (World Settings) パネルが開きます。\n  ワールドセッティング (World Settings) パネルで、ワールド (World) グループに行き、詳細設定 (Advanced) を開きます。ラージワールドの有効化 (Enable Large Worlds) オプションをチェックしてください。\n  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/dotnet/",
	"title": "ArcGIS Maps SDK for .NET",
	"tags": [],
	"description": "ArcGIS Maps SDK for .NET の開発に役立つガイド集です。",
	"content": "ArcGIS Maps SDK for .NET (バージョン 200.x) の開発に役立つガイド集です。\n インストール ガイド\nArcGIS Maps SDK for .NET のインストールとセットアップ手順を紹介します。\n\r アプリケーション配布ガイド\nArcGIS Maps SDK for .NET を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を紹介します。\n\r バージョン 100.x から 200.x への移行\n今まで ArcGIS Runtime SDK for .NET バージョン 100.x を使用してアプリケーションを開発されていた開発者向けのガイドです。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-maplibre/",
	"title": "MapLibre GL JS",
	"tags": [],
	"description": "MapLibre GL JS を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。",
	"content": "マップを表示する このチュートリアルでは、MapLibre GL JS と ベースマップ レイヤー サービスを使用して、マップを表示する方法を紹介します。\nベースマップ レイヤー サービスのベクター タイル ベースマップ レイヤーを使用して、MapLibre GL JS にマップを表示できます。ベクター タイル ベースマップレイヤーは、ソース、レイヤー、フォントグリフ(Font Glyphs)、およびレイヤーをレンダリングするためのアイコンを含む MapLibre GL スタイルです。\nこのチュートリアルでは、ベースマップ レイヤー サービスの地形ベースマップ レイヤーを使用して、富士山周辺の地図を表示します。\nマップとレイヤーの詳細については、Mapping APIs and servicesのガイドのDisplay maps, scenes, and layersにアクセスしてください。\n前提条件 この機能を使うには、ArcGIS アカウントが必要です。アカウントの作成手順については「開発者アカウントの作成」を参照してください。\n手順 新しい Pen の作成 CodePen にアクセスして、マッピング アプリケーション用の新しい Pen を作成します。\nHTML の作成 HTML ページを定義して、Web ブラウザの幅と高さにあわせたマップを作成します。\n CodePen \u0026gt; HTML で、HTML と CSS を追加して、map という id 属性を持つ div 要素のあるページを作成します。 map id は、マップを表示するために使用される id 属性です。CSS はブラウザの設定をリセットして、マップがブラウザの幅と高さ全体に表示されるようにします。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;MapLibre GL JS Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; API の参照  \u0026lt;head\u0026gt;タグで、MapLibre GL JS CSS および JS ライブラリへの参照を追加します。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;MapLibre GL JS Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- maplibre gl js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=https://unpkg.com/maplibre-gl@3.2.1/dist/maplibre-gl.js\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=https://unpkg.com/maplibre-gl@3.2.1/dist/maplibre-gl.css rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; APIキーの設定 ロケーションサービスにアクセスするには、API キーまたは OAuth2.0 アクセストークンが必要です。API キーの作成手順については「API キーの取得」を参照してください。\n認証方法とアクセストークンの取得方法の詳細については、「セキュリティと認証」を参照してください。\n 開発者ダッシュボードに移動して、API キーを取得します。これは、次の手順で使います。  マップの作成 Map クラスを使用して、指定したベースマップを使用してマップを追加します。 Map クラスは、map の HTML 要素 を使用して、マップのコンテンツを表示し、対話するためのユーザーインターフェイスを提供します。地図のクリック、ズーム、パン、回転、視点の変更をサポートします。また、マウスがクリックされた場所のフィーチャの検索など、マップデータに関する情報を操作および検出することもできます。また、新しいソースを追加したり、レイヤープロパティを変更したりして、表示されるデータを変更することもできます。 詳細については、MapLibre GL JS のドキュメントを参照してください。\n \u0026lt;body\u0026gt;タグ内に\u0026lt;script\u0026gt;タグを追加します。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;MapLibre GL JS Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- maplibre gl js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=https://unpkg.com/maplibre-gl@3.2.1/dist/maplibre-gl.js\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=https://unpkg.com/maplibre-gl@3.2.1/dist/maplibre-gl.css rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script のタグを追加--\u0026gt; \u0026lt;script\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; API キーを格納するための apiKey 変数を作成します。YOUR_API_KEY を、API キーの設定で開発者ダッシュボードからコピーした API キーに置き換えます。アクセスする各 ArcGIS サービスの URL にこれを含める必要があります。なお、ここでは maplibre.accessToken を設定する必要はありません。使用するベースマップ arcgis/topographic を格納する basemapEnum 変数を作成します。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;MapLibre GL JS Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- maplibre gl js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=https://unpkg.com/maplibre-gl@3.2.1/dist/maplibre-gl.js\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=https://unpkg.com/maplibre-gl@3.2.1/dist/maplibre-gl.css rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script のタグを追加--\u0026gt; \u0026lt;script\u0026gt; // API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ベースマップの指定  const basemapEnum = \u0026#34;arcgis/topographic\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 表示と動作を制御するオプションを使用して Map を作成します。container プロパティを、作成した div の id に設定します。style プロパティは、ベースマップレイヤーサービスの場所を参照し、ベースマップ識別子と API キーを含みます。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;MapLibre GL JS Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- maplibre gl js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=https://unpkg.com/maplibre-gl@3.2.1/dist/maplibre-gl.js\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=https://unpkg.com/maplibre-gl@3.2.1/dist/maplibre-gl.css rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script 要素を追加--\u0026gt; \u0026lt;script\u0026gt; // API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ベースマップの指定  const basemapEnum = \u0026#34;arcgis/topographic\u0026#34;; const map = new maplibregl.Map({ container: \u0026#34;map\u0026#34;, // div 要素内の id を指定  style: `https://basemapstyles-api.arcgis.com/arcgis/rest/services/styles/v2/styles/${basemapEnum}?token=${apiKey}\u0026amp;language=${language}`, zoom: 12, // マップ初期表示時点でのズームレベル  center: [138.729858, 35.362752] // マップ初期表示時の位置  }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; アプリの実行 CodePen で、作成したコードを実行して地図を表示します。\n地図には、日本の富士山のエリアの地形ベースマップ レイヤーが表示されています。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/services/create-webmap/",
	"title": "Web マップの作成",
	"tags": [],
	"description": "さまざまなフォーマットのデータを 1 つのマップとして集約し、それを可視化する方法を紹介します。",
	"content": "Web マップとは Web マップとは背景地図や主題となる地図データを追加し、表示方法などを設定してクラウド上に JSON 形式で保存される Web 上の地図です。Web マップの作成には ArcGIS クラウド サービスが提供する地図作成ツール（マップ ビューアー）を使用します。クラウド上に保存された Web マップを使えば、地図上に何をどのように表示するかを一つ一つコーディングする必要がなく、非常にローコストで地図アプリを作成することができます。\nWeb マップに含まれる情報は以下の JSON 仕様で確認できます。\n Web マップ仕様 (Web Map JSON)  Web マップの作成 1. Web マップの作成とレイヤーの追加 マップ ビューアーで Web マップを作成していきましょう。\n  マップ ビューアーを開きます。\n  開発者アカウントでサインインします（サインインをしないと地図作成機能を利用できません）。\n  ArcGIS Living Atlasで共有中のレイヤーを追加します。[追加] をクリック後、[マイコンテンツ]を [Living Atlas] に変更し [レイヤーの検索] を選択します。\n  レイヤーの検索を行います。検索先を変えるなどしてもよいので、検索フォームにお好きなキーワードを入力して検索してみましょう。\n  検索結果が表示されたら、追加したいレイヤーの[+]ボタンをクリックするとレイヤーが追加されます。\n   今回は、東京都 避難所と南海トラフ巨大地震の被害想定（震度/最大クラス）のレイヤーを追加しています。  2. レイヤーの表示方法の設定   レイヤーの表示設定を変えてみましょう。 レイヤー リストから表現を変更したいレイヤーを選び、[\u0026hellip;] アイコンをクリックして、[プロパティの表示] をクリックします。\n  画面右側に表示される[プロパティ]内の[レイヤースタイルの編集]をクリックします。\n  レイヤースタイルの個別値シンボルの場合は、属性値ごとに表示したいシンボルを設定することができます。シンボルを設定してみましょう。\n  [スタイルの選択]内の[場所(単一シンボル)]の[スタイルオプション]をクリックします。ペンアイコンをクリックして、シンボルをお好きなシンボルに変更します。また、見ずらいという方はサイズの変更を行うこともできます。\n  レイヤー リスト上の透過率を設定したいレイヤー下にある [\u0026hellip;] アイコンをクリックして、画面右側に表示される[プロパティ]内の[透過表示] にカーソルを合わせると、スライダ－で透過率を設定できます。 これで背景地図が見えるように設定できるので場所の特定はできるようになりましたが、地震の被害想定は見たい人だけに見てほしい。そんな場合には、初期状態で非表示にしておくことができます。   非表示にしたいレイヤー名の右にある目のマークをクリックして[／]で消すと、レイヤーは非表示になります。\n  3. Web マップの保存 最後にここまで設定を行ってきた Web マップの保存を行います。保存すると Web マップには ID が割り当てられます。開発の際に、この ID を参照することで、設定を行った状態の地図をそのまま表示することができます。\n  画面左側のメニューから[保存と開く] →[名前をつけて保存]の順にクリックし、マップの情報を入力します。入力し終わったら、[保存] をクリックして、保存は完了です。必須項目はマップのタイトルです。\n  保存が完了すると、URL が自動的に変更されます。URL 末尾の ?webmap=\u0026lt;Web マップ ID\u0026gt; が Web マップの ID です。メモしておきましょう。\n   アプリの作成を始めましょう！お使いの開発環境からお選びください。\n JavaScript Android iOS .NET  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/install-guide/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) をインストールする手順を紹介します。",
	"content": "ArcGIS Experience Builder は、モダンな Web アプリ構築のための新しいビルダーで、コードを記述することなく Web アプリケーションを作成することができます。豊富なウィジェット セットから必要なツールを選択したり、独自のテンプレートをデザインしたり、2D コンテンツや 3D コンテンツを操作したりすることができます。Developer Edition (開発者向けエディション)は、これらの機能に加え、ウィジェットやテーマを独自に開発するなどのアプリをカスタマイズするためのフレームワークを提供します。また、作成したアプリケーションをダウンロードして、Web サーバーなどの独自のサーバーにホストすることが可能です。\nArcGIS Experience Builder (Developer Edition) で使用されている技術は、ArcGIS Maps SDK for JavaScript 4.x に加えて、React + Redux といったフレームワークや Bootstrap 4 などのコンポーネントライブラリ等を使用しています。開発に必要な情報は ArcGIS Experience Builder (Developer Edition) のコア コンセプト (Core concepts) を参照してください。\nインストール ArcGIS Experience Builder (Developer Edition) は、ArcGIS Online および ArcGIS Enterprise 10.6 以降をサポートしています。 Experience Builder (Developer Edition) は server と client の 2 つのサービスを使用しています。\n server サービス  Experience Builder (Developer Edition) の本体を起動します。   client サービス  独自のウィジェットやテーマを開発するためには client サービスを使用する必要があります。通常、server サービスを起動することで、Experience Builder (Developer Edition) を動作させることはできますが、開発したウィジェットなどを配置したり、デバッグするには、client サービスを起動しておく必要があります。    両方のサービスを実行しておくことで、Experience Builder での更新を自動的に反映することができます。 ここでは、Experience Builder (Developer Edition) の server と client のインストール手順について説明します。また、インターネットに接続していない環境で Experience Builder をインストールする必要がある場合は、offlineでのインストール手順を参照してください。\nServer インストール 1. Client ID の作成 はじめに Client ID を作成する必要があります。Client ID は、このあとの server サービスを起動して立ち上がるアプリケーションで指定します。 Client ID の作成は、ArcGIS Developers 、もしくは ArcGIS Online/ArcGIS Enterprise を使用して作成します。ご使用の環境に応じて作成を行ってください。\n 1-1. ArcGIS Developers を使用した Client ID の作成 1-2. ArcGIS Online/ArcGIS Enterprise を使用した Client ID の作成  1-1. ArcGIS Developers を使用した Client ID の作成 ArcGIS Developers を使用している場合は、以下の手順を行います。\nインストール手順については Esri が公開しているインストール動画 (英語)でも確認することができます。\n\r ArcGIS Developers にサイン インします。 サイン イン後にダッシュボードが表示されますので OAuth 2.0 タブをクリックします。 + New Application をクリックし、アプリケーションの詳細を入力して、新しいアプリケーションを登録します。 Redirect URLs のセクションまでスクロール ダウンします。 + Add URI をクリックして、https://localhost:3001/ を追加します。  Client ID は、このあとの手順で使用するため、コピーなどをして控えておきます。  1-2. ArcGIS Online/ArcGIS Enterprise を使用した Client ID の作成 ArcGIS Online または ArcGIS Enterprise を使用している場合は、以下の手順を行います。\n※ インストール手順については Esri が公開しているインストール動画 (英語)でも確認することができます。\n\r ArcGIS Online または ArcGIS Enterprise ポータルにログインし、コンテンツ ページの マイ コンテンツ タブに移動して、新しいアイテム をクリックし、アプリケーション を選択します。 アプリケーション タイプ で 他のアプリケーション を選択します。 ダイアログボックスで、以下のパラメータを入力し、保存 をクリックします。  タイトル - 例えば、Experience Builder credentials などの任意のタイトルをを入力します。 フォルダー - アイテムを保存する任意のフォルダーを選択します。 タグ - Experience Builder のような内容を入力します。 サマリー - アイテムのサマリーを入力します。    設定 タブをクリックします。アプリケーションの登録の項目までスクロールして、更新 をクリックします。 登録情報 ダイアログ ボックスで、次のように、リダイレクト URI に https://localhost:3001/ と入力し、追加をクリックして、更新 をクリックします。アプリケーション ID は、このあとの手順で使用するため、コピーなどをして控えておきます。   2. server サービスのインストール Client ID の作成が完了したら以下の手順で server サービスのインストールを行います。\nExperience Builder は、Node.js を使用します。長期サポート (LTS) バージョン v12 以上がサポートされています。お使いの OS に対応した最新の Node.js LTS バージョンをダウンロードしてインストールを行ってください。\n Experience Builder (Developer Edition) の ZIP ファイルをローカルにダウンロードして、解凍します。 ※ ダウンロードページでサイン イン ページが表示される場合は、ArcGIS Developers 開発者アカウント（あるいは ArcGIS Online 組織向けプランのアカウント）のユーザー名およびパスワードを入力しサイン インします。 コマンド プロンプト、またはターミナル ウィンドウを開き、Experience Builder の /server ディレクトリに cd コマンドで移動して npm ci と入力し、Enter キーを押して、必要なモジュールをインストールします。 ※ npm ci でのインストールは初回のみになります。次回以降は Experience Builder (Devloper Edition) の起動のみになりますので、npm start で実行します。 npm start と入力して server を起動します。  カスタムポートを使用するには、次のようにオプションとしてポートを指定します。： npm start -- --port 81 --https_port 443 .\nサブディレクトリ（例：https://localhost:3001/subfolder）でサーバーを実行するには、次のように path オプションを指定します： npm start -- --path /subfolder .\n\r次の URL https://localhost:3001/ を指定して Experience Builder をブラウザで開きます。  Experience Builder は、Node.js の自己署名証明書を使用して HTTPS をサポートしています。この証明書を信頼して Experience Builder を実行することもできますし、独自の証明書を使用することもできます。独自の証明書を使用するには、server/cert ディレクトリのこれら 2 つのファイル server.key と server.cert を置き換えます。また、次のように証明書ファイル (server.cert および server.key) が存在するフォルダへのカスタムパスを指定することもできます。：npm start \u0026ndash; \u0026ndash;cert_folder \u0026lt;フォルダパス\u0026gt;\n\rポータルの URL には ArcGIS Online または ArcGIS Enterprise の組織サイトの URL を指定し、クライアント ID には「1-1. ArcGIS Developers を使用した Client ID の作成」で作成した client ID」、または「1-2. ArcGIS Online/ArcGIS Enterpriseを使用した Client ID の作成」で作成したアプリケーション ID を指定します。 すべてを指定したらサイン インをクリックします。  Safari で、PKI、Kerberos、IWA、または LDAP 認証タイプを使用して Experience Builder Developer Edition にサインインするには、Safari の開発メニューにある「Cross-Origin Restrictions を無効にする」を選択する必要があります。\n\rサイン インをクリックすると、以下のように「権限のリクエスト画面」、もしくは、「ArcGIS ログイン画面」が表示されます。 ● 権限のリクエスト画面 権限のリクエスト画面は、使用しているブラウザですでに ArcGIS Online などにログインしているため、ログインした組織のアカウントが表示されます。許可をクリックすることで、Experience Builder の初期画面が表示されます。もし、他のアカウントでサイン インする場合は、別のアカウントでサイン インをクリックしてください。以下の ArcGIS ログイン画面が起動しますので、目的のユーザー名、パスワードを入力してサイン インします。 ● ArcGIS ログイン画面 使用しているブラウザで ArcGIS Online などにログインしていない場合は、ArcGIS ログイン画面が表示されます。目的のユーザー名、パスワードを入力してサイン インをクリックしてください。認証に成功すると、Experience Builder の初期画面が表示されます。  6. 次のステップで client インストールを行います。\nClient インストール Experience Builder の開発では、ローカルの Experience Builder で使用しているカスタム ウィジェットやテーマをバンドルしてロードするため webpack を起動する必要があります。webpack を起動するために client サービスをインストールする必要があります。\n コマンド プロンプト、またはターミナル ウィンドウを開き、Experience Builder の /client ディレクトリに cd コマンドで移動して npm ci と入力し、Enter キーを押して、必要なモジュールをインストールします。 ※ npm ci でのインストールは初回のみになります。次回以降は Experience Builder (Devloper Edition) の起動のみになりますので、npm start で実行します。 ※ npm ci でのインストール時は Visual Studio C++ Build Tools と Python が端末上にある必要があります。 npm start と入力して client を起動します。 ※ client のサービスを起動することで、カスタム ウィジェットやテーマは https://localhost:3001 で表示した Experience Builder 上で使用することが可能となります。  /client/your-extensions ディレクトリに新しいファイルやフォルダを作成した場合は、client サービスの再起動が必要になります。\n\r同じマシンで複数のバージョンの Developer edition を持つことができます。お使いのマシンがシステム要件を満たしていることを確認してください。\nOffline インストール   インターネットに繋がらない環境では、ArcGIS API JavaScript (JSAPI) CDN にアクセスすることはできません。このシナリオでは、JSAPI をダウンロードしてローカルにインストールする必要があります。\n  Experience Builder は、Node.js 12+.x 以上のバージョンで動作します。 Experience Builder のインストール環境に Node.js (v12+.x) をダウンロードしてインストールを行います。\n  Experience Builder の機能強化や新機能をサポートするために、最新版の ArcGIS API JavaScript をインストールすることが推奨されています。Esri が公開しているオフライン インストール動画（英語）](https://youtube.com/watch?v=1rO1cZNEr0E) を参照してください。ホストされた JSAPI のために、サーバーで CORS サポートを設定することが推奨されます。例えば、Windows OS の場合、HTTPSレスポンスヘッダーにAccess-Control-Allow-Original アクションを追加することができます。\n\r Experience Builder (Developer Edition) の ZIP ファイルをローカルにダウンロードして、解凍します。 Experience Builder (Developer Edition) 用の npm-cache zip をローカルにダウンロードして、解凍します。 コマンド プロンプト(例えば、Windows OS c:\\Users\\exbuser)、またはターミナル(例えば、macOS /Users/installExB)で、ユーザーフォルダを開き、npm config get cache と入力します。 npm config get cache の実行で表示された npm-cache のフォルダのパスをコピーして、そのディレクトリを Windows のエクスプローラーか Mac の場合は Finder で開きます。 ダウンロードした Experience Builder (Developer Edition) 用 の npm-cache ディレクトリをコピーして、4 で参照しているディレクトリに貼り付けます。 コマンド プロンプト、またはターミナル ウィンドウを開き、Experience Builder インストールの client ディレクトリに cd コマンドで移動して、npm install --offline と入力して Enter キーを押します。 別のコマンド プロンプト、またはターミナル ウィンドウを開き、Experience Builder インストールの server ディレクトリに cd コマンドで移動して、npm install -- offline と入力して Enter キーを押します。 Experience Builder の client ディレクトリを以下のパス \u0026lt;install folder\u0026gt;/client/dist で開きます。 変数 ARCGIS_JS_API_URL をローカルで JSAPI を参照している URL に更新する必要が4箇所あります。例えば、以下の各ファイルで var ARCGIS_JS_API_URL = 'https://js.arcgis.com/4.16/' を var ARCGIS_JS_API_URL = 'https://exb.esri.com/4.16/' に置き換えてください。  \u0026lt;install folder\u0026gt;/client/dist/index.html \u0026lt;install folder\u0026gt;/client/dist/experience/index.html \u0026lt;install folder\u0026gt;/client/dist/template/index.html \u0026lt;install folder\u0026gt;/client/dist/builder/index.html   コマンド プロンプト、またはターミナル ウィンドウを開き、Experience Builder のインストール先の client ディレクトリに cd コマンドで移動して、npm start と入力して client サービスを起動します。 コマンド プロンプト、またはターミナル ウィンドウを開き、Experience Builder のインストール先の server ディレクトリに cd コマンドで移動して、npm start と入力して server サービスを起動します。  Experience Builder (Developer Edition) を使用するために Client ID が必要になります。Client ID を作成するために ArcGIS Online または ArcGIS Enterprise に接続します。\n\rここでは、ArcGIS Online または ArcGIS Enterprise を使用した Client ID の作成手順について示します。\n  ArcGIS Online または ArcGIS Enterprise ポータルにログインし、コンテンツ ページの マイ コンテンツ タブに移動して、新しいアイテム をクリックし、アプリケーション を選択します。\n  アプリケーション タイプ で 他のアプリケーション を選択します。\n  ダイアログボックスで、以下のパラメータを入力し、保存 をクリックします。\n タイトル - 例えば、Experience Builder credentials などの任意のタイトルをを入力します。 フォルダー - アイテムを保存する任意のフォルダーを選択します。 タグ - Experience Builder のような内容を入力します。 サマリー - アイテムのサマリーを入力します。     設定 タブをクリックします。アプリケーションの登録の項目までスクロールして、更新 をクリックします。\n  登録情報 ダイアログ ボックスで、次のように、リダイレクト URI に https://localhost:3001/ と入力し、追加をクリックして、更新 をクリックします。アプリケーション ID は、このあとの手順で使用するため、コピーなどをして控えておきます。   次の URL https://localhost:3001/ を指定して Experience Builder をブラウザで開きます。\n  ポータルの URL には、ArcGIS Online または ArcGIS Enterprise の組織サイトの URL を指定し、5. で作成した アプリケーション ID を指定します。すべてを指定したらサイン インをクリックします。\n  サイン イン後の流れについては、2. server サービスのインストールのステップ5 以降を参照してください。\n  Windows サービスとしてインストール   お使いの OS に対応した最新の Node.js LTSバージョンをダウンロードし、インストールしてください。\n  Windows のコマンドプロンプトを管理者権限で開きます。\n  Experience Builder の /server ディレクトリにディレクトリを変更 (cd) します。\n  npm ci  コマンドを実行し、依存関係をインストールします。\n  npm run install-windows-service のコマンドを実行します。\n  Windows サービスアプリを開き、Experience Builder サービス（デフォルト名：exb-server）を起動します。\n  Experience Builder サービスを削除するには、 npm run uninstall-windows-service  というコマンドを実行します。\n  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/python-api-install/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS API for Python の環境構築方法を紹介します。",
	"content": "ArcGIS API for Python (以下、Python API) を使用するための環境構築は主に 2 つあります。一つは ArcGIS Pro でインストールする方法、もう一つは Anaconda でインストールする方法です。 Python API は、arcgis という名前のパッケージで Anaconda Cloud 等で配布されています。Anaconda Cloud 上のパッケージは conda を使用してインストールやバージョン管理を行うことができます。conda の詳細については ArcGIS API for Python のための基礎環境：conda入門 を参照してください。\nPython API は ArcGIS Pro 経由でインストールするか、Anaconda 経由でインストールする方法がありますが、PATH の問題を引き起こす可能性があるため、ベストプラクティスとしては、単一のマシンに ArcGIS Pro と Anaconda の両方をインストールすることは推奨されません。\nArcGIS Pro と Anaconda の違いについては以下のブログもご参照ください。\n ArcGIS API for Python のコアコンセプト その 2：Anaconda、Conda、Jupyter Notebook、そしてArcGIS Pro  \rSTEP 1: Python API をインストールする  ArcGIS Pro でインストールする Anaconda 経由でインストールする  STEP 2: arcgis パッケージをアップグレードする  ArcGIS Pro 2.3 以上の環境の場合 Anaconda 環境の場合  STEP 3: ArcGIS API for Python を実行する  Jupyter Notebook を起動する Jupyter Notebook で地図を表示してみる  参考  1. オフライン時のインストール方法   Python API をインストールする ArcGIS Pro でインストールする ArcGIS Pro では、2.1 以降のリリースから conda と arcgis パッケージが最初からインストールされています。 ArcGIS API for Python を実行するを試してみましょう。バージョンが最新でない場合はarcgis パッケージをアップグレードするを参照して Python API を更新します。\nAnaconda 経由でインストールする ArcGIS Pro をお持ちでない場合は、Anaconda をインストールします。 Anaconda は Python とデータサイエンス向けの Python パッケージなどを提供するプラットフォームです。  Python API は Python 3.5 以降を必要とするため、Anaconda ダウンロードページから、適切なバージョンをダウンロードしてください。  ※ Python API は、国内では Windows 版のサポートを提供しています。\nターミナルアプリケーション（ここでは Anaconda Prompt）を開き、次のコマンドを使用して arcgis パッケージをインストールします。\nconda install -c esri arcgis\r --\rインストールされる Python API のバージョンは基本的に最新バージョンとなりますが、古いバージョンがインストールされた場合は以下のようにバージョン番号を指定することで指定したバージョンがインストールされます。\nconda install -c esri arcgis=2.x.x\rAnaconda で Python API の環境構築をした場合、内部ではデータの書き出し等に pyshp を利用しています。2022 年 2 月現在の最新版である pyshp 2.2.0 ではフィールド名が Unicode に対応して日本語が扱えるようになる等、機能が改善されていますが、Python API 1.7.1 以前のバージョンでは古いバージョンの pyshp を使っています。そのため、Anaconda で環境構築する際は 1.8.0 以降の Python API のインストールを推奨します。\n\rインストールが完了したら、ArcGIS API for Python を実行するを試してみましょう。\n arcgis パッケージをアップグレードする ArcGIS Pro 2.3 以上の環境の場合 ArcGIS Pro 2.3 以上では Python API が最初からインストールされています。 ArcGIS Pro をインストールすると、デフォルトで \u0026ldquo;arcgispro-py3\u0026rdquo; という読み取り専用の conda 環境が作成されています。Python API を最新のバージョンに更新するには、Python パッケージ マネージャー (ArcGIS Pro の機能のひとつ) を使用して、デフォルトの環境をクローンし、クローンした環境の Python API を最新バージョンにアップグレードします。\n ArcGIS Pro を起動し、スタートアップ画面の左下にある [設定] をクリックします。 ArcGIS Pro 3.x の場合は[パッケージマネージャー]メニューを、 ArcGIS Pro 2.x の場合は[Python]メニューオプションを選択します。 ArcGIS Pro 3.x の場合は[環境マネージャー]ボタンを、ArcGIS Pro 2.x の場合は[環境の管理]ボタンをクリックし、「環境の管理」ウィンドウを開いて、[デフォルトのクローン]ボタンを選択します。  (ArcGIS Pro 3.x)①[環境マネージャー]ボタンと環境の②[デフォルトのクローン]ボタン\n(ArcGIS Pro 2.x)①[環境の管理]ボタンと環境の②[デフォルトのクローン]ボタン\n\r デフォルト環境のクローンが作成されます。  [名前]の入力ボックスへ入力する ※日本語は推奨しません。半角英数で入力します。\n --\r クローンの作成中は下部にインストール中のパッケージ名が表示されます。すべてのパッケージのインストールが完了すると、クローンされた環境が格納されているディレクトリ名が表示されます。※完了前に操作をすると、作成した環境が正常に動作しない可能性があります。  クローンの作成中の様子(ArcGIS Pro 2.x)\n\r ArcGIS Pro 3.x の場合は、作成した環境をダブルクリック、もしくはアクティブ化をクリックし、ArcGIS Pro 2.x の場合は、作成した環境のラジオボタンをクリックして、環境をアクティブにします。  (ArcGIS Pro 3.x)環境をアクティベート\n(ArcGIS Pro 2.x)環境をアクティベート\n\r 環境の管理ダイアログを閉じ、ArcGIS Pro を閉じます Python コマンドプロンプトを開きます。\nスタートメニュー\u0026gt;すべてのプログラム\u0026gt; ArcGIS\u0026gt; Python コマンドプロンプトで開くことができます。 次のコマンドを入力します。  conda upgrade -c esri arcgis\rコマンドの入力\n\r インストール、アップグレードするパッケージの名前とバージョン番号が表示されるので、問題がなければ y を入力し、実行します。 ArcGIS Pro のバージョンによっては、最新の Python API のバージョンが表示されない場合があります。その場合、一度 n を入力・実行し、以下のコマンドを再入力してください。  conda upgrade -c esri arcgis --no-pin\rArcGIS Pro のバージョンによってはデフォルトの設定で、アップグレードできる Python API のバージョンの上限が指定がされています。 conda upgrade -c esri --no-pin arcgis のうち、--no-pin がバージョンの指定を外して最新版までアップグレードするためのオプションです。 ただし、デフォルトの設定が変更されるわけではないため、アップグレード後に他のパッケージをインストールしようとすると、設定された上限のバージョンにダウングレードするように conda で計画されます。 その場合、そのパッケージをインストールした後に再度上記のコマンドを入力し arcgis パッケージをアップグレードしてください。\n*以下の操作はデフォルトで想定されているパッケージ管理の制御を変更するため、必ず事前に環境を複製しておく等、適切なバックアップの処置をしてください。*\r *また、以下操作の実行による不具合等はサポートの対象としかねますので、ご承知おきください。*\r 永続的に設定を変更するには conda 環境の中の pinned ファイルを書き換える必要があります。\r  C:\\Users\\ (ユーザー名) \\AppData\\Local\\ESRI\\conda\\envs\\ (複製した環境名) \\conda-meta\\pinned\r 上記ファイルをテキストエディタで開くと、`arcgis 1.5.*` と記載されているので、数字部分を `2` など、アップグレードしたいバージョン以上の数字に書き換え保存します。\r 他の記載されているパッケージの設定を変更すると、予期しない不具合を招く恐れがありますので注意してください。 --\r\rインストールされるパッケージの確認\n\r アップグレードしたバージョンを確認するには、次のコマンドを入力します。  conda list arcgis\r Python API を含む ArcGIS 関連のパッケージとそのバージョン番号が表示されます。  \n\rアップデートが完了したら、ArcGIS API for Python を実行するを試してみましょう。\nArcGIS Pro をインストールすると、デフォルトで \"arcgispro-py3\" という読み取り専用の conda 環境が作成されています。Python API を最新のバージョンに更新するには、Python パッケージ マネージャー (ArcGIS Pro の機能のひとつ) を使用して、デフォルトの環境をクローンし、クローンした環境の Python API を最新バージョンにアップグレードします。\r* 新しい空のプロジェクトで ArcGIS Pro を開きます。\r* [プロジェクト]タブを選択して、ArcGIS Pro の詳細オプションを表示します。（下記のスクリーンショットを参照）\r* [Python]メニューオプションを選択します。\r* [環境の管理]ボタンをクリックしウィンドウを開いて、[新規作成]ボタンを選択します。 [環境の管理]ボタンと環境の[新規作成ボタン]\n\r* 新しい環境の名前を入力して[保存]を選択します。\r[名前]の入力ボックスへ入力する ※日本語は推奨しません。半角英数で入力します。\n\r* ダイアログの下部にある青色の進行状況バーが消えたら完了です。この表示が完了してから、次の操作に進んでください。※完了前の操作は正しい環境が作成・動作しない可能性があります。\r青色の進行状況バー\n\r* 作成した環境のラジオボタンを選択して、環境をアクティブにします。ここでの操作は、Anacondaで仮想環境をアクティベートする操作に値します。\r仮想環境を指定する\n\r* 環境の管理ダイアログを閉じ、ArcGIS Pro を閉じます\r* Python コマンドプロンプトを開きますまたはスタートメニューすべてのプログラム ArcGIS Python コマンドプロンプトで開きます。\r* 次のコマンドを入力します。\r```\rconda upgrade -c esri arcgis\r```\rコマンドの入力\n\r* 「Proceed([y]/n)?」 の表示は `y` を入力して実行します。\rインストールするパッケージ計画が表示され、この計画でよい場合は\"y\"を選択します\n\r* アップグレードしたバージョンを確認するには次のコマンドを入力します。\r```\rconda list arcgis\r```\rPython API を含む ArcGIS 関連のパッケージとそのバージョン番号が表示できます\n\rアップデートが完了したら、[ArcGIS API for Python を実行する](#arcgis-api-for-python-を実行する)を試してみましょう。 --\rAnaconda 環境の場合 Anaconda Prompt のようなターミナルアプリケーションを開き、次のコマンドを使用して arcgis を実行してアップグレードします。\nconda upgrade -c esri arcgis\rインストールするパッケージの計画が表示されるので、y を選択し、アップグレードします。\nアップデートが完了したら、ArcGIS API for Python を実行するを試してみましょう。 上記以外の ArcGIS API for Python を実行環境の構築については、Install and Setup(英語)でご確認ください。\n ArcGIS API for Python を実行する Jupyter Notebook を起動する  Pythonコマンドプロンプト (ArcGIS Pro でインストールした場合)、もしくは Anaconda Prompt (Anaconda でインストールした場合) を起動します。 cd コマンドを使用して、ノートブックがあるディレクトリ、またはノートブックを作成したいディレクトリに移動します。 次のように入力して Jupyter Notebook を起動します。  jupyter notebook\r 起動しなかった場合は、以下を試してください。  jupyter-notebook\rまたは、スタートメニュー\u0026gt;すべてのプログラム\u0026gt; ArcGIS\u0026gt;Jupyter Notebook を選択しても起動することができます。\nJupyter Notebook の詳しい操作は Jupyter Notebook を使ってみようもご覧ください。 Python API バージョン 1.5.0 以降からは、Jupyter Lab からも操作が可能です。Jupyter Lab を使ってみようも是非ご覧ください。\nJupyter Notebook で地図を表示してみる 次の手順で、地図を表示するための新しいノートブックを作成します。\n Click New \u0026gt; Python 3  Python[default] --\r\r次のコードを入力します。\nfrom arcgis.gis import GIS my_gis = GIS() my_gis.map() \rJupyter Notebook から使用している Python API のバージョンを確認する場合、次のコードを実行することで、現在お使いのバージョンを確認することができます。\nimport arcgis arcgis.__version__ もしくは、先頭に ! を付けて以下のようにコマンドを実行して確認することも可能です。\n!conda list arcgis\r\r 参考 1. オフライン時のインストール方法 インターネットに接続していない環境の場合、次の手順で Python API のインストールが可能です。\nただし、この場合、すべての依存パッケージがインストールされるわけではないため、Jupyter Notebook の利用など、一部の機能が制限される可能性があります (※ 組織やコンテンツの管理など特定のタスクは以下手順でインストールする six パッケージのみで可能です。)\n依存パッケージについては米国Esri 社のガイドページ：System requirements を参照ください。\nインターネットに接続できる環境で以下の必要なソフトウェアをダウンロードします。  最新の Python 3.x 用の Anaconda 適切なバージョンの Python API のファイル  Anaconda クラウドの Esri のチャネルからダウンロード可能です。 ファイル名は以下のパターンに従います  OS/arcgis-x.x.x-pyZZyyyyyyy-y.tar.bz2.  OS: 使用するマシンの OS x.x.x: API のバージョン ZZ: 使用する Python のバージョン yyyyyyy-y: チャネルにアップロードされた conda のパッケージに付与されるハッシュ ナンバー     例えば、Windows 64 bit のマシンで、Python API 1.6.0 の Python 3.7 版をダウンロードする場合は、\u0026quot;win-64/arcgis-1.6.0-py37h62639d4_1.tar.bz2\u0026quot; をクリックしてダウンロードします。    \rオフライン環境で Anaconda を設定  Anaconda をインストールします。 次のコマンドでオフライン モードに設定します。  conda config --set offline True\r 次のコマンドで新しい環境を作成します。  conda create -n \u0026lt;環境名\u0026gt; python six\r 環境をアクティベートします。  conda activate \u0026lt;環境名\u0026gt;\r ArcGIS API for Python をインストールします。  conda install \u0026lt;事前にダウンロードしたファイルのパス\u0026gt;\r\u0026ldquo;done\u0026quot;が表示されればインストール完了です。\nより詳しい情報は 米国Esri ガイドページ：Install-Offline をご覧ください。\n現在国内では ArcGIS API for Python の Linux での利用は未サポートです。ご利用そのものを妨げるものではありませんが、利用される際は ESRIジャパンの提供するサポート サービス等の対象とならない可能性がある点に留意してください。\r\r##### Anaconda をインストール\rLinux では ArcGIS Pro を利用できないため、Anaconda から ArcGIS API for Python をインストールします。\r* Linux 版の Anaconda の [ダウンロード URL](https://www.anaconda.com/distribution/#download-section) を確認し、wget でファイルをダウンロードします\r* ここでは Anaconda 2019.10 for Linux をダウンロードします。\r```\rwget https://repo.anaconda.com/archive/Anaconda3-2019.10-Linux-x86_64.sh\r```\r\r* ダウンロードしたインストーラーを以下のコマンドで実行します。\r```\rsh Anaconda3-2019.10-Linux-x86_64.sh\r```\r\r* インストールするディレクトリは任意のディレクトリを選ぶことができます。ここではデフォルトの設定である、ログイン ユーザーのホーム ディレクトリにインストールすることにします。\r\r* 最後に PATH を通すか確認されます。ここでは [Anaconda のドキュメント](https://docs.anaconda.com/anaconda/user-guide/faq/#id2)に従い、yes として進めます。\r\r変更を反映させるためには一度 シェル を閉じて再度開く必要があります。\r\r##### `arcgis` パッケージをインストール\rArcGIS API for Python (arcgis) をインストールします。\rAnaconda の base 環境にインストールしてもよいですが、ここでは conda で新しい環境を作成してインストールします。\r* 新しい Python 環境を作成\r* 以下のコマンドで新しい Python 環境を作成します。\r*  には識別しやすい任意の環境名を指定します。また、ここではインストールする Python のバージョンとして 3.7 を指定しています。\r```\rconda create -n  python=3.7\r```\r* 作成した環境をアクティベート\r* 以下のコマンドで作成した環境に切り替えます\r```\rconda activate \r```\r* ArcGIS API for Python をインストール\r* 以下のコマンドで ArcGIS API for Python をインストールします。\r* 以下では ArcGIS API for Python 1.7.1 をインストールするよう指定しています。\r```\rconda install -c esri arcgis=1.7.1\r```\r* インストールの確認\r* インストールが終了したら以下のコマンドで正常にインストールされているか確認しましょう。\r* 正常にインストールされていれば、arcgis というパッケージ名とインストールしたバージョン番号が表示されます。\r```\rconda list arcgis\r```\r --\rESRIジャパンが運営する GIS アプリ開発者のためのコミュニティ グループ では、Python API の機能や実際のコードをブログでご紹介しています。 また、GitHub にも日本語による解説付きのコードを公開していますので、是非ご参照ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/window/",
	"title": "ウィンドウ（Window）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Window\nウィンドウ（Window） ウィンドウはページに似ていて、任意のウィジェットを追加することができ、コンテンツを表示するための2つの設定（固定とアンカー設定）があります。 固定ウィンドウはモーダルを作成し、メインウィンドウを無効にしますが、ユーザーがエクスペリエンスに戻る前にウィンドウと対話できるように表示を維持します。固定ウィンドウはスプラッシュスクリーンとして使用したり、ページで開いたり、ウィジェットから開いたりすることができます。アンカー ウィンドウは、ボタンやテキストウィジェットなどのウィジェットからトリガーされます。\napp config では、ウィンドウは dialogs で定義されます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/calcite-design-system/tutorials/",
	"title": "チュートリアル",
	"tags": [],
	"description": "Calcite の開発パターンを学び、ワークフローやアプリケーションを構築します。",
	"content": "出典：Calcite Design System - Tutorials\n段階的な手順に従って、ArcGIS Maps の機能と Calcite Design System のコンポーネントやパターンを組み込んだアプリケーションを構築します。\nコンセプト コア コンセプトを適用し、Calcite Design System の機能を確認します。\n  地図アプリの作成\nCalcite Components を使ってインタラクティブな地図アプリケーションを作成します。\n  ダークモードスイッチの作成\nCalcite Components と ArcGIS Maps SDK for JavaScript をライトモードとダークモードを切り替えるダークモードスイッチを構築します。\n  アプリケーションパターン 基本的な概念とパターンに基づいて構築し、それらをエクスペリエンスとワークフローに適用します。\n  コア コンセプトの適用\nインタラクティブなアプリケーションを作りながら、Calcite Components の基本的な概念を学びます。\n  最近の地震をフィルタリング\nCalcite Design System でユーザー インターフェース(UI)を作成します。\n  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/deploy-pattern/",
	"title": "デプロイ パターン",
	"tags": [],
	"description": "ArcGIS Web AppBuilder (Developer Edition) で作成したアプリやウィジェットのデプロイ パターンを紹介します。",
	"content": "トピック  概要 Web アプリケーションをデプロイ ウィジェットをデプロイ テンプレートをデプロイ  概要 ArcGIS Web AppBuilder (Developer Edition) (以下 Developer Edition) では ArcGIS Web AppBuilder を拡張して、独自の Web アプリケーションやウィジェット、テンプレートを作成することが可能です。エンド ユーザーの利用形態や要件により最適なデプロイは異なりますが、このページでは以下の 3 つの主要なデプロイ パターンと、それぞれのデプロイ方法についてご紹介します。\n Web アプリケーションをデプロイ 全体像  Web アプリケーションを作成し、独自のサーバーでホストすることができます。特定の業務で継続的に利用されるアプリ等、ユーザーによる設定変更が不要な場合や、ユーザーに設定変更をさせたくない場合等に活用できます。   必要なコンポーネント  開発時  Node.js Developer Edition   運用時  ArcGIS Enterprise または ArcGIS Online Web サーバー (ArcGIS Enterprise の Web サーバーと併用も可)    手順概要 以下は Web アプリケーション作成から、デプロイ、実際の運用までの流れの概要です。\n カスタム ウィジェットを含む web アプリケーションを作成  Developer Edition を用いたウィジェットの開発や web アプリケーションの作成には Node.jsが必要です。 詳しくはインストールガイドをご覧下さい。 カスタム ウィジェットを開発する際は、カスタム ウィジェット開発ガイドをご覧ください。   作成した web アプリケーションを自身で用意した Web サーバーに配置  ArcGIS Enterprise で使用している Web サーバーと併用することも可能です。 ※ ArcGIS Online を使用してホストすることはできません。 詳しくは、アプリケーションのデプロイをご覧ください。   ユーザーが作成された web アプリケーションを利用  ユーザーが web アプリケーションにアクセスして利用します。 ArcGIS Enterprise や ArcGIS Online のポータルにアイテムとして表示させたい場合はアプリの URL をアイテムに登録する必要があります。  詳細は「アプリの追加」及びその後の「アプリの登録」をご覧ください。   内部的には、アプリは ArcGIS Online もしくは ArcGIS Enterprise の Web マップを参照してアプリ上に地図を表示します。     ウィジェットをデプロイ  WebApp Builder で使用できるウィジェットのみを開発し、独自のサーバーでホストすることも可能です。ユーザーが ArcGIS Online や ArcGIS Enterprise を使用して独自に web アプリケーションを作成することを想定しているものの、デフォルトの ArcGIS Web AppBuilder のウィジェットには無い機能を拡張したい場合に活用できます。   必要なコンポーネント  開発時  Node.js Developer Edition   運用時  ArcGIS Enterprise Web サーバー (ArcGIS Enterprise の Web サーバーと併用も可)    手順概要 以下はカスタムウィジェットの作成から、デプロイ、実際の運用までの流れの概要です。\n カスタムウィジェットを作成  Developer Edition を用いたウィジェットの作成には Node.jsが必要です。 詳しくはインストールガイドをご覧下さい。 カスタムウィジェット開発の詳細については、カスタム ウィジェット開発ガイドをご覧下さい。   作成したカスタムウィジェットを自身で用意した Web サーバーに配置  ArcGIS Enterprise で使用している Web サーバーと併用することも可能です。 ※ ウィジェットを配置するサーバーが自己署名証明書を使用している場合、Portal for ArcGIS に証明書をインポートする必要があります。詳しい方法はポータルへの証明書のインポートをご覧ください。 Web サーバーに配置後、ArcGIS Enterprise に組み込まれている ArcGIS Web AppBuilder にカスタムウィジェットを追加します。  詳しくは、カスタム ウィジェットの追加をご覧ください。 ※ ArcGIS Online に追加することはできません。     ウィジェットを使った web アプリケーションの作成・利用  ユーザーが ArcGIS Enterprise に組み込まれている ArcGIS Web AppBuilder を利用してカスタムウィジェットを使用した web アプリケーションを作成・利用します。 内部的には、アプリは Web サーバーでホストされているカスタムウィジェットを参照して動作します。     テンプレートをデプロイ  Esri が用意している web アプリケーションのテンプレートとは別に、Developer Edition で作成した web アプリケーションをベースに独自のテンプレートを作成できます。テンプレートを用いることで、ユーザー自身がマップや簡易な設定の変更のみで web アプリケーションを作成することができるようになります。テンプレートを作成しておくと、必要な機能が共通している複数の業務に対して、異なるマップや設定を適用するだけですぐ各業務向けのアプリを作成できます。 ここでご紹介する方法では開発環境と運用環境が同じである点にご注意ください。   必要なコンポーネント  開発時  Node.js Developer Edition   運用時  Node.js Developer Edition ArcGIS Online または ArcGIS Enterprise    手順概要 以下はテンプレートの作成から、デプロイ、実際の運用までの流れの概要です。\n カスタムウィジェットを含む web アプリケーションを作成  Developer Edition を用いたウィジェットの作成には Node.jsが必要です。 詳しくはインストールガイドをご覧下さい。 カスタム ウィジェットを開発する際は、カスタム ウィジェット開発ガイドをご覧ください。   web アプリケーションをテンプレートとして保存 (登録)  Developer Edition で作成した web アプリケーションを組織にエクスポートします。  Developer Edition でアプリを作成し、[保存] ボタンをクリックした後 [テンプレートとしてエクスポート] をクリックします。  構成可能にするパラメーターを設定した後、組織にエクスポートをクリックします。  ※ テンプレートは、組織が設定するテンプレート グループに共有される必要があります。管理権限を持っていない場合、権限が無いことと別途マニュアルで追加する必要がある旨がダイアログで表示されます。 組織の管理者権限がある場合、以下の手順でテンプレート グループを設定できます。  [組織] → [設定] → [マップ] の順にクリック  [テンプレート] の中でテンプレートを共有するグループを指定  [Esri のデフォルトの構成可能なアプリをグループで共有します] をクリックすると、Esri がデフォルトで用意しているテンプレートも通常どおり使用できます。         テンプレートを使った web アプリケーションの作成・利用  ユーザーが ArcGIS Online もしくは ArcGIS Enterprise のテンプレートから web アプリケーションを作成・利用します。 内部的には、アプリは Developer Edition のテンプレートを参照して動作します。 ※ 上記理由から、運用時においてもユーザーが Developer Edition にアクセスできる必要があります。    3つのデプロイ パターンの総括表    パターン 開発時に必要なコンポーネント 運用時に必要なコンポーネント ArcGIS Online での利用可否 ArcGIS Enterprise での利用可否     Web アプリケーションをデプロイ Node.js、Developer Edition Web サーバー、ArcGIS Online もしくは ArcGIS Enterprise 〇 〇   ウィジェットをデプロイ Node.js、Developer Edition Web サーバー、 ArcGIS Enterprise × 〇   テンプレートをデプロイ Node.js、Developer Edition Developer Edition、ArcGIS Online もしくは ArcGIS Enterprise 〇 〇    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/android/migration-android-100.x/",
	"title": "バージョン 10.2.x から 100.x への移行",
	"tags": [],
	"description": "今まで ArcGIS Runtime SDK for Android バージョン 10.2.x を使用してアプリケーションを開発されていた開発者向けのガイドです。",
	"content": "ArcGIS Runtime SDK バージョン 100.x は新しいアーキテクチャを使用してゼロから開発された次世代の ArcGIS Runtime です。このバージョンアップに伴い API の再設計が行なわれています。このドキュメントでは、バージョン 100.x の変更点について説明します。\nArcGIS Runtime SDK for Android に関しては、ESRIジャパン 製品ページをご参照ください。\n以下は、バージョン 100.x の主な変更点です。\n Gradle 参照プロジェクトの変更 マップ ビュー レイヤー クラス名の変更 フィーチャ レイヤーの表示 フィーチャの操作 個別属性表示 グラフィックス オーバーレイ ジオメトリとジオメトリ ビルダー ローダブル パターン 新しい同期パターン 既知の制限事項  Gradle 参照プロジェクトの変更 Android Studio のビルド ツールは Gradle を使用し、maven リポジトリとライブラリの参照を変更します。\nrepositories {\rjcenter()\rmaven {\rurl 'https://esri.jfrog.io/artifactory/arcgis'\r}\r}\rdependencies {\rimplementation 'com.esri.arcgisruntime:arcgis-android:100.10.0'\r}\rArcGIS Runtime SDK for Android がサポートする最新の動作環境は、ESRIジャパン 製品ページ（動作環境）をご参照ください。\nマップ 100.x では、ArcGISMap オブジェクトを API のコアとして、ArcGIS プラットフォームの Web GIS 機能を迅速に利用できるようになりました。\nArcGISMap オブジェクトは 、それを表示する View と分離されています。ArcGISMap オブジェクトには 、操作レイヤー、ベースマップ、ブックマーク等の ArcGIS 固有のデータを設定でき、アプリケーションで利用することができます。\nビュー MapView（2D表示用）と SceneView（3D表示用）は、UI コンポーネントです。MapView クラスの map プロパティに、ArcGISMap オブジェクトを設定します。\n100.x では、以下のようにマップを表示します。\n// ベースマップを指定してマップを初期化 ArcGISMap mArcGISMap = new ArcGISMap(); mArcGISMap.setBasemap(Basemap.createTopographic()); // マップビューにマップを設定 MapView mMapView = findViewById(R.id.MapView); mMapView.setMap(mArcGISMap); レイヤー クラス名の変更 各レイヤーのクラス名が以下のように変更されています。\n   レイヤー 10.2.x のクラス名 100.x のクラス名     ArcGIS Server ダイナミック マップ サービス レイヤー ArcGISDynamicMapServiceLayer ArcGISMapImageLayer   タイル マップ サービス レイヤー ArcGISTiledMapServiceLayer ArcGISTiledLayer   タイル パッケージ レイヤー ArcGISLocalTiledLayer ArcGISTiledLayer    100.x でサポートされているレイヤーの種類については、ArcGIS Runtime SDK for Android: レイヤー（英語）をご参照ください。\n作成した各レイヤーは、以下の方法でマップに追加します。\n// 操作レイヤーとしてマップに追加する mArcGISMap.getOperationalLayers().add(arcgis_map_image_layer) // ベースマップとしてマップに追加する Basemap mBasemap = new Basemap(); mBasemap.getBaseLayers().add(arcgis_tiled_layer); フィーチャ レイヤーの表示 フィーチャ サービスや端末のローカルに格納されたジオデータベースのデータをマップに表示するにはフィーチャ レイヤーを使用します。 フィーチャ レイヤーを表示するには、はじめにフィーチャ テーブルを作成します（フィーチャ サービスのデータをフィーチャ レイヤーで表示する場合は ArcGISFeatureTable オブジェクト、ジオデータベースのデータを表示する場合は GeodatabaseFeatureTable オブジェクトを使用します）。次に作成したフィーチャ テーブルを引数として FeatureLayer オブジェクトを作成し、ArcGISMap オブジェクトの OperationalLayers に追加します。\n次のコードは、フィーチャ サービスのデータを FeatureLayer としてマップに追加する方法を示しています。\n// フィーチャ サービスの URL からフィーチャ テーブルを作成 ServiceFeatureTable serviceFeatureTable = new ServiceFeatureTable(\u0026#34;https://services.arcgis.com/wlVTGRSYTzAbjjiC/arcgis/rest/services/all_Japan_shikuchoson/FeatureServer/0\u0026#34;); // フィーチャ テーブルからフィーチャ レイヤーを作成 FeatureLayer featureLayer = new FeatureLayer(serviceFeatureTable); // フィーチャ レイヤーをマップの操作レイヤーに追加 mArcGISMap.getOperationalLayers().add(featureLayer); フィーチャの操作 フィーチャの検索や編集はフィーチャ テーブル （ServiceFeatureTable または GeodatabaseFeatureTable）に対して行います。\nフィーチャ サービスから作成したフィーチャ テーブル（ServiceFeatureTable）の場合、フィーチャ テーブルのフィーチャは、マップ上にレンダリングするために必要最小限の情報だけを含むように最適化されています。これにより、フィーチャを表示するための待機時間と帯域幅の消費が削減されます。フィーチャの編集やすべての属性情報を表示するような場合は完全な情報を取得するために、ローダブル パターン等を使用して、フィーチャを明示的にロードしておく必要があります。\nフィーチャのリクエスト モード フィーチャ サービスからフィーチャを取得する場合は、 リクエスト モードの設定によってフィーチャの取得頻度とや端末上でのデータのキャッシュ方法を制御します。リクエスト モードには、ON_INTERACTION_CACHE、 ON_INTERACTION_NO_CACHE、MANUAL_CACHE  があります。リクエスト モードはフィーチャ テーブルが初期化される前に、ServiceFeatureTable の setFeatureRequestMode メソッドを使用して設定できます。\n ON_INTERACTION_CACHE : ユーザーの操作によりマップの表示領域が変更されると、フィーチャが自動的にリクエストされます。リクエストされたすべてのデータはローカルにキャッシュされます。データがキャッシュされルため、既に表示された領域にマップが移動しても、再度フィーチャはリクエストされません。サーバー上のデータが変更される可能性が少ない静的なデータに適したモードです。 ON_INTERACTION_NO_CACHE : ユーザーの操作によりマップの表示領域が変更されると、フィーチャが自動的にリクエストされますが、キャッシュはされません。既に表示された領域にマップが移動すると、再度フィーチャがリクエストされます。サーバー上のデータが継続的に更新される可能性がある場合に適したモードです。 MANUAL_CACHE : ユーザーによるマップ操作では、フィーチャは自動的にリクエストされません。このモードを使用する場合は、ServiceFeatureTable の populateFromServiceAsync メソッドを使用して明示的にデータをリクエストする必要があります。  以下のコードは populateFromServiceAsync メソッドを使用して、サーバー上のすべてのフィーチャを取得する方法の例です。\n// フィーチャの検索パラメーターを設定 QueryParameters queryParameters = new QueryParameters(); // すべてのフィーチャを取得するように条件を設定 queryParameters.setWhereClause(\u0026#34;1=1\u0026#34;); // 検索結果にフィーチャのすべての属性情報（outFields の配列に \u0026#34;*\u0026#34; を指定）を含める ArrayList\u0026lt;String\u0026gt; outFields = new ArrayList\u0026lt;\u0026gt;(); outFields.add(\u0026#34;*\u0026#34;); serviceFeatureTable.populateFromServiceAsync(queryParameters,true,outFields); フィーチャの編集 フィーチャの編集はフィーチャ テーブルに対して行います。フィーチャ サービスまたはジオデータベースのデータから作成したフィーチャ テーブルのどちらを編集する場合も実装方法に違いはありません。\nフィーチャの編集方法は、 ArcGIS Runtime SDK for Android: フィーチャの編集（英語）をご参照ください。\nフィーチャの検索 フィーチャの検索はフィーチャ テーブルに対して行います。フィーチャ サービスまたはジオデータベースのデータから作成したフィーチャ テーブルのどちらを編集する場合も実装方法に違いはありません。検索を行うには ServiceFeatureTable または GeodatabaseFeatureTable クラスの queryFeaturesAsync メソッドを使用します。\n次のコードは、フィーチャ サービスから作成したフィーチャ テーブルからフィーチャを検索する方法を示しています。\nfinal ListenableFuture\u0026lt;FeatureQueryResult\u0026gt; queryResult = serviceFeatureTable.queryFeaturesAsync(queryParameters); queryResult.addDoneListener(()-\u0026gt;{ // call get on the future to get the result  try { FeatureQueryResult result = queryResult.get(); for (Iterator\u0026lt;Feature\u0026gt; features = result.iterator(); features.hasNext();) { // 検索結果のフィーチャを取得  Feature feature = features.next(); ・・・ } } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } }); 個別属性表示 マップ上で特定の場所をタップして、その位置にあるフィーチャをすべてのレイヤーから検索して取得することができます。この操作はビューに対して行います。次のコードは、MapView クラスの identifyLayersAsync メソッドを使用してフィーチャを取得する方法を示しています。\nfinal ListenableFuture\u0026lt;List\u0026lt;IdentifyLayerResult\u0026gt;\u0026gt; identifyLayersResult = mapView.identifyLayersAsync(screenPoint,10,true); identifyLayersResult.addDoneListener(()-\u0026gt;{ try { List\u0026lt;IdentifyLayerResult\u0026gt; identifyResult = identifyLayersResult.get(); for(IdentifyLayerResult identifyLayerResult : identifyResult){ // GeoElement オブジェクトの取得  List\u0026lt;GeoElement\u0026gt; geoElement = identifyLayerResult.getElements(); ・・・ } } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } }); グラフィックス オーバーレイ グラフィックは、マップ上に一時的なデータを表示するために使用されます。MapView オブジェクトにはグラフィックを表示するためのグラフィックス オーバーレイ（GraphicsOverlay）が含まれています。 グラフィックス オーバーレイを使用することで、マップ上のレイヤーの順序が変更されても、グラフィックが常に最上位に表示されます。\n次のコードは、MapView オブジェクトに、グラフィックス オーバーレイを使用してグラフィックを追加する方法を示しています。\n// ジオメトリとシンボルを設定してグラフィックを作成 Graphic graphic = new Graphic(geometry,symbol); // グラフィックス オーバーレイに作成したグラフィックを追加 GraphicsOverlay graphicsOverlay = new GraphicsOverlay(); graphicsOverlay.getGraphics().add(graphic); // MapView の GraphicsOverlays に作成したグラフィックス オーバーレイを追加 mapView.getGraphicsOverlays().add(graphicsOverlay); ジオメトリとジオメトリ ビルダー Geometry オブジェクトのコンストラクタを使用すると、既知の座標を使用してジオメトリを作成できますが、作成後にそのジオメトリを変更することはできません。\nジオメトリ ビルダー（GeometryBuilder）を使用すると、ゼロから新しいジオメトリを作成したり、既存のジオメトリを基に、ジオメトリを変更することができます。\nローダブル パターン データを非同期でロードして状態を初期化するマップやレイヤー等のリソースは、ローダブル パターンが採用されています。各リソースのプロパティにアクセスするには、ローダブル パターンを使用して、リソースがロードされた後にアクセスすることが推奨されます。ローダブル パターンは、ロード状態の振る舞いをより均一にして且つ一貫性を持たせることで、非同期性をより明示的にします。ローダブル パターンでは、各リソースは自動的にリソースの状態をロードしません。それらは、開発者が明示的に実行したときに、遅延ロードします。 各リソースの状態は、NotLoaded（ロードが開始していない、Loading（ロード中）、Loaded（ロードに成功）、FailedToLoad（ロードに失敗） のいずれかで監視することもできます。\n詳細は、ArcGIS Runtime SDK for Android: ローダブル パターン（英語）をご参照ください。\n次のコードは、ローダブル パターンの基本的な使用方法の例を示しています。\nFeatureLayer featureLayer = new FeatureLayer(serviceFeatureTable); if(featureLayer.getLoadStatus().equals(LoadStatus.FAILED_TO_LOAD)){ Log.e(\u0026#34;eTag\u0026#34;,\u0026#34;error\u0026#34;); }else{ // フィーチャ レイヤーのロードに成功 } 新しい同期パターン Java 言語で ListenableFuture というインターフェースで馴染みのある Future パターンが拡張されました。この新しい API は、メソッドの完了時に必要な数のリスナーを追加できます。\n既知の制限事項 本バージョンでの既知の制限事項が、ArcGIS Runtime SDK for Android: リリース ノート（英語）に記載されていますので、ご参照ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/ios/migration-ios-100.x/",
	"title": "バージョン 10.2.x から 100.x への移行",
	"tags": [],
	"description": "今まで ArcGIS Runtime SDK for iOS バージョン 10.2.x を使用してアプリケーションを開発されていた開発者向けのガイドです。",
	"content": "ArcGIS Runtime SDK バージョン 100.x は新しいアーキテクチャを使用してゼロから開発された次世代の ArcGIS Runtime です。このバージョンアップに伴い API の再設計が行なわれています。このドキュメントでは、バージョン 100.x の変更点について説明します。\nArcGIS Runtime SDK for iOS に関しては、ESRIジャパン 製品ページをご参照ください。\n以下は、バージョン 100.x の主な変更点です。\n マップとシーン ビュー レイヤー クラス名の変更 フィーチャ レイヤーの表示 フィーチャの操作 個別属性表示 グラフィックス オーバーレイ ジオメトリとジオメトリ ビルダー スケッチ エディター ローダブル パターン ブロックを使用した非同期プログラミング 既知の制限事項  マップとシーン 100.x では、AGSMap オブジェクト（2D表示用）と AGSScene オブジェクト（3D表示用）を API のコアとして、ArcGIS プラットフォームの Web GIS 機能を迅速に利用できるようになりました。\nAGSMap オブジェクトと AGSScene オブジェクトは 、それらを表示する View と分離されています。AGSMap オブジェクトと AGSScene オブジェクトには 、操作レイヤー、ベースマップ、ブックマーク等の ArcGIS 固有のデータを設定でき、アプリケーションで利用することができます。\nビュー AGSMapView（2D表示用）と AGSSceneView（3D表示用）は、UI コンポーネントです。AGSMapView クラスの map プロパティに、AGSMap オブジェクトを、AGSMapSceneView クラスの scene プロパティには AGSScene オブジェクトを設定します。\n100.x では、以下のようにマップを表示します。\n// ベースマップを指定してマップを初期化 let map = AGSMap(basemap:AGSBasemap.imagery()) // マップビューにマップを設定 self.mapView.map = map レイヤー クラス名の変更 各レイヤーのクラス名が以下のように変更されています。\n   レイヤー 10.2.x のクラス名 100.x のクラス名     ArcGIS Server ダイナミック マップ サービス レイヤー AGSDynamicMapServiceLayer AGSArcGISMapImageLayer   タイル マップ サービス レイヤー AGSTiledMapServiceLayer AGSArcGISTiledLayer   タイル パッケージ レイヤー AGSLocalTiledLayer AGSArcGISTiledLayer    作成した各レイヤーは、以下の方法でマップに追加します。\n// 操作レイヤーとしてマップに追加する self.map.operationalLayers.add(arcgis_map_image_layer) // ベースマップとしてマップに追加する self.map.basemap = AGSBasemap(baseLayer: arcgis_tiled_layer) フィーチャ レイヤーの表示 フィーチャ サービスや端末のローカルに格納されたジオデータベースのデータをマップに表示するにはフィーチャ レイヤーを使用します。 フィーチャ レイヤーを表示するには、はじめにフィーチャ テーブルを作成します（フィーチャ サービスのデータをフィーチャ レイヤーで表示する場合は AGSArcGISFeatureTable オブジェクト、ジオデータベースのデータを表示する場合は AGSGeodatabaseFeatureTable オブジェクトを使用します）。次に作成したフィーチャ テーブルを引数として AGSFeatureLayer オブジェクトを作成し、AGSMap オブジェクトの OperationalLayers に追加します。\n次のコードは、フィーチャ サービスのデータを AGSFeatureLayer としてマップに追加する方法を示しています。\n// フィーチャ サービスの URL からフィーチャ テーブルを作成 let featureTable = AGSServiceFeatureTable(url: URL(string: \u0026#34;https://services.arcgis.com/wlVTGRSYTzAbjjiC/arcgis/rest/services/all_Japan_shikuchoson/FeatureServer/0\u0026#34;)!) // フィーチャ テーブルからフィーチャ レイヤーを作成 let featureLayer = AGSFeatureLayer(featureTable: featureTable) // フィーチャ レイヤーをマップの操作レイヤーに追加 self.map.operationalLayers.add(featureLayer) フィーチャの操作 フィーチャの検索や編集はフィーチャ テーブル （AGSArcGISFeatureTable または AGSGeodatabaseFeatureTable）に対して行います。\nフィーチャ サービスから作成したフィーチャ テーブル（AGSArcGISFeatureTable）の場合、フィーチャ テーブルのフィーチャは、マップ上にレンダリングするために必要最小限の情報だけを含むように最適化されています。これにより、フィーチャを表示するための待機時間と帯域幅の消費が削減されます。フィーチャの編集やすべての属性情報を表示するような場合は完全な情報を取得するために、ローダブル パターン等を使用して、フィーチャを明示的にロードしておく必要があります。\nフィーチャのリクエスト モード フィーチャ サービスからフィーチャを取得する場合は、 リクエスト モードの設定によってフィーチャの取得頻度とや端末上でのデータのキャッシュ方法を制御します。リクエスト モードには、OnInteractionCache、 OnInteractionNoCache、ManualCache があります。リクエスト モードはフィーチャ テーブルが初期化される前に、AGSServiceFeatureTable の featureRequestMode プロパティを使用して設定できます。\n  OnInteractionCache: ユーザーの操作によりマップの表示領域が変更されると、フィーチャが自動的にリクエストされます。リクエストされたすべてのデータはローカルにキャッシュされます。データがキャッシュされルため、既に表示された領域にマップが移動しても、再度フィーチャはリクエストされません。サーバー上のデータが変更される可能性が少ない静的なデータに適したモードです。\n  OnInteractionNoCache: ユーザーの操作によりマップの表示領域が変更されると、フィーチャが自動的にリクエストされますが、キャッシュはされません。既に表示された領域にマップが移動すると、再度フィーチャがリクエストされます。サーバー上のデータが継続的に更新される可能性がある場合に適したモードです。\n  ManualCache: ユーザーによるマップ操作では、フィーチャは自動的にリクエストされません。このモードを使用する場合は、AGSServiceFeatureTable の populateFromService メソッドを使用して明示的にデータをリクエストする必要があります。\n以下のコードは populateFromService メソッドを使用して、サーバー上のすべてのフィーチャを取得する方法の例です。\n// フィーチャの検索パラメーターを設定 let params = AGSQueryParameters() // すべてのフィーチャを取得するように条件を設定 params.whereClause = \u0026#34;1 = 1\u0026#34; // 検索結果にフィーチャのすべての属性情報（outFields の配列に \u0026#34;*\u0026#34; を指定）を含める self.featureTable.populateFromService(with: params, clearCache: true, outFields: [\u0026#34;*\u0026#34;]) {(result, error) -\u0026gt; Void in if let error = error { // フィーチャの取得に失敗  print(\u0026#34;Error:\\(error.localizedDescription)\u0026#34;) } else { // フィーチャの取得に成功（フィーチャ数を表示）  print(result?.featureEnumerator().allObjects.count ?? \u0026#34;0\u0026#34;) } }   フィーチャの編集 フィーチャの編集はフィーチャ テーブルに対して行います。フィーチャ サービスまたはジオデータベースのデータから作成したフィーチャ テーブルのどちらを編集する場合も実装方法に違いはありません。\nフィーチャの編集方法は、 ArcGIS Runtime SDK for iOS: フィーチャの編集（英語）をご参照ください。\nフィーチャの検索 フィーチャの検索はフィーチャ テーブルに対して行います。フィーチャ サービスまたはジオデータベースのデータから作成したフィーチャ テーブルのどちらを編集する場合も実装方法に違いはありません。検索を行うには AGSServiceFeatureTable または AGSGeodatabaseFeatureTable クラスの queryFeaturesWithParameters メソッドを使用します。\n次のコードは、フィーチャ サービスから作成したフィーチャ テーブルからフィーチャを検索する方法を示しています。\nfeatureTable.queryFeatures(with: queryParameters, queryFeatureFields: .loadAll, completion:{ (result, error) -\u0026gt; Void in if let error = error { print(\u0026#34;Error:\\(error.localizedDescription)\u0026#34;) } else { let enumr = result?.featureEnumerator() for feature in enumr! { // 検索結果のフィーチャを取得  let feature = feature as! AGSArcGISFeature } } }) 個別属性表示 マップ上で特定の場所をタップして、その位置にあるフィーチャをすべてのレイヤーから検索して取得することができます。この操作はビューに対して行います。次のコードは、AGSMapView クラスの identifyLayers メソッドを使用してフィーチャを取得する方法を示しています。\nself.mapView.identifyLayers(atScreenPoint: screenPoint, tolerance: 10, returnPopupsOnly: true, completion: { (results, error) -\u0026gt; Void in if let error = error { print(error) } else { for identifyLayerResult in results! { for geoElement in identifyLayerResult.geoElements { // AGSGeoElement オブジェクトの取得  } } } }) グラフィックス オーバーレイ グラフィックは、マップ上に一時的なデータを表示するために使用されます。AGSMapView と AGSSceneView オブジェクトにはグラフィックを表示するためのグラフィックス オーバーレイ（AGSGraphicsOverlay）が含まれています。 グラフィックス オーバーレイを使用することで、マップ上のレイヤーの順序が変更されても、グラフィックが常に最上位に表示されます。\n次のコードは、AGSMapView オブジェクトに、グラフィックス オーバーレイを使用してグラフィックを追加する方法を示しています。\n// ジオメトリとシンボルを設定してグラフィックを作成 let pointGraphic = AGSGraphic(geometry: pointGeometry, symbol: poitnSymbol, attributes: nil) // グラフィックス オーバーレイに作成したグラフィックを追加 let graphicsOverlay = AGSGraphicsOverlay() graphicsOverlay.graphics.add(pointGraphic) // AGSMapView の GraphicsOverlays に作成したグラフィックス オーバーレイを追加 self.mapView.graphicsOverlays.add(graphicsOverlay) ジオメトリとジオメトリ ビルダー AGSGeometry オブジェクトのコンストラクタを使用すると、既知の座標を使用してジオメトリを作成できますが、作成後にそのジオメトリを変更することはできません。\nジオメトリ ビルダー（AGSGeometryBuilder）を使用すると、ゼロから新しいジオメトリを作成したり、既存のジオメトリを基に、ジオメトリを変更することができます。\nスケッチ エディター スケッチ エディター（AGSSketchEditor）を使用すると、ユーザーがマップ上で対話的にジオメトリをスケッチすることができます。\n次のコードは、AGSSketchEditor の使用方法の例を示しています。\n// マップ ビューにスケッチ エディターを設定 self.sketchEditor = AGSSketchEditor() self.mapView.sketchEditor = self.sketchEditor // ジオメトリの種類を設定してスケッチを開始 self.sketchEditor.start(with: AGSGeometryType.polygon) // スケッチ中のジオメトリの更新を監視 NotificationCenter.default.addObserver(self, selector: #selector(ViewController.respondToGeometryChanged), name: NSNotification.Name.AGSSketchEditorGeometryDidChange, object: nil) ・・・・・・ @objc func respondToGeometryChanged() { // ジオメトリが更新された際の処理 } ローダブル パターン データを非同期でロードして状態を初期化するマップやレイヤー等のリソースは、ローダブル パターンが採用されています。各リソースのプロパティにアクセスするには、ローダブル パターンを使用して、リソースがロードされた後にアクセスすることが推奨されます。ローダブル パターンは、ロード状態の振る舞いをより均一にして且つ一貫性を持たせることで、非同期性をより明示的にします。ローダブル パターンでは、各リソースは自動的にリソースの状態をロードしません。それらは、開発者が明示的に実行したときに、遅延ロードします。 各リソースの状態は、NotLoaded（ロードが開始していない、Loading（ロード中）、Loaded（ロードに成功）、FailedToLoad（ロードに失敗） のいずれかで監視することもできます。\n詳細は、ArcGIS Runtime SDK for iOS: ローダブル パターン（英語）をご参照ください。\n次のコードは、ローダブル パターンの基本的な使用方法の例を示しています。\nself.featureLayer.load(completion: {(error) -\u0026gt; Void in if let error = error { print(error) }else { // フィーチャ レイヤーのロードに成功  } }) ブロックを使用した非同期プログラミング 非同期操作を実行するメソッドは、完了ブロックを引数として受け取ります。ブロックは操作が正常に完了したとき、または、エラーが発生したときに呼び出されます。操作が成功すると、その操作の結果がブロックに渡されます。それ以外の場合はエラーが渡されます。 これは、デリゲートを使用して各非同期操作の結果とエラーをハンドリングしていた 10.2.x のプログラミング方法を置き換えます。\n次のコードは、例として端末の GPS の位置情報の取得開始の操作結果をハンドリングする方法を示しています。\nself.mapView.locationDisplay.start(completion: { (error) -\u0026gt; Void in if let error = error { // GPS の位置情報の取得に失敗  print(\u0026#34;Error:\\(error.localizedDescription)\u0026#34;) } else { // GPS の位置情報の取得に成功  } }) 既知の制限事項 現バージョンでの既知の制限事項が、ArcGIS Runtime SDK for iOS: リリース ノート（英語）に記載されていますので、ご参照ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/android/migration-android-200.x/",
	"title": "バージョン 100.x から 200.x への移行",
	"tags": [],
	"description": "今まで ArcGIS Runtime SDK for Android バージョン 100.x を使用してアプリケーションを開発されていた開発者向けのガイドです。",
	"content": "出典：ArcGIS Maps SDK for Kotlin - Guide - Migrate from 100.x to 200.x\nArcGIS Runtime SDK バージョン 100.15 は、不具合修正とマイナー アップデートのみに焦点を当てた長期サポート リリースです。ArcGIS Maps SDKs for Native Apps バージョン 200.x は、100.15 の実績あるアーキテクチャをベースに、最新の開発者フレームワークのイノベーションを活用するように設計されています。このトピックでは、変更された API の領域について概説し、200.x アプリ用に 100.x コードをリファクタリングするための手順を説明します。\n200.0 リリースでは、Android 向けの新しい Kotlin ベースの API「ArcGIS Maps SDK for Kotlin」が導入されました。\nこのリリースは、ArcGIS Runtime SDK for Android を Kotlin ファーストの SDK として完全に再構築したもので、コルーチン、フロー、null 安全などの機能をすぐにサポートすることができます。Java ベースの ArcGIS Runtime SDK for Android は、長期サポート（LTS）となり、不具合修正は継続されますが、それ以上の機能アップデートはありません。\n新機能を利用するには、Java ベースの ArcGIS Runtime SDK for Android を置き換える ArcGIS Maps SDK for Kotlin に移行してください。詳細については、ブログ「ArcGIS Runtime SDK の今後のバージョンアップの計画についてのお知らせ」をご確認ください。\nLifeCycleObserver GeoView クラスは MapView や SceneView のベースクラスで、DefaultLifecycleObserver を実装しています。したがって、onResume、onPause、onDestroy のようなライフサイクルイベントを GeoView に転送することは、もはや必要ではありません。\nArcGIS Maps SDK for Kotlin v200.x\noverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // API キーを設定する  ArcGISEnvironment.apiKey = ApiKey.create(BuildConfig.API_KEY) // アクティビティにデータバインディングを設定する  val activityMainBinding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main) mapView = activityMainBinding.mapView // アクティビティのライフサイクルに MapView を追加する  lifecycle.addObserver(mapView) } ArcGIS Runtime API for Android v100.x\noverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val activityMainBinding = ActivityMainBinding.inflate(layoutInflater) setContentView(activityMainBinding.root) // API キーを設定する  ArcGISRuntimeEnvironment.setApiKey(BuildConfig.API_KEY) // MapView と値のビューバインディング  mapView = activityMainBinding.mapView } override fun onPause() { mapView.pause() super.onPause() } override fun onResume() { super.onResume() mapView.resume() } override fun onDestroy() { mapView.dispose() super.onDestroy() } コルーチンとコルーチンのスコープ Kotlin のサスペンド関数は、より安全で、非同期操作のエラーが発生しにくくなっています。すべてのサスペンド関数は結果を返すため、try/catch ブロックは不要になりました。さらに、ライフサイクルを認識するコルーチン スコープを使用してコルーチンを起動できます。これは、ライフサイクルが破棄されると自動的にキャンセルされます。\nArcGIS Maps SDK for Kotlin v200.x\nlifecyleScope.launch { // サスペンド関数を実行してジオデータベースを取得する  val geodatabaseResult = Geodatabase.create(filePath) // サスペンドが完了したら結果を取得する  geodatabaseResult.onSuccess { geodatabase -\u0026gt; // サスペンド関数を実行してジオデータベース フィーチャテーブルを作成する  val featureTableResult = geodatabase.createTable(tableDescription) // サスペンドが完了したら結果を取得する  featureTableResult.onSuccess { geodatabaseFeatureTable -\u0026gt; setupMapFromGeodatabase(geodatabaseFeatureTable) }.onFailure { throwable -\u0026gt; showMessage(throwable.message) } }.onFailure { throwable -\u0026gt; showMessage(throwable.message) } } ArcGIS Runtime API for Android v100.x\nval geodatabaseFuture = Geodatabase.createAsync(filePath) // ジオデータベースを非同期で作成する geodatabaseFuture.addDoneListener { try { // モバイル ジオデータベースのインスタンスを取得する  val geodatabase = geodatabaseFuture.get() // テーブルの説明を使用してテーブルを作成する  val featureTableFuture = geodatabase.createTableAsync(tableDescription) featureTableFuture.addDoneListener { try { // 作成されたフィーチャテーブルを取得する  val featureTable = featureTableFuture.get() setupMapFromGeodatabase(featureTable) } catch (e: Exception) { showMessage(e.message) } } } catch (e: Exception) { showMessage(e.message) } } イベント処理 すべてのイベントが SharedFlow を使用して表現されるようになったため、コールバックは不要になりました。\nArcGIS Maps SDK for Kotlin v200.x\nval simulatedLocationDataSource = SimulatedLocationDataSource(polyline) simulatedLocationDataSource.start() simulatedLocationDataSource.locationChanged.collect { location -\u0026gt; val locationPoint = location.position } ArcGIS Runtime API for Android v100.x\nval simulatedLocationDataSource = SimulatedLocationDataSource().apply { setLocations(polyline) } simulatedLocationDataSource.startAsync() simulatedLocationDataSource.addLocationChangedListener { locationChangedEvent -\u0026gt; val locationPoint = locationChangedEvent.location.position } ローダブル ローダブルの状態 (LoadStatus) は StateFlow を使用して表されますが、load() はロード処理完了の Result を返すサスペンド関数です。ロード エラーは、失敗した場合に Result から取得できます。\nArcGIS Maps SDK for Kotlin v200.x\nprivate suspend fun loadPortalItem() { val portalItem = PortalItem(Portal(\u0026#34;https://www.arcgis.com\u0026#34;), itemID) portalItem.load().onSuccess { val featureLayer = FeatureLayer(portalItem) setFeatureLayer(featureLayer, viewpoint) }.onFailure { throwable -\u0026gt; showError(throwable.message) } } ArcGIS Runtime API for Android v100.x\nprivate fun loadPortalItem() { val portal = Portal(\u0026#34;https://www.arcgis.com\u0026#34;, false) val portalItem = PortalItem(portal, itemID) portalItem.addDoneLoadingListener { if(portalItem.loadStatus == LoadStatus.LOADED){ val featureLayer = FeatureLayer(portalItem) setFeatureLayer(featureLayer) }else if(portalItem.loadStatus == LoadStatus.FAILED_TO_LOAD){ showError(portalItem.loadError.message) } } portalItem.loadAsync() } LoadStatus の更新は StateFlow になったため、非同期でリッスンする方法があります。このようにして、中間の LoadStatus 値を取得できます。\nArcGIS Maps SDK for Kotlin v200.x\nlifecycleScope.launch { portalItem.load() } lifecycleScope.launch { portalItem.loadStatus.collect { loadStatus -\u0026gt; when (loadStatus) { LoadStatus.Loaded -\u0026gt; { val featureLayer = FeatureLayer(portalItem) setFeatureLayer(featureLayer) } is LoadStatus.FailedToLoad -\u0026gt; { showError(\u0026#34;Error loading portal item: ${loadStatus.error.message}\u0026#34;) } LoadStatus.Loading -\u0026gt; { ... } LoadStatus.NotLoaded -\u0026gt; { ... } } } } タスクとジョブ ArcGIS Maps SDK for Kotlin では、ジョブまたはタスクのワークフローが大幅に変更されました。ジョブは、進行状況または完了の流れを制御する CoroutineScope で実行する必要があります。コルーチン フローを使用して複数のジョブとタスクを実行できるため、ネストされたコールバックの操作を回避できます。\nArcGIS Maps SDK for Kotlin v200.x\n// 新しいオフライン マップ タスクを作成する val offlineMapTask = OfflineMapTask(mapView.map) // タスクのパラメータを設定する val generateOfflineMapParameters = GenerateOfflineMapParameters( geometry, minScale, maxScale ) // オフライン マップ パラメータを使用してジョブを作成する val offlineMapJob = offlineMapTask.generateOfflineMap( generateOfflineMapParameters, offlineMapPath ) // ジョブを開始する offlineMapJob.start() with (lifecycleScope) { // ジョブの進捗を取得する  launch { offlineMapJob.progress.collect { val progressPercentage = offlineMapJob.progress.value } } // ジョブが成功した場合にマップを表示する  launch { offlineMapJob.result().onSuccess { offlineMapResult -\u0026gt; mapView.map = offlineMapResult.offlineMap }.onFailure { throwable -\u0026gt; showMessage(throwable.message.toString()) } } } ArcGIS Runtime API for Android v100.x\n// 新しいオフライン マップ タスクを作成する val offlineMapTask = OfflineMapTask(mapView.map) // タスクのパラメータを設定する val generateOfflineMapParameters = GenerateOfflineMapParameters( geometry, minScale, maxScale ) // オフライン マップ パラメータを使用してジョブを作成する val offlineMapJob = offlineMapTask.generateOfflineMap( generateOfflineMapParameters, offlineMapPath ) // ジョブを開始する offlineMapJob.start() // ジョブの進捗を取得する offlineMapJob.addProgressChangedListener { val progress = offlineMapJob.progress } // ジョブが成功した場合にマップを表示する offlineMapJob.addJobDoneListener { if (offlineMapJob.status == Job.Status.SUCCEEDED) { mapView.map = offlineMapJob.result.offlineMap } else if (offlineMapJob.status == Job.Status.FAILED) { showMessage(offlineMapJob.error.message) } } ジオメトリとジオメトリ ビルダー 読みやすさと使いやすさを向上させるために、ジオメトリとジオメトリ ビルダーの使用法にいくつかの変更があります。\n  PolylineBuilder や PolygonBuilder などのジオメトリ ビルダーは、レシーバー タイプとしてビルダーを使用して関数パラメーターを受け取るようになり、Kotlin の慣用的な方法でビルダーにジオメトリを追加できるようになりました。\n  MutablePart.createWithSegments を使用して、セグメントでパーツを作成できます。\n  可変および不変のジオメトリ コレクション タイプの名前は、Kotlin のイディオムに合わせて調整されています。以下は、ArcGIS Runtime API for Android に類似した ArcGIS Maps SDK for Kotlin で定義されているジオメトリ タイプのリストです。\n MutablePart \u0026lt;- Part Part \u0026lt;- ImmutablePart MutablePartCollection \u0026lt;- PartCollection PartCollection \u0026lt;- ImmutablePartCollection    .points プロパティにアクセスすることにより、Part および MutablePart をポイントのコレクションとして表示できます。\n  GeometryEngine メソッドはジェネリックであり、より優れたタイプ セーフを提供するため、以下に示すように同一のジオメトリが返されます。\n  ArcGIS Maps SDK for Kotlin v200.x\nfun \u0026lt;T : Geometry\u0026gt; project(geometry: T, outputSpatialReference: SpatialReference, datumTransformation: DatumTransformation?): T fun \u0026lt;T : Geometry\u0026gt; project(geometry: T, spatialReference: SpatialReference): T fun \u0026lt;T : Geometry\u0026gt; simplify(geometry: T): T fun \u0026lt;T : Geometry\u0026gt; setM(geometry: T, m: Double?): T fun \u0026lt;T : Geometry\u0026gt; setZ(geometry: T, z: Double?): T fun \u0026lt;T : Geometry\u0026gt; setZAndM(geometry: T, z: Double?, m: Double?): T ArcGIS Maps SDK for Kotlin v200.x\n// ポリライン ジオメトリを作成する val polylineGeometry = PolylineBuilder(spatialReference) { addPoint(-10e5, 40e5) addPoint(20e5, 50e5) }.toGeometry() // セグメントを使用してパーツ ジオメトリを作成する val partGeometry = MutablePart.createWithSegments( listOf(leftCurve, leftArc, rightArc, rightCurve), spatialReference ) val polygon = Polygon(listOf(partGeometry)) ArcGIS Runtime API for Android v100.x\n// ポリライン ジオメトリを作成する val polylineGeometry = PolylineBuilder(spatialReference).apply { addPoint(-10e5, 40e5) addPoint(20e5, 50e5) }.toGeometry() // セグメントを使用してパーツ ジオメトリを作成する val partGeometry = Part(spatialReference).apply { addAll(listOf(leftCurve,leftArc,rightArc,rightCurve)) } val polyon = Polygon(partGeometry, spatialReference) ジェスチャー MapView と SceneView には、DefaultMapViewOnTouchListener をオーバーライドする代わりに、ジェスチャー イベントがあります。 イベントは SharedFlow として表され、コルーチンで取得できます。\nArcGIS Maps SDK for Kotlin v200.x\nlifecycleScope.launch { mapView.onSingleTapConfirmed.collect { tapConfirmedEvent -\u0026gt; val mapPoint = tapConfirmedEvent.mapPoint val screenCoordinate = tapConfirmedEvent.screenCoordinate } } ArcGIS Runtime API for Android v100.x\nmapView.onTouchListener = object : DefaultMapViewOnTouchListener(applicationContext, mapView) { override fun onSingleTapConfirmed(motionEvent: MotionEvent): Boolean { val screenPoint = android.graphics.Point( motionEvent.x.roundToInt(), motionEvent.y.roundToInt() ) val mapPoint = mapView.screenToLocation(screenPoint) return super.onSingleTapConfirmed(motionEvent) } } 認証 ArcGIS Maps SDK for Kotlin には、セキュリティで保護された ArcGIS サービスを操作するための異なるアプローチがあります。SDK は、ArcGIS 認証情報を作成し、特定の保護されたリソースの読み込みとは関係なくトークンを生成するための一連の非同期 API を提供します。認証チャレンジの処理中に作成された資格情報は保存され、後続のリクエストの送信中に再利用されます。\nArcGIS Maps SDK for Kotlin v200.x\nArcGISEnvironment.authenticationManager.arcGISAuthenticationChallengeHandler = ArcGISAuthenticationChallengeHandler { challenge -\u0026gt; val result: Result\u0026lt;TokenCredential\u0026gt; = TokenCredential.create( challenge.requestUrl, \u0026#34;username\u0026#34;, \u0026#34;password\u0026#34;, tokenExpirationInterval ) val credential = result.getOrElse { throwable -\u0026gt; Log.e(\u0026#34;TokenCredential Creation\u0026#34;, \u0026#34;Failed\u0026#34;) return@ArcGISAuthenticationChallengeHandler ArcGISAuthenticationChallengeResponse .ContinueAndFailWithError(throwable) } Log.d(\u0026#34;TokenCredential Creation\u0026#34;, \u0026#34;Succeeded\u0026#34;) return@ArcGISAuthenticationChallengeHandler ArcGISAuthenticationChallengeResponse .ContinueWithCredential(credential) } lifecycleScope.launch { // authenticationManager は認証を処理して PortalItem を取得します  val portal = Portal(portalURL, Portal.Connection.Authenticated) val portalItem = PortalItem(portal, itemID) val map = ArcGISMap(portalItem) mapView.map = map map.loadStatus.collect { loadStatus -\u0026gt; when (loadStatus) { LoadStatus.NotLoaded -\u0026gt; { ... } LoadStatus.Loading -\u0026gt; Log.e(\u0026#34;LoadStatus\u0026#34;, \u0026#34;About to load map\u0026#34;) LoadStatus.Loaded -\u0026gt; Log.e(\u0026#34;LoadStatus\u0026#34;, \u0026#34;Map loaded successfully\u0026#34;) is LoadStatus.FailedToLoad -\u0026gt; Log.e(\u0026#34;LoadStatus\u0026#34;, loadStatus.error.message.toString()) } } } Output\nLoadStatus: About to load map TokenCredential Creation: Succeeded LoadStatus: Map loaded successfully アプリで認証コードを移行する手順については、Migrate authentication from 100.x to 200.x トピックを参照してください。\nカスタム Location DataSource ArcGIS Maps SDK for Kotlin には、ユーザー定義のロケーション データ プロバイダーによって駆動できる CustomLocationDataSource が導入されています。これは、カスタム ソースからのロケーション データがあり、そのデータを LocationDataSource の形式にして、API の他の部分と連携できるようにする場合に役立ちます。\nArcGIS Maps SDK for Kotlin v200.x\n{ // ... MapView を設定する  // カスタム ロケーション エミッタを作成する  val customLocationProvider = { SingleLocationEmitter() } // ロケーション プロバイダーをデータソースに追加する  val customLocationDataSource = CustomLocationDataSource(customLocationProvider) lifecycleScope.launch { customLocationDataSource.start().onSuccess { // カスタム ロケーション データソースが正常に開始される  }.onFailure { throwable -\u0026gt; // ロケーション データソースの開始エラー  } customLocationDataSource.locationChanged.collect { // ロケーションの変更を取得する  } } // データソースを MapView に追加する  mapView.locationDisplay.dataSource = customLocationDataSource } // ... 外部クラスで、カスタム ロケーション プロバイダーを作成する class SingleLocationEmitter() : CustomLocationDataSource.LocationProvider { override val locations: Flow\u0026lt;Location\u0026gt; = flow { emit( Location( Clock.System.now(), point, horizontalAccurary, verticalAccuracy, speed, course, lastKnown ) ) } override val headings: Flow\u0026lt;Double\u0026gt; = flow { emit(0.0) } } ApplicationContext の要件 ArcGIS Runtime SDK for Android から ArcGIS Maps SDK for Kotlin へのアップデートでは、API のいくつかの部分で ArcGISEnvironment.applicationContext プロパティを設定することが必要です。LocationDataSource, CustomLocationDataSource, SystemLocationDataSource, IndoorsLocationDataSource, RouteTask, ServiceAreaTask, ClosestFacilityTask または AuthenticationManager でコンテキストが必要です。このプロパティは、以下のようにアクティビティの開始時に設定することができます。\nArcGIS Maps SDK for Kotlin v200.x\nArcGISEnvironment.applicationContext = this.applicationContext ライブラリ固有のデータ型 Color: このアップデートにより、android.graphics.color が com.arcgismaps.Color に置き換えられます。この Color ライブラリには、すぐに使用できるデフォルトのカラーが付属しており、カスタム RGB カラーを作成したり、アプリのリソースの色を使用したりできます。\nArcGIS Maps SDK for Kotlin v200.x - Color\n// arcgismaps.Color を作成する複数の方法 var accentColor = Color(getColor(R.color.colorAccent)) accentColor = Color.fromRgba(10,255,0,255) accentColor = Color(0x0AFF00) // 選択色を設定 mapView.selectionProperties.color = accentColor ArcGIS Maps GUID: ArcGIS Maps SDK for Kotlin は独自のデータ型 GUID を導入します。これは、128 ビットのグローバルに一意の識別子を表し、ArcGIS サービスおよびジオデータベースからの GlobalID および GUID フィールドを表します。\nArcGIS Maps SDK for Kotlin v200.x - Guid\nval utilityElement = utilityNetwork.createElement( utilityAssetType, Guid(\u0026#34;\u0026lt;Unique-Identifier-Here\u0026gt;\u0026#34;) ) 既知の制限事項 現バージョンでの既知の制限事項が、ArcGIS Maps SDK for Kotlin: リリース ノート に記載されていますので、ご参照ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/dotnet/migration-dotnet-200.x/",
	"title": "バージョン 100.x から 200.x への移行",
	"tags": [],
	"description": "今まで ArcGIS Runtime SDK for .NET バージョン 100.x を使用してアプリケーションを開発されていた開発者向けのガイドです。",
	"content": "出典：ArcGIS Maps SDK for .NET - Guide - Migrate from 100.x to 200.x\nArcGIS Runtime SDK バージョン 100.15 は、バグ修正とマイナー アップデートのみに特化した長期サポート リリースです。ArcGIS Maps SDKs for Native Apps バージョン 200.x は、100.15 の実績あるアーキテクチャをベースに、最新の開発者向けフレームワークの技術を活用するよう設計されています。このトピックでは、変更された API の領域の概要と、200.x アプリ用に 100.x コードをリファクタリングするためのガイダンスを提供します。\n基本的な移行手順 ArcGIS Runtime SDK for .NET バージョン 100.0 から 100.15 で構築した既存のアプリを ArcGIS Maps SDK for .NET バージョン 200.0 に移行するには、以下の一般的な手順に従います。\n 以下の システム要件の変更 のセクションを確認し、推奨される変更または更新を行います。 アプリケーションのソース コードを開きます。 すべての Esri.ArcGISRuntime.* NuGet リファレンスをバージョン 200.0 に更新します。 API の破壊的変更に対処します。v100.x で非推奨とマークされた API は 200.0 で削除され、これらの API を使用するとコンパイル エラーが発生します。 アップグレードされたアプリをビルドして実行し、正しく機能することを確認します。  Xamarin アプリケーションの移行 バージョン 100.15 は、Xamarin.Forms、Xamarin.Android、Xamarin.iOS をサポートする ArcGIS Runtime SDK for .NET の最後のリリースとなりました。バージョン 200.0 は、.NET MAUI、.NET for Android、.NET for iOS をサポートしています。既存の Xamarin Forms アプリケーションは .NET MAUI（Multi-platform App UI）へ、Xamarin.Android と Xamarin.iOS はそれぞれ .NET for Android と .NET for iOS へ移行する必要があります。\n.NET MAUI 用の ArcGIS Maps SDK パッケージの初期化 ArcGIS Maps SDK for .NET を .NET MAUI アプリで使用するには、アプリの初期化時に MauiAppBuilder クラスで UseArcGISRuntime() を呼び出します。下記の例は、その方法を示しています。\nMauiProgram.cs\npublic static class MauiProgram { // このクラスは、標準的な MAUI テンプレートの一部です  // MAUI アプリは、CreateMauiApp を使用してアプリを準備します  public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); builder.UseMauiApp\u0026lt;App\u0026gt;(); // この行は、ArcGIS Runtime を使用する場合に必要です  builder.UseArcGISRuntime(); return builder.Build(); } } Xamarin Forms アプリの .NET MAUI への移行については、以下のドキュメントを参照してください。\n Xamarin.Forms からアプリを移行する (Microsoft ドキュメント) Migrating from Xamarin.Forms (Preview) - Wiki  API の変更 バージョン 100.x で非推奨だった API は、バージョン 200.0 ですべて削除されました。非推奨の API を使用すると、コンパイルエラーが発生するため、バージョン 200.0.0 を使用してアプリケーションを正常にビルドするには、このエラーに対処する必要があります。\nシステム要件の変更 ArcGIS Runtime SDK for .NET を使用するアプリを開発およびデプロイするためのシステム要件がバージョン 200.x で以下のように変更されました。詳細については、System requirements のトピックを参照してください。\nよくある質問 (FAQ) 移行に関するよくある質問と回答は、以下のとおりです。\n  質問: ArcGIS Runtime SDK for .NET バージョン 100.x から ArcGIS Maps SDK for .NET バージョン 200.x にアプリをすぐに移行する必要がありますか？\n回答: いいえ。ArcGIS Runtime SDK for .NET バージョン 100.15 は、長期サポート リリースです。バージョン 200.0（または将来のバージョンの 200.x リリース）で提供される新機能を必要としないアプリの場合、アプリは正常に動作します。詳細については、製品ライフサイクルのドキュメント を参照してください。\nただし、ArcGIS Maps SDK for .NET が提供する最新の機能を使用するためには、アプリを移行する必要があります。\n  質問: ArcGIS Runtime SDK for .NET バージョン 100.x で利用可能な機能で、ArcGIS Maps SDK for .NET バージョン 200.x で利用できない機能はありますか？\n回答: いいえ。ArcGIS Runtime SDK for .NET 100.15 に含まれるすべての機能は、ArcGIS Maps SDK for .NET 200.0 で利用可能です。さらに、バージョン 200.0 では、100.15 では利用できなかった新しい機能が提供されています。詳細については、リリース ノート を参照してください。\n  質問: ArcGIS Runtime SDK for .NET バージョン 100.x で作成したアプリを ArcGIS Maps SDK for .NET バージョン 200.x で使用するには、アプリを書き換える必要がありますか？\n回答: いいえ。ArcGIS Runtime SDK for .NET バージョン 100.15 を使用するアプリを ArcGIS Maps SDK for .NET バージョン 200.0 に更新することは、通常のバージョンアップ通りで簡単です。Xamarin.Forms アプリを .NET MAUI に移行するには、ArcGIS Maps SDK for .NET の機能とは関係なく Xamarin から MAUI アプリへ移行するための一般的な追加作業が必要です。\n  質問: ArcGIS Maps SDK for .NET はまったく新しい製品ですか？\n回答: いいえ。ArcGIS Runtime SDK として知られていた製品群は、現在 ArcGIS Maps SDK for Native Apps として提供されています。これらの SDK のバージョン 200.x は、ArcGIS Runtime 100.15 の実績あるアーキテクチャを基盤としており、最新の開発者用フレームワークの技術を活用するように設計されています。\n  既知の制限事項 現バージョンでの既知の制限事項が、ArcGIS Maps SDK for .NET: リリース ノートに記載されていますので、ご参照ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/ios/migration-ios-200.x/",
	"title": "バージョン 100.x から 200.x への移行",
	"tags": [],
	"description": "今まで ArcGIS Runtime SDK for iOS バージョン 100.x を使用してアプリケーションを開発されていた開発者向けのガイドです。",
	"content": "出典：ArcGIS Maps SDK for Swift - Guide - Migrate from 100.x to 200.x\nイントロダクション ArcGIS Maps SDK for Swift v200.0 は、Swift 開発者向けに設計された次世代マッピング API を提供します。これは、ArcGIS Runtime SDK for iOS v100.x の後継であり、同じ基盤、アーキテクチャ、および機能を継承しています。API の概念の多くは変更されていませんが、SwiftUI、構造化された同時並行処理、値型、Measurement、デフォルト パラメーターなどの Swift の規則、フレームワーク、および機能に合わせて記述されています。\n既存のアプリを移行するには、大幅な変更が必要です。具体的には、SwiftUI を使用してユーザー インターフェイスを再構築し、async/await を使用して非同期コードを実装する必要があります。 これらのテクノロジーをしっかりと理解することは、移行を容易にし、強固な基盤を提供するのに役立ちます。\nAPI 名の変更 型名変更 型 (クラス、プロトコル、構造体、および列挙型) は ArcGIS モジュールにカプセル化され、名前に AGS プレフィックスが含まれなくなりました。その結果として生じる名前の変更の例を次に示します。\n   v100.x v200     AGSMap Map   AGSMapView MapView   AGSLoadable Loadable   AGSViewpoint Viewpoint   AGSPoint Point   AGSFeatureLayer FeatureLayer   AGSArcGISFeatureTable ArcGISFeatureTable    ArcGIS Maps SDK への製品名変更の一環として、Runtime という単語がタイプ名から削除されました。\n   v100.x v200     ArcGISRuntimeEnvironment ArcGISEnvironment    メソッドおよびプロパティ名の変更 Swift API Design Guidelines に従うように、さまざまなメソッドとプロパティが調整されています。\n  メソッド引数のラベルが読みやすくなりました。\n100.x:\nAGSGeometryEngine.bufferGeometry(geometry, byDistance:5000) 200:\nGeometryEngine.buffer(around:geometry, distance: 5000)   メソッドの引数の順序が変更されました。\n100.x:\nfeatureLayer.setFeature(feature, visible: true) 200:\nfeatureLayer.setVisible(true, for:feature)   Boolean プロパティはアサーションとして読み取られます。\n100.x:\ntrackingStatus.calculatingRoute 200:\ntrackingStatus.isCalculatingRoute   ファクトリ メソッドは、make プレフィックスを使用します。\n100.x:\nfeatureTable.createFeature() 200:\nfeatureTable.makeFeature()   コレクションを含むクラスは、それらを変更するための変更メソッドを提供します。\n100.x:\ngraphicsOverlay.graphics.add(graphic) 200:\ngraphicsOverlay.addGraphic(graphic)   Swift 構造化された同時並行処理関連の変更 非同期メソッドの呼び出しで、完了を処理するためにクロージャ コールバックを渡す必要がなくなりました。 非同期メソッドを待機して、結果を直接使用するか、エラーを処理できます。\n100.x:\nrouteTask.solveRoute(with: routeParameters) { (routeResult: AGSRouteResult?, error: Error?) in if let error { // エラー処理 } else if let routeResult { // 結果の使用 } } 200:\ndo { let routeResult = try await routeTask.solveRoute(using: routeParameters) // 結果の使用 } catch { // エラー処理 } ジョブを開始するために、ステータスを監視したり完了を処理したりするためにクロージャ コールバックを渡す必要がなくなりました。代わりに、ジョブを開始し、その出力を待って結果を取得し、そのメッセージを非同期的に反復してステータスを監視できます。\n100.x:\nlet job = offlineMapTask.generateOfflineMapJob( with: parameters, downloadDirectory: downloadDirectoryURL ) job.start(statusHandler: { status in print(status) }, completion: { [weak self] (result, error) in guard let self = self else { return } if let result { self.offlineMapGenerationDidSucceed(with: result) } else if let error { self.offlineMapGenerationDidFail(with: error) } }) 200:\nlet job = offlineMapTask.makeGenerateOfflineMapJob( parameters: parameters, downloadDirectory: downloadDirectoryURL ) job.start() Task { for await status in job.$status { print(status) } } do { let output = try await job.output } catch { self.error = error } イベントは、コールバック ハンドラ、デリゲート、または通知センターではなく、非同期シーケンスを通じて提供されます。\n100.x:\nlocationDisplay.dataSourceStatusChangedHandler = { [weak self] isStarted in // 開始したかどうかを確認 } 200:\nfor await isStarted in locationDisplay.statusChanged { // 開始したかどうかを確認 } 具体的には、AGSRouteTrackerDelegate によって提供されるルート トラッカーなどのデリゲート メソッドの場合、新しい一致パターンは非同期ストリームを使用します。\n100.x:\nextension NavigateRouteViewController: AGSRouteTrackerDelegate { func routeTracker(_ routeTracker: AGSRouteTracker, didUpdate trackingStatus: AGSTrackingStatus) { routeRemainingGraphic.geometry = trackingStatus.routeProgress.remainingGeometry routeTraversedGraphic.geometry = trackingStatus.routeProgress.traversedGeometry } } 200:\nfor try await newStatus in routeTracker.$trackingStatus { routeRemainingGraphic.geometry = newStatus?.routeProgress.remainingGeometry routeTraversedGraphic.geometry = newStatus?.routeProgress.traversedGeometry } SwiftUI 関連の変更 マップ ビューを作成する SwiftUI は宣言型 UI フレームワークです。これは、View を作成するときに、特定の状態で何を表示するかについての説明も作成することを意味します。これは、フレームが定義されたビューを作成する UIKit の UIView からの変更です。SwiftUI では、ビューは親ビューの body に含まれています。ただし、UIKit ビューは、プログラムまたは Storyboard を使用してビュー コントローラーのルート ビューに追加されていました。次のコードは、v200.0 と比較して、v100.15 でマップ ビューを作成する方法を示しています。\n100.x:\n@IBOutlet private var mapView: AGSMapView! { didSet { mapView.map = AGSMap(basemapStyle: .arcGISOceans) mapView.setViewpoint(AGSViewpoint(latitude: -117, longitude: 34, scale: 1e5)) } } 200:\n// Geo ビューに必要なさまざまなモデル オブジェクトを格納するモデル private class Model: ObservableObject { let map = Map(basemapStyle: .arcGISOceans) } // ビューの状態が変化したときに再作成されないように、StateObject として保持される @StateObject private var model = Model() // マップ ビューの現在の視点 @State private var viewpoint = Viewpoint( center: Point(x: -117, y: 34, spatialReference: .wgs84), scale: 1e5 ) var body: some View { MapView( map: model.map, viewpoint: viewpoint ) } 修飾子を表示 ビュー修飾子をビューに適用して、ビューの外観と動作をカスタマイズします。 新しい MapView と SceneView には、対応する UIKit と同じ機能を実現するためのさまざまなビュー修飾子があります。\n  Viewpoint: ビューポイント状態変数をマップビューの現在のビューポイントで更新します。\n.onViewpointChanged(kind: .centerAndScale) { viewpoint = $0 }   DrawStatus: マップ ビューの描画ステータスが変化したときにアクションを実行します。\n.onDrawStatusChanged { if $0 == .completed { print(\u0026#34;Map view draw completed.\u0026#34;) } }   LocationDisplay: マップビューの位置情報表示をオンにして設定します。\n.locationDisplay(model.locationDisplay)   Callout: マップ ビューでタップされたポイントの座標を含むコールアウトを表示します。\nAGSGeoViewTouchDelegate のジェスチャ デリゲート メソッドは、さまざまなビュー修飾子に置き換えられました。\n.onSingleTapGesture { screenPoint, mapPoint in if calloutPlacement == nil { // タップした位置にコールアウトを WGS84 で表示する calloutPlacement = LocationCalloutPlacement(location: mapPoint) } else { // コールアウトを非表示にする calloutPlacement = nil } } .callout(placement: $calloutPlacement.animation(.default.speed(4))) { callout in Text( CoordinateFormatter.toLatitudeLongitude( point: callout.location, format: .decimalDegrees, decimalPlaces: 2 ) ) .font(.callout) }   ジオエレメントを識別する UIKit と SwiftUI の違いにより、Identify(識別)の操作をマップ ビューで直接実行することはできません。 v200.0 では、SwiftUI の reader-proxy デザイン パターンに従い、MapViewProxy を導入して、Identify などの操作を実行できるようにします。\n次のコードは、v100.15 での AGSGeoView.identifyLayers を使用した Identify と、v200.0 での MapViewProxy.identify を使用した Identify の違いを示しています。\n100.x:\n// Completion ブロック mapView.identifyLayer( featureLayer, screenPoint: screenPoint, tolerance: 12, returnPopupsOnly: false, maximumResults: 10 ) { (results: [AGSIdentifyLayerResult]?, error: Error?) in if let error { self.presentAlert(error: error) } else if let results { self.handleIdentifyResults(results) } } 200:\nMapViewReader { mapViewProxy in MapView(map: map) .onSingleTapGesture { screenPoint, tapLocation in identifyScreenPoint = screenPoint identifyTapLocation = tapLocation } .task(id: identifyScreenPoint) { guard let screenPoint = identifyScreenPoint else { return } // Async/Await do { let results = try await mapViewProxy.identify( on: featureLayer, screenPoint: screenPoint, tolerance: 12, maximumResults: 10 ) } catch { self.error = error } // 以下で識別結果を処理 } } @State および @StateObject SwiftUI でのビューの更新は、状態の変化によって駆動されます。 次のコードは、マップ ビューの最新の表示領域の取得方法を、v200.0 と v100.15 で比較しています。\n100.x:\n@IBOutlet private var mapView: AGSMapView! { didSet { mapView.map = AGSMap(basemapStyle: .arcGISOceans) } } // 表示領域の取得 private var visibleArea: AGSPolygon? { mapView.visibleArea } 200:\nprivate class Model: ObservableObject { let map = Map(basemapStyle: .arcGISOceans) } @StateObject private var model = Model() /// 現在のマップ ビューの表示領域 /// 概観図で使用できる @State private var visibleArea: Polygon? var body: some View { MapView(map: model.map) .onVisibleAreaChanged { visibleArea = $0 } } 認証 アプリで認証コードを移行する手順については、Migrate authentication from 100.x to 200.x トピックを参照してください。\nスケッチ マップ ビューでジオメトリをインタラクティブに描画するには、AGSSketchEditor の代わりに GeometryEditor を使用します。\nその他のリソース その他の例については、新しいサンプルまたはツールキットを確認できます。\n既知の制限事項 現バージョンでの既知の制限事項が、ArcGIS Maps SDK for Swift: リリース ノート に記載されていますので、ご参照ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/migrating-from-3.x-to-4.0/",
	"title": "バージョン 3.x から 4.x への移行",
	"tags": [],
	"description": "バージョン 3.x の API で作成した既存のアプリケーションを 4.x に移行するために必要な情報を紹介します。",
	"content": "出典：ArcGIS Maps SDK for JavaScript - Migrating from 3.x to 4.28\nバージョン 4.x では ArcGIS Maps SDK for JavaScript の構成要素が大きく見直され、機能拡張が行われています。バージョン 3.x で開発したアプリケーションをアップデートすることも可能ですが、アプリケーションを書き換えることを検討してください。\n本トピックでは 3.x の API で作成した既存のアプリケーションを 4.x に移行するために必要な情報を解説します。API で更新された仕様はいくつかありますが、その中でも重要な項目について紹介します。\n プロパティのハンドリング View の利用 Map と Layer の仕様 モジュールとパッケージの更新 Web マップのサポート ローカライズ モジュール 廃止項目  バージョン 4.0 では、大幅な変更が行われました。これらの変更は、開発者がどのようなアプリケーションを作成する場合でも、より効率的かつ効果的に作業できるようにするために行われました。この変更は、コンストラクタ、プロパティ、イベントの処理方法に見られます。\nプロパティ 4.0 より前のバージョンでは、getMethodName や setMethodName を呼び出すことで、一部のプロパティを get (読み込み）または set（書き込み）することができました。API では、すべてのプロパティを取得・設定するためのシンプルで一貫した方法がサポートされているため、これらのタイプのメソッドは不要になりました。\n 例えば map.basemap = \u0026quot;oceans\u0026quot; のようにオブジェクトに直接プロパティを設定します。 例えば map.basemap.title. のようにオブジェクトから直接プロパティを取得します。  例えば、3.x ではフィーチャーレイヤーの definitionExpression 設定は、以下のようになります。\nmyFeatureLayer.setDefinitionExpression(expression); 次の行は、4.0 でフィーチャーレイヤーの definitionExpression 設定する方法を示しています。\nmyFeatureLayer.definitionExpression = expression; 4.0 では、以下のように .get() を使用して深い階層のプロパティにアクセスすることができます。\nvar basemapTitle = map.get(\u0026#34;basemap.title\u0026#34;); プロパティの変更の監視 4.0 より前のバージョンでは、プロパティの変更はイベントでハンドリングされていました。4.0 では、プロパティの変更を監視することが非常に簡単になりました。これは、.watch(property, callback) メソッドで処理されます。このコールバックは、プロパティが変更されるたびに呼び出され、プロパティの新しい値、古い値、名前を監視対象のオブジェクトと一緒に操作することができます。\n// ベースマップ \u0026#39;streets-vector\u0026#39; を定義し、新しい map オブジェクトを作成 var map = new Map({ basemap: \u0026#39;streets-vector\u0026#39; }); // map オブジェクトで定義したベースマップのタイトルが変更されるとコールバックが発生します。 var handle = map.watch(\u0026#39;basemap.title\u0026#39;, function(newValue, oldValue, property, object) { console.log(\u0026#34;新しい値: \u0026#34;, newValue, // プロパティの新しい値  \u0026#34;\u0026lt;br\u0026gt;古い値: \u0026#34;, oldValue, // プロパティの前の値（変更される前の値）  \u0026#34;\u0026lt;br\u0026gt;監視しているプロパティ: \u0026#34;, property, // この例では、この値は常に \u0026#34;basemap.title\u0026#34; になります。  \u0026#34;\u0026lt;br\u0026gt;監視しているオブジェクト: \u0026#34;, object); // この例では、この値は常に map オブジェクトになります。 }); View の利用 4.0 では、Map を 2D または 3D で表示できるようになりました。それに併い、マップの描画ロジックが変更されました。描画ロジックは、マップとレイヤーではなく、View によって制御されるようになりました。\nView は 4.0 で導入されたコンセプトです。View は 2 つのタイプがあります。\n 2D で表示する場合: MapView 3D で表示する場合: SceneView  View は、Map や Scene 内のデータを可視化するために使用されます。Map には実際に表示するデータやレイヤーが含まれていますが、View はそのデータの表示を行います。データの可視化（表示）方法は、2D か 3D かによって異なります。View は、view.map のように、Map への参照を持っています。しかし、Map は View への参照を持っていません。注意すべき点は、1 つの Map が複数の View によって消費されることがあるということです。\nこれを別の言い方をすると、Map は世界のベースマップや機能を表し、View はその地図を見るための窓ということになります。\n以下の構文は、2D View (MapView) と 3D View (SceneView) の両方を作成し、操作する方法を示しています。\n次のスニペットは、MapView を使った 2D マッピングを示しています。\nfunction (Map, MapView){ map = new Map({ basemap: \u0026#34;topo-vector\u0026#34; }); view = new MapView({ container: \u0026#34;viewDiv\u0026#34;, map: map, scale: 2400000 }); } このスニペットは、SceneView を使った 3D マッピングです。\nfunction (Map, SceneView){ map = new Map({ basemap: \u0026#34;topo-vector\u0026#34; }); view = new SceneView({ container: \u0026#34;viewDiv\u0026#34;, map: map, scale: 2400000 }); } Map と Layer の仕様 Map と Layer にはいくつかの重要なアップデートが行われましたが、その一部を以下にご紹介します。\n 4.0 からは、basemap と地図上の operational layers を分離しました。 2D または 3D の View を回転させることができるようになりました。 グラフィック レイヤーは、マップのレイヤー コレクションの中のどこにでも追加することができます。4.0 以前では、グラフィック レイヤーは他の形式のレイヤーよりも上に追加する必要がありました。 GroupLayer クラスが追加されました。  モジュールとパッケージの更新 詳細は3.x/4.x 機能比較表（英語）を確認してください。以下に挙げた項目は、その中でも重要な更新です。\n パッケージ名の変更（例: esri/dijit が esri/widgets に変更） モジュール名の短縮（例: ArcGISTiledMapServiceLayer が TileLayer に変更） モジュール名の大文字・小文字を統一し、「Map」「Graphic」「Query」など、すべてのモジュールが大文字で始まるようになりました。 サポート クラスは、API リファレンスをより組織化するために support フォルダに 移動しました(例: esri/layers/support, esri/tasks/support)。 esri/config の構成が変更され、 esriConfig.defaults のプロパティは esriConfig に移動しました。以下は、デフォルトで使用されるジオメトリ サービスの設定方法の例です。  // 3.x esriConfig.defaults.geometryService = new GeometryService(\u0026#34;\u0026lt;ジオメトリ サービスのURL\u0026gt;\u0026#34;); // 4.x esriConfig.geometryService = new GeometryService(\u0026#34;\u0026lt;ジオメトリ サービスのURL\u0026gt;\u0026#34;);  defaults.io オブジェクトは esriConfig.request に移動しました。  // 3.x esriConfig.defaults.io.timeout = 30000; // 4.x esriConfig.request.timeout = 30000;  3 つの *-all レガシー モジュールが削除されました。これは、ビルドや Website Optimizer を使用してより適切に処理されます。 各コンストラクタは JSON をサポートしなくなったため、代わりに、fromJSON() メソッド（例: Graphic.fromJSON() ）を使用してください。(注: ベータ3では、まだ 3.x のスタイルを使用したコンストラクタがいくつか含まれています。) FeatureLayer はグラフィックを保持しません。代わりに LayerView が FeatureLayer のフィーチャを表すグラフィックを描画します。  Web マップのサポート バージョン 2.x の Web マップ を読み込むことができます。WebMap の操作は部分的にサポートされています。これは、API ですでに利用可能な機能に依存していることを意味します。例えば、まだ実装されていないレイヤータイプが含まれている場合でも WebMap を読み取ることができます。このような場合、API でサポートされているレイヤータイプのみが表示されます。WebMap の保存は、バージョン 4.14 からサポートされています。\nローカライズ 4.x では、ロケールを \u0026ldquo;ar \u0026ldquo;や \u0026ldquo;he \u0026ldquo;に設定しても、right-to-left (RTL) は行われなくなりました。\n どのロケールでも RTL をオプトインできるようになりました。RTL サポートを参照してください。 \u0026lt;html\u0026gt; または \u0026lt;body\u0026gt; タグで方向を指定します。RTL サポートを参照してください。  モジュール 4.x の API は、AMD モジュールと ES モジュールとして提供されます。4.0 以前は、AMD と dojo.require のレガシー モジュールの両方を使用することができました。4.0 以降は、AMD モデルのみのサポートとなり、4.18でESモジュールが導入されました。4.xの異なるモジュールタイプの概要については、Introduction to tooling を参照してください。\n廃止項目 Geocoder ウィジェットはバージョン 3.13 で非推奨となり、4.x では提供されません。代わりに Search ウィジェットを使用してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/services/create-routing/",
	"title": "ルートの検索",
	"tags": [],
	"description": "マッピングAPI＆ロケーションサービス内のルーティング＆ディレクションズについて紹介します",
	"content": "ルーティングとは？ ルーティングとはシンプル ルーティングとも呼ばれ、人や車両を出発地点地から目的地点地までの最適経路を導き出す手段の一つです。ルーティングは、制限速度や車線の数、時間帯といった道路網における様々なデータ パラメータを考慮しています。その他にも道路状況や事故、障害物といったリアルタイム データを考慮したルーティングも可能となります。\nルーティングを利用して以下のアプリケーションを構築することができます。\n・出発地点から目的地点までの最短経路を検索\n・複数の目的地点への最短経路を検索\n・多言語での経路案内を実現\nルーティングの仕組み 経路作成における典型的なワークフロー\n１　出発地点と経由地点および目的地点を明確にする\n２　経路における移動手段を明確にする\n３　サービスから経路や道案内を呼び出す際に、経路の特徴や道順を確認することが可能\nルーティング サービスを用い、シンプルな経路ものや最適化された経路を作成することができます。\n・シンプルな経路とは地点間の最短経路のことをいいます。\n・最適化された経路とは、地点間の最も効率的な経路のことをいいます。\n最適化された経路を作成するためには、findBestSequenceパラメータを使用する必要があります。このパラメータを使用すると、地点間の最も効率的な経路を返すように順序が変更されます。\nヒント： ArcGIS Developer 開発者アカウントをお持ちの場合、シンプルな経路の作成は位置情報サービスへのアクセスの無料枠に含まれています。最適化された経路の作成を利用するには、従量課金となります。\n経路のナビゲーションの方法 経路が決定したら、現在の端末位置情報を使用して進行状況を把握することや、経路を縦断する際にナビゲーション指示(音声案内)を呼び出したい場合、ArcGIS Maps SDKs for Native Appsで実行するのが効果的です。\n注：経路案内についてより詳しく知りたい方は、以下に記載のガイド「Navigate a route」をご参照ください。\n・ArcGIS Maps SDK for Kotlin\n・ArcGIS Maps SDK for Swift\n・ArcGIS Maps SDK for .NET\n・ArcGIS Maps SDK for Qt\nURLリクエスト ルーティング サービスにhttps リクエストを行うか、クライアント APIを使用することで経路と道順を検索できます。出発地点、目的地点、そしてオプションで追加のパラメータを指定すると経路検索結果を絞り込むことができます。ここで最も一般的なパラメータの一部を以下に説明します。\nリクエスト制限    リミット ダイレクト ジョブ     最大ストップ数 150 10,000   最大トランザクション時間 5分 60分   最大バリア地点 250 250   ポリライン バリアと交差する道路ストリート フィーチャーの最大数 500 500   ポリゴン バリアと交差するストリートフィーチャーの最大数 2,000 2,000   徒歩移動モードにおける最長距離（いずれかのストップ間の直線距離がこの制限を超える場合に歩行制限を使用すると解析が失敗します） 27マイル (43.45km)\n 27マイル (43.45km)\n   直線距離が以下の距離を超えると階層化を強制します(いずれかの停止位置間の直線距離がここに示す限界値より大きい場合、\ntravel_modeで階層化を使用しないと、定義されていても解析では階層化を使用します)\n 50マイル\n(80.46km)\n 50マイル (80.46km)\n   最大スナップ許容範囲：(入力地点と最寄りのトラバース可能な道路との距離がここで指定した距離より大きい場合、その地点は解析から除外されます) 12.42マイル (20km)\n 12.42マイル\n(20km)\n   返すことができる方向性のフィーチャ特徴の最大数(travel_modeで階層を使用しないと、定義されていても各地点間の直線距離がここに示した制限値を超える場合、解析では階層を使用します) 制限なし 1,000,000\n\n   返すことができる路肩の最大数 利用不可\n\n 1,000,000    必要なパラメータ    パラメータ名 説明 一例     f 返されるデータ形式 f=json f=pjson f=geojson f=html   token APIキーまたはOauth 2.0のアクセストークン アクセストークンの取得方法については、セキュリティと認証をご覧ください。 token=\u0026lt;YOUR_API_KEY\u0026gt;\ntoken=\u0026lt;ACCESS_TOKEN\u0026gt;\n   Stops 経路上で訪問する必要のある2か所以上の場所 Stops=139.767176,35.681260;139.796337. 35.710982   findBestSequence 複数の目的地点を訪れる際に、サービスが最適な順序を発見するサービスを行うかどうかを指定します。注意：最適化された経路を生成する場合は、このパラメータをtrueに設定します。 findBest Sequence=true    ダイレクト 5分以内で経由地点が150未満の短い処理のものに使用します\nエンドポイント https://route-api.arcgis.com/arcgis/rest/services/World/Route/NAServer/Route_World/solve?\u0026lt;parameters\u0026gt;\rhttps://route.arcgis.com/arcgis/rest/services/World/Route/NAServer/Route_World/solve?\u0026lt;parameters\u0026gt;\r注：上記のエンドポイントは、いずれも機能は基本的に同じものです。エンハンスド エンドポイントの詳細については、サービス エンドポイントをご覧ください。\nキー パラメータ    パラメータ名 説明 一例     travelMode 車やトラックの運転、徒歩などの移動手段 travelMode=JSONObject   startTime 入力した地点から移動を開始する時刻です。Nnowを指定すると出発時刻を現在時刻に設定することもできます。 startTime=now   returnDirections　 各経路ルートのドライブガイドを生成する returnDirections=true   directionsLanguage 経路案内目的地の生成時に使用する言語 directionsLanguage=ja    追加パラメータ polygon_Barriersは一時的な減速など経路を追加設定する場合、\nroute_shyapeはサービスで作成するルート フィーチャの種類を指定する場合、\nreturn_to_startは経路の開始位置と終了位置が同じ場合に設定します。\nヒント：リクエストやパラメータ、有効な入力値の詳細については、Routing service REST APIドキュメントを参照してください。\nジョブ 60分以内で経由地点が最大10000までの長時間の処理のものに利用します。\nエンドポイント https://logistics.arcgis.com/arcgis/rest/services/World/Route/GPServer/FindRoutes/submitJob?\u0026lt;parameters\u0026gt;\rヒント：エンドポイントについての詳細は、サービス エンドポイントをご覧ください。\n必要パラメータ    パラメータ名 説明 一例     f 返されるデータ形式 f=json f=pjson f=geojson f=html   token APIキーまたはOAuth 2.0のアクセス トークン アクセストークンの取得方法については、セキュリティと認証をご覧ください。 Token=\u0026lt;YOUR_API_KEY\u0026gt;   stops 経路上で2か所以上の経由する地点 Stops=,139.767176,35.681260; 139.796337,35.710982   reorder_stops_to_\nfind_optimal_routes\n 複数の目的地点地を訪問する際に、最適な順序を見つけるかどうかを指定します。 Reoder_stops_to_find_\noptimal_routes=true\n    キー パラメータ    パラメータ名 説明 一例     travel_mode 車やトラックの運転、徒歩などの移動手段 travel_mode=JSON Object   time_of_day 入力した終点から移動を開始する時間 time_of_day=1608022800000   populate_directions 各経路のドライブガイドを生成 populate_directions=true   directions_language 経路案内目的地の生成時に用いる言語 directions_language=ja    追加パラメータ polygon_barriersは一時減速を設定する場合、\nroute_shapeはサービスで作成するルート フィーチャーの種類を指定する場合、return_to_startは経路の開始位置と終了位置が同じ場合に設定します。\nヒント：リクエストやパラメータ、有効な入力値の詳細については、ルーティング サービスREST APIドキュメントを参照してください。\nサンプル コード ダイレクト:経路や道順の検索 この例ではルーティング サービスを使用して、現在の交通状況を考慮した停留所間の経路ルートを検索し、日本語のドライブガイドを生成します。\n経路を見つけるには、訪れる地点を少なくとも２つ定義する必要があります。デフォルトの travelMode では自動車の走行時間ですが、徒歩やトラック輸送の走行モードでも使用可能です。最適な結果を得るためには常に startTime を指定するのがよいでしょう。この例では、startingTimeをnowと指定し、経路ルートの出発時刻を現在の時刻に設定するとともに、経路が現在の交通状況を使用することをサービスに表設定しています。また、directorsLanguage を設定して選択した言語で道案内を生成しています。\n応答には目的地点地やルート セグメント、ターンバイターンのテキスト道案内が含まれています。\nヒント：アクセストークンを取得するには、トークンの生成、APIキーの生成と管理、OAuth2.0の実装のいずれかを行ってください。\nAPIs ArcGIS Maps SDK for JavaScript \rクリックでコードを表示\r\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34;\u0026gt; \u0026lt;title\u0026gt;ArcGIS JavaScript Tutorials: Find a route and directions (Auth)\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.26/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.26\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; require([ \u0026#34;esri/Map\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;, \u0026#34;esri/Graphic\u0026#34;, \u0026#34;esri/geometry/Point\u0026#34;, \u0026#34;esri/rest/route\u0026#34;, \u0026#34;esri/rest/support/RouteParameters\u0026#34;, \u0026#34;esri/rest/support/FeatureSet\u0026#34;, \u0026#34;esri/config\u0026#34;, \u0026#34;esri/widgets/Expand\u0026#34; ],(Map, MapView, Graphic, Point, route, RouteParameters, FeatureSet, esriConfig,Expand)=\u0026gt; { const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; esriConfig.apiKey = apiKey; const map = new Map({ basemap: \u0026#39;osm-standard\u0026#39; }); const center = new Point ([139.78679,35.71374]); const origin = new Point([139.77770,35.71159]); const stop = new Point([139.79016,35.711]); const destination = new Point([139.79637,35.71108]); const view = new MapView({ container: \u0026#34;viewDiv\u0026#34;, map: map, center: center, zoom: 12, constraints: { snapToZoom: false } }); view.when(()=\u0026gt;{ addGraphic(\u0026#34;start\u0026#34;, origin); addGraphic(\u0026#34;stop\u0026#34;, stop); addGraphic(\u0026#34;finish\u0026#34;, destination); getRoute(); }); view.on(\u0026#34;click\u0026#34;, (event)=\u0026gt;{ if (view.graphics.length === 0) { addGraphic(\u0026#34;start\u0026#34;, event.mapPoint); } else if (view.graphics.length === 1) { addGraphic(\u0026#34;stop\u0026#34;, event.mapPoint); } else if (view.graphics.length === 2) { addGraphic(\u0026#34;finish\u0026#34;, event.mapPoint); getRoute(); } else { view.graphics.removeAll(); view.ui.empty(\u0026#34;top-right\u0026#34;); addGraphic(\u0026#34;start\u0026#34;,event.mapPoint); } }); function addGraphic(type, point) { let color = \u0026#34;#ffffff\u0026#34;; let outlineColor = \u0026#34;#000000\u0026#34; let size = \u0026#34;12px\u0026#34;; if (type == \u0026#34;start\u0026#34;) { color = \u0026#34;#ffffff\u0026#34;; } else if (type == \u0026#34;stop\u0026#34;) { color = \u0026#34;#000000\u0026#34;; outlineColor = \u0026#34;#ffffff\u0026#34;; size = \u0026#34;8px\u0026#34;; } else { color = \u0026#34;#000000\u0026#34;; outlineColor = \u0026#34;#ffffff\u0026#34;; } const graphic = new Graphic({ symbol: { type: \u0026#34;simple-marker\u0026#34;, color: color, size: size, outline: { color: outlineColor, width: \u0026#34;1px\u0026#34; } }, geometry: point }); view.graphics.add(graphic); } function getRoute() { const routeUrl = \u0026#34;https://route-api.arcgis.com/arcgis/rest/services/World/Route/NAServer/Route_World\u0026#34;; const routeParams = new RouteParameters({ stops: new FeatureSet({ features: view.graphics.toArray() }), returnDirections: true, directionsLanguage: \u0026#34;ja\u0026#34; }); route.solve(routeUrl, routeParams) .then((data)=\u0026gt; { if (data.routeResults.length \u0026gt; 0) { showRoute(data.routeResults[0].route); showDirections(data.routeResults[0].directions.features); } }) .catch((error)=\u0026gt;{ console.log(error); }) } function showRoute(routeResult) { routeResult.symbol = { type: \u0026#34;simple-line\u0026#34;, color: [5, 150, 255], width: 3 }; view.graphics.add(routeResult,0); } function showDirections(directions) { function showRouteDirections(directions) { const directionsList = document.createElement(\u0026#34;ol\u0026#34;); directions.forEach(function(result,i){ const direction = document.createElement(\u0026#34;li\u0026#34;); direction.innerHTML = result.attributes.text + ((result.attributes.length \u0026gt; 0) ? \u0026#34; (\u0026#34; + result.attributes.length.toFixed(2) + \u0026#34; miles)\u0026#34; : \u0026#34;\u0026#34;); directionsList.appendChild(direction); }); directionsElement.appendChild(directionsList); } const directionsElement = document.createElement(\u0026#34;div\u0026#34;); directionsElement.innerHTML = \u0026#34;\u0026lt;h3\u0026gt;Directions\u0026lt;/h3\u0026gt;\u0026#34;; directionsElement.classList = \u0026#34;esri-widget esri-widget--panel esri-directions__scroller directions\u0026#34;; directionsElement.style.marginTop = \u0026#34;0\u0026#34;; directionsElement.style.padding = \u0026#34;0 15px\u0026#34;; directionsElement.style.minHeight = \u0026#34;365px\u0026#34;; showRouteDirections(directions); view.ui.empty(\u0026#34;top-right\u0026#34;); view.ui.add(new Expand({ view:view, content:directionsElement, expanded:true, mode:\u0026#34;floating\u0026#34;}), \u0026#34;top-right\u0026#34;); } }); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \rREST API curl https://route-api.arcgis.com/arcgis/rest/services/World/Route/NAServer/Route\\_World/solve? \\-d \u0026#34;f=json\u0026#34;-d \u0026#34;token=\u0026lt;ACCESS\\_TOKEN\u0026gt;\u0026#34;-d \u0026#34;stops=-139.77770,35.71159; 139.79016,35.711; 139.79637,35.71108\u0026#34;-d \u0026#34;startTime=now\u0026#34;-d \u0026#34;returnDirections=tr-d \u0026#34;directionsLanguage=ja"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/services/",
	"title": "ロケーションサービスの利用",
	"tags": [],
	"description": "ArcGIS Platform をはじめて使う方向けにロケーションサービスの紹介やフィーチャ サービス、Web マップを作成する方法について紹介します。",
	"content": "ArcGIS Platform をはじめて使う方向けにロケーションサービスの紹介やフィーチャ サービス、Web マップを作成する方法について紹介します。\nロケーションサービス ArcGIS Platform で提供されているロケーションサービスは、背景地図サービス（ベースマップレイヤー）、ジオコーディングサービス、ルーティングサービス、空間分析サービス、人口統計などのサービスがあります。ロケーションサービスを利用したアプリケーションは、Web アプリやネイティブアプリなどのクライアント APIs を使用して開発することができます。また、ロケーションサービスへ直接アクセスするには REST API を使用できます。そのため、地図アプリケーションの開発や自社のソリューション、サービス、製品などにこれらのサービスを組み込んで利用することもできます。\nチュートリアル ArcGIS Platform のチュートリアルでは、ロケーションサービスを利用したアプリケーションの構築方法を学ぶことができます。\nチュートリアルは、以下の ArcGIS、オープンソース、およびサードパーティの API を利用できます。\n Web: ArcGIS Maps SDK for JavaScript、ArcGIS REST JS、Esri Leaflet、MapBox GL JS、OpenLayers. ネイティブ: ArcGIS Runtime APIs for Android、iOS、Java、.NET、Qt.  フィーチャ サービス、Web マップの作成   フィーチャ サービスの作成\nデータの検索や編集が可能な地図サービス (REST API) の配信方法を紹介します。\n  Web マップの作成\nさまざまなフォーマットのデータを 1 つのマップとして集約し、それを可視化する方法を紹介します。\n  ルートの検索\nマッピングAPI＆ロケーションサービス内のルーティング＆ディレクションズについて紹介します。\n  ベースマップ\nマッピングAPI＆ロケーションサービス内のベースマップについて紹介します。\n  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/visualization/6ways-to-improve-your-maps/",
	"title": "地図上に賢くデータを可視化するための 6 つの方法",
	"tags": [],
	"description": "マップ ビューアーを使って地図データを賢く可視化するために おさえておくべき６つの方法を紹介します。",
	"content": "ArcGIS のデータ ビジュアライゼーション ツール（マップ ビューアー）を使って地図データを賢く可視化するために おさえておくべき６つの方法を紹介します。\n 色について考える パターンを発見する アウトラインを調整する 透過率を調整してパターンをハイライトする ２つの属性データをサイズと色で表現する もっとも大きい値を発見する  色について考える 主題となるデータに色を加える場合に考えるべき事項は以下の 3 つです。\n 背景地図 ストーリー カラーランプ  地図を使ったデータ可視化ではほとんどの場合、__背景地図__の上に主題となるデータが重なります。 そのため、色は背景地図の配色に応じて見やすい適切な色を選択するべきです。 ただし、データ可視化においてはむしろ背景地図を使わないという選択肢も１つのテクニックになり得ます。\nデータ可視化には必ず伝えたい__ストーリー__があります。 そのストーリーを説明するような説得力のある色を選びましょう。\n最後に__カラーランプ__ですが、数値データに対してその値の範囲をカラーランプ（色の変化）で表現します。 上記のストーリーとデータのもつ意味を照らし合わせて、どの色からどの色へ変化すべきなのか考えてみましょう。\nパターンを発見する データ可視化の主題となるデータからパターンを導き出すことは重要です。 パターンを浮かび上がらせるためにはいくつかの方法があります。 たとえば、数値データに対しての表現として以下がまず前提となる２つの項目です。\n 色を使うか？サイズを使うか？ クラスで分類するか？しないか？  たとえば、公園の面積で大中小のような３段階の規模でカテゴライズして可視化したい場合、 色よりもサイズで規模を表現したほうが意図を伝えやすいと思います。 そして、面積に比例してシンボルが変化するより、３段階でクラス分類すべきでしょう。\nArcGIS のビジュアライゼーション ツールにはヒストグラムを掛け合わせたスライダーを操作することによって、 動的に見栄えを確認しながら変化させることができます。 ストーリーとの関連から、基点となる数字に意味を持たせるのもよいと思いますが、 このスライダーを使ってあくまで地図上で可視化されたグラフィックの集合から、 あるパターンを浮かび上がらせるには便利なツールです。\n変化前（左）と変化後（右）\nアウトラインを調整する ポイントとポリゴンのシンボルはアウトライン（枠線）があります。 アウトラインはデータをそれぞれ視認するのには役立ちますが、 適切に調整をしないで使用すると視覚的には邪魔な要素となり、 地図上の主題データが伝えるストーリーを理解するための焦点を逸らしてしまいかねません。\n色と透過率を用いて、強調しないようなアウトラインの表現に調整してみてください。 場合によっては、完全にアウトラインをなくしてしまうことも選択肢として考えられます。\n調整前（左）と調整後（右）\n透過率を調整してパターンをハイライトする パターンを発見/可視化するためのシンボル表現として色あるいはサイズを選択することを伝えましたが、 もう１つ値の変化を表現する方法として透過率を利用する方法があります。 パターンや基点となるような重要な値をハイライトする際に採用することをお薦めします。\n透過率もスライダーで動的にレンジを調整することが可能です。\n２つの属性データをサイズと色で表現する 従来、地図上で属性データを可視化する場合は単一の属性値に基づいて色やサイズで表現することが基本でした。 マップ ビューアーのビジュアライゼーション機能では、 ２つのデータを色とサイズでそれぞれ表現することで１つのシンボルに対して２つの意味を含めることが可能です。\nたとえば、エリアごとの家賃相場を色、居住者の平均年収をサイズで表現することで、 家賃相場と居住者の収入の関連を単一の主題図で可視化することができます。\nもっとも大きい値を発見する ビジュアライゼーション機能のなかでもっともユニークなものとして、 複数の属性値を比較してもっとも大きい値を占める属性を可視化する機能があります。\nたとえば、選挙マップを作って各選挙区でどの政党がもっとも優勢かを表したいときに有効な表現です。 選挙区の属性値として政党ごとの得票数が A 党 100、B 党 150、C 党 50 といったように格納されている場合に、 A 党は赤、B 党は青、C 党は黄と色を割り振って、 値の割合に応じて色をブレンドして１つの色で表現します。\nB 党がもっとも優勢なので、色味としては青が強い色になり、 各政党が拮抗している場合には色彩の弱い色になります。\n以上、６つの方法を紹介してきましたが、 まずはそれぞれの機能を実際に使ってみて表現を確かめてコツをつかんでみてください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/",
	"title": "技術 Tips 集",
	"tags": [],
	"description": "開発に役立つ技術 Tips 集です。",
	"content": "　開発ドキュメント 各 API/SDK の開発をサポートするドキュメントです。\n ArcGIS Maps SDK for JavaScript ArcGIS Experience Builder (Developer Edition) ArcGIS Web AppBuilder (Developer Edition) ArcGIS Maps SDK for .NET ArcGIS Maps SDK for Kotlin ArcGIS Maps SDK for Swift ArcGIS API for Python ArcGIS Pro SDK ArcGIS AppStudio ArcGIS Maps SDK for Unity ArcGIS Maps SDK for Unreal Engine  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/android/",
	"title": "ArcGIS Maps SDK for Kotlin",
	"tags": [],
	"description": "ArcGIS Maps SDK for Kotlin の開発に役立つガイド集です。",
	"content": "ArcGIS Maps SDK for Kotlin (バージョン 200.x) の開発に役立つガイド集です。\n インストール ガイド\nArcGIS Maos SDK for Kotlin のインストールとセットアップ手順を紹介します。\n\r アプリケーション配布ガイド\nArcGIS Maps SDK for Kotlin を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を紹介します。\n\r バージョン 100.x から 200.x への移行\n今まで ArcGIS Runtime SDK for Android バージョン 100.x を使用してアプリケーションを開発されていた開発者向けのガイドです。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/python-api-jnsetup/",
	"title": "Jupyter Notebook を使ってみよう",
	"tags": [],
	"description": "ArcGIS API for Python の実行に便利な JupyterLab の初期設定方法と使用方法を簡単に紹介します。",
	"content": "ここでは、対話的に Python コードを実行し、出力を地図やグラフとして視覚化することができる Jupyter Notebook をご紹介します。Jupyter Notebook はオープンソ－スとして公開されている開発ツールのひとつで、ArcGIS API for Python (以下、Python API)はこのツール上でマップ等を表示することができます。 Jupyter Notebook の詳細については、Jupyter の公式マニュアルおよびクイックスタートガイドを参照してください。 また、サポートされているブラウザについてもご確認ください。Jupyter Notebook がサポートしていないブラウザ（Internet Explorer 等）ではマップ等が表示されないことがあります。\nJupyter Notebook の起動 conda と Python API がインストールされたら、Python コマンドプロンプト (ArcGIS Pro 経由でインストールした場合) または、Anaconda Prompt (Anaconda でインストールした場合) 等のターミナル アプリケーションに次のコマンドを入力して Jupyter Notebook を起動します。\njupyter notebook\rもし起動できなかった場合は次のコマンドをお試しください (参考: Jupyter fails to start)。\njupyter-notebook\r他、Windows OS を実行している場合はコマンド プロンプトまたは PowerShell ウィンドウでも代用できます。以下は、Windows のコマンドプロンプトからコマンドを実行した場合の画面のスクリーンショットです。\nWindows のコマンドプロンプトからコマンドを実行した場合\n\rPython API を root 以外の仮想環境を作成しインストールした場合、Jupyter Notebook を起動する前にその仮想環境をアクティベートする必要があります。root 以外の仮想環境を使用するメリットと仮想環境の作成および管理する方法の詳細については、公式のマニュアルページを参照してください。\nEsri では GitHub 上でサンプルのノートブック (*.ipynb) を公開していますが、こうしたノートブックをダウンロードしてを実行したい場合は、Jupyter Notebook を起動する前に、ノートブックを格納したディレクトリに移動 (cd) する必要があります。 上の例では、ノートブックが C:\\code ディレクトリに配置されています。\nJupyter Notebook 起動のコマンドを実行すると Jupyter Notebook は以下のように端末のデフォルトに設定されている Web ブラウザで開きます。\nJupyert Notebook 起動画面 (Google Chrome)\n\rこのページは、ノートブック ダッシュボードと呼ばれています。\nノートブックを実行する Jupyter Notebookでは、ディレクトリを移動してノートブックをクリックすることでそのノートブックを新しいブラウザのタブまたはウィンドウで開くことができます。各セルを選択し、[セルを実行]ボタン(または shift + Enter)をクリックすることで、各セルを実行できます。以下の画像では、実行までの一通りの手順を示しています。\nノートブックを開いて実行するまで\n\rセルを実行すると、そのセルのコードを実行している間、左わきにアスタリスク (*) が表示されます。実行が完了するとセル実行番号に変わります。\n新しいノートブックの作成 Esri が提供するサンプルのノートブックを実行するだけでなく、プロジェクト用の新しいノートブックを作成することもできます。 これを行うには、ノートブックダッシュボードから、「New」ボタンをクリックし、以下の画像のように Python のカーネルを選択します。\n新しいノートブックを作成する\n\r実行中のノートブックの「ファイル」メニューから新しいノートブックを作成することもできます。 上の画像では、現在実行中のノートブックのアイコンが緑色で表示されています。\rJupyter Notebook ヘルプとキーボードショートカット その他、Jupyter Notebook の各機能や使い方は、任意のノートブックを開いて、[Help \u0026gt; User Interface Tour] から体験することができます。 また、便利なキーボード ショートカットも設定されています。ショートカット キーの一覧は、[Help \u0026gt; Keyboard Shortcuts] で表示できます。\nショートカットキー一覧\n\rショートカットの中でも、[Ctrl + Shift + P] はコマンド パレットを表示できるため、特に便利です。コマンド パレットでは、実行したい機能を入力して実行することができます。Jupyter Notebook の使い方については Five Tips To Get You Started With Jupyter Notebook（英語） のブログ記事も参考にしてください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-openlayers/",
	"title": "OpenLayers",
	"tags": [],
	"description": "OpenLayers を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。",
	"content": "マップを表示する このチュートリアルでは、OpenLayers と ベースマップ レイヤー サービス を使用して、マップを表示する方法を紹介します。\nマップには、地理データのレイヤーが含まれています。マップには、ベースマップ レイヤーと、オプションで1つ以上のデータ レイヤーが含まれます。マップ ビューを使用し、場所とズームレベルを設定することで、マップの特定の領域を表示できます。\nこのチュートリアルでは、地形 ベースマップ レイヤーを使用して、 OpenLayers で富士山周辺の地図を表示します。\n前提条件 このチュートリアルを実施するには、以下が必要です。\n 開発者ダッシュボードにアクセスして API キーを作成するには、ArcGIS アカウントが必要です。アカウントの作成手順については「開発者アカウントの作成」を参照してください。  ステップ 新しい Pen の作成 CodePen にアクセスして、マッピング アプリケーション用の新しい Pen を作成します。\nHTML の作成 HTML ページを定義して、Web ブラウザの幅と高さにあわせたマップを作成します。\n  CodePen ＞ HTML で、HTML と CSS を追加して、map という id 属性をもつ div 要素のあるページを作成します。\nHTML を使って、マップを表示する Web ページを作成します。この時マップは map div 内に表示します。CSS を使って、マップを全幅・全高で表示されるようにします。\nCodePenでは、\u0026lt;!DOCTYPE html\u0026gt;タグは必要ありません。他のエディタを使用している場合や、ローカルサーバでページを実行している場合は、必ずこのタグを HTML ページの先頭に追加してください。\n  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ライブラリの読み込み OpenLayers と ol-mapbox-style の JavaScript と CSS ファイルを参照するために、\u0026lt;script\u0026gt;と\u0026lt;link\u0026gt;タグを追加します。\n \u0026lt;head\u0026gt;要素の中に、OpenLayers の CSS と JavaScript ライブラリへの参照を追加します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ol-mapbox-style ライブラリへの参照を追加します。これは、OpenLayers でベク​​タータイル スタイルを使用してベクタータイル レイヤーをロードおよびスタイル設定するために必要です。\nolms.js は、OpenLayers の開発者によって提供されています。\u0026ldquo;olms\u0026rdquo; は OpenLayers Mapbox Style の略です。詳しくは、ol-mapbox-style のドキュメントをご覧ください。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css\u0026#34;\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@6.1.4/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Map と View の作成 OpenLayers マップを作成するには、Map クラスと View クラスを使用します。\nOpenLayers の Map クラスは、マップのコンテンツを表示し、それを操作するためのユーザーインターフェースを提供します。マップのクリック、ズーム、パン、回転、視点の変更をサポートしています。また、マップデータの可視コンテンツを操作することもでき、例えば、マウスカーソルでフィーチャを見つけることができます。また、新しいソースを追加したり、レイヤーのプロパティを変更したりして、表示されるデータを修正することもできます。OpenLayers は、レイヤーの変更に応じて、必要に応じて自動的に再レンダリングを行います。\n詳細については、OpenLayers のドキュメントを参照してください。\n \u0026lt;body\u0026gt;要素の中に\u0026lt;script\u0026gt;要素を追加します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css\u0026#34;\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@6.1.4/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Map クラスを使用して、表示や動作を制御するオプション付きのマップを作成します。target プロパティには、div 要素の id として \u0026ldquo;map\u0026rdquo; を設定します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css\u0026#34;\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@6.1.4/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 地図を表示するタグの id 属性を指定  const map = new ol.Map({ target: \u0026#34;map\u0026#34; }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; View を作成し、setView を使ってマップに適用します。マップビューを中央に配置するために、center プロパティを [138.729858,35.362752] に、zoom プロパティを12に設定します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css\u0026#34;\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@6.1.4/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 地図を表示するタグの id 属性を指定  const map = new ol.Map({ target: \u0026#34;map\u0026#34; }); // 地図を表示する位置と初期のズームレベルの指定  map.setView( new ol.View({ center: ol.proj.fromLonLat([138.729858, 35.362752]), zoom: 12 }) ); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; APIキーの設定 ロケーションサービスにアクセスするには、API キーまたは OAuth2.0 アクセストークンが必要です。API キーの作成手順については「API キーの取得」を参照してください。\n認証方法とアクセストークンの取得方法の詳細については、「セキュリティと認証」を参照してください。\n  開発者ダッシュボードに移動して、API キーを取得します。\n  次の手順に使うため API キーをコピーします。\n  ベースマップ レイヤーの追加 OpenLayers はベクター ベースマップやベクター スタイル ファイルを直接サポートしていないので、openlayers-mapbox-style (olms) JavaScript ライブラリを使用して、ベースマップ レイヤー サービスから Mapbox スタイルをロードし、OpenLayers でレンダリングします。\nMapbox スタイルは、スタイルで使用されるベクター タイル レイヤーへの参照と、それらのタイル内の1つまたは複数のデータ レイヤーに適用される表示スタイル ルールを含む JSON ファイルです。\n API キーを変数として保存します。ArcGIS サービスを呼び出す際には、必ずこの API キーを含める必要があります。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css\u0026#34;\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@6.1.4/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 地図を表示するタグの id 属性を指定  const map = new ol.Map({ target: \u0026#34;map\u0026#34; }); // 地図を表示する位置と初期のズームレベルの指定  map.setView( new ol.View({ center: ol.proj.fromLonLat([138.729858, 35.362752]), zoom: 12 }) ); // API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; basemapId 変数を作成し、それを arcgis/topographic に設定します。また、ベースマップを日本語で表示するため、language 変数を作成し、ja を設定します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css\u0026#34;\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@6.1.4/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 地図を表示するタグの id 属性を指定  const map = new ol.Map({ target: \u0026#34;map\u0026#34; }); // 地図を表示する位置と初期のズームレベルの指定  map.setView( new ol.View({ center: ol.proj.fromLonLat([138.729858, 35.362752]), zoom: 12 }) ); // API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ベースマップの設定  const basemapId = \u0026#34;arcgis/topographic\u0026#34;; // ベースマップの言語設定  const language = \u0026#34;ja\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; basemapId と API キーに基づいてベースマップの URL を作成します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css\u0026#34;\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@6.1.4/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 地図を表示するタグの id 属性を指定  const map = new ol.Map({ target: \u0026#34;map\u0026#34; }); // 地図を表示する位置と初期のズームレベルの指定  map.setView( new ol.View({ center: ol.proj.fromLonLat([138.729858, 35.362752]), zoom: 12 }) ); // API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ベースマップの設定  const basemapId = \u0026#34;arcgis/topographic\u0026#34;; // ベースマップの言語設定  const language = \u0026#34;ja\u0026#34;; // ベースマップの URL を設定  const basemapURL = \u0026#34;https://basemapstyles-api.arcgis.com/arcgis/rest/services/styles/v2/styles/\u0026#34; + basemapId + \u0026#34;?type=style\u0026amp;token=\u0026#34; + apiKey + \u0026#34;\u0026amp;language=\u0026#34; + language; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; olms を使用して、ベースマップ スタイルをマップに適用します。olms 関数は、マップ要素と Mapbox ベースマップ スタイル ファイルの URL の2 つの入力を受け取ります  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css\u0026#34;\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@6.1.4/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 地図を表示する要素の id 属性を指定  const map = new ol.Map({ target: \u0026#34;map\u0026#34; }); // 地図を表示する位置と初期のズームレベルの指定  map.setView( new ol.View({ center: ol.proj.fromLonLat([138.729858, 35.362752]), zoom: 12 }) ); // API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ベースマップの設定  const basemapId = \u0026#34;arcgis/topographic\u0026#34;; // ベースマップの言語設定  const language = \u0026#34;ja\u0026#34;; // ベースマップの URL を設定  const basemapURL = \u0026#34;https://basemapstyles-api.arcgis.com/arcgis/rest/services/styles/v2/styles/\u0026#34; + basemapId + \u0026#34;?type=style\u0026amp;token=\u0026#34; + apiKey + \u0026#34;\u0026amp;language=\u0026#34; + language; // olms 関数でベクター タイル レイヤー をベースマップに適用  olms(map, basemapURL); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; アプリを実行する CodePen で、作成したコードを実行して地図を表示します。\n地図には、日本の富士山のエリアの地形ベースマップ レイヤーが表示されているはずです。パンとズームで地図を探索してみましょう。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/deploy-your-app/",
	"title": "Web アプリケーションのデプロイ",
	"tags": [],
	"description": "ArcGIS Web AppBuilder (Developer Edition) で作成したアプリケーションをダウンロードし、独自のサーバーにホストする手順を紹介します。",
	"content": "トピック  アプリのダウンロード アプリのデプロイ グループ アクセスの設定 動作環境  ArcGIS Web AppBuilder (Developer Edition)（以下 Web AppBuilder）で作成したWeb アプリケーション (以下、アプリ) はダウンロードして、独自の Web サーバーにホストすることができます。もしアプリが未共有のアイテムを参照しているとき、ダウンロードしたアプリは ArcGIS Online または Portal for ArcGIS に登録する必要があります。 アプリをデプロイする場所にかかわらず、Web マップへのアクセスは必須です。\nその他のデプロイ パターンについてはデプロイ パターンのページをご覧下さい。\nアプリのダウンロード  Web AppBuilder を起動し、トップページを開いたら、アプリのダウンロードボタンをクリックします。 アプリケーションは ZIP ファイルでダウンロードされます。保存ダイアログが表示されたら、任意のフォルダーを指定し、[保存] をクリックします。これで、アプリケーションはローカル ドライブに保存されます。  アプリのデプロイ  ダウンロードしたアプリを解凍します。 解凍したアプリを Web サーバーへ配置します。 アプリのルート ディレクトリにある config.json ファイルを開き、以下の項目を編集します。 プロキシ\n必要に応じて、使用するプロキシを proxy プロパティに追加します。プロキシの詳細は Use proxy をご参照ください。 アプリケーション ID\nアプリケーション ID を appId プロパティへ設定します。アプリケーション ID を入手するには、アプリの追加、登録が必要です。詳細はアプリの追加およびアプリの登録をご参照ください。 OAuth と SAML を用いたプラットフォーム認証を活用するために、アプリケーション ID を使用することを推奨しています。  アプリをカスタマイズするには、以下のドキュメントを参照してください。\n アプリとウィジェットの設定：App configuration ArcGIS API for JavaScript の変更：ArcGIS API for JavaScript の参照先を変更する（オプション）  グループ アクセスの設定 もしアプリがグループや異なる組織間のメンバーで共有している、パブリックではない Web マップを使用しているとき、すべてのグループのメンバーがWeb マップにアクセスできるように設定します。\n アプリの config.json ファイルを開きます。 portalUrl プロパティの値を www.arcgis.com に変更します。 map プロパティに portalUrl プロパティが含まれている場合は、値を www.arcgis.com に変更します。  動作環境 アプリがサポートしているブラウザーは以下の通りです。\n 2D  Google Chrome Firefox Safari（Mac） Edge Internet Explorer 11\nIE11 または Edge で OAuth 認証を使用してアプリを開くとき、ポップアップが表示されることがあります。はいをクリックすると、ポップアップは消えますが、アプリは読み込まれません。この場合は、ブラウザーの設定から .arcgis.com を信頼済みサイトとして追加してください。 Safari（iOS） Google Chrome（Android）   3D  Google Chrome Firefox Safari（Mac） Edge Internet Explorer 11\n3D アプリには WebGL をサポートしているデスクトップの Web ブラウザーが必要です。ほとんどの最新バージョンのデスクトップ Web ブラウザーは WebGL を内蔵しています。ご利用の Web ブラウザーが WebGL を利用可能かどうかは get.webgl.org で確認できます。WebGL に関するトラブルシューティングは WebGL Troubleshooting をご参照ください。また、シーン ビューアーについての詳細は シーン ビューアーの要件 をご参照ください。    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/",
	"title": "その他",
	"tags": [],
	"description": "開発に役立つ技術です。",
	"content": "　テーマ別ページ   データ ビジュアライゼーション\n 地図にデータを可視化する際の tips を紹介します。    サンプル集\n 開発にすぐに使えるサンプル データ/コードを紹介します。    ミートアップ\n 開発者向けのイベント用に提供したページのリンクです。    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/",
	"title": "アプリ開発",
	"tags": [],
	"description": "シンプルな地図アプリの作成方法を紹介します。",
	"content": "マップとベースマップ レイヤーを表示するシンプルな地図アプリの作成方法を紹介します。お使いの開発環境からお選びください。\nWeb APIs \r\rArcGIS Maps SDK for JavaScript\rEsri Leaflet\rMapLibre GL JS\rOpenLayers\rCesiumJS\r\r\rNative APIs \r\rAndroid\riOS\r.NET\rUnity\rUnreal Engine\r\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/custom-widget/",
	"title": "ウィジェット開発",
	"tags": [],
	"description": "ウィジェットと呼ばれる、再利用可能な UX コンポーネント作成の基礎を紹介します。",
	"content": "出典：ArcGIS Maps SDK for JavaScript - Widget development\nウィジェットは再利用可能な UI コンポーネントで、リッチな UX を提供する鍵となります。ArcGIS Maps SDK for JavaScript では、完全にカスタム化されたウィジェットを HTML 要素として View に含めることができます。これには、完全に新しい機能を持つ独自のビューを開発する必要があり、ウィジェットの ViewModel を拡張することとは異なります。\nカスタムウィジェットを作成する場合、@arcgis/core ES モジュールをお好みのフロントエンド JavaScript フレームワークと共に使用することをお勧めします。React、Angular、Vue.js などのフレームワークは必須ではありませんが、最大の拡張性を提供します。SDK と疎結合で、フレームワークのよく知られた UI/UX パターンとコンポーネントのライフサイクルに準拠した複数のウィジェットを作成できます。独自のカスタムウィジェットの作成方法については、jsapi-custom-widget のサンプルを参照してください。\n非推奨のお知らせ\nバージョン 4.27 以降、完全なカスタム ウィジェットを構築するための基礎として、/esri/widgets/Widget をサブクラス化または拡張することは推奨されなくなりました。このパターンでは、SDK 内部への依存関係が作成され、文書化されていない変更が頻繁に発生する可能性があります。以下のガイド内容は、レガシー パターンに従ったものであり、既存のウィジェットを保守する場合にのみ使用してください。\n\rこのフレームワークはすべての Dijit を直接差し替えることを意図していません。例えば、dgrid の利用には Dijit が必要です。\nトピック\n 開発要件 ウィジェット ライフサイクル ウィジェットの実装 TypeScript デコレーター サンプルコード 関連リンク  開発要件 独自のカスタムウィジェットを作成する前に、自分のマシンでローカルにアプリケーションをビルドできるなど、最低限の要件を満たしていることを確認してください。このプロセスは、Web サーバー上でホストされ、ブラウザー上で実行される標準的な JavaScript アプリケーションを作成する場合に比べ、いくつかのステップが増えます。\nTypeScript TypeScript を使うことをお勧めします。その利点のひとつは、デコレーターを使って機能を強化できることです。TypeScript のセットアップ ガイド ページでは、ArcGIS Maps SDK for JavaScript を使用して TypeScript 開発環境をセットアップするための基本的な手順を説明しています。また、TypeScriptとは何か、なぜ使われるのか、どのように使うのかについて詳しく説明したオンライン リソースもたくさんあります。これらの基本に慣れることで、ウィジェット開発プロセスがより簡単になります\nJSX JSX は、JavaScriptの拡張構文で、HTMLと同様にウィジェットのユーザーインターフェイスを記述することができます。一般的には React と関連していますが、他の実装においても使うことができます。JavaScript とインラインで使えるという点では、HTML に似ています。カスタム ウィジェットは、TypeScript と JSX を組み合わせた拡張子 .tsx を使ってビルドされ、JavaScript に直接コンパイルされます。\nesri/core/Accessor の理解 Accessor は 4.x の主要な特徴のひとつであり、ウィジェットを含むすべてのクラスの基盤です。既存の API クラスを拡張してサブクラス、つまり子クラスを作成するため、カスタムウィジェットもこれに含まれます。カスタムウィジェットは、super() メソッドを呼び出すことで、親クラスからメソッドとプロパティを継承します。その他の詳細や使用パターンについては、Implementing Accessor のトピックを参照してください。\narcgis/core @arcgis/core のESモジュールは、AMD モジュールと同じ API 機能を持ちます。 ES モジュールは専用の AMD ローダーを必要としないため、ほぼすべての主要な JavaScript フレームワークやビルドツールでシームレスに動作し、ブラウザや最新のビルドツールでネイティブに消費できるため、カスタムウィジェットの構築には @arcgis/core を使用することをお勧めします。モジュールは npm を使って開発マシンのローカルにインストールします。\nウィジェット ライフサイクル 開発をはじめる前に、ウィジェット ライフサイクルを理解している必要があります。ウィジェットの種類にかかわらず、ライフサイクル特有の一般的な概念は同じです。\n constructor (params) - プロパティを設定している間に、ウィジェットが最初に作成されるところです。ウィジェットは Accessor から生じるので、get、set、watch を使いプロパティへアクセスできます（get、set、watch の詳細は Working with properties をご参照ください）。 postInitialize() - このメソッドは、ウィジェット作成後、UI の描画前に呼ばれます。 render() - ウィジェット開発で唯一の必須となるメソッドです。UI を描画するために使用されます。 destroy() - ウィジェットのインスタンスを解放するためのメソッドです。  TypeScript デコレーター ウィジェット開発では TypeScript のデコレーターが活用され、API ではデコレーターがクラスの作成に使用される基礎的なグルーとして使用されます。これにより、既存のプロパティ、メソッド、コンストラクタに共通する動作を設計時に拡張することができます。ウィジェット デコレーターの最も一般的なタイプについて、以下で説明します。\nAPI デコレーターを使用する場合は、後方互換性のために useDefineForClassFields フラグを false に設定する必要があります。詳細は TSConfig を参照してください。\n\r@subclass（declared と共に使われます） @subclass() デコレーターは、API クラスを拡張するために使用します。また、コンストラクタで declaredClass プロパティを文字列で指定することもできます。これは、declaredClass が読み取り専用である既存のクラスと、作成しようとしているカスタム クラスを区別するのに役立ちます。\n以下のスニペットは、ベースとなる Widget クラスをインポートして継承し、render メソッドで UI を定義しています。JSX は UI を定義するために使用されます。この単純なシナリオでは、div 要素が作成され、そのコンテンツとして John Smith という文字列が定義されます。\nimport Widget from \u0026#34;@arcgis/core/widgets/Widget.js\u0026#34;; @subclass(\u0026#34;esri.widgets.HelloWorld\u0026#34;) class HelloWorld extends declared(Widget) { render() { return ( \u0026lt;div\u0026gt;John Smith\u0026lt;/div\u0026gt; ); } } @property() Accessor プロパティを定義するには @property() デコレーターを使用します。このデコレーターで定義されたプロパティはすべて、get と set ができます。さらに、プロパティの変更を watch することもできます。\n@property() name: string; @aliasOf() @aliasOf() デコレーターは、デコレートするプロパティとそのメンバーの内部プロパティとの間に双方向バインディングを作成します。\n@aliasOf(\u0026#34;initialCenter.extent\u0026#34;) extent: Extent; ウィジェットの実装 以下のステップは、独自のカスタム ウィジェットを実装する際に必要なステップの簡単な概要を提供します。\nウィジェットの拡張\rプロパティとメソッドの実装\rウィジェットのレンダリング\rエクスポート モジュール\r新しいウィジェット クラスの作成 ベースとなる Widget クラスを拡張し、@subclass() コンストラクタで宣言されたクラスを指定することから始めます。\n// 拡張に使用する Widget クラスのインポート import Widget from \u0026#34;@arcgis/core/widgets/Widget.js\u0026#34;; @subclass(\u0026#34;esri.widgets.HelloWorld\u0026#34;) class HelloWorld extends Widget { } プロパティとメソッドの実装 次に、ウィジェット特有のプロパティとメソッドを実装します。このコードは、プロパティ作成において、デコレーターをどのように利用するのかを示しています。\n// \u0026#39;name\u0026#39; プロパティの作成 @property() name: string = \u0026#34;John Smith\u0026#34;; // private _onNameUpdateメソッドの作成 private _onNameUpdate(): string { return \u0026#39;${this.name}\u0026#39;;} デフォルトでは、要素の中で参照される関数は、実際の要素を参照する this を持ちます。必要に応じて、this の参照先を変更するために bind 属性を使用します。以下では、name プロパティを更新するときに呼ばれる _onNameUpdate コールバック関数を結び付けています。これは次の postInitialize メソッドに表示されます。\nclass HelloWorld extends Widget { constructor(params?: any) { super(params); this._onNameUpdate = this._onNameUpdate.bind(this); } } postInitialize メソッドは、ウィジェットのプロパティは用意されているが、描画される前に呼ばれます。以下のコードは name プロパティを監視しています。プロパティが更新されると、_onNameUpdate コールバック関数を呼びます。watchUtils.init() は WatchHandle オブジェクトを返し、own() に渡されます。これは、ウィジェットを削除した時点で、リソースを解放するメソッドです。\nimport * as watchUtils from \u0026#34;@arcgis/core/core/watchUtils.js\u0026#34;; postInitialize() { const handle = watchUtils.init(this, \u0026#34;name\u0026#34;, this._onNameUpdate); // Helper used for cleaning up resources once the widget is destroyed  this.own(handle); } ウィジェットのレンダリング プロパティが実装された後、ウィジェットの UI は JSX を使用して描画されます。これはウィジェットの renderer メソッドに処理されます。これは、ウィジェットの実装に必要な唯一のメソッドです。\nJSX 要素として作成されたウィジェットは、まだサポートされていないことに注意してください。例えば、以下のスニペットは動作しません。\rconst search = \u0026lt;Search view={view} /\u0026gt;;\r// UI の描画 render() { return ( \u0026lt;div\u0026gt; {this._onNameUpdate()} \u0026lt;/div\u0026gt; ); } 最後に、destroy を呼びます。このメソッドはウィジェットを削除し、postInitialize() 内で参照されている own() メソッドに登録された、すべてのリソースを解放します。\npostInitialize() { const handle = watchUtils.init(this, \u0026#34;name\u0026#34;, this._onNameUpdate); // ウィジェットが削除された時点でリソースを解放するメソッド  this.own(handle); } エクスポート モジュール コードページの一番最後に、モジュールをエクスポートする行を追加します。エクスポートは、ウィジェットの機能を import 文によって利用可能にします。\nexport default HelloWorld; 完成したコード jsapi-custom-widget サンプルは、widget.tsx ファイル全体を示します。TypeScript ファイルは、クラスが JSX を使用していることを示すために次のような拡張子を使用しています。例：.ts + .jsx = .tsx\nウィジェット レンダリング 以下のプロパティは、ウィジェットのレンダリングに使用できます。\nclasses: ウィジェットの class プロパティの値を構築するために使用されるユーティリティ メソッドです。これは、CSS クラスのセットアップを簡略化するのに役立ちます。\r// Widget のクラス ヘルパー メソッドで動作する新しいメソッド render() { const dynamicClass = { [CSS.bold]: this.isBold, [CSS.italic]: this.isItalic } return { \u0026lt;div class={this.classes(CSS.base, dynamicClass)}\u0026gt;Hello World!\u0026lt;/div\u0026gt; }; } styles: スタイルを動的に変更できるようにします。\rrender() { const dynamicStyles = { background-color: this.__hasBackgroundColor ? \u0026#34;chartreuse\u0026#34; : \u0026#34;\u0026#34; }; return ( \u0026lt;div styles={dynamicStyles}\u0026gt;Hello World!\u0026lt;/div\u0026gt; ); } afterCreate: このコールバック メソッドは、ノードが DOM に追加された後に実行されます。子ノードやプロパティはすでに適用されています。実際の DOM ノードにアクセスするには、render 内でこのメソッドを使用します。要素ごとに使用することも可能です。\rprivate _doSomethingWithRootNode(element: Element){ console.log(element); } private _doSomethingWithChildNode(element: Element){ console.log(element); } // Access real DOM node within render() render() { return ( \u0026lt;div afterCreate={this._doSomethingWithRootNode}\u0026gt;Hello World!\u0026lt;/div\u0026gt; ); } // Can also be used per element  render() { return ( \u0026lt;div afterCreate={this._doSomethingWithRootNode}\u0026gt; \u0026lt;span afterCreate={this._doSomethingWithChildNode}\u0026gt;Hello World!\u0026lt;span\u0026gt; \u0026lt;/div\u0026gt; ); } afterUpdate: このコールバック メソッドは、ノードが更新されるたびに実行されます。\rprivate _afterUpdate(element: Element){ console.log(element); } render() { return ( \u0026lt;div afterUpdate={this._afterUpdate}\u0026gt;Hello world!\u0026lt;/div\u0026gt; ); } bind: このプロパティは、イベント ハンドラーの `this` の値を設定するために使用される。\rprivate _whatIsThis(): void { console.log(\u0026#39;this === widget: ${this}\u0026#39;); } render() { return ( \u0026lt;div bind={this} onclick={this._whatIsThis}\u0026gt;\u0026#39;this\u0026#39; is the widget instance\u0026lt;/div\u0026gt; ); } key: これは、兄弟要素の中で DOM ノードを一意に識別するために使用されます。これは、同じセレクターを持つ兄弟要素があり、要素が動的に追加/削除される場合に重要です。\r// キーは、以下のサンプルでは文字列で指定されていますが、数値やオブジェクトを指定することもできます。  render() { const top = this.hasTop ? \u0026lt;li class={CSS.item} key=\u0026#34;top\u0026#34;\u0026gt;Top\u0026lt;/header\u0026gt; : null; const middle = this.hasMiddle ? \u0026lt;li class={CSS.item} key=\u0026#34;middle\u0026#34;\u0026gt;Middle\u0026lt;/section\u0026gt; : null; const bottom = this.hasBottom ? \u0026lt;li class={CSS.item} key=\u0026#34;bottom\u0026#34;\u0026gt;Bottom\u0026lt;/footer\u0026gt; : null; return ( \u0026lt;ol\u0026gt; {top} {middle} {bottom} \u0026lt;/ol\u0026gt; ); } 上記のメソッドに加えて、storeNode という便利なメソッドもあります。HTMLElement の DOM ノード リファレンスを変数に代入するときに使います。これは、カスタム データ属性 data-node-ref を使用して、要素の DOM ノードへの参照を格納します。これを正しく動作させるには、以下のスニペットに示すように、bind={this} のように、ウィジェット インスタンスにもバインドする必要があります。\n// data-node-ref 属性を DOM ノード値に割り当てます。 //これは `bind` プロパティと組み合わせて使用する必要があり、 // storeNode コンビニエンス メソッドを使用するときに使用します。  rootNode: HTMLElement = null; render() { return ( \u0026lt;div afterCreate={storeNode} bind={this} data-node-ref=\u0026#34;rootNode\u0026#34; /\u0026gt; ); } 関連リンク  Sample - jsapi-custom-widget（英語） Accessor class（英語） Guide - TypeScript Setup（英語） Guide - Implementing Accessor（英語） Guide - Build with ES modules（英語） Guide - Working with properties（英語） TypeScript reference（英語） JSX reference（英語） バージョン 3.x から 4.x への移行 ArcGIS Maps SDK for JavaScript を利用したウィジェット開発ハンズオン  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/",
	"title": "カスタム ウィジェット開発ガイド",
	"tags": [],
	"description": "カスタム ウィジェットを開発する手順を紹介します。",
	"content": "カスタム ウィジェットを開発する手順を紹介します。  ウィジェット開発のスタート\nウィジェット開発に使用しているライブラリから開発に必要な概要までを紹介します。\n\r ウィジェット manifest\nウィジェットの名前やバージョンなどのウィジェットの属性などを設定する manifest.json ファイルについて紹介します。\n\r ウィジェットの実装\nウィジェットの実装方法について紹介します。\n\r ウィジェット UI の作成\nウィジェット UI の作成方法について紹介します。\n\r ウィジェットでデータソースを使用\nウィジェットでデータソースを使用する方法について紹介します。\n\r ウィジェット間の通信\nウィジェット同士がどのように相互に通信する方法について紹介します。\n\r ウィジェット開発のデバック\nウィジェット開発におけるデバック方法について紹介します。\n\r サードパーティ製のライブラリ使用\nサードパーティ製のライブラリの使用方法について紹介します。\n\r 単体テスト\n単体テストの方法について紹介します。\n\r assets の使用\nassets の使用について紹介します。\n\r コードリンティング\nコードリンティングについて紹介します。\n\r webpack config のオーバーライド\nwebpack config をオーバーライドする方法について紹介します。\n\r dist フォルダーへのファイルのコピー\ndist フォルダーへファイルをコピーする必要がある場合の方法について紹介します。\n\r ウィジェット間のコードの共有\nウィジェット間で同じコードを共有して利用する方法を紹介します。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/create-startup-app-js3/",
	"title": "スタートアップ ガイド（3.x）",
	"tags": [],
	"description": "",
	"content": "サンプル プロジェクトのダウンロード このリポジトリ（arcgis-dev-resources）には開発を試してみたい方向けのサンプル コードが含まれています。ダウンロードする際の方法は 2 通りあります。\n リポジトリをご自身のアカウントに Fork（複製）   GitHub にログインして、arcgis-dev-resources ページを開いて [Fork] をクリックすると、ご自身のアカウントに同じリポジトリが作成されます。 Fork 後はご自身のローカル マシンにクローンを作成します。   zip ファイルでダウンロード（※GitHub アカウントをお持ちでない方向け）  arcgis-dev-resources ページを開いて [Download ZIP] をクリックするとプロジェクト ファイル一式が手に入ります。\n地図の表示 まずはダウンロードしたサンプル コードを実行してみましょう。\n  ダウンロードしたサンプル コード（arcgis-dev-resources/startup/javascript/3.x/map/index.html）を Web ブラウザーにドラッグ＆ドロップします。 Web サーバーをお持ちの方はサンプル コードを Web サーバーにホストしてアクセスすることを推奨します。http://localhost/arcgis-samples-js/simple/map.html のように localhost を指定してアクセスできます。\n  この状態では地図は表示されません。サンプル コードをテキスト エディターで開いてみましょう。\n  map.html 29 行目にある以下のコードの \u0026lt;Web マップ ID\u0026gt; と記載されている箇所に Web マップの作成で作成した Web マップ ID を上書きします。\n  var mapDeferred = arcgisUtils.createMap(\u0026#34;\u0026lt;Web マップ ID\u0026gt;\u0026#34;, \u0026#34;mapDiv\u0026#34;); まだ Web マップを作成しておらず、すぐに試してみたい方はサンプル Web マップをご利用ください。\n Web アプリを実行すると、以下のように地図が表示されます。   検索機能の追加 検索機能の実装方法はいくつかありますが、ここではもっとも簡単な方法をご紹介します。検索機能の実装には esri/dijit/Search モジュール（検索ウィジェット）を使用します。検索ソースにはサンプル Web マップに含まれる東京都 23 区のデータを使用します。\n検索ウィジェットは住所検索/属性検索機能を組み込んだ文字入力フォームの UI を提供します。\n ArcGIS Maps SDK for JavaScript から使用したいモジュールを追加します。モジュールのインポートは require 関数の第一引数に入力される配列内で行います。配列内に検索機能の実装に必要なモジュールを追加します。  require([\u0026#34;esri/arcgis/utils\u0026#34;, \u0026#34;esri/dijit/Search\u0026#34;, \u0026#34;esri/layers/FeatureLayer\u0026#34;, \u0026#34;esri/InfoTemplate\u0026#34;, \u0026#34;dojo/domReady!\u0026#34;], function(arcgisUtils, Search, FeatureLayer, InfoTemplate) { ... }); 以下は検索機能に必要なモジュール一覧です。\n * `\u0026quot;esri/dijit/Search\u0026quot;`: 検索ウィジェット\r* `\u0026quot;esri/layers/FeatureLayer\u0026quot;`: フィーチャ レイヤー（オプション）\r* `\u0026quot;esri/InfoTemplate\u0026quot;`: 情報テンプレート（オプション）\rフィーチャ レイヤーは検索ソース、情報テンプレートは検索結果の属性表示を設定するために利用します。\r ここで以下の点に注意してください。\n * 配列の一番最後のモジュールは必ず `\u0026quot;dojo/domReady!\u0026quot;` になるようにしてください\r* `require` 関数の第ニ引数の無名関数の引数にはモジュールに対応したクラス名（任意）を定義しますが、これは配列内のモジュールの順序と対応している必要があります\r  検索ウィジェット用の DOM 要素を作成します。  \u0026lt;div id=\u0026#34;searchDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ここで指定した DIV の ID は検索ウィジェットを作成する際に、JavaScript 側で使用します。\n 検索ウィジェットの表示位置を CSS で記述します。  #searchDiv { display: block; position: absolute; z-index: 2; top: 20px; left: 74px; }  mapDeffered.then の関数内で検索ウィジェット作成のスクリプトを記述します。  mapDeferred.then(function(response) { map = response.map; var search = new Search({ map: map, sources: [] }, \u0026#34;searchDiv\u0026#34;); }); \u0026quot;esri/dijit/Search\u0026quot; モジュールが定義する Search クラスは require 関数内でのみ動作します。\nマップのオブジェクトは `mapDeffered.then` の処理完了後の `Deferred` で取得できます。検索ウィジェットはマップのオブジェクトを使用するため、この位置に記述する必要があります。\r対応するマップを指定するための `map` プロパティにはマップのオブジェクトを、検索ソースを指定するための `sources` プロパティには空の配列を定義します。検索ソースがない状態でも ArcGIS のクラウド サービスが提供する住所検索サービスが標準で含まれています。\r  検索ソースに検索対象とするフィーチャ レイヤーを定義します。  var sources = search.get(\u0026#34;sources\u0026#34;); sources.push({ featureLayer: new FeatureLayer(\u0026#34;https://services.arcgis.com/wlVTGRSYTzAbjjiC/arcgis/rest/services/tokyo_23/FeatureServer/0\u0026#34;), // 検索ソースとなるフィーチャ レイヤー  placeholder: \u0026#34;検索キーワードの入力\u0026#34;, // プレースホルダー  enableLabel: false, // 検索結果ラベルの表示  searchFields: [\u0026#34;\u0026lt;フィールド名\u0026gt;\u0026#34;], // 検索対象となる属性フィールド  displayField: \u0026#34;\u0026lt;フィールド名\u0026gt;\u0026#34;, // 検索結果のポップアップに表示する属性フィールド  outFields: [\u0026#34;*\u0026#34;], // 結果として返す属性フィールド  name: \u0026#34;東京都\u0026#34;, // 検索ソースの名前  infoTemplate: new InfoTemplate(\u0026#34;東京都\u0026#34;, \u0026#34;市区町村: ${Name}\u0026#34;), // 検索結果のポップアップ表示構成  enableSuggestions: true // 検索結果の候補リスト表示  }); // 検索ソースを検索ウィジェットに設定  search.set(\u0026#34;sources\u0026#34;, sources); search.startup(); sources.featureLayer には検索ソースとなるレイヤーを定義しますが、必ずしも地図上に表示されているレイヤーを使う必要はありません。サンプルはマップ オブジェクトに存在しない別のレイヤーを検索ソースとして利用します。\nフィールド名の確認は次の手順で紹介します。\r   検索対象とするレイヤーの詳細ページにて、[レイヤー] の項目から対象とするレイヤーをクリックして [サービスの URL] を選択します。   [Fields] という項目にレイヤーのフィールド情報のリストが表示されているので、検索対象とするフィールド名をコピーして searchFields の配列に追加します。 検索結果のポップアップに表示する属性情報として利用したい場合は displayField にも入力してください。\n  Web アプリを実行すると、以下のように地図上に検索ウィジェットが表示され、設定した検索ソースでの検索が可能になります。   "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/section-view/",
	"title": "セクションとビュー（Section and view）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Section and view\nセクションとビュー（Section and view） セクションは、複数のビューを追加できる領域を占めています。ビューはレイアウトコンテナで、ページやウィンドウに似ていますが、セクションの中にしか置くことができません。ビュー・ナビゲーション・ウィジェットは、セクション内のビューをナビゲートします。メニュー \u0026ldquo;ウィジェットで複数のページを使用したり、\u0026ldquo;ビュー・ナビゲーション \u0026ldquo;ウィジェットでセクションとビューを使用して同様の操作感を得ることができますが、両者には主な違いがあります。\n レンダリングについて - 複数のページを読み込む場合、最初は現在のページのコンテンツのみがレンダリングされます。セクション内の複数のビューを読み込む場合、ビュー内のすべてのコンテンツがレンダリングされますが、現在のビューのみが表示され、他はすべて非表示になります。 アニメーションについて - セクションでのみトランジションアニメーションを定義できます。  app config では、セクションは sections で定義され、ビューは views で定義されます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/dotnet/migration-dotnet-100.x/",
	"title": "バージョン 10.2.x から 100.x への移行",
	"tags": [],
	"description": "今まで ArcGIS Runtime SDK for .NET バージョン 10.2.x を使用してアプリケーションを開発されていた開発者向けのガイドです。",
	"content": "ArcGIS Runtime SDK バージョン 100.x は新しいアーキテクチャを使用してゼロから開発された次世代の ArcGIS Runtime です。このバージョンアップに伴い API の再設計が行なわれています。このドキュメントでは、バージョン 100.x の変更点について説明します。\nArcGIS Runtime SDK for .NET に関しては、ESRIジャパン 製品ページをご参照ください。\n以下は、バージョン 100.x の主な変更点です。\n マップとシーン ビュー レイヤー クラス名の変更 フィーチャ レイヤーの表示 フィーチャの操作 個別属性表示 グラフィックス オーバーレイ ジオメトリとジオメトリ ビルダー スケッチ エディター ローダブル パターン ローカルサーバー 既知の制限事項  マップとシーン 100.x では、Map オブジェクト（2D表示用）と Scene オブジェクト（3D表示用） を API のコアとして、ArcGIS プラットフォームの Web GIS 機能を迅速に利用できるようになりました。\nMap オブジェクトと Scene オブジェクトは 、それらを表示する View と分離されています。Map オブジェクトと Scene オブジェクトには 、操作レイヤー、ベースマップ、ブックマーク等の ArcGIS 固有のデータを設定でき、アプリケーションで利用することができます。\nビュー MapView（2D表示用）と SceneView（3D表示用）は、UI コンポーネントです。MapView クラスの map プロパティに、Map オブジェクトを、MapSceneView クラスの scene プロパティには Scene オブジェクトを設定します。\n100.x では、以下のようにマップを表示します。\n// ベースマップを指定してマップを初期化 Map myMap = Map(Basemap.CreateImagery()); // マップビューにマップを設定 MyMapView.Map = myMap; レイヤー クラス名の変更 各レイヤーのクラス名が以下のように変更されています。\n   レイヤー 10.2.x のクラス名 100.x のクラス名     ArcGIS Server ダイナミック マップ サービス レイヤー ArcGISDynamicMapServiceLayer ArcGISMapImageLayer   タイル マップ サービス レイヤー ArcGISTiledMapServiceLayer ArcGISTiledLayer   タイル パッケージ レイヤー ArcGISLocalTiledLayer ArcGISTiledLayer    100.x でサポートされているレイヤーのタイプについては、ArcGIS Runtime SDK for .NET: レイヤー（英語）をご参照ください。\n作成した各レイヤーは、以下の方法でマップに追加します。\n// 操作レイヤーとしてマップに追加する myMap.OperationalLayers.Add(arcgis_map_image_layer) // ベースマップとしてマップに追加する myMap.Basemap.BaseLayers.Add(arcgis_tiled_layer); フィーチャ レイヤーの表示 フィーチャ サービスや端末のローカルに格納されたジオデータベースのデータをマップに表示するにはフィーチャ レイヤーを使用します。 フィーチャ レイヤーを表示するには、はじめにフィーチャ テーブルを作成します（フィーチャ サービスのデータをフィーチャ レイヤーとして表示するに場合は ServiceFeatureTable オブジェクト、ジオデータベースのデータ表示する場合は GeodatabaseFeatureTable オブジェクトを使用します）。次に作成したフィーチャ テーブルを引数として FeatureLayer オブジェクトを作成し、Map オブジェクトの OperationalLayers に追加します。\n次のコードは、フィーチャ サービスのデータを FeatureLayer として追加する方法を示しています。\n// フィーチャ サービスの URL からフィーチャ テーブルを作成 ServiceFeatureTable featureTable = new ServiceFeatureTable(new Uri(\u0026#34;https://services.arcgis.com/wlVTGRSYTzAbjjiC/arcgis/rest/services/all_Japan_shikuchoson/FeatureServer/0\u0026#34;)); // フィーチャ テーブルからフィーチャ レイヤーを作成 FeatureLayer featureLayer = new FeatureLayer(featureTable); // フィーチャ レイヤーをマップの操作レイヤーに追加 myMap.OperationalLayers.Add(featureLayer); フィーチャの操作 フィーチャの検索や編集はフィーチャ テーブル （ServiceFeatureTable または GeodatabaseFeatureTable）に対して行います。\nフィーチャ サービスから作成したフィーチャ テーブル（ServiceFeatureTable）の場合、フィーチャ テーブルのフィーチャは、マップ上にレンダリングするために必要最小限の情報だけを含むように最適化されています。これにより、フィーチャを表示するための待機時間と帯域幅の消費が削減されます。フィーチャの編集やすべての属性情報を表示するような場合は完全な情報を取得するために、ローダブル パターン等を使用して、フィーチャを明示的にロードしておく必要があります。\nフィーチャのリクエスト モード フィーチャ サービスからフィーチャを取得する場合は、 リクエスト モードの設定によってフィーチャの取得頻度とや端末上でのデータのキャッシュ方法を制御します。リクエスト モードには、OnInteractionCache、 OnInteractionNoCache、ManualCache があります。リクエスト モードはフィーチャ テーブルが初期化される前に、ServiceFeatureTable の FeatureRequestMode プロパティを使用して設定できます。\n  OnInteractionCache: ユーザーの操作によりマップの表示領域が変更されると、フィーチャが自動的にリクエストされます。リクエストされたすべてのデータはローカルにキャッシュされます。キャッシュされたデータは、既に表示された領域にマップが移動しても、再度リクエストされません。サーバー上のデータが変更される可能性が少ない静的なデータに適したモードです。\n  OnInteractionNoCache: ユーザーの操作によりマップの表示領域が変更されると、フィーチャが自動的にリクエストされますが、キャッシュはされません。既に表示された領域にマップが移動すると、再度リクエストされます。サーバー上のデータが継続的に更新される可能性がある場合に適したモードです。\n  ManualCache: ユーザーによるマップ操作では、フィーチャは自動的にリクエストされません。このモードを使用する場合は、ServiceFeatureTable の PopulateFromServiceAsync メソッドを使用して明示的にデータをリクエストする必要があります。\n以下のコードは PopulateFromServiceAsync メソッドを使用して、サーバー上のすべてのフィーチャを取得する方法の例です。\n  // フィーチャの取得（検索）時のパラメーターを設定 QueryParameters queryParameters = new QueryParameters(); // すべてのフィーチャを取得するように条件を設定 queryParameters.WhereClause = \u0026#34;1 = 1\u0026#34;; // 検索結果にフィーチャのすべての属性情報（outFields の配列に \u0026#34;*\u0026#34; を指定）を含める var outputFields = new string[] { \u0026#34;*\u0026#34; }; // クエリの条件に基づいてフィーチャ テーブルにデータを設定する await featureTable.PopulateFromServiceAsync(queryParameters, true, outputFields); フィーチャの編集 フィーチャの編集はフィーチャ テーブルに対して行います。フィーチャ サービスまたはジオデータベースのデータから作成したフィーチャ テーブルのどちらを編集する場合も実装方法に違いはありません。\nフィーチャの編集方法は、 ArcGIS Runtime SDK for .NET: フィーチャの編集（英語）をご参照ください。\nフィーチャの検索 フィーチャの検索はフィーチャ テーブルに対して行います。フィーチャ サービスまたはジオデータベースのデータから作成したフィーチャ テーブルのどちらを編集する場合も実装方法に違いはありません。検索を行うには ServiceFeatureTable または GeodatabaseFeatureTable クラスの QueryFeaturesAsync メソッドを使用します。\n次のコードは、フィーチャ テーブルからフィーチャを検索する方法を示しています。\ntry { // フィーチャの取得（検索）時のパラメーターを設定  QueryParameters queryParams = new QueryParameters(); // 検索条件を設定  queryParams.WhereClause = \u0026#34;upper(KEN) LIKE \u0026#39;%東京%\u0026#39;\u0026#34;; // フィーチャ テーブルから検索条件を取得  FeatureQueryResult queryResult = await _featureTable.QueryFeaturesAsync(queryParams); // 結果に問い合わせるためにリストを取得  var features = queryResult.ToList(); if (features.Any()) { // 結果から1件のフィーチャを取得  Feature feature = features[0]; } else { MessageBox.Show(\u0026#34;検索結果が見つかりませんでした。\u0026#34;); } } catch (Exception ex) { MessageBox.Show(\u0026#34;処理エラー\u0026#34;, \u0026#34;検索処理でエラーが発生しました：\u0026#34; + ex.ToString()); } 個別属性表示 マップ上で特定の場所をタップして、その位置にあるフィーチャをすべてのレイヤーから検索して取得することができます。その操作はビューに対して行います。次のコードは、MapView クラスの IdentifyLayerResult メソッドを使用してフィーチャを取得する方法を示しています。\n// MapView のすべてのレイヤーを識別し、タップしたポイント、許容値、戻り値のタイプ、最大結果数を渡します IReadOnlyList\u0026lt;IdentifyLayerResult\u0026gt; idLayerResults = await MyMapView.IdentifyLayersAsync(tapScreenPoint, pixelTolerance, returnPopupsOnly, maxLayerResults); foreach (IdentifyLayerResult idResults in idLayerResults) { // 検索されたレイヤーを取得して FeatureLayer にキャストする  FeatureLayer idLayer = idResults.LayerContent as FeatureLayer; // 反復処理を行い、検索されたレイヤー内の GeoElement を取得する  foreach (GeoElement idElement in idResults.GeoElements) { // GeoElement を Feature にキャストする  Feature idFeature = idElement as Feature; // フィーチャ レイヤーでフィーチャを選択状態にする  idLayer.SelectFeature(idFeature); } } グラフィックス オーバーレイ グラフィックは、マップ上に一時的なデータを表示するために使用されます。MapView と SceneView オブジェクトにはグラフィックを表示するためのグラフィックス オーバーレイ（GraphicsOverlay）が含まれています。 グラフィックス オーバーレイを使用することで、マップ上のレイヤーの順序が変更されても、グラフィックが常に最上位に表示されます。\n次のコードは、MapView オブジェクトに、グラフィックス オーバーレイを使用してグラフィックを追加する方法を示しています。\n// ジオメトリとシンボルを使用してグラフィックを作成 var pointGraphic = new Graphic(pointGeometry, poitnSymbol); // グラフィックス オーバーレイに作成したグラフィックを追加 var graphicsOverlay = new GraphicsOverlay(); graphicsOverlay.Graphics.add(pointGraphic); // MapView の GraphicsOverlays に作成したグラフィックス オーバーレイを追加 MyMapView.GraphicsOverlays.Add(graphicsOverlay); ジオメトリとジオメトリ ビルダー Geometry オブジェクトのコンストラクタを使用すると、既知の座標を使用してジオメトリを作成できますが、作成後にそのジオメトリを変更することはできません。\nジオメトリ ビルダー（GeometryBuilder）を使用すると、ゼロから新しいジオメトリを作成したり、既存のジオメトリを基に、ジオメトリを変更することができます。\nスケッチ エディター スケッチ エディター（SketchEditor）を使用すると、ユーザーがマップ上で対話的にジオメトリをスケッチすることができます。\n次のコードは、SketchEditor の使用方法の例を示しています。\n// 頂点の編集、サイズ変更、移動ができるようにスケッチエディタの設定を行います var config = MyMapView.SketchEditor.EditConfiguration; config.AllowVertexEditing = true; config.ResizeMode = SketchResizeMode.Uniform; config.AllowMove = true; // スケッチエディタをページのデータコンテキストとして設定する DataContext = MyMapView.SketchEditor; ・・・・・・ try { // ジオメトリの種類を設定してスケッチを開始  geometry = await MyMapView.SketchEditor.StartAsync(creationMode, true); ・・・・・・ // ジオメトリが更新された際の処理 } catch (TaskCanceledException) { // スケッチのキャンセル } catch (Exception ex) { // スケッチのエラー } ローダブル パターン データを非同期的にロードして状態を初期化するマップやレイヤー等のリソースは、ローダブル パターンを採用しています。各リソースのプロパティにアクセスするときは、ローダブル パターンを使用して、リソースがロードされた後にアクセスすることが推奨されます。ローダブル パターンは、ロード状態の振る舞いをより均一にして且つ一貫性を持たせることで、非同期性をより明示的にします。ローダブル パターンでは、各リソースは自動的にリソースの状態をロードしません。それらは、開発者が明示的に実行したときに、遅延ロードします。 ローダブル パターンを採用しているリソースの状態は、NotLoaded（ロードが開始していない、Loading（ロード中）、Loaded（ロードに成功）、FailedToLoad（ロードに失敗） のいずれかで監視することができ、ロードに失敗した場合はロードを再試行することができます。\n詳細は、ArcGIS Runtime SDK for .NET: ローダブル パターン（英語）を参照してください。\n次のコードは、ローダブル パターンの使用方法の例を示しています。\n// ローダブル時のイベント featureLayer.Loaded += (s, e) =\u0026gt; { // フィーチャ レイヤーのプロパティにアクセス  Debug.Assert(featureLayer.MinScale == 5000); Debug.Assert(featureLayer.MaxScale == 1000000); }; // フィーチャ レイヤーのロード await featureLayer.LoadAsync(); ローカルサーバー ローカル サーバーの機能を使用する場合は、ArcGIS Runtime SDK for .NET とは別に ArcGIS Runtime Local Server SDK のインストールが必要となります。インストールの詳細は、ArcGIS Runtime SDK for .NET: ローカル サーバー（英語）を参照してください。\n既知の制限事項 現バージョンでの既知の制限事項が、ArcGIS Runtime SDK for .NET: リリース ノート（英語）に記載されていますので、ご参照ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/services/basemaps/",
	"title": "ベースマップ",
	"tags": [],
	"description": "マッピングAPI＆ロケーションサービス内のベースマップについて紹介します",
	"content": "出典：Mapping APIs and location services - Basemaps\n\rベースマップとは？ ベースマップはベースマップ レイヤーとも呼ばれ、マップとシーンの全体的なビジュアルを提供するレイヤーです。ベースマップには通常は大陸、湖沼、行政境界、道路、都市、地名などの地理的な特徴やラベルが含まれます。ベースマップの最も一般的なデータ ソースは、ベースマップ スタイル サービスとデータ サービス です。\nベースマップ レイヤーを使って以下のようなことができます。\n マップとシーンの両方で、世界中の地理データを表示 ArcGIS streets、navigation、light gray canvas、OSM streets などのベースマップを表示 自身で指定した色、字体、フォントを使用したベースマップを表示 街路やナビゲーションのベクター タイル レイヤーを表示 衛星画像や陰影起伏図用のマップ タイル レイヤーを表示 独自のデータを独自の空間参照で表示  ベースマップの仕組み ベースマップ レイヤーは、マッピング アプリケーションの視覚的な基礎を提供します。ベースマップ レイヤーは、一般的にグローバルなデータを含み、マップやシーンに追加される最初のレイヤーです。マップを表示する場合、ベースマップ レイヤーが最初に描画され、次にデータ レイヤー、グラフィックス レイヤーの順に描画されます。\nベストプラクティス ほとんどの場合、アプリケーションはフィーチャの選択やポップアップの表示など、ベースマップ レイヤーとのやり取りを許可していません。ベースマップ レイヤーの上にあるデータレイヤーを使用してマップ内のフィーチャを表示して、フィーチャ内のデータにアクセスできます。\nデータ ソースの種類 ベースマップの一般的なデータ ソースは、ベースマップ スタイル サービスとデータ サービスの 2 つです。\nベースマップ スタイル サービス ベースマップ スタイル サービスは、世界中のベースマップ スタイルとデータを提供するロケーション サービスです。各ベースマップ スタイルには、地理的なフィーチャとラベルの視覚的なプロパティに固有のセットがあります。このサービスには ArcGIS と OSM の 2 つのデータ プロバイダが含まれます。データ プロバイダは、streets、navigation、light gray canvas、imagery などのデフォルトのベースマップ スタイルをサポートしています。各スタイルのデータは、ArcGIS でホストされているベクター タイル レイヤーとマップ タイル レイヤーを通じて提供され、Web メルカトル空間参照に格納されます。\nベストプラクティス 世界中のあらゆる場所の地理的特徴やラベルを表示するロケーション サービスを使用する場合や、独自のカスタム ベースマップ スタイルを作成する場合は、ベースマップ スタイル サービスを使用してください。このサービスでは、場所、ローカル言語、worldview を表示することもできます。\nベースマップ スタイル サービスを利用するための一般的な手順は以下の通りです。\n  ベースマップ スタイル サービスで使用できるデフォルトのベースマップ スタイルを確認します。\n  サービス、データ プロバイダ、スタイルを参照します\n データ プロバイダ : ArcGIS または OSM ベースマップ スタイル例 : streets、imagery、navigation、topography、light gray canvas、outdoors など    ベースマップを表示します\n  ArcGIS Maps SDKs は、各スタイルにアクセスするための列挙型またはヘルパークラスを提供します。ただし、オープン ソース ライブラリを使用する場合は、ベースマップ スタイル サービスまたは基礎となるベクター タイル レイヤーまたはマップ タイル レイヤーを直接参照する必要があります。\n例 : ArcGIS API for Python from arcgis import GIS gis = GIS(api_key=\u0026#34;YOUR_API_KEY\u0026#34;) map = gis.map() map.basemap = \u0026#34;streets-navigation-vector\u0026#34; API リファリンスへ\r\rベースマップ スタイル サービスを使用する方法を学ぶにはベースマップ スタイルの表示、ローカライズされた地名ラベルの表示、worldview の表示を参照してください。地点の表示について学ぶ方法は Basemap places を参照してください。\n\rREST API : さまざまなスタイルと機能の詳細についてはベースマップ スタイル サービス (v2) を参照してください。\n\rデータ サービス フィーチャ サービス、ベクター タイル サービス、マップタイル サービスなどのデータ サービスは、ArcGIS Online または ArcGIS Enterprise でホストされているサービスで、お客様のデータを含んでいます。ほとんどの場合、クライアント API でサポートされているデータ サービスは、ベースマップのデータ ソースとして使用できます。データ サービスは、ArcGIS のホスト レイヤー (アイテム) でアクセスおよび管理できます。\nベストプラクティス ArcGIS Online または ArcGIS Enterprise でホストされている既存のデータ サービスまたは独自のホスト型データ サービスを使用する場合は、データ サービスを使用します。また、Web メルカトル以外の空間参照を必要とする小規模な地域やエリアのデータを表示する場合にも使用します。\nデータ サービスを利用するための一般的な手順は以下の通りです。\n ホスト レイヤーおよびデータ サービスを検索または作成します。  ArcGIS Online および ArcGIS Living Atlas of the World で既存のサービスを検索します。 独自のデータ サービスを作成する方法については、Data hosting を参照してください。   レイヤー アイテム ID またはサービス URL を取得します。例 :  レイヤー アイテム : https://www.arcgis.com/home/item.html?id=4d9fb5c0a6344407aec56f47a11482b5 アイテム ID : 4d9fb5c0a6344407aec56f47a11482b5 サービス URL : https://services2.arcgis.com/FiaPA4ga0iQKduv3/arcgis/rest/services/State_Geologic_Map_Compilation_%E2%80%93_Geology/FeatureServer/0   ベースマップを表示します。  ArcGIS Maps SDKs は、ホスト レイヤーのアイテム ID またはサービス URL を使用してデータ サービスにアクセスします。一方、オープンソース ライブラリは、サービス URL を使用してデータ サービスにアクセスします。\n例 : ArcGIS Maps SDK for JavaScript const featureLayer = new FeatureLayer({ portalItem: { id: \u0026#34;4d9fb5c0a6344407aec56f47a11482b5\u0026#34; // ArcGIS Online 上の State Geologic Map Compilation – Geology を参照  } }); const basemap = new Basemap({ baseLayers: [featureLayer] }); チュートリアルへ\r\rベースマップ用のホスト レイヤーとデータ サービスを使用する方法については、ホスト レイヤー (データ サービス) の表示を参照してください。\n\rベースマップ用に独自のサービスを作成する方法については、Data services \u0026gt; Introduction を参照してください。\n\rコード例 ベースマップ スタイルの表示 この例では、ベースマップのデータ ソースとしてベースマップ スタイル サービスを使用する方法を示します。そのためには、デフォルトのベースマップ スタイルの 1 つを使用します。表示可能なベースマップについては、ベースマップ スタイル (v2) を参照してください。\nステップ  マップを作成します。 ベースマップ スタイル サービスからスタイルを参照します。 ベースマップをマップに追加します。  例 : ArcGIS API for Python from arcgis.gis import GIS gis = GIS(api_key=\u0026#34;YOUR_API_KEY\u0026#34;) map = gis.map() map.basemap = \u0026#34;streets-vector\u0026#34; # map.basemap = \u0026#34;streets-navigation-vector\u0026#34; # map.basemap = \u0026#34;topo-vector\u0026#34; # map.basemap = \u0026#34;gray-vector\u0026#34; # map.basemap = \u0026#34;satellite\u0026#34; map.center = [35.25615700207951, 139.15502776889684] map.zoom = 13 map APIリファリンスヘ\r\rArcGIS/Streets \rArcGIS/Navigation \rArcGIS/Topographic \rArcGIS/Outdoor \rArcGIS/Light gray canvas \rArcGIS/Imagery \rOSM/Standard \rOSM/Navigation \rOSM/Blueprint \rローカライズされた地名ラベルの表示 ベースマップ スタイル サービスはデフォルトで英語のラベルを表示します。以下の例では、ローカライズされた言語ベースの地名ラベルで OSM スタイルを表示する方法を示します。\nステップ  マップまたはシーンを作成します。 ベースマップ スタイル サービス (v2) からスタイルを参照します。 スタイルの URL で、language パラメーターに言語コードを設定します。 ベースマップをマップに追加します。  ローカライズされた地名ラベル (ローカル) この例では、arcgis/light-gray のマップ スタイルを使用します。デフォルトでは地名ラベルはグローバルな地名を表示します。ローカライズされた地名ラベルをレンダリングするには、language パラメーターを local に設定します。ローカライズされたラベルはズームレベル 10 以降でレンダリングされます。\n\r例 : Esri Leaflet const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; const map = L.map(\u0026#34;map\u0026#34;).setView([35.67255187657312, 139.76323442958844], 14); L.esri.Vector.vectorBasemapLayer(\u0026#34;arcgis/light-gray\u0026#34;, { apikey: apiKey, language: \u0026#39;local\u0026#39;, version: 2 }).addTo(map); チュートリアルへ\r\r言語ベースの地名ラベル (グローバル) この例では、arcgis/dark-gray マップ スタイルを使用しています。language パラメーターに言語コード (ここでは ja) を設定し、全てのズームレベルで地名ラベルがすべて日本語で表示されるようにしています。\n\r例 : Esri Leaflet const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; const map = L.map(\u0026#34;map\u0026#34;).setView([2.35, 48.856], 6); L.esri.Vector.vectorBasemapLayer(\u0026#34;arcgis/dark-gray\u0026#34;, { apikey: apiKey, language: \u0026#39;ja\u0026#39;, version: 2 }).addTo(map); チュートリアルへ\r\rworldview の表示 ベースマップ スタイル サービスは、デフォルトのグローバルな worldview を使用して、国の境界線とラベルを表示します。この例では、ある国の特定のビューに基づいてベースマップの境界線とラベルを表示する方法を示します。 worldview は、navigation、streets、community など一部の ArcGIS ベースマップ スタイルでのみ使用できます。OSM スタイルはサポートされていません。\n特定の worlview を選択した場合、その国以外の国際的な方針ではないことに注意してください。\n\rステップ  マップまたはシーンを作成します。 ベースマップ スタイル サービス (v2) からベースマップ レイヤーを参照します。 スタイルの URL で、サポートされている worldview 名を worldview パラメーターに設定します。 ベースマップをマップに追加します。  この例では、 arcgis/light-gray のマップ スタイルを使用し、境界線とラベルの worldview を morocco に設定しています。すべての worldview オプションを見るには、ベースマップ スタイル サービス (v2) をご覧ください。\n\r例 : MapLible GL JS const worldView = \u0026#34;morocco\u0026#34; // モロッコの worldview を指定  const map = new maplibregl.Map({ container: \u0026#34;map\u0026#34;, // div 要素の ID  style: `https://basemapstyles-api.arcgis.com/arcgis/rest/services/styles/v2/styles/arcgis/light-gray?token=${apiKey}\u0026amp;worldview=${worldView}`, zoom: 3, center: [-7.09, 31], // 初期位置 [経度, 緯度]  }) ホスト レイヤー (データ サービス) の表示 この例では、ベースマップのデータ ソースとして ArcGIS のデータ サービスを使用する方法を示します。データはアメリカ全土の地質を示すホスト フィーチャ レイヤーです。データ サービスを利用するためには、ホスト レイヤーのアイテム ID を参照する必要があります。\nステップ  ホスト レイヤーのアイテム ID を見つけます。 ベースマップを作成し、そのレイヤーをベースレイヤーとして追加します。 マップを作成し、ベースマップを使用します。  \r例 : ArcGIS Maps SDK for JavaScript const featureLayer = new FeatureLayer({ portalItem: { id: \u0026#34;4d9fb5c0a6344407aec56f47a11482b5\u0026#34; // ArcGIS Online 上の State Geologic Map Compilation – Geology を参照  } }); const basemap = new Basemap({ baseLayers: [featureLayer] }); チュートリアルへ\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/arcade/",
	"title": "Arcade",
	"tags": [],
	"description": "ArcGIS プラットフォーム標準で利用できる条件式のためのスクリプト言語 Arcade について紹介します。",
	"content": "出典：ArcGIS Maps SDK for JavaScript - Arcade\nArcade とは ArcGIS プラットフォームで使用するために作られた軽量でセキュアな条件式のためのスクリプト言語です。 他の一般的な式言語のように、数学的な計算や評価ロジックの命令語を利用できます。 ArcGIS プラットフォームにおける独自のデータ可視化とラベル表現の作成のためにデザインされており、独自の命令語を ArcGIS Pro や ArcGIS Online、ArcGIS Runtime SDK、ArcGIS Maps SDK for JavaScript で編集・共有・実行することができます。\nArcade が他のスクリプト言語に比べてユニークなのは、ジオメトリ関数を含んでいるところです。 ジオメトリ関数は、面積や長さの計算、トポロジ リレーションシップのテスト、そしてシンプルなオーバーレイの実行を可能にします。 現在のリリースでは、ジオメトリの作成と参照が可能です。 しかし、Arcade バージョン 1.3 で導入されたジオメトリの操作は、4.x 系の ArcGIS Maps SDK for JavaScript ではサポートされていません。\nArcade バージョン 1.3 で導入されたジオメトリ関数は、4.x 系の ArcGIS Maps SDK for JavaScript ではサポートされていません。3.x 系の API では、バージョン 3.23 以上で使用できます。将来的には、4.x でのサポートを予定しています。\nシンタックス Arcade のシンタックスは JavaScript ライクに変数の宣言やロジックの実行、関数の記述などができます。 しかし、二つの言語間にはいくつか異なる部分があります。 記述方法の詳細については、Arcade ドキュメント（英語）をご参照ください。 また、ArcGIS Arcade Playground では独自のスクリプトをテスト実行するための環境を提供していますので、アクセスしてみてください。\nArcade には外部データにアクセスするためのグローバル変数が用意されています。 $feature というグローバル変数は、フィーチャ レイヤー内のフィーチャが持つフィールド値にアクセスするために使用します。 以下のシンタックスを使用することでフィールド値を参照できます。\n$feature.fieldName このように、ランタイムでフィールド値を使用したシンプルな計算を容易に実行できます。\n// 民主党候補者に投票した人の割合（%）を計算 ($feature.DEM_VOTES / $feature.TURNOUT ) * 100 Arcade はコンテクスト内、または Arcade が理解されるプロファイル内でのみ実行可能です。JavaScript アプリでは、式は常に文字列の値として参照されます。Arcade は、シンプルな一行の式、または、より複雑な複数行からなる式として書かれます。\n一行の式を書くとき、シンプルにダブルまたはシングル クォーテーションで囲みます。\nrenderer.valueExpression = \u0026#34;Round( ($feature.AGE_18UP / $feature.TOTAL_POP) * 100 )\u0026#34;; 複数行に渡る式を書くとき、JavaScript の外に \u0026lt;script\u0026gt; タグを分け、タイプを text/plain に設定し、JavaScript から参照できるようユニークな ID を付与して配置することが推奨されます。\n\u0026lt;script type=\u0026#34;text/plain\u0026#34; id=\u0026#34;adult-population\u0026#34;\u0026gt; // 複数行の式を記述 \u0026lt;/script\u0026gt; そして、JavaScript は、document.getElementById() メソッドを呼ぶことで、文字列として参照します。\nrenderer.valueExpression = document.getElementById(\u0026#34;adult-population\u0026#34;).text; 下記のスニペットや Create a custom visualization using an Arcade expression サンプルを参照ください。\nプロファイル Arcade はいくつかのプロファイルにおける使用のためにデザインされました。プロファイルとは、理解し使用される命令語のコンテクストです。ArcGIS API 4.5 for JavaScript では、ビジュアライゼーション、ポップアップ、ラベリング（3D のみサポート）の３つのプロファイルをサポートしています。3D では、Arcade を使用することにより、フィーチャの標高を計算することも可能です。\nビジュアライゼーション ビジュアライゼーション プロファイルにおいて、Arcade を使ってランタイムで FeatureLayer (フィーチャ レイヤー) あるいは SceneLayer (シーン レイヤー) 内の各フィーチャが持つ値を計算することができます。 また、データドリブンな可視化のための基盤として、それらの値を使用することができます。 これは、レイヤー内の単一フィールド値をもとにしたデータ ビジュアライゼーションを作成するための別のアプローチになります。 これによって、Arcade 命令語は field/normarizationField あるいは JavaScript 関数の代わりに ClassBreaksRenderer (数値分類) や UniqueValueRenderer (個別値分類)、その他の可視化変数 (color, size, opacity, rotation) の valueExpression プロパティに渡されます。\nArcade は FeatureLayer と SceneLayer におけるビジュアライゼーションの作成のみサポートします。 ClassBreaks と UniqueValueRenderer を利用できる他のレイヤー (例えば、MapImageLayer) は Arcade をサポートしていません。\nClassBreaksRenderer あるいはその他の可視化変数を使用する際、命令語は必ず数値を評価してください。 UniqueValueRenderer は文字列と数値のいずれも評価して構いません。\n以下の例では、Arcade 命令語が UniqueValueRenderer の valueExpression プロパティを使用しています。 アメリカの州を表すフィーチャ レイヤーのためにビジュアライゼーションを作成します。 このサービスは各州における共和党、民主党、無所属に対する得票数という 3 つのフィールドを持ちます。 そこで、得票数で勝った党を各州で可視化したいとします。 サービスには優勢な党を示すフィールドが含まれていません。 したがって、Arcade を使ってその党を明らかにしましょう。\n// まず、各フィールドの属性値の参照と変数宣言を記述しています。 // Max() 関数を使って最大数を算出し、 // 最大数を持つ党を判定するために Decode() 関数を使います。  var arcade = \u0026#34;var republican = $feature.MP06025a_B;\u0026#34; + \u0026#34;var democrat = $feature.MP06024a_B;\u0026#34; + \u0026#34;var independent = $feature.MP06026a_B;\u0026#34; + \u0026#34;var parties = [republican, democrat, independent];\u0026#34; // Decode() と Max() は Arcade 組み込みの関数です。  + \u0026#34;Decode( Max(parties),\u0026#34; + \u0026#34; republican, \u0026#39;republican\u0026#39;,\u0026#34; + \u0026#34; democrat, \u0026#39;democrat\u0026#39;,\u0026#34; + \u0026#34; independent, \u0026#39;independent\u0026#39;,\u0026#34; + \u0026#34; \u0026#39;n/a\u0026#39;);\u0026#34;; // `valueExpression` プロパティに Arcade で記述した式を割り当て、 // Decode() で処理された値をもとに個別値の情報を設定します。  var renderer = new UniqueValueRenderer({ valueExpression: arcade, valueExpressionTitle: \u0026#34;Counties by dominant party among registered voters\u0026#34;, uniqueValueInfos: [{ value: \u0026#34;democrat\u0026#34;, symbol: createSymbol(\u0026#34;#00c3ff\u0026#34;), label: \u0026#34;Democrat\u0026#34; }, { value: \u0026#34;republican\u0026#34;, symbol: createSymbol(\u0026#34;#ff002e\u0026#34;), label: \u0026#34;Republican\u0026#34; }, { value: \u0026#34;independent\u0026#34;, symbol: createSymbol(\u0026#34;#faff00\u0026#34;), label: \u0026#34;Independent/non-affiliated\u0026#34; }] }); また、各州における優勢な党の相対的な力を示すために renderer に対して opacity の可視化変数を追加します。 より多くの人々が特定の党に投票している州を高い透過率でし、各党に対する得票数が拮抗している州は低い透過率で描画してみましょう。\n// まず、各フィールドの属性値の参照と変数宣言を記述しています。 // Max() 関数を使って最大数を、 // Sum() 関数ですべての党の得票数の合計値を算出します。 // 合計値に対するもっとも多くの投票を得た党の得票数の割合をパーセントで返します。  var opacityArcade = \u0026#34;var republican = $feature.MP06025a_B;\u0026#34; + \u0026#34;var democrat = $feature.MP06024a_B;\u0026#34; + \u0026#34;var independent = $feature.MP06026a_B;\u0026#34; + \u0026#34;var parties = [republican, democrat, independent];\u0026#34; + \u0026#34;var total = Sum(parties);\u0026#34; + \u0026#34;var max = Max(parties);\u0026#34; + \u0026#34;return (max / total) * 100;\u0026#34;; // `valueExpression` プロパティに Arcade で記述した式を割り当て、 // 返り値であるパーセントに応じて透過率を設定します。  var opacityVV = { type: \u0026#34;opacity\u0026#34;, valueExpression: opacityArcade, stops: [ { value: 33, opacity: 0.1 }, { value: 50, opacity: 1.0 } ] }; // 先に作成したレンダラーに透過率による可視化変数を追加します。  renderer.visualVariables = [ opacityVV ]; 実際にビジュアライゼーションを行った結果はサンプル アプリ (Create a custom visualization using Arcade) で確認してみてください。\nポップアップ Arcadeを PopupTmplate のコンテンツ  内で参照することもできます。ビジュアライゼーション プロファイルと同様に、 FeatureLayer  インスタンスに属性値として存在しないデータを表示する場合に便利です。 例えば、サンプルアプリ （ Reference Arcade expressions in PopupTemplate ）では、各米国郡の労働統計を含むレイヤーを表示します。いくつかの属性には、失業率、人口、および労働人口が含まれます。労働参加率の属性は含まれていません。 Arcade を使用して、実行時に算出することができます。\n// 労働参加率を計算 Round(($feature.CIVLBFR_CY / $feature.POP_16UP)*100,2) この式から返された値を使用して、レイヤーを視覚化したり、レイヤーの PopupTmplate に表示したりすることができます。ポップアップで値を表示するには、PopupTmplate の expressioninfo プロパティで値を参照し、 name と title を割り当てる必要があります。\nlayer.popupTemplate = {　expressionInfos: [{　name: \u0026#34;participation-rate\u0026#34;,　title: \u0026#34;% of population 16+ participating in the labor force\u0026#34;,　expression: \u0026#34;Round(($feature.CIVLBFR_CY / $feature.POP_16UP)*100,2)\u0026#34;　}],　content: \u0026#34;In {NAME} county, {expression/participation-rate}% of the population\u0026#34;　+ \u0026#34; participates in the labor force.\u0026#34;　};　式が expressionInfos プロパティに存在すると、 PopupTemplate のコンテンツ内の{expession/expression-name} プレースホルダー テンプレートを使用して式から返された値を参照できます。 ポップアップのコンテンツは、ユーザーが Greenlee , AZ を表現しているフィーチャーをクリックした後に次のように表示されます。\nまた、PopupTmplate　のコンテンツ の fieldinfos　プロパティの中で Arcade から返された値を参照できるため、表形式で表示することもできます。オブジェクトの fieldName プロパティで式の名前を参照するだけです。なお、 expression/expression-name シンタックスを使用してください。\nlayer.popupTemplate = { expressionInfos: [{ name: \u0026#34;participation-rate\u0026#34;, title: \u0026#34;% of population 16+ participating in the labor force\u0026#34;, expression: \u0026#34;Round(($feature.CIVLBFR_CY / $feature.POP_16UP)*100,2)\u0026#34; }], content: [{ type: \u0026#34;fields\u0026#34;, fieldInfos: [{ fieldName: \u0026#34;expression/participation-rate\u0026#34; }] }] }; ポップアップには以下のように表示されます。\nPopupTmplate の fieldinfos プロパティの書式設定オプションを利用して、式から返された数値を書式設定することもできます。 このワークフローはサンプルアプリ（PopupTemplate Reference Arcade）でご覧ください。\nラベリング ラベリングは、現在、3D SceneView のみサポートしています。2D MapView でのラベリングは将来のリリースで追加される予定です。\nArcade は、FeatureLayer または SceneLayer に含まれるフィーチャのラベルの式を作成するためにも使用されます。バージョン 4.5 からは、フィーチャをラベリングするためにサポートされた唯一の方法です。\n少なくともひとつの LabelClass をレイヤーの LabelingInfo プロパティへ追加し、labelsVisible プロパティを true へ設定する必要があります。式は、LabelClass の labelExpressionInfo オブジェクトの expression プロパティへ文字列として渡します。\n// レイヤーのフィールド値を返す // フィールド値は各フィーチャのラベルに使用される var arcade = \u0026#34;$feature.STATION_NAME\u0026#34;; // new LabelClass() の autocast オブジェクト var labelClass = { // 式を labelExpressionInfo の `expression` プロパティに設定する  labelExpressionInfo: { expression: arcade }, labelPlacement: \u0026#34;below-right\u0026#34;, minScale: 2500000, symbol: { type: \u0026#34;label-3d\u0026#34;, symbolLayers: [{ type: \u0026#34;text\u0026#34;, material: { color: \u0026#34;white\u0026#34; }, halo: { color: \u0026#34;black\u0026#34;, size: 1 }, size: 8 }] } }; // LabelClass を FeatureLayer へ設定 featureLayer.labelingInfo = [ labelClass ]; featureLayer.labelsVisible = true; Arcade で書かれたラベル式は、数学的で論理的な操作を実行する複数行に渡るもっと複雑な式になるかもしれません。例えば、Label features using Arcade expressions サンプルは、より複雑な複数行に渡るラベル式を示しています。この式は２つの数値フィールドの値を変数に入れ、評価し、文字列を返します。Arcade の When() は、風向き（0 - 360 度）を評価し、N、NE、E、SE、S、SW、W または NW のいずれかの関連する方角を返します。風力が 0 のとき、方角は返されません。式の最後で、ラベル（WIND 変数の値）を返します。\n\u0026lt;script type=\u0026#34;text/plain\u0026#34; id=\u0026#34;wind-direction\u0026#34;\u0026gt; var DEG = $feature.WIND_DIRECT; var SPEED = $feature.WIND_SPEED; var DIR = When( SPEED == 0, \u0026#39;\u0026#39;, (DEG \u0026lt; 22.5 \u0026amp;\u0026amp; DEG \u0026gt;= 0) || DEG \u0026gt; 337.5, \u0026#39;N\u0026#39;, DEG \u0026gt;= 22.5 \u0026amp;\u0026amp; DEG \u0026lt; 67.5, \u0026#39;NE\u0026#39;, DEG \u0026gt;= 67.5 \u0026amp;\u0026amp; DEG \u0026lt; 112.5, \u0026#39;E\u0026#39;, DEG \u0026gt;= 112.5 \u0026amp;\u0026amp; DEG \u0026lt; 157.5, \u0026#39;SE\u0026#39;, DEG \u0026gt;= 157.5 \u0026amp;\u0026amp; DEG \u0026lt; 202.5, \u0026#39;S\u0026#39;, DEG \u0026gt;= 202.5 \u0026amp;\u0026amp; DEG \u0026lt; 247.5, \u0026#39;SW\u0026#39;, DEG \u0026gt;= 247.5 \u0026amp;\u0026amp; DEG \u0026lt; 292.5, \u0026#39;W\u0026#39;, DEG \u0026gt;= 292.5 \u0026amp;\u0026amp; DEG \u0026lt; 337.5, \u0026#39;NW\u0026#39;, \u0026#39;\u0026#39; ); var WIND = SPEED + \u0026#39; mph \u0026#39; + DIR; return WIND; \u0026lt;/script\u0026gt; そのほかにも、テキスト整形のロジックを提供するテキスト関数を含む、ラベリングに役立つ多くの関数が用意されています。詳細は Arcade をご参照ください。\nその他のケース 標高 3D SceneView では、Arcade を使用してフィーチャごとに独自の標高を設定できます。フィーチャは Z 値を持つことができますが、属性値や Z 値を使用した計算式をもとに高さを演算したい場合に有効です。さらに、Z 値を含まないが、属性フィールドに Z 値に関連する情報を持つデータの場合、featureExpressionInfo.expression プロパティに式を設定できます。例として、Elevation options サンプルは Arcade を使用してポイント シンボルの高さがどのように変化するのかを示しています。\nlayer.elevationInfo = { mode: \u0026#34;absolute-height\u0026#34;, featureExpressionInfo: { expression: \u0026#34;Geometry($feature).z + $feature.HEIGHT\u0026#34; }, unit: \u0026#34;meters\u0026#34; }; 上記の例では、独自の HEIGHT 属性がジオメトリの Z 値として、グラフィックの標高に設定されます。ラインまたはポリゴン フィーチャにおいて、すべてのフィーチャの頂点は expression の戻り値の標高を持ちます。\nプレイグラウンドでは、入力フィーチャ サービスからインポートしたフィールド値をもとに、ブラウザーから式をビルド、デバッグ、テストできます。Console() 機能を使い、複雑なスクリプトをデバッグすることも可能です。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/ios/",
	"title": "ArcGIS Maps SDK for Swift",
	"tags": [],
	"description": "ArcGIS Maps SDK for Swift の開発に役立つガイド集です。",
	"content": "ArcGIS Maps SDK for Swift (バージョン 200.x) の開発に役立つガイド集です。\n インストール ガイド\nArcGIS Maps SDK for Swift のインストールとセットアップ手順を紹介します。\n\r アプリケーション配布ガイド\nArcGIS Maps SDK for Swift を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を紹介します。\n\r バージョン 100.x から 200.x への移行\n今まで ArcGIS Runtime SDK for iOS バージョン 100.x を使用してアプリケーションを開発されていた開発者向けのガイドです。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-cesium/",
	"title": "CesiumJS",
	"tags": [],
	"description": "CesiumJS を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。",
	"content": "シーンを表示する このチュートリアルでは、CesiumJS と ベースマップ レイヤー サービスを使用して、シーンを表示する方法を紹介します。\nArcGIS マップ タイル サービスを使用すると、CesiumJS で地図が表示できます。例えば ArcGIS:Imagery マップ タイル レイヤーには、世界の地形と組み合わせて使用できる、グローバルなカバレッジを持つ衛星画像が含まれています。\nこのチュートリアルでは、ArcGIS:Imagery と Cesium World Terrain を使用して、富士山周辺のシーンを表示します。\nベースマップ レイヤーの詳細については、Mapping APIs and services ガイドの Basemaps とベースマップを参照してください。\n\r前提条件 この機能を使うには、ArcGIS アカウントが必要です。アカウントの作成手順については「開発者アカウントの作成」を参照してください。\nステップ 新しい Pen の作成 CodePen にアクセスして、新しい Pen を作成します。\nHTML の追加 HTML ページを定義して、Web ブラウザの幅と高さにあわせたマップを作成します。\n CodePen \u0026gt; HTML で、HTML と CSS を追加して、cesiumContainer という id 属性を持つ div 要素のあるページを作成します。 cesiumContainer は、マップを表示するために使用される id 属性です。CSS はブラウザの設定をリセットして、マップがブラウザの幅と高さ全体に表示されるようにします。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;CesiumJS: Display a Scene\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #cesiumContainer { margin: 0; padding: 0; width: 100%; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;cesiumContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; スクリプト参照の追加  \u0026lt;head\u0026gt;タグで、CesiumJS CSS および JS ライブラリへの参照を追加します。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;CesiumJS: Display a Scene\u0026lt;/title\u0026gt; \u0026lt;!-- cesium js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;style\u0026gt; html, body, #cesiumContainer { margin: 0; padding: 0; width: 100%; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;cesiumContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Cesium ion アクセス トークンの取得 すべての Cesium アプリケーションは、Cesium ion を通じて提供されるアクセス トークンを使用する必要があります。このトークンによって、アプリケーションで Cesium World Terrain などのアセットにアクセスできるようになります。\n Cesium ion のダッシュボード にアクセスし、アクセス トークンを生成し、取得します。 \u0026lt;body\u0026gt;タグ内に\u0026lt;script\u0026gt;タグを追加します。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;CesiumJS: Display a Scene\u0026lt;/title\u0026gt; \u0026lt;!-- cesium js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;style\u0026gt; html, body, #cesiumContainer { margin: 0; padding: 0; width: 100%; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;cesiumContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script のタグを追加--\u0026gt; \u0026lt;script\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 変数 cesiumAccessToken を作成し、Cesium ion ダッシュボードからコピーしたアクセス トークンを格納し、Cesium.Ion.defaultAccessToken に設定します。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;CesiumJS: Display a Scene\u0026lt;/title\u0026gt; \u0026lt;!-- cesium js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;style\u0026gt; html, body, #cesiumContainer { margin: 0; padding: 0; width: 100%; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;cesiumContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script のタグを追加--\u0026gt; \u0026lt;script\u0026gt; // 取得した Cesium ion のアクセス トークンを貼り付け  const cesiumAccessToken = \u0026#34;YOUR_CESIUM_ACCESS_TOKEN\u0026#34;; // Cesium ion へのアクセス トークンを cesiumAccessToken に設定  Cesium.Ion.defaultAccessToken = cesiumAccessToken; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ArcGIS APIキーの取得 ロケーション サービスにアクセスするには、API キーまたは OAuth2.0 アクセス トークンが必要です。API キーの作成手順については「API キーの取得」を参照してください。\n認証方法とアクセストークンの取得方法の詳細については、「セキュリティと認証」を参照してください。\n  開発者ダッシュボードに移動して、API キーを取得します。\n  作成した ArcGIS API キーを変数 apiKey に格納し、Cesium.ArcGisMapService.defaultAccessToken に設定します。\n  CesiumJS で利用可能な ArcGIS サービスの詳細については、Key features を参照してください。\n\r\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;CesiumJS: Display a Scene\u0026lt;/title\u0026gt; \u0026lt;!-- cesium js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;style\u0026gt; html, body, #cesiumContainer { margin: 0; padding: 0; width: 100%; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;cesiumContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script のタグを追加--\u0026gt; \u0026lt;script\u0026gt; // ArcGIS API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ArcGIS API キーを Cesium.ArcGisMapService.defaultAccessToken に設定  Cesium.ArcGisMapService.defaultAccessToken = apiKey; // 取得した Cesium ion のアクセス トークンを貼り付け  const cesiumAccessToken = \u0026#34;YOUR_CESIUM_ACCESS_TOKEN\u0026#34;; // Cesium ion へのアクセス トークンを cesiumAccessToken に設定  Cesium.Ion.defaultAccessToken = cesiumAccessToken; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; シーンの作成 World Imagery マップ タイル レイヤーにアクセスする Viewer を作成します。ArcGisMapServerImageryProvider クラスを使用して、ベースマップ スタイル サービスに認証済み要求を行います。\n SATTELITE ベースマップ タイプを使用して新しい ArcGisMapServerImageryProvider クラスを作成します。SATTELITE ベースマップ タイプは、ArcGIS:World Imagery マップ タイル サービスにアクセスします。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;CesiumJS: Display a Scene\u0026lt;/title\u0026gt; \u0026lt;!-- cesium js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;style\u0026gt; html, body, #cesiumContainer { margin: 0; padding: 0; width: 100%; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;cesiumContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script のタグを追加--\u0026gt; \u0026lt;script\u0026gt; // ArcGIS API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ArcGIS API キーを Cesium.ArcGisMapService.defaultAccessToken に設定  Cesium.ArcGisMapService.defaultAccessToken = apiKey; // 取得した Cesium ion のアクセス トークンを貼り付け  const cesiumAccessToken = \u0026#34;YOUR_CESIUM_ACCESS_TOKEN\u0026#34;; // Cesium ion へのアクセス トークンを cesiumAccessToken に設定  Cesium.Ion.defaultAccessToken = cesiumAccessToken; // fromBasemapType メソッドを利用して ArcGIS のベースマップを呼び出し  const arcGisImagery = Cesium.ArcGisMapServerImageryProvider.fromBasemapType(Cesium.ArcGisBaseMapType.SATELLITE); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; CesiumContainer に接続された Cesium.Viewer クラスを作成します。 Cesium.ImageryLayer.fromProviderAsync メソッドで、baseLayer プロパティを設定します。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;CesiumJS: Display a Scene\u0026lt;/title\u0026gt; \u0026lt;!-- cesium js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;style\u0026gt; html, body, #cesiumContainer { margin: 0; padding: 0; width: 100%; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;cesiumContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script のタグを追加--\u0026gt; \u0026lt;script\u0026gt; // ArcGIS API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ArcGIS API キーを Cesium.ArcGisMapService.defaultAccessToken に設定  Cesium.ArcGisMapService.defaultAccessToken = apiKey; // 取得した Cesium ion のアクセス トークンを貼り付け  const cesiumAccessToken = \u0026#34;YOUR_CESIUM_ACCESS_TOKEN\u0026#34;; // Cesium ion へのアクセス トークンを cesiumAccessToken に設定  Cesium.Ion.defaultAccessToken = cesiumAccessToken; // fromBasemapType メソッドを利用して ArcGIS のベースマップを呼び出し  const arcGisImagery = Cesium.ArcGisMapServerImageryProvider.fromBasemapType(Cesium.ArcGisBaseMapType.SATELLITE); // CesiumContainer に接続された Cesium.Viewer クラスを作成  const viewer = new Cesium.Viewer(\u0026#34;cesiumContainer\u0026#34;, { // Cesium のベースマップを SATELLITE に設定  baseLayer: Cesium.ImageryLayer.fromProviderAsync(arcGisImagery), }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; オプションの追加パラメーターを設定し、Viewer の外観を構成します。今回は、timeline、animation、geocoder コントロールを無効にし、Cesium World Terrain を追加します。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;CesiumJS: Display a Scene\u0026lt;/title\u0026gt; \u0026lt;!-- cesium js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;style\u0026gt; html, body, #cesiumContainer { margin: 0; padding: 0; width: 100%; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;cesiumContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script のタグを追加--\u0026gt; \u0026lt;script\u0026gt; // ArcGIS API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ArcGIS API キーを Cesium.ArcGisMapService.defaultAccessToken に設定  Cesium.ArcGisMapService.defaultAccessToken = apiKey; // 取得した Cesium ion のアクセス トークンを貼り付け  const cesiumAccessToken = \u0026#34;YOUR_CESIUM_ACCESS_TOKEN\u0026#34;; // Cesium ion へのアクセス トークンを cesiumAccessToken に設定  Cesium.Ion.defaultAccessToken = cesiumAccessToken; // fromBasemapType メソッドを利用して ArcGIS のベースマップを呼び出し  const arcGisImagery = Cesium.ArcGisMapServerImageryProvider.fromBasemapType(Cesium.ArcGisBaseMapType.SATELLITE); // CesiumContainer に接続された Cesium.Viewer クラスを作成  const viewer = new Cesium.Viewer(\u0026#34;cesiumContainer\u0026#34;, { // Cesium のベースマップを SATELLITE に設定  baseLayer: Cesium.ImageryLayer.fromProviderAsync(arcGisImagery), // Viewer のオプションを設定。  terrain: Cesium.Terrain.fromWorldTerrain(), timeline: false, animation: false, geocoder:false }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; viewer.camera.setView を使用して、シーンのカメラの位置は河口湖付近に設定し、少し上から見下ろしているような視点にします。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;CesiumJS: Display a Scene\u0026lt;/title\u0026gt; \u0026lt;!-- cesium js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;style\u0026gt; html, body, #cesiumContainer { margin: 0; padding: 0; width: 100%; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;cesiumContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script のタグを追加--\u0026gt; \u0026lt;script\u0026gt; // ArcGIS API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ArcGIS API キーを Cesium.ArcGisMapService.defaultAccessToken に設定  Cesium.ArcGisMapService.defaultAccessToken = apiKey; // 取得した Cesium ion のアクセス トークンを貼り付け  const cesiumAccessToken = \u0026#34;YOUR_CESIUM_ACCESS_TOKEN\u0026#34;; // Cesium ion へのアクセス トークンを cesiumAccessToken に設定  Cesium.Ion.defaultAccessToken = cesiumAccessToken; // fromBasemapType メソッドを利用して ArcGIS のベースマップを呼び出し  const arcGisImagery = Cesium.ArcGisMapServerImageryProvider.fromBasemapType(Cesium.ArcGisBaseMapType.SATELLITE); // CesiumContainer に接続された Cesium.Viewer クラスを作成  const viewer = new Cesium.Viewer(\u0026#34;cesiumContainer\u0026#34;, { // Cesium のベースマップを SATELLITE に設定  baseLayer: Cesium.ImageryLayer.fromProviderAsync(arcGisImagery), // Viewer のオプションを設定。  terrain: Cesium.Terrain.fromWorldTerrain(), timeline: false, animation: false, geocoder:false }); // カメラの位置と角度を設定  viewer.camera.setView({ destination : Cesium.Cartesian3.fromDegrees(138.74482706645605,35.509217041554955, 3500), orientation : { heading : Cesium.Math.toRadians(180.0), pitch : Cesium.Math.toRadians(-10.0), } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; アプリの実行 CodePen で、作成したコードを実行してシーンを表示します。\n表示されるシーンには、日本の富士山周辺の衛星画像が 3D で表示されています。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/python-api-jnlabsetup/",
	"title": "Jupyter Lab を使ってみよう",
	"tags": [],
	"description": "ArcGIS API for Python の実行に便利な Jupyter Notebook の基本的な起動と使用方法を簡単に紹介します。",
	"content": "JupyterLab は、コード、データ、そして Jupyter Notebook のファイル形式（*.ipynb）を扱う最新の対話型開発環境（IDE）です。Jupyter Notebook 同様、オープンソースとして公開されています。 ArcGIS API for Python（以下、Python API ）のバージョン 1.5.0 以降で対応しています。\nJupyterLab で GIS データとグラフの操作\n\rJupyterLab は、より柔軟で強力なユーザー体験を実現するために Jupyter Notebook の主要コンポーネント (ノートブック、ターミナル、テキスト エディター、ファイル ブラウザー、ipywidgets など) をベースに構築されています。JupyterLab の詳細は JupyterLab のブログや GitHub をご参照ください。\nJupyterLab をはじめる Python API を JupyterLab で使用するためには、いくつかインストールなどの設定が必要です。\nインストール   バージョン 1.5.0 以上の Python API をインストールするか、既存の環境を 1.5.0 以上にアップデートする ターゲットの仮想環境がある場合は、アクティベート（activate）してから行います。Python API のインストールまたはアップデートの方法はインストールガイドをご覧ください。\n  次の 2 つのコマンドを実行します\n jupyter labextension install @jupyter-widgets/jupyterlab-manager jupyter labextension install arcgis-map-ipywidget@バージョン番号    2 つ目のコマンドの最後にある「バージョン番号」部分は、使用する Python API のバージョンに合わせて変更してください (例：1.6.1)。\nエラー等で正常に完了できない場合は、お使いの端末または現在の環境に npm および nodejs をインストールする必要があります。インストールの詳細は npm のウェブサイト、または node.js のウェブサイトを参照してください。\n\r\\anaconda3\\share\\jupyter\\lab\r@jupyter-widgets/jupyterlab-manager v0.38.1 enabled ok\rarcgis-map-ipywidget v1.5.1 enabled ok\r``` --\r 以上の設定が完了したら、次のコマンドで JupyterLab を起動します。  jupyter lab    任意のディレクトリをルート ディレクトリとして起動したい場合は、cd コマンドでディレクトリを移動してから起動コマンドを実行します。\nファイルエクスプローラー JupyterLab は、従来の Jupyter Notebook のように、既存のノートブックを開いたり、新しいノートブックを作成したり、コンテンツを整理するためのファイルエクスプローラを備えています。 JupyterLab のファイルエクスプローラは、メインビューの左側のウィンドウです。\n\rJupyterLab も Jupyter Notebook と同様に、ノートブック形式（*.ipynb）で動作しコードや結果を保存できます。この 2 つのツールの違いは、主にユーザーインターフェースといくつかの外部エクステンションが追加された点です。\nウィンドウとタブを使用する JupyterLab には、Jupyter Notebook とは違って、「ウィンドウ」と「タブ」という概念があります。 これにより、ノートブックを重ねたり、横に並べたり、タブで整理したりすることができます。これらの操作は、以下のように「タブ」をクリックしてドラッグするだけで可能です。\n\rどのようなウィンドウでもこのようにドラッグすることが可能です。*.csv、*.json などのファイルも表示や編集することができます。\rセルの使用 上記のウィンドウとタブと同様に、JupyterLab ではノートブックのセルをドラッグアンドドロップして移動することができます。 JupyterLab は、1 つのノートブックから別のノートブックにセルをドラッグする機能もサポートしています。 移動したいセルの左側の領域をクリックして、それをドラッグします。\n\rJupyterLab では、Shift キーを押しながら複数のセルを選択することもできます。前述のようにこれらのセルを移動するか、右クリックして [Copy Cells] を選択してコピーします。また、右クリックのメニューには、[Create New View For Output] を含む多くのオプションがあります。[Create New View For Output] を使用すると、任意のセルの実行結果を別のタブで表示することができ、重ねたり、並べて表示したりすることができます。\n\rJupyterLab には他にも様々なセルの操作ができるので、いろいろと探してみてください！\rマップ ウィジェットとの連携 バージョン 1.5.0 以上の Python API では、2D 回転、3D モード、3D レンダラーのサポートなどマップ ウィジェットの機能が多数追加されています。これらの機能の詳細については、ガイドページ（米国ESRI ページ）でご紹介しています。このガイドでは、マップ ウィジェットと JupyterLab のシームレスな連携を紹介します。\n\rPython API の MapView クラスのデフォルトの表示動作は、Jupyter Notebook と同じで、ウィジェットはセルの出力にマップが表示されます。JupyterLab では、これに加えて以下のようなボタンが表示されます。\n\rこのボタンを押すと、ウィジェットが新しいウィンドウで表示されます。 このウィンドウは、他のすべてのウィンドウと同様に、タブでの表示、分割などが可能です。 ウィジェットを元に戻すには、以下のボタンを押します。\n\rここからは、実際にコードを試してみましょう。 以下のセルを実行します。\nfrom arcgis.gis import GIS # JupyterLab へ地図を表示する gis = GIS() map = gis.map() map \rWeb マップ と Web シーン Web マップ、Web シーン の両方とも、このボタンを使用することができます。\nfrom arcgis.mapping import WebMap webmap_item = gis.content.get(\u0026#34;ab42b088573d4253a22a8b38ee698ccd\u0026#34;) webmap = WebMap(webmap_item) webmap from arcgis.mapping import WebScene webscene_item = gis.content.get(\u0026#34;421433baeb8d487b903d4a89df79149b\u0026#34;) webscene = WebScene(webscene_item) webscene \rプログラムによるウィンドウの制御 ここまではこの機能をマウスで実行しましたが、Pythonを使用して制御することもできます。 MapView ウィジェットの各インスタンスには、tab_mode プロパティと toggle_window_view（） メソッドがあります。tab_mode を設定すると、地図ウィジェットの新しいウィンドウへの移動方法が変更されます。 この動作を試すには、以下のコードを実行してみてください。\n# 対象の地図を表示する map = gis.map() map # コメントをひとつずつオフにして実行し、map で表示している地図の UI ボタンを都度押してみてください。 # map.tab_mode = \u0026#34;split-bottom\u0026#34; # map.tab_mode = \u0026#34;split-right\u0026#34; # map.tab_mode = \u0026#34;auto\u0026#34; # map.tab_mode = \u0026#34;tab-after\u0026#34; \rUI ボタンによる新しいウィンドウでの地図表示は、toggle_window_view（） メソッドを使用することでも制御できます。次のコードでは、マップが表示されたらメソッドを使用して新しいウィンドウで表示させます。新しいウィンドウに戻すときも、このメソッドを使用可能です。 以下のコードを実行してみてください。\nfrom arcgis.widgets import MapView # 対象の地図を表示する map = MapView(gis=gis) map map.toggle_window_view() \rタイトル（タブに表示されるテキスト）と tab_mode をメソッドを呼び出すたびに指定することも可能です。\n# 対象の地図を表示する map = gis.map(mode=\u0026#34;3D\u0026#34;) map # このセルを実行して、新しいウィンドウに地図を表示します map.toggle_window_view(title=\u0026#34;My 3D Map\u0026#34;, tab_mode=\u0026#34;split-top\u0026#34;) # ウィンドウを元に戻す map.toggle_window_view() import time # このセルを実行して全てのタブモードの挙動を確認してみてください tab_modes = [\u0026#39;auto\u0026#39;, \u0026#39;split-top\u0026#39; \u0026#39;split-bottom\u0026#39;, \u0026#39;split-left\u0026#39;, \u0026#39;split-right\u0026#39;, \u0026#39;tab-before\u0026#39;, \u0026#39;tab-after\u0026#39;] for tab_mode in tab_modes: # 新しいウィンドウで開く map.toggle_window_view(title=tab_mode, tab_mode=tab_mode) time.sleep(4) # ウィンドウを元に戻す map.toggle_window_view() time.sleep(4) \r最後に、3 つ以上の Web シーンを表示すると仮定した表示方法をご紹介します。各マップ ID で構成したリストから、1 度だけ処理を実行し、3 つの　Web シーンを一度にすべて新しいタブに表示します。\n#このセルの内容を1度で実行する from arcgis.gis import GIS from arcgis.widgets import MapView gis = GIS() for webscene_id in [\u0026#39;31874da8a16d45bfbc1273422f772270\u0026#39;, \u0026#39;91b46c2b162c48dba264b2190e1dbcff\u0026#39;, \u0026#39;46c47340708f446ba7f112f139e8ae5e\u0026#39;]: webscene_item = gis.content.get(webscene_id) map = MapView(gis=gis, item=webscene_item, mode=\u0026#34;3D\u0026#34;) map.toggle_window_view(title=webscene_item.title, tab_mode=\u0026#39;tab-after\u0026#39;) \rより詳細な情報は、マップ ウィジェットの API リファレンスを参照してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/getting-started-widget/",
	"title": "ウィジェット開発のスタート",
	"tags": [],
	"description": "ウィジェット開発に使用しているライブラリから開発に必要な概要までを紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Getting started with widget development\nArcGIS Experience Builder は、React と ArcGIS Maps SDK for JavaScript を使用して構築されています。これにより、特定のワークフローに合わせて、カスタム ウィジェットを作成することができます。独自のウィジェットを作成するには、以下の基本的な理解が必要となります。\n TypeScript は、JavaScript のスーパーセットです。TypeScript は、ウィジェットの開発に使用される言語です。 React は、ユーザーインターフェースを作成するための JavaScript ライブラリです。React は DOM を抽象化したもので、アプリケーションや UI を様々な状態で考え、それらの状態をレンダリングすることで、UI の一貫性を保つことを容易にしています。 JSX は JavaScript の拡張構文で、React を通じてウィジェットの UI のあるべき姿を記述することができます。 Jimu は、Experience Builder がウィジェットを作成する際に使用する JavaScript ライブラリです。  インストール Experience Builder は、インストール用の ZIP ファイルとして提供されています。詳細については、インストールガイドを参照してください。\nウィジェット ウィジェットは、Experience Builder で設定可能で共有可能な機能群です。基本的に、ウィジェットは jimu フレームワークによってこれらの共通のプロパティが設定された React コンポーネントです。\n ウィジェットの設定 (id、label、configなど) state や isClassLoaded などを含むウィジェットのランタイム情報 ローカル言語の文字列 データソースのインスタンスとステータス情報 URL パラメータ情報  必要最小限のファイルですぐに始めるには、your-extensions\\widgets フォルダ内の simple widget を参照してください。\nウィジェット開発の詳細については、ウィジェットの実装について学習してください。\nウィジェットの配置場所 カスタム ウィジェットは Experience Builder の Web 拡張機能リポジトリに配置されます。Web 拡張機能リポジトリは、client フォルダー内のフォルダーで下のコンテンツを含む manifest.json ファイルが格納されています。\n{ \u0026#34;name\u0026#34;: \u0026#34;my-web-extension-repo\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;exb-web-extension-repo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is a sample extension repository.\u0026#34;, \u0026#34;copyright\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;\u0026#34; } Experience Builder (Developer Edition) には、client/your-extensions にサンプルの Web 拡張機能リポジトリが付属しています。このリポジトリを使用することも、独自のリポジトリを作成することもできます。Git のようなソース コード リポジトリ システムを使用する場合は、独自のものを使用した方がうまくいく場合があります。独自に作成する場合、Jimu モジュールの型宣言がないなど、コード エディター上でエラーが表示されることがあります。これを修正するには、tsconfig.json ファイル内の include 配列に、Web 拡張機能リポジトリのフォルダーを次のように追加します。\n{ \u0026#34;include\u0026#34;: [ \u0026#34;dist/widgets\u0026#34;, \u0026#34;your-extensions\u0026#34;, \u0026#34;types\u0026#34;, \u0026#34;jimu-core/lib/types\u0026#34;, /** Web 拡張機能リポジトリのフォルダー名を追加します **/ \u0026#34;my-web-extension-repo\u0026#34; ], } widget フォルダー内では、有効なウィジェットには manifest.json ファイルとその他の必須ファイルが含まれている必要があります。\nウィジェット ファイル Web 拡張機能リポジトリのルート フォルダーには、widgets と themes の 2 つのフォルダーがあります。カスタム ウィジェットを作成するには、widgets フォルダー内にカスタム ウィジェットの名前で新しいフォルダーを作成してください。カスタム ウィジェットのすべてのファイルは、この新しいフォルダーに配置されます。\n- my-web-extension-repo/ - manifest.json - themes/ - widgets/ - my-custom-widget/  manifest.json ファイルの詳細については、ウィジェット manifest を参照してください。 その他の必要なファイルや一般的なウィジェット開発の詳細については、ウィジェットの実装 を参照してください。 必要最小限のファイルですぐに始めるには、your-extensions/widgets フォルダーにある、simple ウィジェットを参照してください。  基本的な考え方 Experience Builder 開発が初めての方で、基本的な考え方を理解したい方は、以下をチェックしてください。\n コア コンセプト コードを見て学ぶのが一番良い場合は、リポジトリからクローンして、サンプルを参照してください。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/security/",
	"title": "セキュリティと認証の紹介",
	"tags": [],
	"description": "API キー、ユーザー認証、アプリ認証を使用して、サービスやセキュアなリソースに認証済みのリクエストを行う方法について説明します。",
	"content": "出典：ArcGIS Developers - Introduction to security and authentication\n認証とは、アイデンティティー（identity）を確認するプロセスです。ArcGIS は、いくつかの認証ワークフローを通じて、認証済みのアイデンティティー（identity） に対して ArcGIS のサービス、コンテンツ、およびリソースへのセキュアなアクセスをサポートします。これにより、有効かつ認証されたユーザーとアプリケーションのみが保護された情報にアクセスできるようになります。安全なリソースにアクセスするアプリケーションを構築するには、認証の種類を選択し、認証ワークフローを実装する必要があります。このセクションでは、API キー、ユーザー認証、アプリ認証を使用して、サービスやセキュアなリソースに認証済みのリクエストを行う方法について説明します。\nトピックス \r\r\r\r\r\rArcGIS リソースにアクセスする方法\n\rArcGIS アカウントとアクセス トークンを使用して保護されたリソースにアクセスする方法について説明します。\n\r\r\r\r\r\r\r\r認証の種類\n\rアクセストークンを付与する認証の種類を比較します。\n\r\r\r\r\r\r\r\rAPI キー認証\nロケーションサービスや保護されたコンテンツにアクセスするための永続的な API キーを作成します。\n\r\r\r\r\r\r\r\rユーザー認証\n\rユーザーに代わって ArcGIS リソースにアクセスするためのユーザー認証ワークフローを作成します。\n\r\r\r\r\r\r\r\rアプリケーション認証\n\rArcGIS ロケーション サービスへ安全にアクセスするために、アプリのクレデンシャル認証を実装します。\n\r\r\r\r\r\r\r\rアクセス トークン\n\rアクセス トークンとは何か、その使用方法について説明します。\n\r\r\r\r\r\r\r\rOAuth 2.0\n\rArcGIS が業界標準の OAuth2.0 認証プロトコルをどのように使用しているかを説明します。\n\r\r\r\r\r\r\r\rHTTP 認証ヘッダー\n\rHTTP 認証ヘッダーについて説明します。\n\r\r\r\r\r\r\r\rセキュリティのベストプラクティス\n\rアプリを認証するためのベスト プラクティスについて説明します。\n\r\r\rチュートリアル \r\r\rAPI キーの作成と管理\rArcGIS リソースにアクセスするための API キーを作成および設定\n\r\r\rOAuth 2.0アプリケーションの登録\r開発者ダッシュボードでのアプリケーションの登録\n\r\r\rユーザー認証の実装\rOAuth 2.0 を使用した ArcGIS ユーザーの認証\n\r\rサービス API のサポート     API キー アプリケーション認証 ユーザー認証     ArcGIS Maps SDK for JavaScript 〇 △1 〇   ArcGIS Maps SDK for .NET 〇 〇 〇   ArcGIS Maps SDK for Kotlin 〇 〇 〇   ArcGIS Maps SDK for Swift 〇 〇 〇   ArcGIS Maps SDK for Java* 〇 〇 〇   ArcGIS Maps SDK for Qt* 〇 〇 〇   ArcGIS API for Python 〇 〇 〇   ArcGIS REST JS 〇 〇 〇   Esri Leaflet 〇 △1 △2   MapLibre GL JS 〇 △1 △2   OpenLayers 〇 △1 △2    〇：対応　△：一部対応 (詳細は各 API のページを参照)　*国内未サポート\n1. トークンやユーザーセッションにアクセスし管理するために、サーバーコンポーネントを使用する必要があります。 2. OAuth 2.0 から取得したトークンの使用をサポートしていますが、ベースマップのフェデレートサーバー検証を欠いています。\nツール \n 開発者ダッシュボード  ArcGIS Developers Web サイトを使用して、API キー、サービスの使用状況、およびデータを管理します。    \n ArcGIS.com  GIS ツールを使用してコンテンツとデータを作成、管理、共有します。    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/visualization/data-visualization-procedure-3d/",
	"title": "データ可視化の手順（3D）",
	"tags": [],
	"description": "",
	"content": "ArcGIS Online が提供するシーン ビューアーを使用して、3D マップにデータを可視化する方法を紹介します。\n [3D マップを作成したい](#3D マップを作成したい) シンボルを変更したい 高さを表現したい  3D マップを作成したい シーン ビューアー → [新しいシーン] → [レイヤーの追加] → [シーンの保存]\nArcGIS Online などに公開されている Web サービスを、レイヤーとしてマップに追加し、様々なレイヤーを組み合わせて 3D マップを作成することができます。3D マップの保存には、コンテンツを作成する権限が必要です（権限を持っていない場合でも 3D マップは作成できますが、保存することはできません）。\n  シーン ビューアーを開きます。シーン ビューアーを開いた時点でベースとなる背景地図(ベースマップ)は自動的に表示されます。\n  [レイヤーの追加] をクリックします。\n  [レイヤーの検索]、[レイヤー URL の入力] いずれかのレイヤーの追加方法を選択します。\n  それぞれのレイヤー追加方法は、以下の通りです。\nレイヤーの検索   [レイヤーの検索] ボックスにキーワードを入力し、[検索] をクリックします。\n  検索結果は下部のボックス内に表示され、[追加] をクリックします。\n  [完了] をクリックし、レイヤーの追加を終了します。\n  レイヤー URL の入力 URL を指定して、ArcGIS Server Web サービスのレイヤーを追加することができます。\nシンボルを変更したい シーン ビューアー → [レイヤー] → [レイヤーの構成] → [スタイル]\nシンボルの色や形を変更します。コンテンツを作成する権限を持っている場合に可能です。\nシンボルを変更できるのは、フィーチャ レイヤーまたはシーン レイヤーです。\n  シーン ビューアーの [レイヤー] が表示されていることを確認し、シンボルを変更したいレイヤーをクリックします。\n  [レイヤーの構成] が表示されます。レイヤーの種類により、設定できるシンボルが異なります。\n  フィーチャ レイヤー（ポイント）のシンボル設定  [①表示するメイン属性を選択] ドロップダウン リストから、シンボルの設定を行う属性フィールドを選択します。\n属性値でシンボル設定をしない場合は、[\u0026lt;なし\u0026gt;] を選択します。\n  [②描画スタイルを選択] で、変更したい描画方法の [選択] をクリックします。既に選択されている描画スタイルは [オプション] と表示されます。\n  2D マーカー / 3D オブジェクト すべてのフィーチャを同じシンボルで表現します。\n2D タイプ / 3D タイプ 樹木の種類、道路クラス、都道府県名など、属性のカテゴリごとにシンボルを割り当てて描画します。\n2D 数と量/ 3D 数と量 数値データをシンボルの色や大きさ、高さで表現します。データの数値が大きいほど、シンボルは大きく、高く表示されます。 ※レイヤーが持つ属性フィールドのタイプに応じて選択できる種類が異なります。例えば、文字列型のフィールドのみで構成されるレイヤーでは、[種類] ドロップダウン リストでサイズや色の指定はできません。\nフィーチャ レイヤー（ライン/ポリゴン）のシンボル設定  [シンボル] ドロップダウン リストから [シンボルの変更] を選択します。\n  シンボルのタイプ（2D または 3D）、大きさ/高さ、色を設定します。\n  シーン レイヤーのシンボル設定  [①表示するメイン属性を選択] ドロップダウン リストから、シンボルの設定を行う属性フィールドを選択します。\n属性値でシンボル設定をしない場合は、[\u0026lt;なし\u0026gt;] を選択します。\n  [②描画スタイルを選択] で、変更したい描画方法の [選択] をクリックします。既に選択されている描画スタイルは [オプション] と表示されます。\n  色 すべてのフィーチャを同じシンボルで表現します。\nタイプ 樹木の種類、道路クラス、都道府県名など、属性のカテゴリごとにシンボルを割り当てて描画します。\n数と量 数値データをシンボルの色で表現します。 ※レイヤーが持つ属性フィールドのタイプに応じて選択できる種類が異なります。例えば、文字列型のフィールドのみで構成されるレイヤーでは、[種類] ドロップダウン リストでサイズや色の指定はできません。\n[オプション] をクリックすると、シンボルの詳細な設定をすることができます。  2D マーカー / 3D オブジェクトの場合 [シンボル] - あらかじめ用意されているシンボルから形状を選択します。\n[色] - シンボルの色を選択します。\n[サイズ] - 大きさを設定します。固定値のほかに属性値をもとに大きさを指定することもできます。\n[回転] - 属性値をもとに回転の角度を設定します。\n2D タイプ / 3D タイプの場合 表からスタイルを変更したい値を選択し、[シンボル]、[色]、[サイズ] を設定します。\n属性値をもとに、すべてのシンボルのサイズと回転を指定することも可能です。\n2D 数と量/ 3D 数と量 [スライダー] - スライダーの上部、下部のバーを動かして、最大 / 最小クラスの閾値を変更できます。また、数値をクリックして、直接入力することもできます。\n[シンボル] - あらかじめ用意されているシンボルから形状を選択します。\n[色] - 色のパターンなどを変更します。\n[サイズ] - 最大 / 最小クラスに設定した値の大きさを設定します。\n[回転] - 属性値をもとに回転の角度を設定します。\n色の場合 [テクスチャ] - テクスチャのタイプを選択します。\n[色] - シンボルの色を選択します。\nタイプの場合 表からスタイルを変更したい値を選択し、[テクスチャ]、[色] を設定します。\n数と量の場合 [スライダー] - スライダーの上部、下部のバーを動かして、最大 / 最小クラスの閾値を変更できます。また、数値をクリックして、直接入力することもできます。\n[色] - 色のパターンなどを変更します。 6. 設定後、各パネルにおいて [完了] をクリックします。\n高さを表現したい シーン ビューアー → [レイヤー] → [レイヤーの構成] → [標高モード] レイヤーに含まれる Z 値や、オフセットを定義して、グラフィックの高さを表現することができます。\n  シーン ビューアーの [レイヤー] が表示されていることを確認し、高さを表現したいレイヤーをクリックします。\n  [レイヤーの構成] が表示されます。\n  [標高モード] でモードを選択し、必要に応じてオフセットを設定します。\n  標高モード 地表 グラフィックは、地表を覆うように配置されます。\nグラフィックに含まれる Z 値は無視されます。また、オフセットを設定することはできません。\n地面を基準 グラフィックは、地面を基準にした高さに配置されます。\nグラフィックに Z 値が含まれる場合、Z 値を使用して高さは表現されます。\nシーンを基準 グラフィックは、シーンを基準にした高さに配置されます。\nグラフィックに含まれる Z 値は無視されます。\n絶対高度 グラフィックは、測地系を基準にした高さに配置されます。\n絶対高度は、各グラフィックの Z 値により決まります。[地面を基準] と似ていますが、[絶対高度] は地表の高さを無視します。\n※レイヤーの種類により、選択できるモードが異なります。例えば、シーン レイヤーでは、[絶対高度] 以外のモードは指定はできません。\nオフセット オフセットは、すべてのグラフィックに高さを加えます。例えば、オフセットに 100 メートルを設定した場合、グラフィックは現在の高さから 100 メートル上に表示されます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/screen/",
	"title": "画面グループ（Screen groups）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Screen groups\n画面グループ（Screen groups） 画面グループは、複数の画面を持つレイアウトコンテナで、スクロールするページのコンテンツやウィジェットを整理するためのものです。各画面はメインステージを持ち、画面グループのテンプレートによってはスクロールパネルを持つこともできます。画面グループにスクロールすると、画面の高さ全体を占めます。画面グループにスクロールパネルがある場合、エンドユーザーがパネル内のコンテンツをスクロールしても、メインステージはその場に留まり、最後のパネルがスクロールしたときにのみ切り替わります。画面グループにパネルがない場合は、メインステージは画面の高さいっぱいにスクロールするまで固定されます。\napp config では、画面グループは screenGroups で定義され、画面は screens で定義されます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-android/",
	"title": "Android",
	"tags": [],
	"description": "ArcGIS Maps SDK for Kotlin を用いたネイティブ地図アプリの作成方法を紹介します。",
	"content": "出典：ArcGIS Maps SDK for Kotlin - Tutorials - Display a map\nマップを表示する このチュートリアルでは ArcGIS Maps SDK for Kotlin を使用して、マップとベースマップ レイヤーを表示する方法を紹介します。\nマップには、地理データのレイヤーが含まれています。マップには、ベースマップ レイヤーと、オプションで 1 つ以上のデータ レイヤーを追加できます。マップ ビューを使用し、場所とズーム レベルを設定することで、マップの特定の領域を表示できます。\nこのチュートリアルでは、地形図ベースマップ レイヤーを使用して、富士山付近を表示する地図を作成します。\nこのチュートリアルのトピックの背景情報については、Mapping API and location services guide の Maps (2D) と ベースマップ を参照してください。\n\rステップ 新しい Android Studio プロジェクトを作成します Android Studio を使用してアプリを作成し、API を参照するように構成します。\n  Android Studio を開きます。\n [Welcome to Android Studio] ウィンドウで [New Project] をクリックします。\nまたは、メニューバーで [File] → [New] → [New Project] をクリックします。 [Create New Project] ウィンドウで、[Phone and Tablet] タブが選択されていることを確認してから、[Empty Activity] を選択して、[Next] をクリックします。 次のウィンドウで、以下の項目を設定します。  Name: Display a map Package name： com.example.app に変更します。または、組織に合わせて変更してください。 Save location: 新しいフォルダに設定します。 Minimum SDK: API 26 (\u0026ldquo;Oreo\u0026rdquo;; Android 8.0) Build configuration language: Kotlin DSL (build.gradle.kts)      プロジェクトのツール ウィンドウで、現在のビューが Android であることを確認してください。チュートリアルの説明では、そのビューを参照しています。\nビュー名が Android 以外の名前 （プロジェクトやパッケージなど） の場合、プロジェクト ツール ウィンドウのタイトルバーの左端のコントロールをクリックし、リストから Android を選択します。   プロジェクト ツール ウィンドウから、[Gradle Scripts] \u0026gt; [build.gradle.kts (Project: Display_a_map)] を開きます。ファイルの内容を次のコードに置き換えます。\nbuild.gradle.kts (Project: Display_a_map)\n// すべてのサブプロジェクト/モジュールに共通の構成オプションを追加できる最上位のビルド ファイル plugins { id(\u0026#34;com.android.application\u0026#34;) version \u0026#34;8.2.0\u0026#34; apply false id(\u0026#34;org.jetbrains.kotlin.android\u0026#34;) version \u0026#34;1.9.10\u0026#34; apply false }   プロジェクト ツール ウィンドウから、[Gradle Scripts] \u0026gt; [build.gradle.kts (Module: app)] を開きます。ファイルの内容を次のコードに置き換えます。\nbuild.gradle.kts (Module: Display_a_map)\nplugins { id(\u0026#34;com.android.application\u0026#34;) id(\u0026#34;org.jetbrains.kotlin.android\u0026#34;) } android { compileSdk = 34 defaultConfig { applicationId = \u0026#34;com.example.app\u0026#34; minSdk = 26 targetSdk = 34 versionCode = 1 versionName = \u0026#34;1.0\u0026#34; testInstrumentationRunner = \u0026#34;androidx.test.runner.AndroidJUnitRunner\u0026#34; } buildTypes { release { isMinifyEnabled = false proguardFiles( getDefaultProguardFile(\u0026#34;proguard-android-optimize.txt\u0026#34;), \u0026#34;proguard-rules.pro\u0026#34; ) } } compileOptions { sourceCompatibility = JavaVersion.VERSION_17 targetCompatibility = JavaVersion.VERSION_17 } buildFeatures { compose = true buildConfig = true } composeOptions { kotlinCompilerExtensionVersion = \u0026#34;1.5.3\u0026#34; } kotlinOptions { jvmTarget = \u0026#34;17\u0026#34; } packaging { resources { excludes += \u0026#34;/META-INF/DEPENDENCIES\u0026#34; } } namespace = \u0026#34;com.example.app\u0026#34; } dependencies { implementation(\u0026#34;androidx.core:core-ktx:1.12.0\u0026#34;) implementation(\u0026#34;androidx.lifecycle:lifecycle-runtime-ktx:2.7.0\u0026#34;) implementation(\u0026#34;androidx.activity:activity-compose:1.8.2\u0026#34;) // Jetpack Compose の BOM  implementation(platform(\u0026#34;androidx.compose:compose-bom:2023.10.01\u0026#34;)) // Jetpack Compose の依存関係  implementation(\u0026#34;androidx.compose.ui:ui\u0026#34;) implementation(\u0026#34;androidx.compose.material3:material3\u0026#34;) // ArcGIS Map Kotlin SDK の依存関係  implementation(\u0026#34;com.esri:arcgis-maps-kotlin:200.4.0\u0026#34;) // Toolkit の依存関係  implementation(platform(\u0026#34;com.esri:arcgis-maps-kotlin-toolkit-bom:200.4.0\u0026#34;)) implementation(\u0026#34;com.esri:arcgis-maps-kotlin-toolkit-geoview-compose\u0026#34;) }   プロジェクト ツール ウィンドウから、[Gradle Scripts] \u0026gt; [settings.gradle.kts] を開きます。ファイルの内容を次のコードに置き換えます。\nsettings.gradle.kts (Display a map)\npluginManagement { repositories { google() mavenCentral() gradlePluginPortal() } } dependencyResolutionManagement { @Suppress(\u0026#34;UnstableApiUsage\u0026#34;) repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) @Suppress(\u0026#34;UnstableApiUsage\u0026#34;) repositories { google() mavenCentral() maven { url = uri(\u0026#34;https://esri.jfrog.io/artifactory/arcgis\u0026#34;) } } } rootProject.name = \u0026#34;Display a map\u0026#34; include(\u0026#34;:app\u0026#34;)   Gradle の変更を同期します。[Sync now] プロンプトをクリックするか、ツールバーの更新アイコン(Sync Project with Gradle Files)をクリックします。同期に数分かかるかもしれません。\n  プロジェクト ツール ウィンドウから、[app] \u0026gt; [manifests] \u0026gt; [AndroidManifest.xml] を開きます。Android マニフェストを更新して、インターネット接続を許可します。\nこれらの新しい要素を manifest 要素内に挿入します。 他のステートメントを変更または削除しないでください。\n今後追加する ArcGIS の機能によっては、マニフェストに追加のアクセス許可を追加する必要がある可能性があります。\nAndroidManifest.xml\n\u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; // 追加開始 \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34;/\u0026gt; // 追加終了   マップを作成する   プロジェクト ツール ウィンドウから、[app] \u0026gt; [Kotlin+java] \u0026gt; [com.example.app] を右クリックし、リストから [New] \u0026gt; [package] を選択します。パッケージ名に com.example.app.screens と入力し、キーボードの [Enter] キーを押します。このステップで、すべての UI ファイルを含む新しいパッケージが作成されます。\n  作成した screens パッケージを右クリックし、リストから [New] \u0026gt; [Kotlin Class/File] を選択します。ポップアップ ウィンドウで [File] を選択し、ファイル名に MainScreen と入力し、キーボードの [Enter] キーを押します。\n  MainScreen.kt で、Android Studio によって自動的に挿入されたコード行をすべて削除します。次に、以下のオプトイン アノテーション、パッケージ名、インポートを追加します。\n以下のコード ブロックでコンポーザブル関数 com.arcgismaps.tookit.geoviewcompose.MapView をインポートしていることを確認してください。これは ArcGIS Maps SDK for Kotlin Toolkit で定義されています。コンポーザブルに対応したコードでは ArcGIS Maps SDK API の com.arcgismaps.mapping.view.MapView という名前のクラスは使用しないでください。\n\rMainScreen.kt\n@file:OptIn(ExperimentalMaterial3Api::class) package com.example.app.screens import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.foundation.layout.padding import androidx.compose.material3.ExperimentalMaterial3Api import androidx.compose.material3.Scaffold import androidx.compose.material3.Text import androidx.compose.material3.TopAppBar import androidx.compose.runtime.Composable import androidx.compose.runtime.remember import androidx.compose.ui.Modifier import androidx.compose.ui.res.stringResource import com.arcgismaps.mapping.ArcGISMap import com.arcgismaps.mapping.Basemap import com.arcgismaps.mapping.BasemapStyle import com.arcgismaps.mapping.BasemapStyleLanguageStrategy import com.arcgismaps.mapping.BasemapStyleParameters import com.arcgismaps.mapping.Viewpoint import com.arcgismaps.toolkit.geoviewcompose.MapView import com.example.app.R import java.util.Locale   ArcGISMap を返す createMap() という名前のトップ レベル関数を作成します。\nMainScreen.kt\nfun createMap(): ArcGISMap { }   BasemapStyle.ArcGISTopographic を使用して ArcGISMap を作成し、マップ上で apply{} を呼び出します。この関数は ArcGISMap を返します。\napply{} の詳細については Kotlin の Scope functions を参照してください。\nMainScreen.kt\nfun createMap(): ArcGISMap { // 追加開始  return ArcGISMap(BasemapStyle.ArcGISTopographic).apply { } // 追加終了  }   apply ブロックで、x (経度) と y (緯度) の座標と縮尺を持つ Viewpoint を作成します。この Viewpoint を ArcGISMap の initialViewpoint プロパティに割り当てます。 また、ベースマップのデフォルトのラベル表示は英語のため、日本語に変更します。\nMainScreen.kt\nfun createMap(): ArcGISMap { // 追加開始  val basemapStyleParams = BasemapStyleParameters() basemapStyleParams.languageStrategy = BasemapStyleLanguageStrategy.Specific(Locale(\u0026#34;ja\u0026#34;)) // 追加終了  return ArcGISMap(Basemap(BasemapStyle.ArcGISTopographic, basemapStyleParams)).apply { // 追加開始  initialViewpoint = Viewpoint( latitude = 35.360626, longitude = 138.727363, scale = 200000.0 ) // 追加終了  } }   マップを保持する MainScreen を作成する。   MapView を呼び出す MainScreen という名前のコンポーザブル関数を作成します。\nMainScreen.kt\n// 追加開始 @Composable fun MainScreen() { } // 追加終了  fun createMap(): ArcGISMap { ・・・   remember ブロックを追加し、その中で createMap() を呼び出します。そして remember を map というローカル変数に割り当てます。\nトップ レベルのコンポーザブル関数は再構成時に状態を保持するために使用されます。\nMainScreen.kt\n@Composable fun MainScreen() { // 追加開始  val map = remember { createMap() } // 追加終了  }   Android Jetpack Compose からいくつかのコンポーザブル関数を呼び出します。Scaffold を呼び出し、アプリ名 (R.string.app_name) を含む Text で TopAppBar を渡します。\nMainScreen.kt\n@Composable fun MainScreen() { val map = remember { createMap() } // 追加開始  Scaffold( topBar = { TopAppBar(title = { Text(text = stringResource(id = R.string.app_name)) }) } ) { } // 追加終了  }   Scaffold の末尾のラムダで、ArcGIS Maps SDK for Kotlin Toolkit で定義されている MapView コンポーザブルを呼び出し、最大サイズとデフォルトのパディングを持つ Modifier を設定します。そして、map を arcGISMap パラメーターとして渡します。\nMainScreen.kt\n@Composable fun MainScreen() { val map = remember { createMap() } Scaffold( topBar = { TopAppBar(title = { Text(text = stringResource(id = R.string.app_name)) }) } ) { // 追加開始  MapView( modifier = Modifier.fillMaxSize().padding(it), arcGISMap = map ) // 追加終了  } }   MainActivity クラス内で MainScreen を呼び出す   [app] \u0026gt; [kotlin+java] \u0026gt; [com.example.app] の MainActivity.kt を開きます。パッケージ宣言 (最初の行) と MainActivity クラスの定義以外のすべての行を削除します。\nMainActivity.kt\npackage com.example.app class MainActivity : ComponentActivity() { }   MainActivity.kt に import 文を追加します。\nMainActivity.kt\npackage com.example.app // 追加開始 import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import com.arcgismaps.ApiKey import com.arcgismaps.ArcGISEnvironment import com.example.app.screens.MainScreen import com.example.app.ui.theme.DisplayAMapTheme // 追加終了  class MainActivity : ComponentActivity() { }   onCreate() ライフサイクル関数の setContent() ブロックでは、デフォルトのテーマ設定を適用して、コンポーザブル関数である MainScreen を呼び出します。これを行うには、onCreate() に以下のコードを追加します。\nMainActivity.kt\nclass MainActivity : ComponentActivity() { // 追加開始  override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { DisplayAMapTheme { MainScreen() } } } // 追加終了 }   API キーを設定する API キーを使用すると、ArcGIS Online でホストされているサービス、Web マップ、および Web シーンにアクセスできるようになります。\n  MainActivity クラスで setApiKey() メソッドを作成し、ApiKey.create() を呼び出し、API キーを文字列として渡すことで、ArcGISEnvironment.apiKey プロパティを設定します。引用符を忘れないでください。\nMainActivity.kt\nclass MainActivity : ComponentActivity() { ・・・ } // 追加開始 private fun setApiKey() { ArcGISEnvironment.apiKey = ApiKey.create(\u0026#34;API キー\u0026#34;) } // 追加終了   onCreate() ライフサイクル メソッド内で setContent{} の前に setApiKey() を呼び出します。\nMainActivity.kt\nclass MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 追加開始  setApiKey() // 追加終了  setContent { DisplayAMapTheme { MainScreen() } } } }   アプリを実行する   [Run] \u0026gt; [Run] \u0026gt; [app] をクリックして、アプリを実行します。\nAndroid Studio では、アプリを実行するのに、実際の Android 端末と Android エミュレータの 2 通りの方法があります。\nAndroid デバイス パソコンと Android 端末を、USB または Wi-Fi で接続します。詳しくは、「Android デバイスを接続する方法」をご覧ください。\nAndroid エミュレータ Android エミュレータで動作させるための AVD(Android Virtual Device)を作成します。 詳しくは、「Android Emulator 上でアプリを実行する」をご覧ください。\nデバイスの選択 Android Studio でアプリをビルドして実行する場合、まずデバイスを選択する必要があります。Android Studio のツールバーから、現在利用可能なデバイス（仮想および物理の両方）のドロップダウンリストにアクセスできます。 ツールバーのリストにアクセスできない場合は、[Tools] → [Device Manader] をクリックします。\n富士山を中心に、地形ベースマップレイヤーが追加されたマップが表示されます。マップビュー上でマウス ホイールをダブルクリック、ドラッグ、およびスクロールして、マップを操作します。\n  Web マップを表示する 「Web マップの作成」のガイドで Web マップを作成している場合は、作成した Web マップを ArcGISMap クラスから参照することができます。\n  プロジェクト ツール ウィンドウから [app] \u0026gt; [Kotlin+java] \u0026gt; [com.example.app] \u0026gt; [screens] の MainScreen.kt を開きます。\n  MainScreen.kt に以下のインポートを追加します。\nMainScreen.kt\nimport com.arcgismaps.mapping.PortalItem import com.arcgismaps.portal.Portal   createMap() 関数を以下のように記述します。\nMainScreen.kt\nfun createMap(): ArcGISMap { val portal = Portal( url = \u0026#34;https://www.arcgis.com\u0026#34;, // 使用する ArcGIS ポータルの URL を記述  connection = Portal.Connection.Anonymous // ArcGIS ポータルへのアクセス方法を設定  ) val portalItem = PortalItem( portal = portal, itemId = \u0026#34;\u0026lt;Web マップの ID\u0026gt;\u0026#34; ) return ArcGISMap(item = portalItem) }    アプリの動作が確認できたら ArcGIS の セキュリティと認証について学びましょう！\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/",
	"title": "ArcGIS API for Python",
	"tags": [],
	"description": "ArcGIS API for Python の開発に役立つガイド集です。",
	"content": "ArcGIS API for Python の開発に役立つガイド集です。\n ArcGIS API for Python のコンセプト\nArcGIS API for Python のプロダクト コンセプトと動作要件について紹介します。\n\r ArcGIS API for Python のための基礎環境：conda入門\nconda の基本について簡単に紹介します。\n\r インストール ガイド\nArcGIS API for Python の環境構築方法を紹介します。\n\r Jupyter Notebook を使ってみよう\nArcGIS API for Python の実行に便利な JupyterLab の初期設定方法と使用方法を簡単に紹介します。\n\r Jupyter Lab を使ってみよう\nArcGIS API for Python の実行に便利な Jupyter Notebook の基本的な起動と使用方法を簡単に紹介します。\n\r スクリプト実行の自動化\nタスクスケジューラや cron を使用した Python スクリプトの実行の自動化について紹介します。\n\r matplotlib での日本語利用について\nArcGIS API for Python で利用されているグラフ描画ライブラリの matplotlib で日本語を使う方法を説明します。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/widget-manifest/",
	"title": "ウィジェット manifest",
	"tags": [],
	"description": "ウィジェットの名前やバージョンなどのウィジェットの属性などを設定する manifest.json ファイルについて紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Widget manifest\n各 ArcGIS Experience Builder ウィジェットには、ウィジェットの属性とプロパティを記述した manifest.json ファイルがあります。ウィジェットの manifest には、name、type、version、exbVersion、および translatedLocales プロパティを含める必要があります。ウィジェットの manifest を作成する簡単な方法は、demo widget から manifest.json ファイルをコピーすることです。以下は manifest.json ファイルの例です。ウィジェット内で ArcGIS Maps SDK for JavaScript を使用するには、dependency プロパティに jimu-arcgis を設定します。\n{ \u0026#34;name\u0026#34;: \u0026#34;count-features\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Count Features\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;widget\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.14.0\u0026#34;, \u0026#34;exbVersion\u0026#34;: \u0026#34;1.14.0\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Esri R\u0026amp;D Center Beijing\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is widget is designed to display the numeric attributes of features.\u0026#34;, \u0026#34;copyright\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;http://www.apache.org/licenses/LICENSE-2.0\u0026#34;, \u0026#34;publishMessages\u0026#34;: [ \u0026#34;EXTENT_CHANGE\u0026#34;, \u0026#34;DATA_RECORDS_SELECTION_CHANGE\u0026#34; ], \u0026#34;messageActions\u0026#34;: [], \u0026#34;defaultSize\u0026#34;: { \u0026#34;width\u0026#34;: 360, \u0026#34;height\u0026#34;: 80 }, \u0026#34;properties\u0026#34;: {}, \u0026#34;translatedLocales\u0026#34;: [ \u0026#34;en\u0026#34;, \u0026#34;es\u0026#34;, \u0026#34;zh-cn\u0026#34; ] } widget\u0026rsquo;s manifest で利用可能なプロパティの詳細を参照してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/custom-font/",
	"title": "カスタム フォント",
	"tags": [],
	"description": "独自のフォントを使用する手順を紹介します。",
	"content": "ArcGIS Maps SDK for JavaScript のバージョン 4.10 以降、MapView 上のフィーチャ レイヤーのラベルやテキスト シンボルで使用するフォントは、pbf (Protocolbuffer Binary Format) で配信する必要があります。 デフォルトでは、pbf フォントは Esri が https://static.arcgis.com/fonts でホストしているフォントを使用できます。 利用可能なフォントの一覧は、Esri のガイドで確認できます（\u0026ldquo;Read more\u0026rdquo; をクリックしてページを展開してください）。\nデフォルトで提供されていないフォントを使用したい場合は、自身で pbf フォントを作成し Web サーバーで配信することで、API から使用することができます。このガイドでは ArcGIS Maps SDK for JavaScript バージョン 4.x で独自のフォントを使用する手順を紹介します。\n※ 本ガイドでご紹介する手順に関しては ESRIジャパンの技術サポート サービスの対象外となります。予めご了承ください。また、フォントの変換・配置を行う場合は、利用されるフォントの利用規約を予めご確認ください。\nフォントの入手 今回は、Google フォント からダウンロードして PBF に変換します。\npbf フォントの作成 pbf ファイルは符号付き距離フィールドのセットとして以下の URL で配信する必要があります。これは MapBox GL JS のスタイル仕様と同じです。\nhttps://fonts/\u0026lt;フォントスタック\u0026gt;/\u0026lt;ユニコード文字範囲\u0026gt;.pbf\npbf ファイルは node-fontnik を使用して、ttf や otf 等のフォントファイルから変換して作成できます。\n node-fontnik をクローンします。  git clone https://github.com/mapbox/node-fontnik.git\r node-fontnik フォルダに移動して、モジュールをインストールします。  npm install\r fonts フォルダを作成し、作成したフォルダにダウンロードした Google フォントを配置します。 glyphs フォルダと変換後のファイルを出力するサブフォルダ（例: glyphs/KosugiMaru-Regular）を作成します。 build-glyphs を実行して pbf ファイルを作成します。  node-fontnik/bin/build-glyphs fonts/KosugiMaru-Regular.ttf glyphs/KosugiMaru-Regular\r glyphs/KosugiMaru-Regular フォルダにユニコード文字範囲の pdf ファイル群が作成されていることを確認します。  PBF フォントの配置 以下のディレクトリ構成にして Web サーバーへ配置します。 IIS を使用する場合は、MIME に .pbf (binary/octet-stream) を登録します。\n「fonts」 フォルダ\n|\u0026ndash;「\u0026lt;フォントファミリー\u0026gt;-\u0026lt;ウェイト\u0026gt;-\u0026lt;スタイル\u0026gt;」フォルダ（例：arial-bold-italic） ※\n|\u0026ndash; pbf ファイル群\n※ \u0026lt;スタイル\u0026gt; は省略可能です。今回は「KosugiMaru-Regular」フォルダを作成します。 詳細は「API の設定」の項目を参照してください。\nAPI の設定   ArcGIS Maps SDK for JavaScript で参照するフォント リソースの URL を変更します。 フォントの URL の設定は、esri/config クラスの fontsUrl プロパティを使用します。\n  マップに表示するフォントを作成します。 フォントの作成は Font クラスを使用します。 family、weight、style の各プロパティに設定した値をもとに設定したフォント URL へリクエストが実行されます。 例えば、family に \u0026ldquo;arial\u0026rdquo;、weight に \u0026ldquo;bold\u0026rdquo;、style に \u0026ldquo;italic\u0026rdquo; を設定した場合は、https://\u0026lt;サーバー名\u0026gt;/fonts/arial-bold-italic フォルダにある pbf ファイルを取得します。 フォントに複数スタイルが存在しない場合は style プロパティは省略可能です。 また、weight プロパティも省略可能ですが、API で指定しない場合は regular が自動で設定され、https://\u0026lt;サーバー名\u0026gt;/fonts/arial-regular がリクエストされます。\n  以下は作成した pbf フォントをテキスト シンボルで表示した画面とサンプルコードです。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1,maximum-scale=1,user-scalable=no\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;font_mapView\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.11/esri/themes/light/main.css\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; background-color: black; } \u0026lt;/style\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.11/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; require([ \u0026#34;esri/Map\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;, \u0026#34;esri/Graphic\u0026#34;, \u0026#34;esri/config\u0026#34; ], function(Map, MapView, Graphic, esriConfig) { // .pbfファイルを独自に配信するURL  esriConfig.fontsUrl = \u0026#34;http://\u0026lt;サーバー名\u0026gt;/fonts\u0026#34;; // テキストシンボルの作成  var textSymbol = { type: \u0026#34;text\u0026#34;, color: \u0026#34;white\u0026#34;, text: \u0026#34;KosugiMaru フォントです\u0026#34;, // 表示する文字列  font: { size: 15, family: \u0026#39;KosugiMaru\u0026#39; // フォントファミリー  } }; var point = { type: \u0026#34;point\u0026#34;, longitude: 139.751068, latitude: 35.684482 }; var pointGraphic = new Graphic({ geometry: point, symbol: textSymbol }); var map = new Map({ basemap: \u0026#34;dark-gray-vector\u0026#34; }); const view = new MapView({ container: \u0026#34;viewDiv\u0026#34;, map: map, center: [139.751068, 35.684482], zoom: 12 }); view.graphics.add(pointGraphic); }); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/automate-tasks/",
	"title": "スクリプト実行の自動化",
	"tags": [],
	"description": "タスクスケジューラや cron を使用した Python スクリプトの実行の自動化について紹介します。",
	"content": "ArcGIS API for Python や ArcPy は、タスク スケジューラなどと組み合わせることで、様々な GIS タスクの実行を自動化することが可能です。\nここでは、例として以下のようなディレクトリ構成で実行する Python スクリプトを作成したと想定し、そのスクリプトを Windows 及び Linux で 30 分ごとに無期限で定期実行する方法を紹介します。\npy-script/\n├ config.ini\n└ task.py\ntask.py は実行する Python スクリプト、config.ini は task.py の実行に必要なパラメータを記載した設定ファイルとします。\nWindows のタスク スケジューラを使用する場合 Windows ではタスク スケジューラを使用することでプログラムやスクリプトを決められた時間や一定の間隔で実行することができます。\nタスク スケジューラは以下の手順で設定します。\n タスク スケジューラを開く  スタート メニューからタスク スケジューラを検索して開く    \r 右側の [操作] ペインから [タスクの作成] をクリック  新規タスクを作成するウィザードが開きます    \r [全般] タブ内のパラメーターを設定する  名前：タスクの名前 説明：タスクの説明を記載 セキュリティ オプション：  タスク実行時に使う Windows のユーザーアカウントを指定 [ユーザーがログオンしているかどうかにかかわらず実行する] をクリック [最上位の特権で実行する] にチェックを入れる   [構成] は使用している Windows のバージョンに合わせる (今回は Windows 10)    \r [トリガー] タブ内のパラメーターを設定する  [新規] をクリックし、新しいトリガーを作成 [タスクの開始] は [スケジュールに従う] をドロップダウンから選択 任意の開始時間を指定 [繰り返し間隔] にチェックを入れ、30分間を指定 [継続時間] は [無期限] を指定    \r [操作] タブのパラメーターを設定する  [操作] のドロップダウンから [プログラムの開始] を選択 [プログラム/スクリプト] で実行する Python の エグゼキュータブル ファイルのパスを指定  上の画像では ArcGIS Pro の Python パッケージ マネージャー で作成した環境の Python を指定しています。 パスが不明な場合、実行したい環境で ArcGIS Pro を起動し、Python ウィンドウを表示させて以下のコードを実行することで確認することができます。  import sys sys.executable     [引数の追加 (オプション)] で実行する Python スクリプトのファイル名を指定 [開始 (オプション)] で Python スクリプトが格納されているディレクトリを指定    \r指定するパス等にスペースが含まれている場合はダブル クォーテーションで囲んでください。\nまた半角括弧 () が含まれるパスを指定すると正常に動作しないため、ディレクトリ名などを変更してください\n\r OK ボタンをクリックし、要求された場合はユーザーアカウント情報を入力  Linux の cron を使用する場合 Linux で特定のタスクを定期実行する場合は cron が用いられます。\ncron は任意のタスクを任意の時間にバックグラウンドで実行するデーモンです。実行する内容は crontab と呼ばれるテキスト ファイルに記述します。\n設定方法は以下のとおりです。\ncrontab を開く  以下のコマンドを Bash ターミナルから実行   crontab -e\r 次のような使用するテキスト エディタを選択する画像が表示された場合、任意の番号のテキストエディタを選択します (今回は 1 番を選択)。  \rcrontab を編集する  crontab の編集画面が開くので次のとおり実行する内容を記述  */30 * * * * cd /home/\u0026lt;ユーザー名\u0026gt;/py-script \u0026amp;\u0026amp; /home/\u0026lt;ユーザー名\u0026gt;/anaconda3/envs/arcgis171/bin/python task.py\r\r 記述した内容の概要は以下のとおりです  */30 * * * *  30分に一回の実行間隔を指定   cd /home/\u0026lt;ユーザー名\u0026gt;/py-script  cd コマンドでカレントのディレクトリを実行するスクリプトと設定ファイルが格納されているディレクトリに移動 ※ ここではログインしているユーザーのホーム ディレクトリ直下に配置していると想定   \u0026amp;\u0026amp;  連続してコマンドを実行する場合に用いるオペレーター   /home/\u0026lt;ユーザー名\u0026gt;/anaconda3/envs/arcgis171/bin/python  実行する Python のパスを指定   task.py  実行する Python スクリプトを指定      上記の内容は Anaconda3 をインストールして構築した ArcGIS API for Python の実行環境を想定しています。詳細はインストールガイドを参照ください。\nより詳細な cron の使い方はubuntu の Community Help Wiki の Cron How to をご覧下さい。\n\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/deployment/",
	"title": "デプロイの紹介",
	"tags": [],
	"description": "開発したアプリをデプロイするために必要なライセンスや利用規約などについて紹介します。",
	"content": "出典：ArcGIS Developers - Introduction to deployment\nさまざまな API や SDK、ArcGIS ロケーション サービス、ArcGIS アカウントを使用して、アプリケーションを構築およびデプロイできます。これには、Web、ネイティブ、およびサービス ベースのアプリケーションが含まれます。このセクションでは、ソリューションをデプロイする前に知っておくべき情報について説明します。\n\r\r\r\r\r\r製品、サブスクリプション、アカウント\n\r製品、サブスクリプション、アカウントが請求とデプロイメントにどのような影響があるのかを説明します。\n\r\r\r\r\r\r\r\rコンテンツとデータの利用\n\rアプリケーションで使用されるデータの利用規約について説明します。\n\r\r\r\r\r\r\r\rベースマップの帰属\n\rアプリケーションで正しいベースマップの帰属を提供する方法について説明します。\n\r\r\r\r\r\r\r\r配布\n\rさまざまな API を使用して構築されたアプリケーションを配布およびデプロイするための要件について説明します。\n\r\r\r\r\r\r\r\r利用規約\n\r利用規約、その他の法的文書について説明します。\n\r\r\r アカウント、ライセンス、価格、サービスの利用方法についての詳細は、FAQ をご確認ください。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/visualization/",
	"title": "データ ビジュアライゼーション",
	"tags": [],
	"description": "地図にデータを可視化する際の Tips を紹介します。",
	"content": "地図にデータを可視化する際の Tips を紹介します。\n データ可視化のワークフロー\nマップ ビューアーを使用した地図上でのデータ可視化のプロセスを紹介します。\n\r データ可視化の手順\nArcGIS Online 上のデータを可視化するための方法を紹介します。\n\r 地図上に賢くデータを可視化するための 6 つの方法\nマップ ビューアーを使って地図データを賢く可視化するために おさえておくべき６つの方法を紹介します。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/layout/",
	"title": "レイアウト（Layout）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Layout\nレイアウト（Layout） レイアウトは、レイアウトコンテナにコンテンツを配置する方法を定義します。コンテンツには、ウィジェット、セクション、または画面グループが含まれ、レイアウト コンテナには、ページ、ビュー、またはダイアログなどがあります。ArcGIS Experience Builder には、いくつかのレイアウト規則があります。たとえば、新しいページを作成するときに、Fixed レイアウトまたは Flow レイアウトを選択したり、Layout ウィジェットを使用して異なるレイアウトを作成したりすることができます。\nアプリ コンフィグでは、レイアウトは layouts プロパティで定義され、レイアウト コンテナは layout id でレイアウトを参照します。レイアウトコンテナには、異なるサイズモードでのレイアウトを定義する layouts オブジェクトプロパティがあります。Experience Builder では、Large、Medium、Small の各サイズモードをサポートしています。レイアウトが定義されていないサイズモードでは、アプリの設定で定義された mainSizeMode レイアウトが使用されます。\nフレームワークのレイアウト・コンテナの他に、ウィジェットもレイアウト・コンテナになることができます。ウィジェットがレイアウト・コンテナになると，ユーザーは他のウィジェットをドラッグ・アンド・ドロップすることができます．例えば、Map や Card はレイアウト・コンテナ・ウィジェットです。レイアウト・コンテナ・ウィジェットは、manifest.json で layouts プロパティを宣言し、LayoutEntry コンポーネントを使用する必要があります。パフォーマンス上の理由から、以下のロジックを使用する必要があります。\nimport {LayoutEntry} from \u0026#39;jimu-layouts/layout-runtime\u0026#39; let LayoutEntryComponent if (window.jimuConfig.isInBuilder) { LayoutEntryComponent = this.props.builderSupportModules.LayoutEntry } else { LayoutEntryComponent = LayoutEntry } "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/prosdk/",
	"title": "ArcGIS Pro SDK",
	"tags": [],
	"description": "ArcGIS Pro SDK の開発に役立つガイド集です。",
	"content": "ArcGIS Pro SDK の開発に役立つガイド集です。\n  ArcGIS Pro を使用した開発\n 概要  SDK の概要・コンポーネント、開発要件、リリースノート等を紹介します。   ArcGIS Pro Extensions Nuget  ArcGIS Pro Extensions Nuget の使用方法や導入の利点を紹介します。   ArcMap から ArcGIS Pro への移行  ArcMap のカスタマイズを ArcGIS Pro に移行する際のアプローチ、ベストプラクティス、および実装上の考慮事項の概要を説明します。   ArcGIS Pro 3.0 への移行  ArcGIS Pro 3.0 の変更点と 2.x から 3.0 への移行手順について説明します。   フレームワーク  開発フレームワークの詳細を説明します。   非同期プログラミング  アドイン開発で使用する非同期プログラミング手法について説明します。      アドイン開発\n インストールとアップグレード  SDK のインストール、アップグレード、およびアンインストール方法を説明します。   はじめてのアドイン作成  ArcGIS Pro アドインの開発方法をステップで説明します。   アドインの種類  開発できる UI コントロールの種類を説明します。   ジオデータベース  ジオデータベースの操作について説明します。   よくある問題  アドイン開発でよく遭遇する問題とその解決策を紹介します。      構成管理\n コンセプト  ArcGIS Pro のカスタマイズ方法のひとつである構成管理のコンセプトを説明します。   カスタマイズ方法  構成管理のカスタマイズ方法をステップで説明します。      "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-ios/",
	"title": "iOS",
	"tags": [],
	"description": "ArcGIS Maps SDK for Swift を用いたモバイル地図アプリの作成方法を紹介します。",
	"content": "出典：ArcGIS Maps SDK for Swift - Tutorials - Display a map\nマップを表示する このチュートリアルでは ArcGIS Maps SDK for Swift を使用して、マップとベースマップ レイヤーを表示する方法を紹介します。\nマップには、地理データのレイヤーが含まれています。マップには、ベースマップ レイヤーと、オプションで1つ以上のデータレイヤーを追加できます。マップビューを使用し、場所とズームレベルを設定することで、マップの特定の領域を表示できます。\nこのチュートリアルでは、地形ベースマップレイヤーを使用して、富士山付近を表示する地図を作成します。\nこのチュートリアルのトピックの背景情報については、Mapping API and location services guide の Maps (2D) と ベースマップ を参照してください。\n\r前提条件 このチュートリアルを実施するには、以下が必要です。\n API キーにアクセスするための ArcGIS 開発者アカウント。アカウントをお持ちでない場合は、サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。 開発環境がシステム要件を満たしていることを確認します。  ステップ 新しい Xcode プロジェクトを作成する Xcode を使用してシングルビュー iOS アプリを作成し、SDK を参照するように構成します。\n  Xcode を開き、メニュー バーから [File] \u0026gt; [New] \u0026gt; [Project] \u0026gt; [iOS] \u0026gt; [App] \u0026gt; [Next] をクリックします。\n [Choose options for your new project] ウィンドウで、次の値を設定します。  Product Name: display_a_map Language: Swift Interface: SwiftUI Organization Identifier: \u0026lt;任意の組織\u0026gt;   他のすべてのオプションのチェックを外します。 [Next] をクリックします。 プロジェクトを保存する場所を選択して、[Create] をクリックします。    Project Navigator で、display_a_mapApp.swift をクリックします。Editor で、display_a_mapApp struct を右クリックします。 [Refactor]、[Rename\u0026hellip;] の順に選択して、構造体の名前を MainApp に変更します。 右上の [Rename] ボタンをクリックして、新しい名前を確認します。 これにより、影響を受けるすべての領域の構造体(struct)とファイルの名前が変更されます。\n  Swift Package Manager を使用して API への参照を追加します。\n  アクセストークンを取得する ArcGIS Online でホストされているサービス、Web マップ、Web シーンにアクセスできるようにするには、アクセストークンが必要です。 まだ作成していない場合は、ArcGIS Developers ダッシュボード に移動して、API キーを取得します。作成方法は「API キーの取得」をご覧ください。 このチュートリアルでは、ロケーションサービスのベースマップの権限が有効になっている API キーが必要です。\nAPI キーを設定する   Project Navigator で MainApp.swift をクリックします。\n  エディターで、API を参照するインポートステートメントを追加します。\nMainApp.swift\nimport SwiftUI // 追加開始 import ArcGIS // 追加終了   DisplayAMap 構造体にイニシャライザを実装します。アクセストークンを使用して、ArcGISEnvironment の ArcGISEnvironment.apiKey プロパティを設定します。\nMainApp.swift\nimport SwiftUI import ArcGIS @main struct MainApp: App { // 追加開始 init() { ArcGISEnvironment.apiKey = APIKey(\u0026#34;\u0026lt;#アクセストークンを入力#\u0026gt;\u0026#34;) } // 追加終了 var body: some Scene { WindowGroup { ContentView() } } }  アクセストークンは、このチュートリアルの便宜上、コードに直接格納されていますが、ソース コードにアクセストークンを格納することは、ベスト プラクティスではありません。\n\r  マップの追加 地形ベースマップレイヤーを含むマップを作成します。 マップは、富士山付近が中心になります。\n  Project Navigator で、ContentView.swift をクリックします。\n  Editor で、API を参照する import ステートメントを追加します。\nContentView.swift\nimport SwiftUI // 追加開始 import ArcGIS // 追加終了   デフォルト値を持つ Map タイプの map という名前の @State プロパティ ラッパーを追加します。 arcGISTopographic ベースマップ スタイルで Map を作成し、それを返します。\nContentView.swift\nstruct ContentView: View { // 追加開始 @State private var map = { //ベースマップのラベルを日本語で表示します。 let bsp = BasemapStyleParameters(language: BasemapStyleLanguage.specific(Locale.Language(identifier: \u0026#34;ja\u0026#34;))) let map = Map(basemap:Basemap(style:.arcGISTopographic,parameters: bsp)) return map }() // 追加終了 } Map や Scene のような GeoModel は、作成にコストがかかり、状態を保持する可能性があります。GeoModel やその他のモデル オブジェクトが必要に応じてのみ作成されるようにするには、上記のコードのように、@State または @StateObject プロパティ ラッパーを適用することができます。詳しくは、Managing model data in your app をご覧ください。\n  マップの initialViewpoint プロパティを、富士山付近の座標を持つ Viewpoint で設定します。\nContentView.swift\nstruct ContentView: View { @State private var map = { //ベースマップのラベルを日本語で表示します。 let bsp = BasemapStyleParameters(language:BasemapStyleLanguage.specific(Locale(languageCode: \u0026#34;ja\u0026#34;))) let map = Map(basemap:Basemap(style:.arcGISTopographic,parameters: bsp)) // 追加開始 map.initialViewpoint = Viewpoint(latitude: 35.360626, longitude: 138.727363, scale: 200000) // 追加終了 return map }() }   マップ ビューの追加 マップ ビューは、マップを表示する UI コンポーネントです。 また、タッチ ジェスチャを使用したナビゲーションなど、マップとのユーザー インタラクションも処理します。Xcode と SwiftUI を使用してマップ ビューを追加します。\n  body で、前の手順で作成したマップを使用して MapView を作成します。\nContentView.swift\nstruct ContentView: View { @State private var map = { //ベースマップのラベルを日本語で表示します。 let bsp = BasemapStyleParameters(language:BasemapStyleLanguage.specific(Locale(languageCode: \u0026#34;ja\u0026#34;))) let map = Map(basemap:Basemap(style:.arcGISTopographic,parameters: bsp)) map.initialViewpoint = Viewpoint(latitude: 35.360626, longitude: 138.727363, scale: 200000) return map }() var body: some View { // 追加開始 MapView(map: map) // 追加終了 } } MapView は Apple View プロトコルに準拠しています。\n  Project Navigator で、MainApp.swift をクリックします。\n  ContentView に .ignoresSafeArea() 修飾子を追加します。 ContentView の body には MapView が含まれており、この修飾子により、マップ ビューがセーフ エリアを超えてすべての端まで表示されるようになります。\nMainApp.swift\nvar body: some Scene { WindowGroup { ContentView() // 追加開始 .ignoresSafeArea() // 追加終了 } }   body 変数の宣言時の型を Scene から SwiftUI.Scene に変更します。\nMainApp.swift\n// 変更前 var body: some Scene { // 変更後 var body: some SwiftUI.Scene {   \u0026lt;Command + R\u0026gt; を押してアプリを実行します。\n富士山を中心とした地形ベースマップレイヤーのマップが表示されます。マップビューをピンチ、ドラッグ、およびダブルタップして、マップを操作します。\n  完成版のプロジェクトはこちらからダウンロードできます（マップの表示場所は本チュートリアルで設定した場所とは異なります）。\nWeb マップを表示する 「Web マップの作成」のガイドで Web マップを作成している場合は、作成した Web マップも基本的に同じステップで表示できます。\n  マップを表示するのステップで作成したプロジェクトの ContentView.swift を開き、map を下記のように書き換えます。\nContentView.swift\nstruct ContentView: View { @State private var map = { let portalItem = PortalItem( portal: .arcGISOnline(connection: .anonymous), id: PortalItem.ID(\u0026#34;Web マップの ID\u0026#34;)! ) let map = Map(item: portalItem) return map }() }    アプリの動作が確認できたら ArcGIS の セキュリティと認証について学びましょう！\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/matplotlib-japanese/",
	"title": "matplotlib での日本語利用について",
	"tags": [],
	"description": "ArcGIS API for Python で利用されているグラフ描画ライブラリの matplotlib で日本語を使う方法を説明します。",
	"content": "ArcGIS API for Python では様々な オープンソース ライブラリを活用していますが、グラフを描画する際は主に matplotlib が使用されています。\nmatplotlib をデフォルトのまま使用すると日本語のテキストは文字化けしてしまいますが、フォント設定を変更することで表示させることが可能です。\n対応環境 ここでは、次の環境を用いた場合の設定方法を説明します。\n ArcGIS Pro 2.5 ArcGIS API for Python 1.7.0 matplotlib 3.1.1  日本語フォントの多くは ttc ファイルで提供されていますが、以前の matplotlib は ttc ファイルに対応していませんでした。matplotlib 3.1.0 から ttc ファイルに対応するようになったため、フォントを追加でインストールすることなく日本語を表示させることができるようになっています。それ以前のバージョンをご利用されている場合は以下をご検討ください。\n ArcGIS Pro のアップグレード  ArcGIS Pro 2.5 では、デフォルトで作成されている arcgispro-py3 という名前の環境に、ArcGIS API for Python 1.7.0 及び matplotlib 3.1.1 がインストールされています。   ArcGIS API for Python をアップグレード  Anaconda を利用して環境構築している場合、ArcGIS API for Python を最新バージョンにアップグレードすることで、依存パッケージである matplotlib も併せてアップグレードされます。    matplotlib での日本語フォントの設定方法 設定方法は主に以下の 2 通りがあります。\n スクリプトで matplotlib の設定を都度変更する matplotlib の設定ファイル (matplotlibrc) を編集する  前者の方法では一時的な設定変更、後者では恒久的な設定変更が可能です。 どちらが適しているかはご自身の状況に合わせて選択してください。\nスクリプトで matplotlib の設定を都度変更する 次のコードをスクリプトの最初に実行することでフォント設定を変更することが可能です。\nimport matplotlib.pyplot as plt from matplotlib import rcParams rcParams[\u0026#34;font.family\u0026#34;] = \u0026#34;sans-serif\u0026#34; rcParams[\u0026#34;font.sans-serif\u0026#34;] = [\u0026#34;Meiryo\u0026#34;] rcParams は matplotlib のデフォルト設定が入っているオブジェクトです。\n上記では Windows で利用可能な Meriyo に変更していますが、ご自身の OS 等に応じて適宜フォントファミリー、フォントを変更してください。\n設定したらサンプル コードを実行してみましょう。\nmatplotlib の設定ファイル (matplotlibrc) を編集する 上記の設定方法では毎回スクリプトの最初にコードを実行する必要がありますが、以下の方法でデフォルトのフォントを恒久的に変更することが可能です。\nmatplotlibrc のパスを確認 次のコードを実行して matplotlib の設定ファイルである matplotlibrc のパスを確認します。\nimport matplotlib as mpl mpl.matplotlib_fname() matplotlibrc を C:\\Users\\\u0026lt;ユーザー名\u0026gt;\\.matplotlib にコピー \u0026amp; ペーストで配置 matplotlibrc が格納されているパスへ移動しファイルをコピーしたら、以下のディレクトリにペーストします。\n C:\\Users\\\u0026lt;ユーザー名\u0026gt;\\.matplotlib  conda を使用して複数の環境を作成・利用している場合、それぞれの環境が matplotlibrc を保持しています。\n上記のパスに配置された matplotlibrc は各環境の matplotlibrc よりも優先されるため、当該ファイルを修正するだけで全ての環境で日本語のフォントを設定することができます。\n\rmatplotlibrc の内容を修正 ペーストした matplotlibrc のフォント設定部分を書き換えます。\nmatplotlibrc は非常に長いファイルですが、160 行目あたりからフォント設定のセクションが始まります。\n\r198 行目にフォント ファミリー、210 行目に sans-serif のフォント設定の箇所があります。\nフォント ファミリーはデフォルトが sans-serif なので、ここではデフォルト設定のままにしておきます。\n210 行目のフォント設定の行で、# を削除し、: の後に日本語のフォントを追加しましょう。\nここでは Meiryo に設定します。設定後の画面は以下のようになります。\n\rキャッシュの再構築 以上で設定は終了ですが、うまく反映されない場合があるので、念のため以下のコードを実行してキャッシュを再構築します。\nimport matplotlib.font_manager matplotlib.font_manager._rebuild() 設定が完了したらしたら以下のサンプルコードを実行してみましょう。\nサンプル コード フォント設定が完了したら以下のサンプル コードを実行してみましょう。\nimport matplotlib.pyplot as plt import numpy as np def test_function(x): return 3*x**3 + 2*x**2 + 4*x - 10 x = np.linspace(-3, 3, 200) plt.plot(x, test_function(x), color = \u0026#34;cornflowerblue\u0026#34;, label = \u0026#34;日本語のラベル\u0026#34;) plt.legend(loc = \u0026#34;upper left\u0026#34;) plt.ylim(-120, 120) plt.title(\u0026#34;日本語のタイトル\u0026#34;) plt.xlabel(\u0026#34;日本語のX軸\u0026#34;) plt.ylabel(\u0026#34;日本語のY軸\u0026#34;) plt.grid(True) plt.show() 次のようなグラフが描ければ成功です。\n\r参考  matplotlibで日本語 - Qiita matplotlib 公式ドキュメント  Configuring the font family The matplotlibrc file    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/extend-base-widget/",
	"title": "ウィジェットの実装",
	"tags": [],
	"description": "ウィジェットの実装方法について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Widget implementation\nExperience Builder ウィジェットは、次のファイルで構成されています。\n src: ウィジェットのソースコード  runtime: フォルダ  widget.tsx: メインのファイル assets: widget.tsx で使用される assets フォルダ translations: ウィジェットで使われる strings フォルダ   setting: フォルダ  setting.tsx: ウィジェットで使用する設定ファイル assets: 設定で使用する assets フォルダ translations: 設定で使用する strings フォルダ     dist: コンパイル済みのウィジェットのソースコードを配置。ウィジェットのソースコードのフォルダと同じ構成 icon.svg: ウィジェットパネルのウィジェットのアイコン config.json: ウィジェットのデフォルト設定 manifest.json: プロパティのリストは jimu-core/WidgetManifest で設定した内容を表示  Client サーバー Experience Builder (開発者向けエディション)で必要なモジュールをインストールしたら、/client ディレクトリで npm start を実行して webpack サーバーを起動します。webpack サーバーを起動した状態にすることでソースコードの編集におけるファイル変更を監視し、自動的にコンパイルを行います。通常は、ソースコードを編集する際に webpack サーバーを再起動する必要はありませんが、以下の場合では、サーバーを再起動する必要があります。\n 新しいモジュールのインストール ウィジェットの追加、削除、名前の変更 ウィジェットの manifest.json の編集 ファイルやフォルダの追加、削除、名前の変更  ctrl + c で webpack サーバーを停止させることができます。\n\rウィジェットの作成 ウィジェットに必要なファイルを作成する簡単な方法は、samples repo にある demo widget をコピーして、client/your-extensions/widget ディレクトリに配置します。demo widget フォルダの名前を変更し、maniest.json で名前とラベルを変更し、ウィジェットの translations フォルダにある default.ts ファイルの _widgetLabel のプロパティを変更します。widget/React コンポーネントを作成するには、クラスと関数の 2 つの方法があります。以下に、2 つの違いについて紹介します。\ndefault.ts の _widgetLabel は、常に manifest.json のラベルと同じとすることを推奨します。\n\r  クラスコンポーネント\n ES6 クラスを利用し、React のコンポーネントクラスを拡張します。 独自のデータを state で維持します。 props(properties) をクラスコンポーネントに渡し、this.props でアクセスします。 render() メソッドを使います。    関数コンポーネント\n アロー関数を使った JavaScript の基本的な関数ですが、通常の関数キーワードを使用することができます。 props を受け入れて使用します。 React Hooks を使用して state やその他の機能を使用します。 render() メソッドはありません。    開発者向けドキュメントで使用されているサンプルは、1 つを除いてすべてクラスコンポーネントに基づいています。今後のリリースでは、関数コンポーネントのサンプルを追加する予定です。\nクラスコンポーネントを使ったウィジェットの作成 以下の例では、React.PureComponent クラスを拡張して、シンプルな hello world クラスの widget/component を作成する方法を示しています。ウィジェットは、export default class Widget extends React.Component\u0026lt;AllWidgetProps\u0026gt;, any\u0026gt; { で AllWidgetProps 型で宣言されており、ウィジェットの props を使用しています。 render() メソッドは、translations ファイル内の _widgetLabel のプロパティで設定した テキスト名：hello world とウィジェット名を返すために呼び出されます。\n//a custom pragma to transform your jsx into plain JavaScript /** @jsx jsx */ import { React, AllWidgetProps, jsx } from \u0026#34;jimu-core\u0026#34;; export default class Widget extends React.PureComponent\u0026lt;AllWidgetProps\u0026lt;{}\u0026gt;, any\u0026gt; { render() { return ( \u0026lt;div className=\u0026#34;widget-starter jimu-widget\u0026#34; style={{ overflow: \u0026#34;auto\u0026#34; }}\u0026gt; \u0026lt;p\u0026gt;Hello world!\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Widget Name: {this.props.label}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } } 関数コンポーネントを使ったウィジェットの作成 以下の例では、シンプルな hello world 関数の widget/component を作成するために必要なモジュールをロードしています。ウィジェットは、export default function Widget (props: AllWidgetProps) { で AllWidgetProps 型の関数として宣言されており、ウィジェットの props を使用しています。translations ファイルの _widgetLabel のプロパティで設定した テキスト名: hello world とウィジェット名を返します。\n/** @jsx jsx */ import { AllWidgetProps, jsx} from \u0026#34;jimu-core\u0026#34;; export default function Widget (props:AllWidgetProps) { return \u0026lt;div className=\u0026#34;widget-starter jimu-widget\u0026#34; style={{ overflow: \u0026#34;auto\u0026#34; }}\u0026gt; \u0026lt;p\u0026gt;Hello world!\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Widget Name: {props.label}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; } ウィジェットの UI 設定 ウィジェットの UI 設定は、ウィジェットの作成と似ていますが、setting フォルダの setting.tsx を使用することができます。ウィジェットの UI 設定を作成するには、クラスと関数の 2 つの方法があります。クラス コンポーネントを使用するには、React.PureComponent クラスを継承します。この例では、データソースを追加して設定パネルの config.json ファイルを操作する方法を示しています。また、この例では以下のインポートに注意する必要があります。\n import React は React.PureComponent クラスに使用されます。 import DataSourceTypes はデータソースの種類に使用します。 import SettingSection と SettingRow は設定に便利な UI コンポーネントです。 import DataSourceSelector もデータソースの選択に使われるコンポーネントです。 import IMConfig は config.json ファイルに使用されます。  import {React, Immutable, FormattedMessage} from \u0026#39;jimu-core\u0026#39;; import {AllWidgetSettingProps} from \u0026#39;jimu-for-builder\u0026#39;; import {DataSourceTypes} from \u0026#39;jimu-arcgis\u0026#39;; import {SettingSection, SettingRow} from \u0026#39;jimu-ui/advanced/setting-components\u0026#39;; import {DataSourceSelector} from \u0026#39;jimu-ui/advanced/data-source-selector\u0026#39;; import {IMConfig} from \u0026#39;../config\u0026#39;; import defaultI18nMessages from \u0026#39;./translations/default\u0026#39; React.PureComponent クラスは AllWidgetSettingsProps 型と IMConfig 型で宣言されています。supportedTypes プロパティは、クラス全体を通してデータソース タイプの Webmap に使用されます。onDataSourceSelected は、データソースの選択を処理する関数を持つクラス プロパティです。this.props.OnSettingChange() 関数は、設定 UI の変更を通知するために使用されます。onP1Change と onP2Change クラス プロパティは、React のイベント処理を使用して、config.json ファイルの値の設定を助けます。\nexport default class Setting extends React.PureComponent{ supportedTypes = Immutable([DataSourceTypes.WebMap]); onDataSourceSelected = (useDataSources: UseDataSource[]) =\u0026gt; { this.props.onSettingChange({ id: this.props.id, useDataSources: useDataSources }); } onP1Change = (evt: React.FormEvent\u0026lt;HTMLInputElement\u0026gt;) =\u0026gt; { this.props.onSettingChange({ id: this.props.id, config: this.props.config.set(\u0026#39;p1\u0026#39;, evt.currentTarget.value) }); } onP2Change = (evt: React.FormEvent\u0026lt;HTMLInputElement\u0026gt;) =\u0026gt; { this.props.onSettingChange({ id: this.props.id, config: this.props.config.set(\u0026#39;p2\u0026#39;, evt.currentTarget.value) }); } jimu ライブラリには、ウィジェットで使用できるコンポーネントがあります。例えば、Web マップを選択のための UI を支援するために、DataSourceSelector コンポーネントが、選択されたデータソースのタイプ、ID、およびコールバックを処理するために使用されます。さらに、SettingSection コンポーネントと SettingRow コンポーネントは、翻訳や config ファイルからの文字列のコンテナの整形を処理するために使用されます。\nrender(){ return \u0026lt;div className=\u0026#34;sample-map-view-setting p-2\u0026#34;\u0026gt; \u0026lt;DataSourceSelector types={this.supportedTypes} mustUseDataSource useDataSources={this.props.useDataSources} onChange={this.onDataSourceSelected} widgetId={this.props.id} /\u0026gt; \u0026lt;SettingSection\u0026gt; \u0026lt;SettingRow label={\u0026lt;FormattedMessage id=\u0026#34;p1\u0026#34; defaultMessage={defaultI18nMessages.p1}/\u0026gt;}\u0026gt; \u0026lt;input defaultValue={this.props.config.p1} onChange={this.onP1Change}/\u0026gt;\u0026lt;/SettingRow\u0026gt; \u0026lt;SettingRow label={\u0026lt;FormattedMessage id=\u0026#34;p2\u0026#34; defaultMessage={defaultI18nMessages.p2}/\u0026gt;}\u0026gt; \u0026lt;input defaultValue={this.props.config.p2} onChange={this.onP2Change}/\u0026gt;\u0026lt;/SettingRow\u0026gt; \u0026lt;/SettingSection\u0026gt; \u0026lt;/div\u0026gt; } } Props ウィジェットでは props があります。クラス コンポーネントの this.props や関数コンポーネントの props パラメータ {props} を通してアクセスすることができます。例えば、クラス コンポーネントを使用してウィジェットの config.json にある props にアクセスするには、this.props.config を使用します。関数コンポーネントでアクセスするには、props.config を使用します。利用可能なプロパティの詳細については、Experience Builder の client/jimu-core/lib/types/props.ts を参照してください。\nstatic mapExtraStateProps = (state: IMState) =\u0026gt; { return { appMode: state \u0026amp;\u0026amp; state.appRuntimeInfo \u0026amp;\u0026amp; state.appRuntimeInfo.appMode }; }; i18n サポート Experience Builder は react-intl ライブラリを使用して i18n をサポートしています。ウィジェットで言語のサポートを有効にするには、ウィジェットの manifest.json で translatedLocales プロパティのロケールを宣言します。慣例によりデフォルトのロケールを最初に指定しなければなりません。例えば、以下のスニペットでは、translatedLocales プロパティのデフォルトロケールは、英語(米国)、スペイン語、中国語(北京語) の順になっています。\n\u0026#34;translatedLocales\u0026#34;: [ \u0026#34;en\u0026#34;, \u0026#34;es\u0026#34;, \u0026#34;zh-cn\u0026#34; ] 翻訳文字列は、runtime/translations フォルダーと settings/translations フォルダーにある default.ts というファイル内に設定する必要があります。default.ts はデフォルトで使用される文字列を定義し、ウィジェットにインポートしてデフォルト メッセージに使用できます。default.ts の書式は以下のとおりです。\nexport default { _widgetLabel: \u0026#39;My Widget\u0026#39;, str1: \u0026#39;String 1\u0026#39;, } サポートされる言語が増えるごとに、translations フォルダーにそのロケールに対応した名前のファイルを作成します。例えば、スペイン語は translations/es.js です。ファイルの内容は default.ts で定義されているものと同じプロパティを持ち、そのロケールの翻訳文字列を値として持つ形式となります。\nSystem.register([], function (_export) {return {execute: function () {_export({ // the strings  _widgetLabel: \u0026#39;Translated Widget Name\u0026#39;, str1: \u0026#39;Translated String 1\u0026#39;, })}}}); ウィジェット ファイル (例：widget.tsx) において、翻訳された文字列にアクセスする様々な方法を示します。\n// Class component this.props.intl.formatMessage({id: \u0026#39;str1\u0026#39;, defaultMessage: defaultMessages.str1}) // Function component props.intl.formatMessage({id: \u0026#39;str1\u0026#39;, defaultMessage: defaultMessage.str1}) // JSX \u0026lt;FormattedMessage id=\u0026#34;str1\u0026#34; defaultMessage={defaultMessages.str1}/\u0026gt; マップ ビュー/シーン ビュー ほとんどの Experience Builder では、ウィジェットはマップ ビュー/シーン ビューで動作し、同様にビュー内のレイヤーにアクセスする必要があります。一貫した拡張性モデルを持つことを保証するために、Experience Builder フレームワーク内での使用をより簡単にするために、他のクラスやメソッドに加えて、MapViewManager クラスが jimu-arcgis で利用可能です。基本的に全てのウィジェットは createJimuMapView メソッドを呼び出して MapViewManager にマップ ビュー/シーン ビューを追加し、他のウィジェットで使用できるようにすることができます。\nMapViewManager.getInstance().createJimuMapView({ mapWidgetId: this.props.id, view: new MapView(options), datasourceId: webmapDs.id, isActive: true }) マップ ビュー/シーン ビューを使用する必要がある他のウィジェットでは、UI 設定で MapWidgetSelector を使用して選択することができます。選択したマップ/シーンは WidgetJson.useMapWidgetsIds に保存されます。\n\u0026lt;MapWidgetSelector onSelect={this.onMapWidgetSelected} useMapWidgetIds={this.props.useMapWidgetIds[0]} /\u0026gt; ArcGIS Maps SDK for JavaScript のモジュール 既定では、Experience Builder はアプリのロード時に ArcGIS Maps SDK for JavaScript (JS API) をロードしません。JS API モジュールを利用するには、2 つのオプションがあります。\n JS API に依存するウィジェット (例：JS API がないと何もできません。)  ウィジェットの manifest.json で jimu-arcgis 依存関係を宣言します。 widget.tsx で必要なモジュールをインポート import Query = require('esri/tasks/support/Query') します。    const query = new Query({ where: `${typeIdField}= ${graphic.attributes[objectIdField]}`, outFields: [\u0026#39;FirstName\u0026#39;], returnGeometry: true })  条件付きで JS API に依存するウィジェット (例：JS API が無くても何かを実行することはできます。)  import {loadArcGISJSAPIModules} と loadArcGISJSAPIModules([]) を使用してモジュールを動的にロードします。    loadArcGISJSAPIModules([\u0026#39;esri/widgets/Directions\u0026#39;]).then(modules =\u0026gt; { [this.Directions] = modules; this.setState({ apiLoaded: true }); }) インライン編集をサポート 構成可能なすべてのウィジェットは、ウィジェットの構成を可能にする設定ページを提供する必要があります。ただし、構成によっては、設定パネルよりもウィジェットの設定を変更する方が簡単な場合があります。このワークフローでは、ウィジェットはインライン編集機能を提供することで、この機能をサポートすることができます。\nインライン編集を実装する方法はいくつかあります。\n ウィジェットの manifest.json の properties オブジェクトに supportInlineEditing を宣言します。このインスタンスでは、ウィジェットが Builder で起動されたときにウィジェットに編集ツールバーが表示されます。Text ウィジェットはこのように実装されています。 ウィジェットの manifest.json の properties オブジェクトに hasEmbeddedLayout を宣言します。この場合、ユーザーが他のウィジェットをウィジェットの中でドラッグ＆ドロップできるようにするために、レイアウト コンポーネントを使用することをお勧めします。jimu-layouts/layout-builder と jimu-layouts/layout-runtime からエクスポートされた 2 つのレイアウト コンポーネントがあります。ウィジェットでは、jimu-layouts/layout-runtime からエクスポートされたレイアウトコンポーネントを使用する必要があります。jimu-layouts/layout-builder からエクスポートされたコンポーネントにアクセスするには、this.props.builderSupportModules.LayoutClass を使用します。List ウィジェットはこの手法を使っています。 ウィジェットの manifest.json で CONTEXT_TOOL 拡張機能を宣言します。宣言した拡張機能は選択ツールバーで利用できるようになります。Image ウィジェットは、このように選択ツールバーに shape ツールや crop ツールを追加して使用します。  インライン編集をサポートするために、ウィジェットは Builder でウィジェットを起動した時にのみ必要なモジュールが含まれている場合があります。このシナリオでは、これらのモジュールを builder-support.tsx に配置します。このファイルは widget.tsx と同じフォルダにあるはずです。このファイル内のモジュールは、ウィジェットが Builder で起動されると、this.props.builderSupportModules.widgetModules 内で利用できるようになります。\nベストプラクティス  ウィジェットのクラス名として widget-\u0026lt;widget name\u0026gt; を、ウィジェット設定のクラス名として widget-setting-\u0026lt;widget name\u0026gt; を使用して、ウィジェットのルート CSS クラス名を指定します。 サードパーティの内蔵ライブラリをロードするには import {} from 'jimu-core' を使います。例えば、import {React} from 'jimu-core から {React} をインポートします; import {} from '3rd_lib' を使うと、lib がウィジェットに組み込まれるので、ウィジェットのサイズは大きくなります。 widget の src フォルダに Typesafe 設定ファイルを作成し、widget.tsx と setting.tsx の両方で使用します。 可能な限りアウトオブボックスの UI コンポーネントを活用して、ウィジェット UI を作成する方法の詳細をご覧ください。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/samples/",
	"title": "サンプル集",
	"tags": [],
	"description": "開発にすぐに使えるサンプル データ/コードを紹介します。",
	"content": "開発にすぐに使えるサンプル データ/コードを紹介します。\nサンプル データ 開発でサンプルとして利用可能なデータです。以下は抜粋ですので、他のサンプル データを探したい場合は、マップ ビューアーでレイヤー検索してみてください。\n マップ  Web マップ（ArcGIS for Developers 開発ガイドのサンプル Web マップ）   フィーチャ レイヤー  tokyo_23（東京都における東京23区、市部、町村部（郡部）（町村部（島部）以外））   タイル レイヤー  南海トラフ巨大地震の被害想定（震度/最大クラス） 南海トラフ巨大地震の被害想定（液状化/最大クラス）    サンプル コード GitHub にて開発サンプルとなるソースコードを公開しています。\n JavaScript  arcgis-samples-js: ArcGIS API for JavaScript のサンプル集 data-visualization-js: JavaScript で始めるデータ ビジュアライゼーションのサンプル webmap-startup-template-js: Web マップを使用した開発手法を伝えるためのアプリケーション テンプレートのサンプル   .NET  arcgis-samples-dotnet: ArcGIS Runtime SDK for .NET のサンプル集 startup-sample-dotnet: .NET SDK のスタートアップ サンプル アプリケーション webmap-startup-template-dotnet: Web マップを使用した開発手法を伝えるためのアプリケーションのサンプル   Android  arcgis-samples-android: ArcGIS Runtime SDK for Android のサンプル集   iOS  arcgis-samples-ios: ArcGIS Runtime SDK for iOS (Objective-C/Swift) のサンプル集 startup-swift-ios: iOS SDK のスタートアップ サンプル アプリケーション   Python  arcgis-samples-python-api    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/theme/",
	"title": "テーマ（Theme）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Theme\nテーマ（Theme） テーマは、エクスペリエンスの外観と使用感を定義します。エクスペリエンスは、すぐに使える (OOB) テーマがあり、カスタムテーマの作成も可能です。テーマ開発については、theme development をご覧ください。\napp config では、アプリが使用するテーマは theme で定義されます。テーマをカスタマイズした場合、そのカスタマイズ内容は customTheme に保存されます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-dotnet/",
	"title": ".NET",
	"tags": [],
	"description": "ArcGIS Maps SDK for .NET を用いたネイティブ地図アプリの作成方法を紹介します。",
	"content": "出典：ArcGIS Maps SDK for .NET - Tutorials - Display a map\nマップを表示する このチュートリアルでは ArcGIS Maps SDK for .NET を使用して、マップとベースマップ レイヤーを表示する方法を紹介します。\nマップには、地理データのレイヤーが含まれています。マップには、ベースマップ レイヤーと、オプションで 1 つ以上のデータ レイヤーを追加できます。マップ ビューを使用し、場所とズーム レベルを設定することで、マップの特定の領域を表示できます。\nこのチュートリアルでは、地形 ベクタータイル ベースマップ レイヤーを使用して、富士山付近を表示する地図を作成します。\nこのチュートリアルのトピックの背景情報については、Mapping API and location services guide の Maps (2D) と ベースマップ を参照してください。\n\r前提条件 このチュートリアルを実施するには、以下が必要です。\n API キーにアクセスするための ArcGIS 開発者アカウント。アカウントをお持ちでない場合は、無料でサインアップ してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。 開発環境がシステム要件を満たしていることを確認します。  必要に応じて、ArcGIS Maps SDK for .NET をインストールして、Visual Studio プロジェクト テンプレート (Windows のみ) とオフラインにコピーされた NuGet パッケージを利用することもできます。\nステップ 新しい Visual Studio プロジェクトを作成する ArcGIS Maps SDK for .NET は、Windows Presentation Framework (WPF)、Universal Windows Platform (UWP)、Windows UI Library (WinUI)、.NET MAUI 向けのアプリをサポートしています。 このチュートリアルの説明は、Visual Studio for Windows を使用して WPF .NET プロジェクトを作成する手順を説明します。\n.NET API アプリを開発できるプラットフォームは、開発環境に応じて異なります。例えば、Visual Studio for Mac を使用する場合、WP Fと UWP のプロジェクトは利用できません。詳しくは、システム要件をご覧ください。\n\r Visual Studio を起動し、新しいプロジェクトを作成します。  Visual Studio の開始画面で、[新しいプロジェクトの作成] をクリックします C# 用の [WPF アプリケーション]テンプレートを選択します。テンプレートが表示されていない場合は、テンプレートの検索テキストボックスに WPF アプリケーション と入力すると、テンプレートを見つけることができます。 [次へ] をクリックします。 [新しいプロジェクトを構成します] 画面で必要な値を入力します。  プロジェクト名: DisplayAMap 場所: 任意のフォルダーを選択   [次へ] をクリックします。  フレームワークで .NET 8.0 (長期的なサポート) を選択します。   [作成] をクリックしてプロジェクトを作成します。    Visual Studio for Windows で開発する場合、ArcGIS Maps SDK for .NET には、サポートされる .NET プラットフォームごとにプロジェクト テンプレート セットが用意されています。これらのテンプレートは、Model-View-ViewModel（MVVM）デザイン パターンに従っています。ArcGIS Maps SDK for .NET Visual Studio Extension をインストールして、テンプレートを Visual Studio に追加します（Windows のみ）。詳細については、インストールとセットアップを参照してください。\nこのチュートリアルの手順は、WPF for .NET（Visual Studio 2022 以降が必要）を使用してアプリケーションを作成することに特化しています。サポートされている他の .NET プラットフォームでアプリを完成させるには、ArcGIS Maps SDK for .NET プロジェクト テンプレートの 1 つからプロジェクトを作成できます。Visual Studio テンプレートの 1 つから開始する場合、ガイドに記載されているコードとプロジェクトに含まれるコードにいくつかの違いがあることがあります。\n\rAPI の参照を追加する ArcGIS Maps SDK for .NET プロジェクト テンプレートの 1 つからプロジェクトを作成した場合、必要な NuGet パッケージが既にプロジェクトに追加されています。\n\r  NuGet パッケージをインストールして、API への参照を追加します。\n ソリューション エクスプローラーで、[依存関係] を右クリックし、[NuGet パッケージの管理] を選択します。 [NuGet パッケージ マネージャー] ウィンドウで、[パッケージ ソース] に nuget.org (右上)が選択されていることを確認します。 [参照] タブを選択して、ArcGIS Maps SDK を検索します。 検索結果から、プラットフォームに適したパッケージを選択します。このチュートリアルではEsri.ArcGISRuntime.WPF NuGet パッケージを選択します。 [バージョン] にパッケージの「最新の安定版\u0026hellip;」が選択されていることを確認します。 [インストール] をクリックします。 NuGet は、パッケージの依存関係または競合を自動的に解決します。デフォルトでは、[変更のプレビュー] ダイアログが表示されます。 変更を確認し [OK] をクリックしてパッケージのインストールを続行します。 [ライセンスへの同意] ダイアログでライセンス条項を確認し、[同意する] をクリックしてパッケージをプロジェクトに追加します。 Visual Studio の [出力] ウィンドウで、パッケージが正常にインストールされたことを確認します。ターゲットの Windows バージョンに関するエラーが表示された場合は、次の手順で修正します。 [NuGet パッケージ マネージャー] ウィンドウを閉じます。    Visual Studio エラー リストに The 'Esri.ArcGISRuntime.WPF' nuget package cannot be used to target 'net8.0-windows'. Target 'net8.0-windows10.0.19041.0' or later instead. のようなエラーが表示される場合があります。その場合は、次の手順に従って対処してください。 *\n  ソリューション エクスプローラーで、ツリー ビューの DisplayAMap プロジェクト エントリを右クリックし、[プロジェクト ファイルの編集] を選択します。\n  \u0026lt;TargetFramework\u0026gt; 要素を net8.0-windows10.0.19041.0（またはそれ以上）で更新します。\n\u0026lt;PropertyGroup\u0026gt; \u0026lt;OutputType\u0026gt;WinExe\u0026lt;/OutputType\u0026gt; \u0026lt;TargetFramework\u0026gt;net8.0-windows10.0.19041.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;UseWPF\u0026gt;true\u0026lt;/UseWPF\u0026gt; \u0026lt;/PropertyGroup\u0026gt;   プロジェクト ファイル (DisplayAMap) を保存して閉じます。\n    API キーを取得する ArcGIS Online でホストされているサービス、Web マップ、および Web シーンにアクセスするには API キーが必要です。\nまだ取得していない場合は、ArcGIS Developers のダッシュボードに移動してAPIキーを取得します。\n以下では、このAPIキーを使用します。\nアプリで API キーを設定する   ソリューション エクスプローラーで、App.xaml のノードを展開し、App.xaml.cs をダブルクリックして開きます。\n  App クラスで、OnStartup() 関数のオーバーライドを追加して、ArcGISRuntimeEnvironment で ApiKey プロパティを設定します。\nAPI キーは、このチュートリアルの便宜上、コードに直接格納されていますが、ソース コードに API キーを格納することは、ベスト プラクティスではありません。\n\rApp.xaml.cs\npublic partial class App : Application { // 追加開始  protected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); // 注: API キーをソース コードに保存することはベスト プラクティスではありません。  // API キーは、チュートリアルの便宜上、ここで参照されています。  Esri.ArcGISRuntime.ArcGISRuntimeEnvironment.ApiKey = \u0026#34;API キー\u0026#34;; } // 追加終了 }   App.xaml.cs ファイルを保存して閉じます。\n  アプリ ロジックを保存するビュー モデルを作成する このアプリは、以降のすべてのチュートリアルで使用する基盤を構築するためのものです。堅固な設計で構築することをお勧めします。\nModel-View-ViewModel (MVVM) デザイン パターンは、ユーザー インターフェイス要素 (および関連するコード) をアプリの基礎となるロジックから分離するアーキテクチャを提供します。このパターンでは、モデルはアプリで消費されるデータを表し、ビュー はユーザー インターフェースであり、ビューモデル にはモデルとビューをバインド (結合) するロジックが含まれます。このようなパターンに必要な追加のフレームワークは、小規模なプロジェクトでは大変な作業に思えるかもしれませんが、プロジェクトの複雑さが増すにつれて、堅固な設計を行うことでコードの保守性と柔軟性が大幅に向上します。\nMVVM で設計された ArcGIS アプリでは、通常、マップ ビューがメインのビュー コンポーネントになります。クラスの多くは、モデルの役割を果たします (データをマップ、レイヤー、グラフィックス、フィーチャなどとして表します)。 ビュー モデル コンポーネントには、ArcGIS オブジェクトを操作するためのロジックを追加したり、ビューに表示するためのデータを提供したりするため、記述するコードの多くはここになります。\nすべての ArcGIS Maps SDK for .NET プロジェクト テンプレートは、MVVM デザインパターンを使用しています。\n\r  プロジェクトのビュー モデルを定義する新しいクラスを追加します。\n [プロジェクト] メニュー \u0026gt; [クラスの追加\u0026hellip;] をクリックします。 新しいクラスに MapViewModel.cs と名前を付けます。 [追加] をクリックして新しいクラスを作成し、プロジェクトに追加します。 新しいクラスが VisualStudio で開きます。    必要な using ステートメントをビュー モデルに追加します。\nMapViewModel.cs\nusing System; using System.Collections.Generic; using System.Text; // 追加開始 using Esri.ArcGISRuntime.Mapping; using System.ComponentModel; using System.Runtime.CompilerServices; // 追加終了   MapViewModel クラスに INotifyPropertyChanged インターフェイスを実装します。\nこのインターフェイスは、ビュー モデルのプロパティが変更されたことをクライアント (ビュー) に通知するために使用される PropertyChanged イベントを定義します。\nMapViewModel.cs\nnamespace DisplayAMap { // 変更前  // internal class MapViewModel  // 変更後  internal class MapViewModel : INotifyPropertyChanged { } }   MapViewModel クラス内に、PropertyChanged イベントを実装するコードを追加します。 ビュー モデルのプロパティが変更されると、OnPropertyChanged の呼び出しにより、このイベントが発生します。\nMapViewModel.cs\nclass MapViewModel : INotifyPropertyChanged { // 追加開始  public event PropertyChangedEventHandler? PropertyChanged; protected void OnPropertyChanged([CallerMemberName] string propertyName = \u0026#34;\u0026#34;) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } // 追加終了 }   ビュー モデルに Map オブジェクトを公開する Map という新しいプロパティを定義します。 プロパティが設定されると、OnPropertyChanged を呼び出します。\nMapViewModel.cs\npublic event PropertyChangedEventHandler? PropertyChanged; protected void OnPropertyChanged([CallerMemberName] string propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } // 追加開始  private Map? _map; public Map? Map { get { return _map; } set { _map = value; OnPropertyChanged(); } } // 追加終了 }   MapViewModel クラスに SetupMap という関数を追加します。この関数は、新しいマップを作成して Map プロパティを設定します。\nマップは、地形 ベクタータイル ベースマップを使用します。ベースマップのデフォルトのラベル表示は英語のため、日本語に変更します。\nMapViewModel.cs\nprivate Map _map; public Map Map { get { return _map; } set { _map = value; OnPropertyChanged(); } } // 追加開始  private void SetupMap() { //ベースマップのラベルを日本語で表示します。  BasemapStyleParameters bsp = new BasemapStyleParameters(); bsp.SpecificLanguage = System.Globalization.CultureInfo.CreateSpecificCulture(\u0026#34;ja\u0026#34;); Basemap basemap = new Basemap(BasemapStyle.ArcGISTopographic, bsp); //地形 ベクタータイル ベースマップを使用して新しいマップを作成します。  Map = new Map(basemap); } // 追加終了 }   MapViewModel が新規にインスタンス化された際に、SetupMap 関数を呼び出すコンストラクターを追加します。\nMapViewModel newMapVM = new MapViewModel(); のようなコードを書くと、クラス コンストラクターが実行されます。これはクラスが初期化された時に実行する必要があるコードを追加するのに良い場所です。\nMapViewModel.cs\nclass MapViewModel : INotifyPropertyChanged { // 追加開始  public MapViewModel() { SetupMap(); } // 追加終了  public event PropertyChangedEventHandler? PropertyChanged; protected void OnPropertyChanged([CallerMemberName] string propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); }   これで MapViewModel が完成しました。\nMVVM デザイン パターンを使用する利点は、ビュー モデルのコードを再利用できることです。API はプラットフォーム間でほぼ標準的な API サーフェスを持っているため、１つのアプリ用に作成した ビュー モデル のコードは、通常、サポートされているすべての .NET プラットフォームで動作します。\n次に、プロジェクトに ビュー を設定して、ビュー モデルを使用します。\nマップ ビューを追加する MapView コントロールは、マップを表示するために使用します。 マップ ビューをプロジェクトの UI に追加し、MapViewModel で定義したマップを使用するように設定します。\n  必要な XML 名前空間とリソースを追加します。\n MainWindow.xaml を開き、XAML ビューに切り替えます。 既存の名前空間の宣言内に、ArcGIS コントロールの esri XML 名前空間を追加します。 MapViewModel インスタンスを静的リソースとして定義する XAML を追加します。  MainWindow.xaml\n\u0026lt;Window x:Class=\u0026#34;DisplayAMap.MainWindow\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:d=\u0026#34;http://schemas.microsoft.com/expression/blend/2008\u0026#34; xmlns:mc=\u0026#34;http://schemas.openxmlformats.org/markup-compatibility/2006\u0026#34; xmlns:local=\u0026#34;clr-namespace:DisplayAMap\u0026#34; \u0026lt;!--追加開始--\u0026gt; xmlns:esri=\u0026#34;http://schemas.esri.com/arcgis/runtime/2013\u0026#34; \u0026lt;!--追加終了--\u0026gt; mc:Ignorable=\u0026#34;d\u0026#34; Title=\u0026#34;MainWindow\u0026#34; Height=\u0026#34;450\u0026#34; Width=\u0026#34;800\u0026#34;\u0026gt; \u0026lt;!--追加開始--\u0026gt; \u0026lt;Window.Resources\u0026gt; \u0026lt;local:MapViewModel x:Key=\u0026#34;MapViewModel\u0026#34; /\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;!--追加終了--\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;/Grid\u0026gt;   MapView コントロールを MainWindow.xaml に追加し、MapViewModel にバインドします。\n MainMapView という名前の MapView コントロールを定義する XAML を追加します。 データ バインディングを使用して、MapViewModel リソースを使用しコントロールの Map プロパティを設定します。  MainWindow.xaml\n\u0026lt;Window.Resources\u0026gt; \u0026lt;local:MapViewModel x:Key=\u0026#34;MapViewModel\u0026#34; /\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;!--追加開始--\u0026gt; \u0026lt;esri:MapView x:Name=\u0026#34;MainMapView\u0026#34; Map=\u0026#34;{Binding Map, Source={StaticResource MapViewModel}}\u0026#34; /\u0026gt; \u0026lt;!--追加終了--\u0026gt; \u0026lt;/Grid\u0026gt;   マップ ビューの視点を設定する ウィンドウの読み込み時にマップ ビューの視点 (ビュー ポイント) を設定します。富士山を中心にマップを表示するための、位置と縮尺を定義します。\n  MainWindow.xaml.cs を開きます。 これは、MainWindow.xaml に関連付けられたコードと、それが定義するユーザー インターフェイス要素を含むコード ビハインド ファイルです。\n  必要な using ステートメントを追加します。\nMainWindow.xaml.cs\nusing System.Windows.Navigation; using System.Windows.Shapes; // 追加開始 using Esri.ArcGISRuntime.Geometry; using Esri.ArcGISRuntime.Mapping; // 追加終了  namespace DisplayAMap {   MainWindow のコンストラクターで、新しい Viewpoint を定義するコードを追加し、マップ ビューに適用します。\nMainWindow.xaml.cs\npublic MainWindow() { InitializeComponent(); // 追加開始  // マップの中心位置として設定する MapPoint を作成  MapPoint mapCenterPoint = new MapPoint(138.727363, 35.360626, SpatialReferences.Wgs84); // マップの視点を決める Viewpoint を設定  MainMapView.SetViewpoint(new Viewpoint(mapCenterPoint, 200000.0)); // 追加終了 }   アプリを実行する [デバッグ] メニュー \u0026gt; [デバッグの開始] をクリックして (またはキーボードの \u0026lt;F5\u0026gt; キーを押して) アプリを実行します。\n富士山を中心に、地形 ベクタータイル ベースマップ レイヤーが追加されたマップが表示されます。マップ ビュー上でマウス ホイールをダブルクリック、ドラッグ、およびスクロールして、マップを操作します。\n完成版のプロジェクトはこちらからダウンロードできます (マップの表示場所は本チュートリアルで設定した場所とは異なります)。\nWeb マップを表示する 「Web マップの作成」のガイドで Web マップを作成している場合は、作成した Web マップも基本的に同じステップで表示できます。\n  Visual Studio で、マップを表示するのステップで作成したプロジェクトの MapViewModel.cs を開きます。\n  必要な using ステートメントを追加します。\nMapViewModel.cs\nusing Esri.ArcGISRuntime.Portal; using System.Threading.Tasks;   MapViewModel.cs 内の SetupMap 関数を下記のように書き換えます。\nMapViewModel.cs\nprivate async Task SetupMap() { // ArcGIS ポータルを作成します。URI を指定しない場合は \u0026#34;www.arcgis.com\u0026#34; を使用します。  ArcGISPortal portal = await ArcGISPortal.CreateAsync(); // アイテム ID を使用して、Web マップをポータル アイテムとして取得します。  PortalItem mapItem = await PortalItem.CreateAsync(portal, \u0026#34;Web マップの ID\u0026#34;); // ポータル アイテムからマップを作成します。  Map map = new Map(mapItem); // マップを表示するには、マップ ビューにバインドされている MapViewModel.Map プロパティを設定します。  this.Map = map; }    アプリの動作が確認できたら ArcGIS の セキュリティと認証について学びましょう！\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/appstudio/",
	"title": "ArcGIS AppStudio",
	"tags": [],
	"description": "ArcGIS AppStudio を使用したアプリ作成に役立つガイド集です。",
	"content": "ArcGIS AppStudio を使用したアプリ作成に役立つガイド集です。\nArcGIS AppStudio は2025年1月末日でサポートが終了します。ArcGIS AppStudio のサポートおよび移行に関する情報についてはこちらをご参照ください。\n\r  ガイド\n AppStudio の概要からアプリの作成・デプロイ、AppStudio Player を使用したモバイル デバイスでのテスト、カスタマイズ方法等を紹介したガイドです。    AppStudio Framework API リファレンス（英語）\n AppStudio Framework API は、ファイルパスの管理、ネットワーク インターフェース、画像操作などの、プラットフォーム共通の基本機能を提供しています。    ユースケース\n ギャラリー（英語）  全世界のユーザーによって作成されたアプリと利活用方法が紹介されています。   国内事例  日本国内での事例を紹介しています。      システム要件\n システム要件（米国Esri社）  AppStudio のデスクトップ用のアプリ、AppStudio Player のサポート OS 等のシステム要件が記載されています。   システム要件（Esriジャパン）  日本国内での固有のシステム要件を記載しています。      ライセンス\n AppStudio の 2 つのライセンス オプション（「ArcGIS AppStudio」と「ArcGIS AppStudio Developer Edition」）について紹介しています。    ダウンロード\n AppStudio のデスクトップ用のアプリ、AppStudio Player はこちらからダウンロード（無償）できます。    インストール\n AppStudio のデスクトップ用のアプリ、AppStudio Player のインストール方法を紹介しています。    チュートリアル\n アプリの作成からデプロイまでの手順を示したチュートリアルです。はじめての方はこちらのチュートリアルをお試しください。 コーディングによるカスタマイズのチュートリアルは、ハイカー向けアプリの構成 をお試しください。AppStudio の Nearby（近傍）テンプレートを使用したアプリ作成のチュートリアルで、最後にコーディングによるカスタマイズを行います。    その他\n  FAQ（米国Esri社）\n よくあるご質問とその回答が記載されています。    Esri Community（英語）\n 全世界のユーザーが投稿した製品に関する質問等の投稿を確認できます。    その他の Tips\n アプリ作成に関する技術的な情報を紹介しています。      "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/widget-ui/",
	"title": "ウィジェット UI の作成",
	"tags": [],
	"description": "ウィジェット UI の作成方法について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Create UI for widget\nExperience Builder のベースとなる Widget クラスは、React のコンポーネントサブクラスから拡張されています。PureComponent から拡張されており、render() と呼ばれる関数を提供しています。UI の作業のほとんどは、この関数の内部で行われることが予想されます。\nJSX の記述 UI テンプレートの作成に使用される React の構文は JSX と呼ばれています。これは HTML を書くのと非常に似ていますが、JavaScript の機能を完全に組み込んでいます。\nJSX の詳細を参照してください。\nここでは、ウィジェットの UI にいくつかの基本的な HTML 要素を追加する簡単な例を示します。\n// in widget.tsx: import { React, AllWidgetProps } from \u0026#39;jimu-core\u0026#39;; export default class Widget extends React.PureComponent\u0026lt;AllWidgetProps\u0026lt;{}\u0026gt;, any\u0026gt;{ render() { return \u0026lt;div className=\u0026#34;myWidget\u0026#34;\u0026gt; \u0026lt;p\u0026gt;This is a sample widget\u0026lt;/p\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; style={{background: \u0026#39;orange\u0026#39;}}\u0026gt;I\u0026#39;m a button\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;; } } Output 例: Jimu UI ライブラリの使用 Jimu フレームワークは、開発者がウィジェット開発で使用するコンポーネントの UI ライブラリを提供しています。\n 基本的な UI コンポーネント: button, dropdown, form controls, icon, navigation, modal, grid layout container など 高度な UI コンポーネント: date picker, resource selector, expression builder など  内部的には、Jimu の UI コンポーネントは Reactstrap と呼ばれる React Bootstrap フレームワークから拡張・カスタマイズされています。このライブラリは、他の類似した React UI ライブラリと同様に、コンポーネントの使用方法についても同様のパターンを踏襲しています。\n一般的に使用されているコンポーネントやアイコンのほとんどは、Storybookのサイト (https://developers.arcgis.com/experience-builder/storybook) にアクセスしてプレビューすることができます。\nExperience Builder の Storybook の詳細を参照してください。\nJimu UI は Experience Builder の公式 UI ライブラリであり、このライブラリのコンポーネントを考慮して UI 開発を利用することを強くお勧めします。その理由は以下の通りです。\n UI/UX の一貫性: ウィジェットの全体的な外観と操作感、それを使って作成されたアプリは、一貫したパターンに従います。 テーマ性：コンポーネントのスタイルは設定可能でテーマ性があるため、さまざまなテーマに対応したウィジェットを簡単に作ることができます。 Experience Builder および ArcGIS とのより良い統合が実現できます。  UI コンポーネント コンポーネントのインポート 基本的な UI コンポーネントは「jimu-ui」から直接インポートでき、高度な UI コンポーネントはパスを使用して個別にインポートする必要があります。\nimport { Button, Icon, TextInput } from \u0026#39;jimu-ui\u0026#39;; // basic import { DatePicker } from \u0026#39;jimu-ui/date-picker\u0026#39;; // advanced クイック サンプル ここでは、\u0026ldquo;primary\u0026rdquo; スタイルの Button コンポーネントとスターアイコンをウィジェットに追加しています。\n// in widget.tsx: import { React, AllWidgetProps } from \u0026#39;jimu-core\u0026#39;; import { Button, Icon } from \u0026#39;jimu-ui\u0026#39;; // import components  // Create an svg icon using Icon component: const iconNode = \u0026lt;Icon icon={require(\u0026#39;jimu-ui/lib/icons/star.svg\u0026#39;)} /\u0026gt;; export default class Widget extends React.PureComponent\u0026lt;AllWidgetProps, any\u0026gt;{ render(){ // Add Button component containing an icon to the widget:  return \u0026lt;Button type=\u0026#34;primary\u0026#34;\u0026gt;{iconNode} primary button\u0026lt;/Button\u0026gt;; } } Output 例: CSS ユーティリティクラス Jimu UI は、Bootstrap と同じ CSS ユーティリティクラスを提供しており、UI 要素に素早くスタイルを適用することができます。\nクイック サンプル ここでは w-100、p-3、bg-primary、text-white を追加して要素を作成しています。\n 親要素の幅を 100% に設定 1 rem の padding（パディング）を設定 背景色を テーマの primary color として設定 テキストカラーを テーマの white color として設定  // in the render() function:  return \u0026lt;div className=\u0026#34;w-100 p-3 bg-primary text-white\u0026#34;\u0026gt; \u0026lt;p\u0026gt;This is a sample widget\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;; Output 例: ウィジェット スタイル設定 Experience Builder では、ウィジェットのスタイルを設定するには 3 つのオプションがあります。\nインライン CSS React のコンテキストでは、インラインの CSS スタイルは JavaScript オブジェクトとして記述され、DOM 要素の style 属性に適用されます。\n// in the render() function: const containerStyle = { background: \u0026#39;darkblue\u0026#39;, color: \u0026#39;white\u0026#39;, width: 200, height: 150, padding: \u0026#39;1rem\u0026#39;, borderRadius: 5 }; return \u0026lt;div style={containerStyle} // CSS styles applied \u0026gt; content \u0026lt;/div\u0026gt;; Output 例: 外部 CSS スタイルシート 別の方法としては、外部スタイルシートのファイルで CSS スタイルを定義し、ウィジェット内で個別にインポートする方法があります。使用できるスタイルシートのファイルの拡張子は .css、.sass、および .scss です。\n先ほどのコードサンプルを例に、CSS スタイルを別のスタイルシート (例: style.css) に移動します。\n/* style.css */ .my-widget { background: \u0026#39;darkblue\u0026#39;; color: \u0026#39;white\u0026#39;; width: 200px; height: 150px; padding: \u0026#39;1rem\u0026#39;; border-radius: 5px; } としてウィジェットにファイルをインポートします。\n// widget.tsx: import \u0026#39;path/to/style.css\u0026#39;; そして、style.css で定義されている DOM 要素にクラス名を追加することを忘れないでください。\n// widget.tsx: // in the render() function: return \u0026lt;div className=\u0026#34;my-widget\u0026#34;\u0026gt; content \u0026lt;/div\u0026gt;; Output 例: CSS-in-JS (推奨) CSS-in-JS とは、ベンダープレフィックス、スコープ付き CSS、JS ロジック、テーマ機能など、CSS では解決できない問題に対処するために JavaScript で CSS を書く方法のことを指します。\nStyled Components や Emotion など、よく知られている CSS-in-JS のライブラリがたくさんあります。Experience Builder では、スタイリングとテーマ設定を目的としたフレームワークとして Emotion を使用しています。\nEmotion には 2 つのスタイリング パターンがあります。\n1. css prop Emotion の css prop を使うと、React のスタイルプロップに比べて、より自然で親しみやすい方法で CSS スタイルを書くことができます。CSS スタイルは template literals で書くことができるので、CSS の中に JS ロジックを書くことができます。\n例えば、以下のサンプルの Counter ウィジェットは、カウント値が 2 以上になるとテキストの色が赤から緑に変わります。\n/// widget.tsx: /** @jsx jsx */ // \u0026lt;-- make sure to include the jsx pragma import { React, AllWidgetProps } from \u0026#39;jimu-core\u0026#39;; import { css, jsx } from \u0026#39;jimu-core\u0026#39;; import { Button, ButtonGroup } from \u0026#39;jimu-ui\u0026#39;; interface State { count: number; } export default class Widget extends React.PureComponent\u0026lt;AllWidgetProps\u0026lt;{}\u0026gt;, State\u0026gt;{ constructor(props) { super(props); this.state = { count: 0, }; } render() { const numberStyle = css` font-size: 2.5rem; color: ${this.state.count \u0026gt; 2 ? \u0026#39;green\u0026#39; : \u0026#39;red\u0026#39;}; `; return \u0026lt;div className=\u0026#34;text-center\u0026#34;\u0026gt; \u0026lt;p css={numberStyle}\u0026gt;{this.state.count}\u0026lt;/p\u0026gt; \u0026lt;ButtonGroup\u0026gt; \u0026lt;Button type=\u0026#34;secondary\u0026#34; onClick={e =\u0026gt; {this.setState({ count: this.state.count - 1 })}}\u0026gt; - \u0026lt;/Button\u0026gt; \u0026lt;Button type=\u0026#34;secondary\u0026#34; onClick={e =\u0026gt; {this.setState({ count: this.state.count + 1 })}}\u0026gt; + \u0026lt;/Button\u0026gt; \u0026lt;/ButtonGroup\u0026gt; \u0026lt;/div\u0026gt;; } } Output 例: 2. Styled Components このパターンは Styled-Components ライブラリにインスピレーションされたもので、使い方は非常に似ています。\u0026ldquo;styled\u0026rdquo; アプローチは、ウィジェット内で再利用可能なコンポーネントを作成するのに最適です。\n/** @jsx jsx */ // \u0026lt;-- make sure to include the jsx pragma import { React, AllWidgetProps } from \u0026#39;jimu-core\u0026#39;; import { styled, jsx } from \u0026#39;jimu-core\u0026#39;; // A styled button component: const StyledButton = styled.button` color: white; background-color: blue; transition: 0.15s ease-in all; \u0026amp;:hover { background-color: darkblue; } `; export default class Widget extends React.PureComponent\u0026lt;AllWidgetProps\u0026lt;{}\u0026gt;\u0026gt;{ render() { return \u0026lt;StyledButton\u0026gt; A styled HTML Button \u0026lt;/StyledButton\u0026gt;; } } Output 例: 3. テーマを使った作業 これは、ウィジェットをアプリケーションの他の部分と一貫して見えるようにしたい場合や、テーマが変更されたときに自動的にルック＆フィールを更新したい場合に必要です。\nExperience Builder フレームワークは、テーマ変数を JSON オブジェクトとして提供し、それをプロパティとしてウィジェットに挿入します。色、フォント、サイズ、コンポーネントなど、すべてのテーマ変数にアクセスできます。\nウィジェット内のテーマ変数にアクセスし、CSS 宣言でそれらを参照するには this.props.theme を使用します。例えば、以下のようになります。\n/** @jsx jsx */ // \u0026lt;-- make sure to include the jsx pragma import { React, AllWidgetProps } from \u0026#39;jimu-core\u0026#39;; import { css, jsx } from \u0026#39;jimu-core\u0026#39;; export default class Widget extends React.PureComponent\u0026lt;AllWidgetProps\u0026lt;{}\u0026gt;\u0026gt;{ render() { const theme = this.props.theme; const style = css` background: ${theme.colors.palette.primary[100]}; color: ${theme.colors.black}; padding: ${theme.sizes[3]}; `; return \u0026lt;div css={style}\u0026gt; \u0026lt;p\u0026gt;This is a sample widget\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;; } } Output 例: default theme vs. dark theme\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/widget/",
	"title": "ウィジェット（Widget）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Widget\nウィジェット（Widget） ウィジェットは設定可能な機能単位で、エクスペリエンスなページを作成するために使用されるビルディングブロックです。Experience Builder は、マップ、ボタン、リストなどのすぐに使える（OOB）ウィジェットが用意されており、カスタムウィジェットを作成することも可能です。ウィジェットは通常、ユーザーがビルダー環境で機能を設定できるように設定UIを提供します。ウィジェットに設定可能なオプションがありますが、設定 UI が含まれていない場合は、JSON エディタを使用して設定することが可能です。\nウィジェットの実装についてはこちらをご覧ください。\napp config では、widgets でウィジェットを定義します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/hackathon/",
	"title": "ミートアップ",
	"tags": [],
	"description": "ミートアップ参加者を支援するリソースをまとめています。",
	"content": "ミートアップ参加者を支援するリソースをまとめています。\nオープンデータを入手する ArcGIS Open Data では ArcGIS のクラウドで公開されている全世界のオープンデータを検索・参照・ダウンロードが可能です。 自由に使える地理データを取得する方法を紹介します。\n オープンデータの入手 (ArcGIS Open Data コミュニティサイト)  地図にデータを可視化する 座標情報を持った地理データや住所情報を持ったテキストデータなどを可視化して、アプリに組み込むための地図を作成する方法や Tips を紹介します。 なお、データ可視化の作業はコーディングが不要なので、プランナーやデザイナーの方でも取り組んでいただくことができます。\n データ可視化のワークフロー データ可視化の手順 データ可視化の手順（3D） 地図上に賢くデータを可視化するための 6 つの方法  アプリに地図を組み込む アプリに ArcGIS の地図を組み込む際に便利な開発キットやライブラリです。アプリ作成ツールを活用することで、ノンコーディングでアプリを作成することも可能です。\nコードを書く JavaScript  ArcGIS Web API: リファレンス (英語) | 日本語ガイド Leaflet.js (Esri Leaflet): リファレンス (英語) | 日本語ガイド(ブログ記事)  Android  ArcGIS Runtime SDK: リファレンス (英語) | 日本語ガイド  iOS  ArcGIS Runtime SDK: リファレンス (英語) | 日本語ガイド  .NET  ArcGIS Runtime SDK: リファレンス (英語) | 日本語ガイド  コードを書かない アプリケーション ビルダー  Web AppBuilder for ArcGIS: リファレンス | 日本語ガイド  ストーリーマップ  ストーリーマップ: リファレンス  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/calcite-design-system/",
	"title": "Calcite Design System",
	"tags": [],
	"description": "Calcite Design System の開発に役立つガイド集です。",
	"content": "Calcite Design System の開発に役立つガイド集です。\nCalcite Design System は、最小限の労力で、アプリ間で美しく、使いやすく、まとまりのある体験を生み出すためのデザインおよび開発リソースを集めたものです。UI キット、アイコン、カラー スキーム、そしてボタン、パネル、アコーディオン、アラートなどの UI 要素を含む Web コンポーネントライブラリが含まれています。\nどこから始めるか Calcite Design System* で、一貫性のある考慮された体験を構築します。 *国内未サポート製品です。\n はじめに\n次の手順に従って、すぐに Calcite Components を使い始めることができます。\n\r コア コンセプト\nWeb コンポーネントを活用するための基本的な概念とパターンを学びます。\n\r チュートリアル\nCalcite の開発パターンを学び、ワークフローやアプリケーションを構築します。\n\r\rDesign System Calcite Design System の基礎、包括的なコンポーネント ライブラリ、およびガイド リソースをご覧いただけます。\n  基礎編（英語）  アクセシブルなアプリケーションを構築し、テーマやアイコンを使って製品をカスタマイズすることができます。\n  コンポーネント（英語）  一貫したユーザビリティを実現するためのインタラクティブな Web コンポーネント群です。\n  リソース（英語）  UI キット、フレームワークの統合、ローカライゼーションのガイダンス、コミュニティとサポートにアクセスできます。\n  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/jimu/",
	"title": "Jimu",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Jimu\nJimu Jimu は、設定可能なエクスペリエンスを作成するために使用されるJavaScript ライブラリで、以下のようなパッケージで構成される拡張フレームワークです。\n jimu-arcgis パッケージは、ArcGIS Maps SDK for JavaScript 4.x を実行するために必要なすべてのコンポーネントが含まれています。 jimu-core パッケージは、アプリの設定をロードして解析し、アプリの設定に基づいてレイアウト、テーマ、ウィジェットをロードします。これをサポートするために、本パッケージは WidgetManager、ConfigManager、ThemeManager などのいくつかのクラスを定義しています。また、jimu-core はウィジェットのインターフェイス、いくつかの共通型、およびいくつかの拡張ポイントを定義していますが、これらは他のパッケージやウィジェットにより拡張される可能性があります。 jimu-for-builder パッケージは、ウィジェットの設定ページの開発をサポートしています。 jimu-for-test パッケージは、ユニット テストに使用できるクラス、型、関数が含まれています。 jimu-ui パッケージは、エクスペリエンスが利用するすべての UI コンポーネントが含まれています。より詳しくは、reactstrap と emotion-js を使用しています。さらに reactstrap に含まれていない、より多くのコンポーネントが追加されています。読み込みサイズを小さくするために、コンポーネントはindex、setting-components、sql-expression-builder などのいくつかのエントリに分割されています。詳細はAPIを参照してください。  これらのパッケージは同じ構造パターンを使用しているため、同じベストプラクティスに沿って使用することができます。各パッケージは import するためのいくつかのエントリを定義し、これらのエントリはパッケージのルートフォルダの下に置かれます。lib フォルダ内のコンテンツは，パッケージの内部コンテンツとみなされますので，ウィジェットには import しないでください。例えば、jimu-ui の Button コンポーネントを使用する必要がある場合は、import {Button} from 'jimu-ui' ではなく、import {Button} from 'jimu-ui/lib/components/button' のようにインポートする必要があります。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-unity/",
	"title": "Unity",
	"tags": [],
	"description": "ArcGIS Maps SDK for Unity を用いたネイティブ地図アプリの作成方法を紹介します。",
	"content": "出典：ArcGIS Maps SDK for Unity - Tutorials - Display a map(UI)\nマップを表示する (UI) Unity の Map Creator UI と High Definition Render Pipeline を使用して、ベースマップ、標高ソースの設定、データレイヤーの追加、特定エリアの表示方法をご紹介します。\nこのチュートリアルでは、ベースマップレイヤーサービスとデータレイヤーを含むローカルシーンを Unity で作成します。\nArcGIS Map SDK for Unity は、現在 ESRIジャパンにおけるサポート対象外の製品です。 ESRIジャパンで提供する Esri 製品サポート サービスや開発者サポート サービスはご利用いただけませんので、予めご了承ください。\n\r前提条件 このチュートリアルを実施するには、以下が必要です。\n  ArcGIS サービスにアクセスするには、ArcGIS Developer アカウントまたは ArcGIS Online アカウントと API キーが必要です。アカウントをお持ちでない場合は、サインアップ (無料) してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。\nAPI キー ページが開発者ダッシュボードに表示されない場合は、アカウントを ArcGIS Developer アカウントにアップグレードする必要があります。\n\r  開発環境がシステム要件を満たしていることを確認してください。\n  インストールとセットアップの手順に従って、プラグインをインストールしてください。必ずサンプルアセットをインポートしてください。\n  まだ作成されていない場合は、新しい HDRP プロジェクトを作成してください。\n  Unity のインターフェイスに慣れていない場合は、最も一般的なエディタウィンドウとそれらを活用するための情報を Unity マニュアル で参照してください。\nステップ 新しいシーンを作成し、Map Creator UI を開く   上部メニューで、ファイル \u0026gt; 新しいシーン (File \u0026gt; New Scene) をクリックし、ポップアップウィンドウを開きます。   Basic Outdoors (HDRP) テンプレートを選択し、作成 (Create) ボタンをクリックします。   上部メニューで、ArcGIS Maps SDK \u0026gt; Map Creator をクリックします。必要に応じて、Map Creator UI を開いた後にウィンドウ サイズを調整します。   マップを作成する このチュートリアルでは、ローカルシーンを作成し、円形の範囲を設定します。\n  Map タブをクリックし、パネルの内容を表示します。\n  Map Type セクションで Local をクリックします。\n  Origin Position セクションでは、GIS シーンの中心を座標とSpatial Reference Well-Known ID (WKID) で設定できます。チュートリアルでは、パラメータを以下の値に設定します :\n Longitude : 139.745723 Latitude : 35.659041 Altitude : 0 Spatial Reference WKID : 4326  spatial reference に関する情報は、spatial references のページを参照してください。\n  Enable Map Extent チェックボックスをオンにして、Map Extent セクションを表示し、マップの範囲をこれらの値に設定します :\n Longitude : 139.745723 Latitude : 35.659041 Shape : Circle Spatial Reference WKID : 4326 Shape Dimensions : (Radius) 5000 メートル    ArcGIS Map ゲームオブジェクトをシーンに追加するには、Create Map をクリックします。\n  以下が、Map パネルに入力した画像です。\nヒエラルキー (Hierarchy) ウィンドウで、作成された ArcGISMap ゲームオブジェクトを確認できます。\nヒエラルキー (Hierarchy) ウィンドウで ArcGISMap ゲームオブジェクトをクリックすると、ゲームオブジェクトに ArcGIS Map コンポーネントがアタッチされていることがわかります。\nArcGIS Map の作成の詳細については、Maps のページを参照してください。\nカメラの作成とセットアップ ArcGIS Maps SDK for Unity は、カメラに近いエリアにはより高い解像度の LOD を表示し、カメラから遠いエリアにはより低い解像度の LOD を表示します。\n  Camera タブをクリックする。\n  Camera Position はカメラの初期視点を定義します。パラメータをこれらの値に設定します :\n Longitude : 139.745723 Latitude : 35.659041 Altitude : 290 Spatial Reference WKID : 4326    Camera Rotation はカメラの角度を定義します。パラメータをこれらの値に設定します :\n Heading : 270 Pitch : 93 Roll : 0    Create Camera ボタンをクリックします。\n  以下が、Camera パネルに入力した画像です。\nヒエラルキー (Hierarchy) ウィンドウで、Main Camera ゲームオブジェクトが ArcGISCamera ゲームオブジェクトに変換され、ArcGISMap ゲームオブジェクトの下に移動していることがわかります。\nArcGISCamera ゲームオブジェクトを右クリックし、ポップアップメニューの Align View to Selected を選択すると、Scene ビューのカメラがその位置に移動します。ピッチ、ヘディング、ロールも調整したい場合は、Scene ビューでマウスの右ボタンを押しながら調整してください。\n\rこの時点で、追加するベースマップとデータレイヤーを見るために、Sky and Fog Volume の フォグ (Fog) を無効にするとよいでしょう。このチュートリアルの最後では、ライティングを調整します。\nカメラについての詳細は、Camera のページを参照してください。\nベースマップの設定 このチュートリアルでは、プリセットオプションからベースマップを選択します。\n  Basemap タブをクリックし、パネルの内容を表示します。\n  プリセットのベースマップギャラリーから Imagery ベースマップを選択します。\n  以下が、プリセットからベースマップを Imagery に設定した画像です。\nAPI キーの設定 前のセクションで選択したプリセットベースマップには API キーが必要です。\n  開発者ダッシュボードにアクセスして API キーを取得してください。\n  Auth タブをクリックしてパネルの内容を表示します。\n  API Key セクションで API キーを設定します。\n  このスクリーンショットで Paste your API key here と表示されているフィールドに API キーが入力されていることを確認してください。API キーの取得方法については、UI の API キーの取得 をクリックしてください。\nUnity プロジェクト内の複数のシーンに対してグローバル API キーを設定するもう1つの方法は、プロジェクト設定です。API キーの詳細については、API キーのセクションを参照してください。\nBasemap タブに戻ると、以前はグレーアウトしていたベースマップアイコンが有効になり、API キーが正常に登録されたことがわかります。\nこの時点で、ローカルエクステントを持つマップデータが表示されるはずです。シーン (Scene) ビューに何も表示されない場合は、ヒエラルキー (Hierarchy) ウィンドウを開き、ArcGIS Camera をダブルクリックしてエディタカメラの位置を移動し、角度を調整してマップを表示します。\nシーン (Scene) ビューにベースマップが表示されない場合は、ヒエラルキー (Hierarchy) ウィンドウで ArcGISCamera ゲーム オブジェクトをダブルクリックして、設定した位置にカメラビューを設定し、必要に応じてマウスの右ボタンを押しながらカメラのピッチ、ヘディング、ロールを調整します。\n\r標高の設定 このチュートリアルでは、デフォルトの標高を使って地形を定義します。\n  Elevation タブをクリックし、パネルの内容を表示します。\n  Terrain 3D が選択され、Enable All のチェックボックスがチェックされていることを確認します。\n  以下が、設定した Elevation パネルの画像です。\nデータレイヤーの追加 ArcGIS Online から使用できるデータを追加します。\n ArcGIS Online Item : 東京都23区・八王子市南大沢 3D 都市モデル（Project PLATEAU）  Layer name : Tokyo Model Type : ArcGIS 3DObject Scene Layer ArcGIS Online サービスの URL（ Source ）:  https://tiles.arcgis.com/tiles/wlVTGRSYTzAbjjiC/arcgis/rest/services/13100_13201_Tokyo-23ku_Minamiosawa_Building/SceneServer\r Opacity : 1.0    以下の手順でレイヤーを追加します。\n  Layers タブをクリックします。\n  右下の Add New ボタンを押して、Add New Layer ポップアップウィンドウを開きます。\n  Type のドロップダウンリストから適切なレイヤータイプを選択します。\n  3D オブジェクトシーンレイヤーを追加するには、サービスの URL を Source フィールドに入力します。\n  Name フィールドにレイヤー名を入力します。\n  Add ボタンをクリックして、レイヤーをマップに追加します。レイヤーが追加されると、Layers セクションに表示されます。\n  Opacity スライダを動かすか、Opacity フィールドに正確な値を入力して、レイヤーの不透明度を設定します。\n  以下が、Layers パネルの画像です。\n空とライティングの調整 Unity には空とライティングのシステムがあります。詳しくは Sky and lighting のページを参照してください。このチュートリアルでは、テンプレートによって追加されたゲームオブジェクトの設定を調整します。\n太陽の調整   ヒエラルキー (Hierarchy) ウィンドウで、Sun ゲームオブジェクトをクリックします。\n  ヒエラルキー (Hierarchy) ウィンドウの トランスフォーム (Transform) セクションで、回転を以下の値に設定します。\n X : 36 Y : 110 Z : 85    放出 (Emission) セクションを開き、強さ (Intensity) の値を10000に設定します。\n  以下が、設定した Sun ゲームオブジェクトの画像です。\n空と霧のボリュームの調整   ヒエラルキー (Hierarchy) ウィンドウの Sky and Fog Volume をクリックします。\n  ArcGIS Maps SDK for Unity には、HDRP 用の Sky and Fog Volume のサンプルプロファイルが用意されています。インスペクター (Inspector) ウィンドウの Volume セクションで、プロファイル名の横にあるアイコンをクリックします。\n  ポップアップウィンドウで Sky and Fog Settings SampleScenes Profile を選択します。\n  カメラコントローラーのアタッチ エディタモードが有効になっている間、ビューポート内をナビゲートするために、シーン (Scene) ビューカメラがあります。プレイモードでは、シーンを探索するためにカメラコントローラーをアタッチする必要があります。このチュートリアルでは、ArcGIS Maps SDK for Unity のサンプルアセットからコントローラをアタッチします。\n  ヒエラルキー (Hierarchy) ウィンドウで ArcGISCamera をクリックします。\n  インスペクター (Inspector) ウィンドウで、コンポーネントを追加 (Add Component) ボタンをクリックします。\n  ArcGIS Camera Controller を検索し、ArcGISCamera ゲームオブジェクトにアタッチします。\n  Map Creator UI でマップの設定が完了しました。Toolbar の Play アイコンをクリックすると、ゲーム (Game) ビューにマップが表示されます。\nWASD キーで左右前後に移動します。マウスの左ボタンでシーンをパン、右ボタンでオービット、スクロールホイールで拡大・縮小します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/use-data-source-in-widget/",
	"title": "ウィジェットでデータソースを使用",
	"tags": [],
	"description": "ウィジェットでデータソースを使用する方法について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Use data source in widget\nデータソースは、ウィジェットがデータにアクセスする方法を定義します。データソースを使用して行いたいことは様々ですが、それぞれについて紹介します。\n ウィジェットの設定でデータソースを選択 ウィジェット ランタイムのデータを読み込んで表示 ユーザー入力に基づくデータのフィルタリングやクエリ データ上の選択を処理 ArcGIS Maps SDK for JavaScript のフィーチャ オブジェクトとデータソースの同期 ウィジェットで出力データソースの生成 ウィジェットでメッセージの公開  本ドキュメントで使用している appConfig という変数は、アプリの config JSON オブジェクトを指します。ArcGIS Online または Enterprise 版では、アプリの config JSON はアイテム データとして保存され、Developer Edition では server/public/apps/[appId]/config.json (公開版) または server/public/apps/[appId]/resources/config.json (ドラフト版) の下に保存されます。\n\rウィジェットの設定でデータソースを選択 ウィジェットの設定でデータソースを選択するには、DataSourceSelector コンポーネントを使用する必要があります。Experience Builder は、複数の種類のデータソースをサポートしています。これらのデータソースは jimu-core と jimu-arcgis の 2 つのパッケージに入っています。jimu-core の DataSourceTypes と jimu-arcgis の DataSourceTypes をご覧ください。jimu-arcgis のデータソースは ArcGIS Maps SDK for JavaScript に依存しており、jimu-core のデータソースは依存していません。\nDataSourceSelector コンポーネントを使用するには、types プロパティを通じてウィジェットがサポートするデータソースの種類を設定する必要があります。データソースを選択した後、onChange コールバックにより選択されたデータソースを取得することができます。onChange コールバックでは、props.onSettingChange() を呼び出して、選択したデータソースを appConfig に保存する必要があります (appConfig.widgets[widgetId].useDataSources)。ユーザーが新しいデータソースを追加した場合、新しく追加されたデータソースは appConfig.dataSources に保存されます。こちらのサンプルウィジェットを参照してください。\n\u0026lt;DataSourceSelector types={Immutable([AllDataSourceTypes.FeatureLayer])} useDataSources={props.useDataSources} useDataSourcesEnabled={props.useDataSourcesEnabled} onToggleUseDataEnabled={onToggleUseDataEnabled} onChange={onDataSourceChange} widgetId={props.id} /\u0026gt; データソースを選択した後、ユーザーがデータからフィールドを選択できるようにしたい場合があります。そのためには、FieldSelector コンポーネントを使用します。データソースと同様に、appConfig.widgets[widgetId].useDataSources にも選択したフィールドを保存する必要があります。\n{ props.useDataSources \u0026amp;\u0026amp; props.useDataSources.length \u0026gt; 0 \u0026amp;\u0026amp; \u0026lt;FieldSelector useDataSources={props.useDataSources} onChange={onFieldChange} selectedFields={props.useDataSources[0].fields || Immutable([])} /\u0026gt; } ウィジェット ランタイムのデータを読み込んで表示 ウィジェット設定でデータソースを選択すると、ウィジェットランタイムは props.useDataSources で選択したデータソースを取得することができます。データを読み込むには、DataSource インスタンスを使用します。DataSource インスタンスを取得するには、DataSourceManager またはDataSourceComponent を使用します。DataSourceComponent を使用する場合は、useDataSource プロパティを渡します。DataSource インスタンスを取得するには、onDataSourceCreated コールバックを使用します。\nデータを読み込むには、render 関数を使用してデータを表示します。こちらのサンプルウィジェットを参照してください。別の方法として、onDataSourceInfoChange コールバックを使用し、データソースの現在のデータに応じてこのコールバック関数でウィジェットの UI を更新することができます。ウィジェットがデータをロードする必要がある場合、query と widgetId プロパティを渡します。フレームワークは、複数のウィジェットが同じデータソースに適用するクエリパラメータを管理するのにこのプロパティを使用するため、widgetId は必須です。\nデータをロードしたいが、データソースのデータを変更したくない場合は、localId プロパティを渡します。これにより、ローカルデータソースが作成され、使用することができます。推奨される localId のパターンは、例えば、widget_1_my_local のように widgetId + ??? とします。\nDataSourceComponent をレンダリングすると、データソースのインスタンスが作成されますが、データは初期状態ではロードされません。なぜなら、query プロパティを渡すことを期待しているので、別のネットワーク要求が発生するためです。読み込まれたデータを取得するには、dataSource.getRecords() を使用します。データはページングされ、デフォルトのページングサイズは 100 です。ユーザーはビルダーデータ設定パネルでページングサイズを変更することができます。ロードされたデータはクライアント上にキャッシュされ、クエリ条件が変更されるとキャッシュはクリアされます。\nデータを表示する際、表示されるページサイズはクエリのページサイズと同じである必要はありません。例えば、クエリのページサイズが 100 の場合、dataSource.getRecordsByPage(1, 10) を使用して、最初の 10 レコードを取得して表示することが可能です。\nレコードの総数を取得するには、queryCount プロパティを渡し、dataSource.count で件数を取得します。\nデータソース情報が変更されるたびに、データレンダリング関数とonDataSourceInfoChange コールバックが呼び出されます。情報の内容は以下の通りです。\n instanceStatus: データソースのインスタンスが正常に作成されたかどうか status: データがロード中か、ロードされたか countStatus: データのカウントがロード中か、ロードされたか selectedIds: 選択されたデータ ID widgetQueries: データソースに適用されるクエリ(フィルタ)ウィジェット version: バージョン番号は、クライアント側でデータの変更を管理するために使用されます。そのため、データソース利用者はデータが変更されたことを認識することができます。 gdbVersion: ブランチ バージョニングをサポートするフィーチャ サービスのためのもの。ブランチ バージョン マネージメント ウィジェットでブランチ バージョンが切り替わると、そのバージョンがここに保存されます。  多くの場合、ウィジェットは現在のデータソース情報と以前の情報とを比較して、何を更新する必要があるかを判断する必要があります。\nウィジェットがデータソースの情報変更を聞く必要があるが、データソースのデータレコードを使う必要がない場合、query パラメータを省略し、onQueryRequired コールバックでクエリを実行することが可能です。\nデータソースのフィールドを取得するには、dataSource.getSchema().fields を使用します。\nユーザー入力に基づくデータのフィルタリングやクエリ ウィジェットがデータをフィルタリングすると、データソース インスタンスのデータが変更され、すべてのウィジェットがその変更を観察します。ウィジェットがデータソースを介してデータをクエリする場合、データソースインスタンスのデータは影響を受けません。\n複数のウィジェットが同じデータソースにフィルタを適用する場合、属性フィルタは and 演算子で結びつけられます。ジオメトリ フィルタの場合、最後にジオメトリ フィルタを適用したウィジェット (アプリ設定でのウィジェット追加順) からのフィルタが使用されます。\n  データソースにフィルタをかけるには、データソースの設定により、基本的に2つの方法があります。\n ウィジェットでデータを読み込む場合は、以下のようにDataSourceComponent を使うのがおすすめです。  \u0026lt;DataSourceComponent useDataSource={} widgetId={} query={}\u0026gt; { Your render method } \u0026lt;/DataSourceComponent\u0026gt; DataSourceComponent の使用例は、Message subscriber のサンプルと Server-side output data source のサンプルに記載されています。\ndataSource.load() を使用して、データの読み込みとフィルタリングも可能です。\n\r ウィジェットがデータを読み込まない場合は、Data Source の updateQueryParams() 関数を使用することができます。例として、Filter feature layer のサンプルをご覧ください。    データソースからデータをクエリするには、dataSource.query() を使用します。データをクエリする際には、このデータソースに適用されているフィルタも使用されます。\n  データ上の選択を処理 Experience Builder アプリで設計された選択の動作は、すべてのウィジェットが同じ選択を更新し、観察することです。例えば、ユーザーがリスト ウィジェット内のレコードを選択すると、選択ビューを使用しているテキスト ウィジェットにはその選択内容が表示されます。すべてのデータソースには、選択範囲を管理する選択範囲データ ビューがあります。選択データビューの他に、選択されたレコードの ID が Redux アプリストアに保存されるので、データソースを使用するウィジェットは、選択内容が変更されたときに通知を受けることができます。\nデータソース内のデータレコードを選択するには、dataSource.selectRecordById() または dataSource.selectRecordsByIds() を使用することができます。レコードがデータソースに読み込まれている場合は、2 番目のパラメータを渡す必要はありません。そうでない場合は、選択項目を使用する他のウィジェットがレコードを読み込めるようにするために、2 番目のパラメータを渡す必要があります。\n選択範囲を読み取るには、dataSource.getSelectedRecords() を使用します。\nWebMap/WebScene の使用 ArcGIS Maps SDK for JavaScript の WebMap と WebScene は、データソースとして jimu-arcgis パッケージでラッピングされています。WebMap にアクセスする場合は WebMapDataSource を、WebScene にアクセスする場合は WebSceneDataSource を使用します。これらのデータソースの使用方法については、MapView のサンプルをご覧ください。WebMap と WebScene オブジェクトに加えて、これらのオブジェクト内のすべてのレイヤーはデータソースとしてラッピングされているため、getChildDataSources() を呼び出してすべてのレイヤーデータソースを取得できます。サポートされるレイヤーとサービスは、SupportedLayerServiceTypes と SupportedServiceTypes で定義されています。\nFeatureLayer の使用 ワークフローによっては、フィーチャ レイヤーで直接動作する軽量なエクスペリエンスを作成する必要があります。このシナリオでは、FeatureLayerDataSource クラスを使用します。一般的に、スタンドアロン レイヤーを使用するウィジェットは、layer プロパティを持たない FeatureLayerDataSource オブジェクトを取得しますが、Web マップまたは Web シーンからのフィーチャ レイヤーを使用すると、layer プロパティを持つ FeatureLayerDataSource オブジェクトを返します。Layer オブジェクトは ArcGIS Maps SDK for JavaScript から提供されています。\nconst getLayerObject = (ds: FeatureLayerDataSource) =\u0026gt; { return ds.layer; // this can be null  } ウィジェット間のデータ共有 ウィジェットは、多くの場合、同じデータを共有します。この良い例が、エクスペリエンスでマップ ウィジェットとリスト ウィジェットを使用する場合です。リスト ウィジェットでフィーチャを選択すると、対応するフィーチャがマップ上で選択されます。これを実現する最も簡単な方法は、両方のウィジェットに同じデータソースを使用することです。たとえば、リスト ウィジェットでアイテムが選択されると、ウィジェットは datasource.selectRecord() を呼び出して、app store のデータソースの状態を更新します。これにより、マップ ウィジェットでは、現在選択されているアイテムを適宜レンダリングすることができます。また、現在選択されているアイテムの ID が URL に配置されるため、現在のアプリの状態を他の人と共有することが可能になります。\nArcGIS Maps SDK for JavaScript のフィーチャ オブジェクトとデータソースの同期 Experience Builder ウィジェットでは、ArcGIS Maps SDK for JavaScript を使用してフィーチャを取得することができます。その後、他のウィジェットがこれらのフィーチャを使用できるようにしたい場合があります。たとえば、マップ上でこれらのフィーチャをハイライト表示したり、リスト ウィジェットでこれらのフィーチャを表示したりする必要があるかもしれません。これには、以下の 3 つのオプションがあります。\n データソースでこれらのフィーチャ レコードを選択する  使用できるデータソース インスタンスがあれば、dataSource.selectRecordsByIds() を呼んでこれらのレコードを選択することができます。Graphic インスタンスを取得する場合は、まずFeatureRecord インスタンスを作成する必要があります。   ウィジェットから出力データソースを生成する  Widget output data source サンプルを参照してください。   メッセージを公開する  ウィジェットが何らかのフィーチャを生成する場合、DataRecordSetChangeMessage メッセージを公開することで、他のウィジェットがサブスクライブできるようになります。    MapView/SceneView または LayerView での作業 ウィジェットがデータソースと連動する場合、MapView/SceneView とも連動する必要がある場合が多くあります。ウィジェットが JimuMapViewComponent によってJimuMapView インスタンスを取得した後、jimuMapView.dataSourceId によって MapView/SceneView の対応するデータソースを取得し、jimuMapView.jimuLayerViews によって関連レイヤーを取得することができます。jimuLayerView インスタンスを介して、jimuMapView.dataSource によって、レイヤービューの対応するデータソースを取得することもできます。一般に、レイヤーからデータソースと同期する機能を取得するには、以下のオプションがあります。\n フィーチャの objectId を使用して、データソースから関連するデータレコードを検索 FeatureDataRecord インスタンスを作成し、そのフィーチャに対応するデータレコードを作成 FeatureDataRecord のインスタンスから、featureDataRecord.getFeature() でフィーチャを取得  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/widget-communication/",
	"title": "ウィジェット間の通信",
	"tags": [],
	"description": "ウィジェット同士がどのように相互に通信する方法について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Widget communication\nExperience Builder のウィジェットは、1 つの機能単位です。しかし、多くの場合、1 つのタスクを完了するために複数のウィジェットが一緒に動作する必要があるので、フレームワーク レベルでウィジェット同士がどのように相互に通信するかをサポートする必要があります。 以下の方法をサポートしています。\n  Message action (メッセージアクション): このメカニズムは、ウィジェット間の通信のための設定可能なソリューションです。詳細は Message action を参照してください。\n  Share state (状態の共有): このメカニズムは、ウィジェット間の通信のためのプログラミングを行います。ウィジェット間で state (状態) を共有するには、ウィジェットの state (状態) を使用する方法と、独自の Redux store/action/reducer を提供する方法の2つの方法があります。\n  ウィジェットの状態を使用してウィジェット間で状態を共有 React コンポーネントとしての Widget は内部 state (状態) を持つことができますが、他の Widget はこの state (状態) にアクセスすることができません。Jimu は state (状態) 管理 として Redux を使用しています。多くの情報を Redux store に保存します。情報の一つは widgetsState と呼ばれるもので、型の定義は jimu-core/lib/types/state にあります。widgetState に保存された情報は、他のすべてのウィジェットからアクセス可能です。widgetsState に情報を保存するには、以下のコードを参照してください。\nimport {appActions} from \u0026#39;jimu-core\u0026#39;; /* * Call this when you need to save state. * * widgetId: your widget id * propKey: can be a string with this format \u0026#34;a.b.c\u0026#34; * value: the info you want to store */ this.props.dispatch(appActions.widgetStatePropChange(widgetId, propKey, value)) 例えば、this.props.dispatch(appActions.widgetStatePropChange(\u0026quot;w1\u0026quot;, \u0026quot;a.b1\u0026quot;, \u0026quot;value1\u0026quot;)) と this.props.dispatch(appActions.widgetStatePropChange(\u0026quot;w1\u0026quot;, \u0026quot;a.b2\u0026quot;, \u0026quot;value2\u0026quot;)) を呼び出すと、Redux store でこの store の state (状態) が取得されます。\nwidgetsState: { w1: { a: { b1: \u0026#39;value1\u0026#39;, b2: \u0026#39;value2\u0026#39; } } } ウィジェット2 の w1 が格納した情報にアクセスするには、mapExtraStateProps を使用するか、useSelect hooks を使用して store から値を選択することができます。\nただし、widgetState にはプレーンな JavaScript オブジェクトのみを格納することができます。複雑な JavaScript オブジェクトを格納するには、this.props.dispatch(appActions.widgetMutableStatePropChange(widgetId, propKey, value)) を使用して値を格納し、MutableStoreManager.getInstance().getStateValue() を使用してアクセスすることができます。\nウィジェット間で状態を共有するための独自の redux store/action/reducer を提供します。 これにより、state (状態) 管理をより柔軟にカスタマイズすることができます。これは通常の Redux で行う方法とほぼ同じです。ご存知のように、Redux には 1 つの store と 1 つの root reducer があり、これは jimu によって使用されます。ウィジェット開発者が通常の Redux の方法で state (状態)を管理できるようにするために、jimu は ReduxStore 拡張ポイントを定義しています。Redux を使用する必要があるウィジェットはこの拡張ポイント用の拡張を提供できます。\n ReduxStoreExtension インターフェースを実装する拡張クラスを作成します。  import {extensionSpec} from \u0026#39;jimu-core\u0026#39;; export default class MyReduxStoreExtension implements extensionSpec.ReduxStoreExtension{ getActions(){ // return your redux actions.  } getInitLocalState(){ // return your redux init local state.  } getReducer(){ // return your redux reducer.  } getStoreKey(){ // return your redux local key.  } }  ウィジェットの manifest.json で拡張機能を宣言します。  \u0026#34;extensions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;My Store\u0026#34;, \u0026#34;point\u0026#34;: \u0026#34;REDUX_STORE\u0026#34;, \u0026#34;uri\u0026#34;: \u0026#34;my-store\u0026#34; } ] "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/unity/",
	"title": "ArcGIS Maps SDK for Unity",
	"tags": [],
	"description": "ArcGIS Maps SDK for Unity の開発に役立つガイド集です。",
	"content": "ArcGIS Maps SDK for Unity の開発に役立つガイド集です。\nArcGIS Map SDK for Unity は、現在 ESRIジャパンにおけるサポート対象外の製品です。 ESRIジャパンで提供する Esri 製品サポート サービスや開発者サポート サービスはご利用いただけませんので、予めご了承ください。\n\r インストールガイド\nArcGIS Maps SDK for Unity のインストールとセットアップ手順を紹介します。\n\r 新規プロジェクトにプラグインを追加\nArcGIS Maps SDK for Unity を新規プロジェクトに導入する手順を紹介します 。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-unreal-engine/",
	"title": "Unreal Engine",
	"tags": [],
	"description": "ArcGIS Maps SDK for Unreal Engine を用いたネイティブ地図アプリの作成方法を紹介します。",
	"content": "出典：ArcGIS Maps SDK for Unreal Engine - Tutorials - Display a map (UI)\nマップを表示する (UI) Modes Panel UI を使用したベースマップ、標高ソースの設定、データレイヤーの追加、特定エリアの表示方法をご紹介します。\nこのチュートリアルでは、ベースマップ レイヤーサービスとデータレイヤーを含むローカルシーンを Unreal Engine で作成します。\nArcGIS Map SDK for Unreal Engine は、現在 ESRIジャパンにおけるサポート対象外の製品です。 ESRIジャパンで提供する Esri 製品サポート サービスや開発者サポート サービスはご利用いただけませんので、予めご了承ください。\n\r前提条件 このチュートリアルを実施するには、以下が必要です。\n  ArcGIS サービスにアクセスするには、ArcGIS Developer アカウントまたは ArcGIS Online アカウントと API キーが必要です。アカウントをお持ちでない場合は、サインアップ (無料) してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。\nAPI キー ページが開発者ダッシュボードに表示されない場合は、アカウントを ArcGIS Developer アカウントにアップグレードする必要があります。\n\r  開発環境がシステム要件を満たしていることを確認してください。\n  インストールとセットアップの手順に従って、プラグインをインストールしてください。必ずサンプルアセットをインポートしてください。\n  シーン設定オプションのページを確認してください。\n  Unreal Engine のインターフェースに慣れていない場合は、最も一般的なエディターパネルとその活用方法について、Unreal Editor のインターフェース を参照してください。\nステップ 新しいレベルを作成し、Modes Panel UI を開く Unreal Engine 5.1 または 5.2 を使用している場合は、手順 3 と 4 を省略できます。\n\r  メニューバーの ファイル (File) をクリックし、新規レベル (New Level) を選択します。\n  ポップアップウィンドウで 空のレベル (Empty Level) を選択します。\n  メニューバーの ウィンドウ \u0026gt; ワールドセッティング (Window ‐\u0026gt; World Settings) を開きます。ワールドセッティング (World Settings) パネルが開きます。\n  ワールドセッティング (World Settings) パネルで、ワールド (World) グループに行き、詳細設定 (Advanced) を開きます。ラージワールドの有効化 (Enable Large Worlds) オプションをチェックします。\n  メインツールバーの モード選択 (Select Modes) ドロップダウンをクリックし、ArcGIS Maps SDK を選択します。\n  Unreal Editor インターフェースの左側に、Modes Panel UI が開きます。\n  マップの作成   Modes Panel UI の Map タブをクリックします。\n  Map Type で Local を選択します。\n  Origin Position セクションでは、GIS シーンの中心を座標と Spatial Reference Well-Known ID (WKID) で設定できます。チュートリアルでは、パラメータをこれらの値に設定します：\n Longitude : 139.745723 Latitude : 35.659041 Altitude : 0 Spatial Reference WKID : 4326  spatial reference については、spatial references のページを参照してください。\n  Enable Extent チェックボックスをオンにすると、Map Extent セクションが表示されます。\n  Map Extent で、マップの範囲をこれらの値に設定します :\n Longitude : 139.745723 Latitude : 35.659041 Shape : Circle Spatial Reference WKID : 4326 Shape Dimensions : (Radius) 5000 メートル  以下が、Map パネルに入力した画像です。\n  Create ボタンをクリックします。アウトライナー (Outliner) パネルに、ArcGISMapActor が作成されます。\n  カメラの作成と設定 ArcGIS Maps SDK for Unreal Engine は、カメラに近いエリアにはより高い解像度の LOD を表示し、カメラから遠いエリアにはより低い解像度の LOD を表示します。\n  Camera タブをクリックします。\n  Camera Position でカメラの初期視点を定義します。パラメータをこれらの値に設定します：\n Longitude : 139.745723 Latitude : 35.659041 Altitude : 290 Spatial Reference WKID : 4326    Camera Rotation でカメラの角度を定義します。\n Heading : 270 Pitch : 93 Roll : 0  以下が、Camera パネルに入力した画像です。\n  Create ボタンをクリックします。アウトライナー (Outliner) パネルに、Default Pawn アクターが作成されます。\n  この時点では、レベルはまだ空です。これからのチュートリアルステップで、マップデータがレベルに追加されます。\nベースマップとAPIキーの設定 このチュートリアルでは、API キーが必要なベースマップを選択します。\n  Basemap タブをクリックし、パネルの内容を表示します。\n  プリセットのベースマップリストから Imagery ベースマップを選択します。プリセットのベースマップから Imagery に設定した結果です。\n  開発者ダッシュボードにアクセスし、API キーを取得してください。\n  Auth タブをクリックしてパネルの内容を表示します。\n  API Key セクションで API キーを設定します。\nAPI キーが、このスクリーンショットの Paste your API key here と表示されているフィールドに入力されていることを確認してください。API キーの取得方法については、UI の API キーの取得をクリックしてください。\n  Basemap タブに戻ると、以前はグレー表示だったベースマップアイコンが有効になり、API キーが正常に登録されたことがわかります。\n  Unreal プロジェクト内の複数のレベルに対してグローバル API キーを設定するもう 1 つの方法は、プロジェクト設定を使用することです。API キーの詳細については、API キーのセクションを参照してください。\n標高の設定 このチュートリアルでは、デフォルトの標高を使って地形を定義します。\n  Elevation タブをクリックし、パネルの内容を表示します。\n  Terrain 3D が選択され、Enable All チェックボックスがチェックされていることを確認します。\n  以下が、Elevation パネルに入力した画像です。\nデータレイヤーの追加 ArcGIS Online から使用できるデータを追加します。\n  ArcGIS Online Item : 東京都23区・八王子市南大沢 3D 都市モデル（Project PLATEAU）\n Layer name : Tokyo Model Type : ArcGIS 3DObject Scene Layer ArcGIS Online サービスの URL（ Source ）:  https://tiles.arcgis.com/tiles/wlVTGRSYTzAbjjiC/arcgis/rest/services/13100_13201_Tokyo-23ku_Minamiosawa_Building/SceneServer\r Opacity : 1.0    以下の手順でレイヤーを追加します。\n  Layers タブをクリックします。\n  Add New Data セクションで、Type のドロップダウンリストから適切なレイヤータイプを選択します。\n  3D オブジェクトシーンレイヤーを追加するには、サービスの URL を Source フィールドに入力します。\n  Name にレイヤー名を入力します。\n  マップにレイヤーを追加するには、Add ボタンをクリックします。レイヤーが追加されると、Layers セクションに表示されます。\n  スライダーをドラッグして Opacity を設定します。\n  Is Visible チェックボックスを使用して、レイヤーの表示 / 非表示を切り替えます。\n  以下が、Layers パネルに入力した画像です。\n空とライティングの設定   メインツールバーの 作成 (Create) ショートカットから、ライト (Light) \u0026gt; Directional Light を選択し、レベルにドラッグして DirectionalLight を作成します。Directional Light の詳細については、ライトのタイプを参照してください。\n  アウトライナー (Outliner) で DirectionalLight を選択し、詳細パネル (Details) の トランスフォーム (Transform) セクションを開きます。\n  位置 (Location) をリセットし、回転 (Rotation) を設定します：\n X: 0 Y: -28 Z: -28    可動性 (Mobility) を ムーバブル (Movable) に設定します。\n  ライト (Light) セクションで、Intensity Value を3.1416に変更します。\n  カスケードシャドウマップ (Cascaded Shadow Maps) セクションで、Dynamic Shadow Distance MovableLight を 2000000 に変更します。\n  大気と雲 (Atmosphere and Cloud) セクションで、Atmosphere Sun Light を有効にします。\n  アクタ (Actor) \u0026gt; Spawn Collision Handling Method セクションで、Always Spawn, Ignore Collisions を選択します。\n  メインツールバーの Create (作成) ショートカットから、ライト (Light) \u0026gt; Sky Light を選択し、レベルにドラッグして SkyLight を作成します。SkyLight の詳細については、ライトのタイプを参照してください。\n  トランスフォーム (Transform) セクションで、位置 (Location) をリセットし、可動性 (Mobility) を ムーバブル (Movable) に設定します。\n  ライト (Light) セクションで、Real Time Capture を有効にします。\n  メインツールバーの Create (作成) ショートカットから、ビジュアルエフェクト (Visual Effects) \u0026gt; Sky Atmosphere を選択し、レベルにドラッグして SkyAtmosphere を作成します。Sky Atmosphere の詳細については、フォグのエフェクトを参照してください。\n  Planet セクションで、Ground Radius を 6378.137207 に変更します。\n  この時点で、エクステントの設定で切り取られたマップデータが表示されるはずです。アウトライナー (Outliner) パネルで、Default Pawn をダブルクリックして、エディターカメラを設定されたカメラ位置に移動します。マウスの右ボタンを押しながら WASD キーを使って移動するか、マウスの左ボタンを押しながらエディターモード中に周囲を見回します。エディターモード中に ビューポート (Viewport) のカメラ移動速度を上げるには、ビューポート (Viewport) 右上の カメラ速度 (Camera Speed) アイコンをクリックし、スライダーをドラッグして値を上げます。\nDefault Pawn を ArcGIS Pawn に置き換える エディターモードでは、Unreal Engine の標準の ビューポート制御 を使用してシーンを自由に移動できます。プレイモードでシーンを移動するには、Pawn 用の独自のコントローラーコンポーネントを作成するか、Default Pawn の移動コンポーネントを修正します。また、Default Pawn を Samples で使用されているサンプル ArcGIS Pawn に置き換えることもできます。サンプル ArcGIS Pawn については、 ArcGIS Pawn のセクションを参照してください。\n  コンテンツ ドロワー (Content Drawer) で以下の場所を開きます。\n\rプラグイン  ArcGIS Maps SDK for Unreal Engine C++ クラス  ArcGISSamples  Public\r\r  ArcGIS Pawn をクリックして選択します。選択されると背景色が青に変わります。\n  アウトライナー (Outliner) パネルで Default Pawn を右クリックします。\n  選択中のアクタを置換 (Replaced Selected Actor with) をクリックし、ArcGIS Pawn を選択します。\n  これで、Modes Panel UI を使用したローカル シーンの構成は完了です。\nメインツールバーの プレイ (Play) アイコンをクリックし、WASD キーで移動します。マウスの右ボタンを押したままカーソルを動かして周囲を見渡し、マウスの左ボタンを押したままカーソルを動かしてパンします。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/widget-list/",
	"title": "ウィジェット一覧表",
	"tags": [],
	"description": "ArcGIS Web AppBuilder で提供されているウィジェットの一覧表です。",
	"content": "ArcGIS Web AppBuilder ウィジェット一覧表 ArcGIS Web AppBuilder（ArcGIS Online 版、ArcGIS Enterprise 版、Developer Edition 版 ※1）で提供されているウィジェットの一覧表です。\n表の「〇」をクリックすると、ウィジェットの詳細ページ（Web ガイド）にリンクします。\n 2D ウィジェット 3D ウィジェット 補足事項  2D ウィジェット    ウィジェット 機能概要 ArcGIS Online (2022 年 11 月アップデート) ArcGIS Enterprise バージョン 11.0 Developer Edition バージョン 2.26 ※1     情報ウィジェット 情報ウィジェットは、ウィジェットに表示するコンテンツを作成します。 〇 〇 〇   データ追加 データ追加ウィジェットを使用すると、ArcGIS Online または ArcGIS Enterprise のコンテンツからレイヤーを検索するか、URL を入力するか、ローカル ファイルをアップロードすることで、データをマップに追加できます。 〇 〇 〇   解析 解析ウィジェットを使用すると、アプリケーション内で ArcGIS Online または ArcGIS Enterprise の空間解析ツールを簡単に利用できます。 〇 〇 〇   属性テーブル 属性テーブル ウィジェットは、操作レイヤーの属性を表形式で表示します。 〇 〇 〇   属性一括編集 属性の一括編集ウィジェットではフィーチャ (関連フィーチャ、別のレイヤーに基づくフィーチャ、または図形内でスケッチしたフィーチャ) を選択し、共通属性を一括更新できます。 〇 〇 〇   ベースマップ ギャラリー ベースマップ ギャラリー ウィジェットには、ベースマップがギャラリー形式で表示され、ギャラリーの中から 1 つのベースマップを選択してアプリのベースマップにすることができます。 〇 〇 〇   ブックマーク ブックマーク ウィジェットには、アプリに表示されるマップ表示範囲 (空間ブックマーク) のコレクションが格納されます。 〇 〇 〇   Business Analyst Business Analyst ウィジェットを使用すると、マップ上のポイントまたはポリゴン フィーチャのレポートとインフォグラフィックスを実行することで、その詳細情報を表示することができます。 〇 〇 〇   チャート チャート ウィジェットには、操作レイヤーから取得された定量属性がデータのグラフィカルな表現として表示されます。 〇 〇 〇   コントローラー コントローラー ウィジェットはパネル内ウィジェット用のコンテナーです。ヘッダー構成とサイドバー構成という 2 種類のコントローラーが事前に組み込まれています。 〇 〇 〇   座標 座標ウィジェットは、マップ上に X と Y の座標値を表示します。 〇 〇 〇   座標変換 座標変換ウィジェットでは、1 つの座標系を使用する座標を入力し、複数の表記形式を使用する別の座標系に出力することができます。 〇 〇 〇   コスト解析 コスト解析ウィジェットを使用すると、作成する各フィーチャにコスト係数を割り当てることができます。 〇 〇 〇   データ集約 データ集約ウィジェットを使用すると、CSV (カンマ区切り値) ファイルに格納されている住所または座標情報から地理フィーチャを作成し、CSV ファイルとターゲット レイヤーのフィールド情報を関連付ける方法を定義できます。 〇 〇 〇   ルート案内 ルート案内ウィジェットは、2 つ以上の地点間のターンに基づくルート案内をすばやく効果的に算出する機能を提供します。 〇 〇 〇   地域検索 地域検索ウィジェットを使用すると、選択したポリゴンに関連するポイント フィーチャを検索したり、各フィーチャの詳細を表示したり、選択したポイント フィーチャへのルート案内を取得したりすることができます。 〇 〇 〇   距離と方向 距離と方向ウィジェットは、線、円、楕円、および範囲リングを描画し、重要な情報を視覚化できます。 〇 〇 〇   描画 描画ウィジェットでは、マップ上に任意のグラフィック (図形) を描画できます。 〇 〇 〇   編集 このウィジェットには、フィーチャ サービスのうち編集可能なレイヤーを編集する機能が含まれています。 〇 〇 〇   緊急時応急措置指針 ERG (緊急時応急措置指針) ウィジェットでは、危険物の流出の種類とユーザーが選択したマップ上の場所に基づいて、潜在的な危険を特定できます。 〇 〇 〇   範囲移動 範囲移動ウィジェットを使用すると、マップの前または次の範囲に移動することができます。 〇 〇 〇   フィルター フィルター ウィジェットを使用すると、レイヤー内のフィーチャの表示設定を制限できます。 〇 〇 〇   全画面 全画面ウィジェットでは、全画面モードを使用できます。 〇 〇 〇   ジオコーダー ジオコーダー ウィジェットは、検索ウィジェットに置き換えられました。検索ウィジェットの項目を参照してください。 〇 〇 〇   地理検索 地理検索ウィジェットは、マップ上のポリゴン フィーチャ レイヤーを使用して、CSV ファイル内の位置リストに情報を付加します。 〇 〇 〇   ジオプロセシング ジオプロセシング ウィジェットには、ジオプロセシング タスクを実行するダイナミック ユーザー インターフェイスが組み込まれています。 〇 〇 〇   グリッド オーバーレイ グリッド オーバーレイ ウィジェットでは、Web アプリでクライアント側のリソースを使用して、U.S. MGRS (Military Grid Reference System) グリッドをすばやくレンダリングできます。 〇 〇 〇   インデックス格子線 インデックス格子線 (GRG) を使用すると、アナリストは対象地理領域を分割する際に使用するグリッドを作成できます。 〇 〇 〇   グループ フィルター グループ フィルター ウィジェットでは、マップ内の 1 つ以上のレイヤーに基づき、マップにフィルターを適用できます。 〇 〇 〇   ホーム ボタン ホーム ボタン ウィジェットは、マップを初期表示範囲にズームします。 〇 〇 〇   画像計測 画像計測ウィジェットでは、計測機能を使用してイメージ サービスで測定を実行できます。 〇 〇 〇   インシデント解析 インシデント解析ウィジェットを使用すると、マップ上でインシデントを特定し、インシデントから指定した距離内にあるさまざまなフィーチャ レイヤーの情報を解析できます。 〇 〇 〇   インフォグラフィック インフォグラフィック ウィジェットが提供する 8 種類のグラフィックス テンプレートを使用すると、マップ内とその他のデータ ソースからの属性と統計情報データを視覚化してモニタリングできます。 〇 〇 〇   情報サマリー 情報サマリー ウィジェットを使用して、指定したレイヤーごとに、現在のマップ範囲内のフィーチャの数を表示できます。 〇 〇 〇   レイヤー リスト レイヤー リスト ウィジェットでは、操作レイヤーとそのシンボルがリスト形式で表示され、レイヤーを個別に表示または非表示にすることができます。 〇 〇 〇   凡例 凡例ウィジェットには、マップ内のレイヤーのラベルとシンボルが表示されます。 〇 〇 〇   計測 計測ウィジェットでは、ポリゴンの面積やラインの長さを計測したり、ポイントの座標を検索したりすることができます。 〇 〇 〇   現在地 現在地ウィジェットでは、ネットワークを使用してユーザーの物理的な位置を特定し、マップ上でその位置にズームできます。 〇 〇 〇   近隣検索 近隣検索ウィジェットを使用して、定義した住所または位置のバッファー内のフィーチャを検索したり、それらのフィーチャに関する詳細な情報を表示したり、選択したフィーチャまでのルート案内を取得したりすることができます。 〇 〇 〇   ネットワーク トレース※2 ネットワーク トレース ウィジェットは、任意のジオプロセシング サービスを呼び出して操作するように設計されています。 〇 〇 〇   傾斜ビューアー 傾斜ビューアー ウィジェットは、ArcGIS の [画像座標系 (ICS)] を使用して、ネイティブの座標系で画像を表示し、カメラ位置から自然なビューを提供します。 〇 〇 〇   概観図 概観図ウィジェットは、より大きなエリア内でマップの現在の範囲を表示し、マップ範囲が変更されるたびに更新します。 〇 〇 〇   パーセル ドラフター パーセル ドラフターは、マッピング技術者が土地境界の説明を入力し、クロージャ エラーをチェックするために使用できる Web AppBuilder for ArcGIS の構成です。 〇 〇 〇   印刷 印刷ウィジェットでは、Web アプリを印刷サービスに接続して、現在のマップを印刷できるようにします。 〇 〇 〇   パブリック通知 パブリック通知は、Web AppBuilder for ArcGIS の構成の 1 つで、地方自治体の職員が、所有者および占有者の財産を特定し、宛名ラベルや構造化テキスト ファイルを作成できるようにします。 〇 〇 〇   クエリ クエリ ウィジェットを使用すると、事前に定義されたクエリを実行して、ソース データから情報を取得することができます。 〇 〇 〇   関連テーブル チャート 関連テーブル チャート ウィジェットを使用して、フィーチャ レイヤーの関連テーブルの値のチャート (バー チャート、パイ チャート、または極座標チャート) を作成できます。 〇 〇 〇   フィーチャ レポート フィーチャ レポート ウィジェットでは、ユーザーからのデータ品質のフィードバックを収集および管理できます。 〇 〇 〇   レビューアー ダッシュボード レビューアー ダッシュボード ウィジェットには、ユーザーの GIS データで特定されたデータ品質の問題を集計し、インフォグラフィックスとしてデータ品質結果の統計情報が円グラフおよび棒グラフで表示されます。 〇 〇 〇   縮尺記号 縮尺記号ウィジェットは、マップに縮尺記号を表示します。 〇 〇 〇   スクリーニング スクリーニング ウィジェットを使用すると、対象地域を定義し、指定されたレイヤーを解析して、潜在的な影響がないか確認できます。 〇 〇 〇   検索 検索ウィジェットを使用すると、エンド ユーザーはマップ上で場所を見つけたり、フィーチャを検索したりできます。 〇 〇 〇   選択 選択ウィジェットを使用すると、マップ上のフィーチャを対話的に選択し、選択したフィーチャに対してアクションを行えます。 〇 〇 〇   共有 共有ウィジェットでは、アプリをソーシャル メディア アカウントにポストしたり、リンクを電子メールで送信したり、Web サイトやブログに埋め込んだりして共有することができます。 〇 〇 〇   状況認識 状況認識ウィジェットでは、マップ上の位置を指定し、指定の領域内にあるフィーチャ レイヤーの情報を解析することができます。 〇 〇 〇   スマート エディター スマート エディター ウィジェットを使用すると、フィーチャおよびその関連レコードを容易に編集できます。 〇 〇 〇   スプラッシュ スプラッシュ ウィジェットは、アプリのスプラッシュ画面上の表示コンテンツを定義します。 〇 〇 〇   ストリーム ストリーム ウィジェットを使用すると、ストリーミング フィーチャ レイヤーからのリアルタイムのデータ フィードを可視化および制御できます。 〇 〇 〇   適合性モデラー 適合性モデラー ウィジェットを使用すると、活動に最適な場所の検索、危険性の予測、事象が発生する可能性が高い場所の識別が可能になります。 〇 〇 〇   サマリー サマリー ウィジェットを使用すると、現在のマップ内のフィーチャ レイヤーから、表示されているマップ範囲内にある数値属性を集計できます。 〇 〇 〇   スワイプ スワイプ ウィジェットを使用して、マップ内のさまざまなレイヤーのコンテンツを簡単に比較できます。 〇 〇 〇   脅威分析 公共安全の担当者と初動対応者は、イベントの計画時に安全な距離と区域を特定します。 〇 〇 〇   タイム スライダー タイム スライダー ウィジェットを使用して時系列レイヤーをマップに表示し、アニメーションを再生して、データが時間とともにどのように変化するかを確認できます。 〇 〇 〇   可視解析 可視解析ウィジェットは、指定された距離、観測点の高さ、および視野に基づいて、観測点から見えるものを特定します。 〇 〇 〇   ズーム スライダー ズーム スライダー ウィジェットは、マップ表示に対話型のズーム コントロールを提供します。 〇 〇 〇    3D ウィジェット    ウィジェット 機能概要 ArcGIS Online (2022 年 11 月アップデート) ArcGIS Enterprise バージョン 11.0.1 Developer Edition バージョン 2.26 ※1     3DFx 3DFx ウィジェットが提供する一連の 3D アニメーション アプローチを使用して、地理情報を直感的で対話的な 3D 環境で視覚化および解析することができます。 〇 〇 〇   情報 情報ウィジェットは、ウィジェットに表示するコンテンツを作成します。 〇 〇 〇   ベースマップ ギャラリー ベースマップ ギャラリー ウィジェットには、組織から提供されるベースマップを表す画像のコレクション、またはユーザー定義の一連のマップ/イメージ サービスが表示されます。 〇 〇 〇   コンパス コンパス ウィジェットをクリックすると、シーンが北向きで再描画されます。 〇 〇 〇   座標 座標ウィジェットは、X,Y 座標、標高、およびカメラの高度の値を 3D アプリに表示します。 〇 〇 〇   日光 日光ウィジェットでは、時刻と月を変化させて日差しと影がシーンに与える影響を変更できます。 〇 〇 〇   全画面 全画面ウィジェットを使用して、全画面モードを開始できます。 〇 〇 〇   ホーム ボタン ホーム ボタン ウィジェットをクリックすると、最初のカメラ位置に戻ります。 〇 〇 〇   レイヤー リスト レイヤー リスト ウィジェットは、シーン内の 2D レイヤーまたは 3D レイヤーをリスト表示します。 〇 〇 〇   凡例 凡例ウィジェットには、シーン内のレイヤーのラベルとシンボルが表示されます。 〇 〇 〇   計測 3D アプリの計測ウィジェットでは、2 つのポイント間の水平、垂直、および直線距離、ポリゴンの面積および周囲長を計測できます。 〇 〇 〇   現在地 現在地ウィジェットでは、ネットワークを使用してユーザーの物理的な位置を特定し、マップ上でその位置にズームできます。 〇 〇 〇   ナビゲート ナビゲート ウィジェットを使用して、シーンを回転したり画面移動したりします。 〇 〇 〇   検索 検索ウィジェットを使用して、シーン内で場所を見つけることができます。 〇 〇 〇   共有 共有ウィジェットでは、3D アプリをソーシャル メディア アカウントにポストしたり、リンクを電子メールで送信したり、Web サイトやブログに埋め込んだりして共有することができます。 〇 〇 〇   スライド スライド ウィジェットは、シーンのさまざまなビューを表示します。 〇 〇 〇   スプラッシュ スプラッシュ ウィジェットは、アプリのスプラッシュ画面上の表示コンテンツを定義します。 〇 〇 〇   ズーム スライダー ズーム スライダー ウィジェットは、マップ表示に対話型のズーム コントロールを提供します。 〇 〇 〇    補足事項  ※1: Developer Edition 版のガイドは英語です。ウィジェットの説明を日本語でご覧になりたい場合は、ArcGIS Online まはた ArcGIS Enterprise のヘルプを参照してください（ウィジェットの説明に関しては、基本的にどのガイドも共通です）。 ※2: 日本国内サポート対象外のウィジェットです。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/debugging-widget-development/",
	"title": "ウィジェット開発のデバック",
	"tags": [],
	"description": "ウィジェット開発におけるデバック方法について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Debugging widget development\nウィジェット開発環境の設定 カスタム ウィジェットの開発には、使い慣れた IDE やテキストエディタを使うことができます。Visual Studio Code は、デフォルトで TypeScript を認識する機能が組み込まれているため、よいオプションのひとつです。\n作成したカスタム ウィジェットは、Experience Builder ファイル構造の client フォルダのディレクトリ内に配置されます。Visual Studio Code 内で、プロジェクトとして client フォルダを開きます。\n ファイル メニューをクリックします。 フォルダを開く をクリックします。 Experience Builder　を初めて起動したときに解凍した Experience Builder ファイル内の client フォルダを参照します。  これにより、client フォルダ内のすべてのファイル (カスタム ウィジェットのファイルを含む) が、左側の VS Code Explorer タブで利用できるようになります。また、Visual Studio Code は、Experience Builder ライブラリの TypeScript の定義について client フォルダの内容全体をスキャンし、カスタム ウィジェットを書いている間に TypeScript の検証と autocomplete (オートコンプリート:自動補完) を可能にします。\nVisual Studio コード テキストエディタとして Visual Studio Code を使用している場合、テキストエディタに機能を追加するために使用できる拡張機能のマーケットプレイスがあります。インストールしておきたい React 拡張機能に加えて、Experience Builder のカスタム ウィジェット開発にはこれらの拡張機能が推奨されています (必須ではありません)。\n  IntelliSense for CSS class names in HTML - ワークスペースで見つけた定義に基づいてHTML クラス属性 の CSS クラス名を補完します (ワークスペースの中の CSS を読み込んで HTML 上でクラス指定するときに入力候補を表示します)。\n  vcode-styled-components - styled-components のシンタックスハイライトを付けます。\n  デバッグツール Web ブラウザ内には、カスタム ウィジェットを効率的に構築するために使用できるさまざまなデバッグツールがあります。\nブラウザ開発ツール Experience Builder のオーサリング インターフェイスまたはプレビュー モードでは、ブラウザの開発者ツールを開いてデバッグ ツールにアクセスすることができます。開発者ツールを開くには\n Chrome で、メイン メニューをクリックし、「その他のツール」→「開発者ツール」を選択します。(詳細) Firefoxで、[メインメニュー] \u0026gt; [Web開発者] \u0026gt; [ツールの切り替え] ((詳細)をクリックします。  DOM 要素 ブラウザの開発者ツールで、Sources (Chrome) または Debugger (Firefox) タブをクリックします。ここでは、カスタムウィジェットの DOM を調べて現在の状態を確認できます。\nJavaScript のソースとブレークポイント ブラウザの開発者ツールで、Elements (Chrome) または Inspector (Firefox) タブをクリックします。ここでは、ページの JavaScript コードを閲覧することができます。ウィジェットが開かれていることを確認して(該当する場合)、左側のファイルブラウザで webpack を選択してウィジェットの widget.tsx ファイルを見つけてダブルクリックしてください。別の方法としては、ctrl + p と入力してファイル コマンドパレットを開き、widget.tsx と入力してください。目的の widget.tsx ファイルはファイル名の最後に ?zzzz (zzzz は数字と文字の組み合わせ) が付いているものになります。\nウィジェット ファイルを開くと、その TypeScript コードを見ることができます。行番号をクリックしてブレークポイントを設定することができます (詳細: Chrome、Firefox)\nGlobal Experience Builder の変数 コードがブレークポイントで停止している場合、右側のパネルで Scope ペインを開き、現在スコープ内にある変数を見ることができます。Global まで下にスクロールしてください。ここには、Experience Builder がいくつかの便利な変数を配置しています。これらの変数を調べて、Experience Builder 内のさまざまな現在のステータスを確認できます。\nこれらの変数には、以下のものがあります。\n _appState - Experience Builder の現在の状態に関するさまざまなプロパティ。 _dataSourceManager - ウィジェット内の現在のデータソース。 _widgetManager - ウィジェットがロードされているかどうかなど、ウィジェットに関する様々なプロパティ。 _sessionManager - ログイン情報の確認と管理に使用できます。 他にも、あまり使われていないグローバル変数もあります。すべてのリストを見るには、ファイル clientjimu-core\\jimu-coreliblib\\typeswindow.d.ts を参照してください。  ビルダーページでのデバッグ ビルダーページでデバッグすると、Experience は iframe で読み込まれます。このため、Javascript の実行コンテキストには top と _appWindow の 2 つに分かれています。top コンテキストがビルダーコンテキストで、_appWindow コンテキストが Experience コンテキストです。コンソールでグローバル変数を検査する場合は、ブラウザの開発者ツールのドロップダウン リストで正しいコンテキストが選択されていることを確認してください。ブレークポイントを使用してデバッグしているときは、window.jimuConfig.isBuilder を見て実行コンテキストを判断してください。true はコードが ビルダーコンテキスト内にあることを意味します。\nネットワーク ブラウザの開発者ツールで、Network タブをクリックします。ここでは、Experience によって送受信されるネットワークのリクエストを確認できます。\nキャッシュのクリア コードをデバッグしている間は、コードを変更したり、ページを頻繁にリロードしたりすることがあります。ブラウザが予期せずにキャッシュし、開発中に混乱を招くこともあります。このため、ブラウザを更新するたびにキャッシュをクリアするか、開発中にネットワーク開発者ツールの Disable cache にするチェックボックスを有効にすることが重要です。\nReact 開発ツール Experience Builder の Experiences は、React JavaScript ライブラリを使用しています。上記の DOM Elements ブラウザに加えて、React がどのように動作するかを知り、React コンポーネントについてさらに詳しい情報を表示してくれるブラウザ拡張機能をインストールすることができます。ブラウザの拡張機能ストア (Chrome, Firefox) から拡張機能をインストールし、ツールを有効にします。これで、ブラウザの開発者ツールに 2 つのタブが追加されました。Components と Profiler です。\nComponents タブをクリックします。Search または \u0026ldquo;Select Element\u0026rdquo; ボタンを使用して、コンポーネントツリーでカスタム ウィジェットを選択します。選択されると、右側の情報パネルにコンポーネントの props と state が表示されます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/data-source/",
	"title": "データ ソース（Data source）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Data sources\nデータ ソース（Data source） データ ソースは、ウィジェットがどのようにデータにアクセスするかを定義します。例えば、データがリモートサーバーからのものである場合、ウィジェットはクライアント側にクエリするために、データ ソース クラスを使用します。ウィジェットでデータが生成された場合、それ自身をデータ ソース クラスに入れることで、別のウィジェットで使用することができます。\n高レベルでは、データ ソースはスキーマといくつかのレコードを持ち、子/親データ ソースを持つ場合があります。さらに、すべてのデータ ソースは、それを識別するのに役立つ型、ID、ステータスがあります。 DataSource インターフェースは jimu-core パッケージで定義されており、これは以下のメソッドとプロパティのいくつかを定義しています。\n id: データ ソースID。 type: どのタイプのデータ ソースを使っているかチェックするため、ウィジェットで使っているプロパティ。 fetchSchema: すべてのデータ ソースは、スキーマを返すためにこのメソッドを実装しなければなりません。これは、リモート データ サービスで定義されたスキーマです。例えば、ユーザーがExperience Builder でデータ ソースを追加した場合、データ ソースのスキーマはアプリ構成に保存されません。代わりに、最新のデータ ソース スキーマを取得するために fetchSchema メソッドが呼び出されます。 getSchema: ウィジェットがデータ ソースのスキーマとフィールドにアクセスするために使用するメソッドです。 getRecords: ウィジェットがデータ ソースのデータレコードにアクセスするために使用するメソッドです。 getStatus: ウィジェットはこのメソッドを使用してデータ ソースのステータスを取得します。これらのステータスには、NotReady、Unloaded、Loading、Loaded および LoadError があります。NotReady はウィジェットの出力データ ソース専用です。出力データ ソースのインスタンスが作成されても、そのインスタンスは使用する準備ができていません。出力データ ソースを生成するウィジェットはデータ ソースを使用可能な状態にするアクション (DataSourceChanged) を送る必要があります。データ ソースのステータスが準備できていない場合、クエリは空の結果を返します。その他のクエリ可能なデータ ソースでは、既定のステータスは Unloaded です。データが要求されると Loading に変更され、最後に Loaded または LoadError に変更されます。  1つのデータ ソースには、サブデータ ソースを含めることができます。その結果、使いやすくするために複数のデータ ソースを含めることができます。このようなデータ ソースを DataSourceSet と呼びます。WebMapDataSource は DataSourceSet です。DataSourceSet も、isDataSourceSet プロパティをtrue に設定していれば、データ ソースの一種です。データ ソースは DataSourceManager で管理し、データ ソースの作成や取得を行います。\n複数のウィジェットが 1 つのデータ ソースに接続する場合、ウィジェットはデータ ソースのローカル ビューを表示したい場合があります。このシナリオでは、データ ビューを使用します。データ ビューとデータ ソースの関係は、リレーショナル データベースのビューとテーブルの関係に非常に似ています。Experience Builder のデータ ソースは、クライアント側の実際のリモート データ ソースのビューですが、データ ソースはテーブル、データ ビューはビューと考えることができます。アプリ作成者は、データ ソースからデータ ビューを作成し、ビルダーでデータ ビューにウィジェットを接続することができます。API レベルでは、データ ビューは DataSource クラスを使用して管理されるため、データ ビューは、属性の違いだけでデータ ソースと同じインターフェースとふるまいを持ちます。\nデータ ソースの使用を簡単にするために、DataSourceComponent コンポーネントが定義されています。これは useDataSource プロパティを受け取り、コールバックを通じてデータ ソース オブジェクトとそのステータス情報を返します。また、子として関数を受け入れ、データ ソース オブジェクトとデータ ソース内のデータをレンダリングするための情報を取得するために使用することができます。DataSourceComponent コンポーネントは、オプションの query プロパティを受け入れることもでき、クエリが変更されたときにデータをリロードします。\nフィーチャーサービスのような最も一般的に使用されるデータ形式をサポートするために、APIにはQueriableDataSourceインターフェイスと抽象クラス AbstractQueriableDataSource があります。このインターフェイスには、url、load、query などのプロパティがあります。ロードとクエリの違いは、ロードはレコードのプロパティとデータ ソースのステータスを更新し、クエリはレコードのみをクエリして返すことです。\n具体的には、Experience Builder で FeatureLayerDataSource データ ソースを定義して、フィーチャレイヤーにアクセスします。データ ソースがスタンドアロンのフィーチャ レイヤから作成された場合、オブジェクトには layer プロパティはありません。Webmap/Webscene に含まれるフィーチャ レイヤから作成された場合、オブジェクトには layer プロパティがあり、これは ArcGIS Maps SDK for JavaScript の FeatureLayer オブジェクトです。FeatureLayerDataSource の実際のデータは、リモート データベースからのものと、クライアント側のフィーチャのコレクションからのものがあり、どちらもクエリをサポートしています。クライアント側のデータについては、データ ソースがスタンドアロン フィーチャ レイヤーから作成された場合でも、クエリをサポートするためにレイヤー オブジェクトが作成されます。\n一般的にデータ ソースは2つの場所に保存され、データ ソースオブジェクトは DataSourceManager に保存・管理され、データ ソース情報はredux アプリ ストアに保存されます。ataSourceComponent を使う場合、コンポーネントは DataSourceManager を呼び出してオンデマンドでデータ ソースを作成し、コールバック プロップを使ってデータ ソース オブジェクトとdataSourceInfo を返します。dataSourceInfo では、データ ソースの instanceStatus, status, selectedIds などを返すことができます。\nArcGIS server サービスの多くは、MapServiceDataSource、FeatureServiceDataSource など、アクセスしやすいようにデータ ソースにマッピングされています。 ArcGIS Maps SDK for JavaScript の WebMap と WebScene は、jimu-arcgis パッケージ内で WebMapDataSource と WebSceneDataSource としてラップされています。\nデータ ソース セット（Data Source Set） データ ソースは、子データ ソースを持つことができます。そのため、使いやすいように複数のデータ ソースを含めることがあります。このようなデータ ソースを DataSourceSet と呼びます。WebMapDataSource は DataSourceSet です。isDataSourceSet プロパティが true に設定されていれば、DataSourceSet もデータ ソースの一種です。getChildDataSources を使って親データ ソースから子データ ソースを取得したり、parentDataSource を使って子データ ソースから親データ ソースを取得することができます。\nデータ ビュー（Data View） 複数のウィジェットが 1 つのデータ ソースに接続している場合、ウィジェットはデータ ソースのローカルビューを見たいと思うかもしれません。このような場合には、データ ビューを使用します。データ ビューとデータ ソースの関係は、リレーショナルデータベースのビューとテーブルの関係によく似ています。Experience Builder のデータ ソースは、クライアント側の実際のリモートデータ ソースのビューですが、データ ソースはテーブル、データ ビューはビューと考えることができます。アプリ作成者は、データ ソースからデータ ビューを作成し、ビルダー内のデータビューにウィジェットを接続することができます。APIレベルでは、データ ビューは DataSource クラスを使用して管理されているため、データビューは、いくつかのプロパティの違いがあるだけで、データ ソースと同じインターフェイスと動作を持っています。データ ビューのベースとなるデータ ソースはメインデータ ソースと呼ばれ、getMainDataSource を使ってデータビューからデータ ソースを取得したり、getDataViews を使ってメインデータ ソースのすべてのビューを取得することができます。\n選択は、メインデータ ソースとそのすべてのデータビューの間で共有されます。選択されたレコードはデータ ソースの選択ビューに保存され、選択されたレコード ID は redux app store のデータ ソース ID の下に保存されます。選択ビューは、メインデータ ソースの特別なデータビューで、${mainDataSourceId}-sclection で識別されます。\nローカルデータ ソースとデータビュー（Local data source and data view） 複数のウィジェットが異なるデータを取得するために異なるデータビューを使用することができますが、異なるウィジェットが同じデータ ソースまたは同じデータビューに接続する必要があっても、ウィジェット内のドロップダウンリストなど、ウィジェット内の異なるデータを取得する必要があるシナリオがあります。この場合、ウィジェットはローカルデータ ソースまたはデータビューを作成することができ、ローカルデータ ソースまたはデータビューに適用されたフィルタは、関連するデータ ソースまたはデータビューに影響を与えません。DataSourceComponent を使用して localId を渡すか、DataSourceManager().getinstance().createLocalDataSource を使用してローカルデータ ソースまたはデータビューを使用することができます。\nデータ ソース内のソースレコード（Source records in data source） ほとんどの場合、データはリモート・データベースにあるので、データ・ソース・インスタンスはリモートからデータを取得してデータ・ソース・インスタンスに保存するだけです。しかし、一部のデータ ソースでは、ウィジェットの出力データ ソースや選択ビューのデータ ソースのように、データがクライアント側で生成される場合があります。これらのシナリオでは、データ ソースのデータは、データ ソース・インスタンスの DsourceRecords に格納されます。getSourceRecords と setSourceRecords を使用して、それを取得および更新することができます。\nウィジェット出力データ ソース（Widget output data source） ウィジェットは、データ ソースを使用することができ、また、データ ソースを生成することもできます。一般的に、ウィジェットはその設定ページで this.props.onSettingChange を呼び出して出力データ ソースを宣言し、他のウィジェットがその出力データ ソースを使用できるようにする必要があります。出力データ ソースは app config の dataSources に保存されます。他のウィジェットでは、出力データ ソースを使用しても、ユーザーが追加したデータ ソースを使用しても、違いはありません。\n内部的には、ウィジェットが出力データ ソースを使用し、ウィジェットがレンダリングされると、出力データ ソースと出力データビューが作成されます。出力データビューは、${outputDataSourceId}-output で識別されます。出力データ ソースを使用するウィジェットは、出力ビューを使用します。出力データ ソースを生成したウィジェットは、出力データ ソースのsetSourceRecords または updateQueryParams を呼び出すことで、データ ソースを更新します。\n出力データ ソースの JSON 内の originDataSources は、オリジンデータ ソースと出力データ ソースの関係を維持するために使用されます。例えば、ウィジェットの出力データ・ソースにスキーマが定義されていない場合、オリジン・データ・ソースのスキーマが使用されます。ウィジェットは、このプロパティと、id、type などの一般的なプロパティを更新する必要があります。クエリとチャートのウィジェットは、どちらも出力データ ソースを生成します。これらの出力データ ソースの JSON を参考にして、出力データ ソースの JSON に必要なプロパティを確認することができます。\nデータアクション（Data action） データアクションの参照\nリピート データ ソース（Repeated Data source） RepeatedDataSourceProvider が提供するデータ ソースをリピートデータ ソースと呼びます。データ ソースを提供するウィジェットのすべての子ウィジェットは、リピートデータ ソースを受け取ります。これは React\u0026rsquo;s Context と似ています。ウィジェットは this.props.repetedDataSource でリピートデータ ソースにアクセスできます。リピートデータ ソースは、データ ソースの id、record、recordIndx を取得します。 どのウィジェットでも、RepeatedDataSourceProvider を使用してリピートデータ ソースを提供することができます。Experience Builder の List ウィジェットは、リピートデータ ソースを提供する良い例です。リピートデータ ソースを使用するには、ウィジェットのマニフェストファイルに supportRepeat プロパティを追加します。\nウィジェットでのデータ ソースの使用（Use data source in widget） データ ソースは、ウィジェットがデータにアクセスする方法を定義します。公開されたエクスペリエンスのすべてのデータ ソースは、アプリの config.json の dataSources プロパティに保存されます。config.json は server/public/apps/ フォルダにあります。以下のスニペットでは、この dataSources プロパティに WEB_MAP タイプのデータ ソースが 1 つあります。\n\u0026#34;dataSources\u0026#34;: { \u0026#34;dataSource_1\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;WEB_MAP\u0026#34;, \u0026#34;itemId\u0026#34;: \u0026#34;cb5329a59a354904a035de57f85112d3\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;dataSource_1\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;US Breweries\u0026#34;, \u0026#34;portalUrl\u0026#34;: \u0026#34;https://www.arcgis.com\u0026#34; } }, ウィジェットでのデータ ソースの使用は、app config で useDataSources というプロパティで宣言されます。\n\u0026#34;useDataSources\u0026#34;: [ { \u0026#34;dataSourceId\u0026#34;: \u0026#34;dataSource_1\u0026#34; } ], ウィジェットでは、データ ソースを選択できる設定UIを提供することをお勧めします。これを実現するには、DataSourceSelector コンポーネントを使用して、設定 UI でデータ ソースを選択します。詳細については、設定 UI の作成をご確認ください。実行時には、DataSourceComponent を使用して、データ ソースオブジェクトとデータ ソース情報を取得します。情報には以下のものが含まれます。\n instanceStatus: データ ソースのインスタンスが正常に作成されたかどうか status: データがロードされているかどうか countStatus: データのカウントがロードされているかどうか selectedIds: 選択されたデータの ID widgetQueries: データ ソースに適用されたクエリ(フィルタ)ウィジェット version: バージョン番号は、クライアント側でデータの変更を管理するためのもので、すべてのデータ ソース・コンシューマーはデータがいつ変更されたかを知ることができます。 gdbVersion： ブランチバージョンをサポートしている機能サービスの場合。ブランチ・バージョン管理ウィジェットがブランチ・バージョンを切り替えると、そのバージョンがここに保存されます。  選択されたデータ ソースの id/index は、datasource.selectRecord または datasource.selectRecordById を使って、クエリパラメータとして URL に入れることができます。\nWebMap/WebScene の使用（Use WebMap/WebScene） jimu-arcgis パッケージでは、データ ソースとして WebMap/WebScene をラッピングしています。WebMap にアクセスするには WebMapDataSource を、WebScene には WebSceneDataSource を使用します。これらのデータ ソースの使用方法については、MapView サンプルをご確認ください。WebMap/WebScene オブジェクトに加えて、これらのオブジェクトに含まれるすべてのレイヤーもデータ ソースとしてラップされているため、getChildDataSources を呼び出してすべてのレイヤーのデータ ソースを取得することができます。サポートされているレイヤーとサービスは、SupportedLayerServiceTypes と SupportedServiceTypes で定義されています。\nFeatureLayer の使用（Use FeatureLayer） ワークフローの中には、FeatureLayer を直接操作するような軽量のエクスペリエンスを作成する必要があるものもあります。このような場合、FeatureLayerDataSource クラスを使用します。独立したフィーチャーマップを使用するウィジェットは、layer プロパティを持たない FeatureLayerDataSource オブジェクトを取得しますが、ウェブマップやウェブシーンからフィーチャーマップを使用すると、layer プロパティを持つ FeatureLayerDataSource オブジェクトが返されます。Layer オブジェクトは、ArcGIS Maps SDK for JavaScript のものです。\nconst getLayerObject = (ds: FeatureLayerDataSource) =\u0026gt; { return ds.layer; // this can be null  } ウィジェット間のデータ共有（Sharing data between widgets） ウィジェットが同じデータを共有することは、一般的なワークフローです。例えば、Map と List の2つのウィジェットを使った体験談です。リストウィジェットでフィーチャーが選択されると、マップでも対応するフィーチャーが選択されます。これを実現する最も簡単な方法は、両方のウィジェットに同じデータ ソースを使用することです。例えば、リストウィジェットでアイテムが選択されると、ウィジェットは datasource.selectRecord() を呼び出し、アプリストアのデータ ソースのステータスを更新します。これにより、Map ウィジェットは現在選択されているアイテムを適宜レンダリングすることができます。また、現在選択されているアイテムが URL に配置されるため、現在のアプリの状態を他の人と共有することが可能になります。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/unreal-engine/",
	"title": "ArcGIS Maps SDK for Unreal Engine",
	"tags": [],
	"description": "ArcGIS Maps SDK for Unreal Engine の開発に役立つガイド集です。",
	"content": "ArcGIS Maps SDK for Unreal Engine の開発に役立つガイド集です。\nArcGIS Map SDK for Unreal Engine は、現在 ESRIジャパンにおけるサポート対象外の製品です。 ESRIジャパンで提供する Esri 製品サポート サービスや開発者サポート サービスはご利用いただけませんので、予めご了承ください。\n\r インストールガイド\nArcGIS Maps SDK for Unreal Engine のインストールとセットアップ手順を紹介します。\n\r 新規プロジェクトにプラグインを追加\nArcGIS Maps SDK for Unreal Engine を新規プロジェクトに導入する手順を紹介します。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/third-party-libraries/",
	"title": "サードパーティ製のライブラリ使用",
	"tags": [],
	"description": "サードパーティ製のライブラリの使用方法について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Using third-party libraries\nExperience Builder に付属の jimu ライブラリを使用して、ウィジェットに様々な機能を組み込むことができます。この機能に加えて、サードパーティのライブラリを追加して、Experience Builder のカスタム ウィジェット内で使用することができます。\nサードパーティのライブラリをインクルードして、ウィジェット内で使用できるようにするには、3 つの方法があります。\nNPM インストール ライブラリを 1 つのウィジェットのみで使用する場合は、使用するライブラリを npm に含めることをお勧めします。\n利用方法 ターミナルでカスタム ウィジェットのルートディレクトリを参照し、npm init を実行し、対話形式で質問に答えます。これにより、カスタム ウィジェットのルートディレクトリに package.json ファイルが作成されます。\n次に、npm のパッケージディレクトリからサードパーティのライブラリの名前を探します。これは npmjs.com にアクセスして検索するか、通常はライブラリのドキュメントページにパッケージ名が記載されています。パッケージ名を使って npm インストールコマンドを実行します。\nnpm install \u0026lt;package-name\u0026gt;\rこのコマンドを実行すると、2 つのことができます。まず、ライブラリファイルをダウンロードし、node_modules ディレクトリに配置します。第二に、上記の npm init コマンドで作成した package.json ファイルにライブラリへの参照を追加します。\nパッケージ名は、カスタムウィジェットの import コマンドで使用できるようになりました。例えば、\u0026quot;import * as ReactDataGrid from \u0026quot;react-data-grid\u0026quot; としてインポートします。\npackage.json にライブラリへの参照が追加されたので、他のコンピュータにすべてのウィジェットの依存関係を素早くインストールするには、ウィジェットのルートディレクトリでターミナルを開き、npm install を実行して、ウィジェットのすべての依存関係をインストールします。\nこのパターンの動作の説明は react-data-grid のサンプルを参照してください。\nmanifest.json を使用して CDN 経由で使用 ライブラリを複数のウィジェットで使用する場合は、ライブラリの CDN url を manifest.json ファイルの dependency プロパティに 配置することで、ライブラリを含めることができます。\n利用方法 ライブラリの CDN url を見つける必要があります。通常、これはライブラリのドキュメントに記載されているか、jsDelivr や unpkg で見つけることができます。たとえば、jQuery サンプルでは、CDN URL は https://unpkg.com/jquery@3.5.1/dist/jquery.js です。\nウィジェットの manifest.json ファイルに dependency と呼ばれる配列プロパティを追加し、その配列に url を追加します。例えば、以下のようになります。\n\u0026#34;dependency\u0026#34;: [ \u0026#34;https://unpkg.com/jquery@3.5.1/dist/jquery.js\u0026#34; ], Experience Builder は Experience がロードされると自動的にライブラリをロードし、ウィジェットはライブラリのドキュメントに従ってライブラリを使用することができます。\nこのパターンの動作の説明は jquery のサンプルを参照してください。\nダウンロードして直接読み込む ライブラリが複数のウィジェットで使用されている場合、手動でファイルをダウンロードしてウィジェットのコード構造内に格納することでライブラリを含めることができます。\n利用方法 ライブラリのダウンロード可能なビルド済み assets を探します。通常、これはライブラリのドキュメントにリンクされているか、ライブラリの GitHub リポジトリの Releases エリアにあるダウンロード可能な assets の dist フォルダにあります。\nダウンロード後、ファイルを展開し、ウィジェットのルートディレクトリにコピーしてください。相対パスで指定し、インポートを介してインクルードされるので、ウィジェット内の任意の場所にファイルを配置することができますが、慣習的には、lib というフォルダ内に配置することをお勧めします。\nファイルを配置した後、相対パスを使用してライブラリをインポートすることができます。例えば、以下のようになります。\nimport * as d3 from \u0026#34;./lib/d3/d3.min.js\u0026#34;; このパターンの動作例は、D3 のサンプルを参照してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/data-action/",
	"title": "データアクション（Data action）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Data action\nデータアクション（Data action） データアクションは、データレコードのコレクションを拡張可能な方法で処理する方法を提供します。\nデータアクションは Data Action インターフェイスによって定義され、isSupported と onExecute という 2 つの重要なメソッドを持っています。isSupported が呼び出されると、アクションがデータを処理できるかがチェックされます。サポートされていないデータアクションは実行中は非表示になります。onExecute メソッドは DataRecordSet インスタンスとオプションのアクション構成を受け取ります。DataRecordSet インスタンスには、データ ソース、オプションのデータ レコードの配列、フィールドが含まれます。\nフレームワークは CSV へのエクスポートや JSON へのエクスポートなどのデータアクションを提供します。ウィジェットもデータアクションを提供できます。例えば、Map ウィジェト手ゃ \u0026ldquo;画面移動 (pan to)\u0026rdquo; と \u0026ldquo;ズーム (zoom to)\u0026rdquo; というデータアクションを提供します。ウィジェットにデータアクションを実装するには、manifest.json でデータアクションを宣言し、AbstractDataAction を継承したクラスを作成します。\nデータアクションによっては、アクションの動作を設定するための UI が必要な場合があります。これを実現するには、manifest.json で settingUri を宣言します。アクション設定の UI コンポーネントは、いくつかの差し込まれたプロパティを持つ React コンポーネントです。ユーザーが設定を変更したら、this.props.onSettingChange を呼び出して設定を保存し、onExecute メソッドで利用できるようにします。\n\u0026#34;dataActions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;showOnMap\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Show on map\u0026#34;, \u0026#34;uri\u0026#34;: \u0026#34;data-actions/show-on-map\u0026#34;, \u0026#34;settingUri\u0026#34;: \u0026#34;data-actions/show-on-map-setting\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;runtime/assets/icons/ds-map-view.svg\u0026#34; } ] データアクションを提供するだけでなく、ウィジェットはデータアクションを使用することもできます。ウィジェットでデータアクションを使用するには、ウィジェットのmanifest.json プロパティで canConsumeDataAction: true を宣言し、import {DataActionDropDown} from 'jimu-ui' をインポートして、ウィジェットの UI で DataActionDropDown をレンダリングする必要があります。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/deploy-pattern/",
	"title": "デプロイ パターン",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) で作成したアプリやウィジェットのデプロイ パターンを紹介します。",
	"content": "トピック  概要 Web アプリケーションをデプロイ ウィジェットをデプロイ  概要 ArcGIS Experience Builder (Developer Edition) (以下 Developer Edition) では ArcGIS Experience Builder を拡張して、独自の Web アプリケーションやウィジェットを作成することが可能です。エンド ユーザーの利用形態や要件により最適なデプロイは異なりますが、このページでは以下の 2 つの主要なデプロイ パターンと、それぞれのデプロイ方法についてご紹介します。\n Web アプリケーションをデプロイ 全体像  Web アプリケーションを作成し、独自のサーバーでホストすることができます。特定の業務で継続的に利用されるアプリ等、ユーザーによる設定変更が不要な場合や、ユーザーに設定変更をさせたくない場合等に活用できます。   必要なコンポーネント  開発時  Node.js Developer Edition   運用時  ArcGIS Enterprise または ArcGIS Online Web サーバー (ArcGIS Enterprise の Web サーバーと併用も可)    手順概要 以下は Web アプリケーション作成から、デプロイ、実際の運用までの流れの概要です。\n カスタム ウィジェットを含む Web アプリケーションを作成  Developer Edition を用いたウィジェットの開発や Web アプリケーションの作成には Node.js が必要です。 詳しくはインストールガイドをご覧下さい。 カスタム ウィジェットを開発する際は、カスタム ウィジェット開発ガイドをご覧ください。   作成した Web アプリケーションを自身で用意した Web サーバーに配置  ArcGIS Enterprise で使用している Web サーバーと併用することも可能です。 ※ ArcGIS Online を使用してホストすることはできません。 詳しくは、アプリケーションのデプロイをご覧ください。   ユーザーが作成された Web アプリケーションを利用  ユーザーが Web アプリケーションにアクセスして利用します。 ArcGIS Enterprise や ArcGIS Online のポータルにアイテムとして表示させたい場合はアプリの URL をアイテムに登録する必要があります。  詳細は「アプリの追加」及びその後の「アプリの登録」をご覧ください。   内部的には、アプリは ArcGIS Online もしくは ArcGIS Enterprise の Web マップを参照してアプリ上に地図を表示します。     ウィジェットをデプロイ  ArcGIS Enterprise 11 以降では、Experience Builder で使用できるウィジェットのみを開発し、独自のサーバーでホストすることも可能です。ユーザーが ArcGIS Online や ArcGIS Enterprise を使用して独自に Web アプリケーションを作成することを想定しているものの、デフォルトの Experience Builder のウィジェットには無い機能を拡張したい場合に活用できます。   必要なコンポーネント  開発時  Node.js Developer Edition   運用時  ArcGIS Enterprise Web サーバー (ArcGIS Enterprise の Web サーバーと併用も可)    手順概要 以下はカスタムウィジェットの作成から、デプロイ、実際の運用までの流れの概要です。\n カスタムウィジェットを作成  Developer Edition を用いたウィジェットの作成には Node.jsが必要です。 詳しくはインストールガイドをご覧下さい。 カスタムウィジェット開発の詳細については、カスタム ウィジェット開発ガイドをご覧下さい。   作成したカスタムウィジェットを自身で用意した Web サーバーに配置  ArcGIS Enterprise で使用している Web サーバーと併用することも可能です。 ※ ウィジェットを配置するサーバーが自己署名証明書を使用している場合、Portal for ArcGIS に証明書をインポートする必要があります。詳しい方法はポータルへの証明書のインポートをご覧ください。 Web サーバーに配置後、ArcGIS Enterprise に組み込まれている Experience Builder にカスタムウィジェットを追加します。  詳しくは、カスタム ウィジェットの追加をご覧ください。 ※ ArcGIS Online に追加することはできません。     ウィジェットを使った Web アプリケーションの作成・利用  ユーザーが ArcGIS Enterprise に組み込まれている Experience Builder を利用してカスタムウィジェットを使用した Web アプリケーションを作成・利用します。 内部的には、アプリは Web サーバーでホストされているカスタムウィジェットを参照して動作します。     --\r2 つのデプロイ パターンの総括表    パターン 開発時に必要なコンポーネント 運用時に必要なコンポーネント ArcGIS Online での利用可否 ArcGIS Enterprise での利用可否     Web アプリケーションをデプロイ Node.js、Developer Edition Web サーバー、ArcGIS Online もしくは ArcGIS Enterprise 〇 〇   ウィジェットをデプロイ Node.js、Developer Edition Web サーバー、 ArcGIS Enterprise × 〇    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/message-action/",
	"title": "メッセージ と アクション（Message and action）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Message and action\nメッセージ と アクション（Message and action） メッセージ/アクションは、ウィジェットからウィジェット、ウィジェットからフレームワーク、フレームワークからウィジェットへの通信をサポートする方法です。 ウィジェット/フレームワークはメッセージを公開したり、メッセージを聞いたりすることができます。メッセージは jimu フレームワークによって定義される MessageType によって識別されます。jimu には ExtentChange や DataRecordsSelectionChange のようないくつかのメッセージタイプが定義されています。\nメッセージの発行（Publishing a message） ウィジェットは，MessageManager.getInstance().publishMessage(message) を呼び出してメッセージを発行します．例えば、List ウィジェットでは，リストアイテムがクリックされたときに DataRecordsSelectionChange メッセージを発行したり，Map ウィジェットでは，ビューが変更されたときに ExtentChange メッセージを発行して，List ウィジェットのコンテンツを更新したりします。以下の MessageTypes がサポートされています。\n StringSelectionChange ExtentChange DataRecordsSelectionChange DataRecordSetChange  各メッセージには、それを定義するクラスがあります。例えば、ExtentChange メッセージは ExtentChangeMessage クラスで定義され、このクラスはメッセージのペイロードである extent プロパティを定義します。\nメッセージを公開するために、ウィジェットは manifest.json ファイルで公開メッセージを宣言する必要があります。\n\u0026#34;publishMessages\u0026#34;: [ \u0026#34;DATA_RECORDS_SELECTION_CHANGE\u0026#34; ] メッセージアクションの作成（Creating a message action） メッセージアクションを作成するには、AbstractMessageAction クラスを継承する必要があります。メッセージアクションの開発に役立つメソッドや関数がいくつかあります。\nfilterMessageType メソッドは、利用可能なアクションのフィルタリングに使用されます。\nexport default class QueryAction extends AbstractMessageAction{ filterMessageType(messageType: MessageType, messageWidgetId?: string): boolean{ return [MessageType.StringSelectionChange, MessageType.DataRecordsSelectionChange].indexOf(messageType) \u0026gt; -1; } } filterMessage メソッドは、メッセージマネージャでメッセージをフィルタリングするために使用されます。\nfilterMessage(message: Message): boolean{ return true; } アクションによっては、アクションの動作を設定するための設定 UI が必要な場合があります。これを実現するには、manifest.json で settingUri を宣言します。特定のケースでは、設定 UI を省略したい場合があります。これを実現するには、getSettingComponentUri メソッドをオーバーライドし、該当する場合は null を返します。\nアクション設定の UI コンポーネントはいくつかの差し込まれたプロパティを持つ React コンポーネントです。ユーザーが設定を変更したら、this.props.onSettingChange を呼び出して設定を保存し、onExecute メソッドで利用できるようにします。\nthis.props.onSettingChange({ actionId: this.props.actionId, config: {} // the action config }) onExecute メソッドは、メッセージタイプに応じて発生させたいロジックを処理します。以下のスニペットでは、基本的にメッセージタイプに基づいてアクションを選択し、dispatch プロパティを使用してアプリケーションから getAppStore() 関数を使用してストアに送信しています。これにより、redux アクションがディスパッチされ、ステートが更新されるようになります。Redux アクションと Redux でのストアの使用について詳しくはこちらをご覧ください。\nonExecute(message: Message, actionConfig?: any): Promise\u0026lt;boolean\u0026gt; | boolean{ let q = `${(actionConfig as ConfigForStringChangeMessage).fieldName}= \u0026#39;${message}\u0026#39;` switch(message.type){ case MessageType.StringSelectionChange: q = `${(actionConfig as ConfigForStringChangeMessage).fieldName}= \u0026#39;${(message as StringSelectionChangeMessage).str}\u0026#39;` break; case MessageType.DataRecordsSelectionChange: q = `${actionConfig.fieldName}= ` + `\u0026#39;${(message as DataRecordsSelectionChangeMessage).records[0].getFieldValue(actionConfig.fieldName)}\u0026#39;` break; } getAppStore().dispatch(appActions.widgetStatePropChange(this.widgetId, \u0026#39;queryString\u0026#39;, q)); return true; } Redux ストアに格納できるのは、プレーンな JSON オブジェクトだけです。複雑な JavaScript オブジェクトを渡す必要がある場合は、MutableStoreManager を使ってミュータブル ストアに格納できます。値を更新したら、ウィジェットも再レンダリングできます。アクション内で次のように記述します。\nMutableStoreManager.getInstance().updateStateValue(this.widgetId, \u0026#39;theKey\u0026#39;, theComplexObject) ウィジェットでは次のようにしてオブジェクトにアクセスできます。\nthis.props.mutableStateProps.theKey manifest.json には messageActions プロパティがあり、メッセージ アクション エクステンションの場所と情報を提供します。\n\u0026#34;messageActions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;query\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Query\u0026#34;, \u0026#34;uri\u0026#34;: \u0026#34;actions/query-action\u0026#34;, \u0026#34;settingUri\u0026#34;: \u0026#34;actions/query-action-setting\u0026#34; } ] 国際化対応（i18n support） メッセージアクションの言語サポートは、ウィジェットと同じパターンですが、1つ重要な違いがあります。メッセージアクションには、ユーザーがアクションを選択するための Select an action パネルがあります。そのため、アクションのプロパティ名を記載した default.ts というファイルを runtime/translations フォルダに用意する必要があります。フレームワークは、このパネルのアクションラベルの翻訳を処理します。そのため、ラベルのプロパティは、_action_\u0026lt;actionName\u0026gt;_label という命名規則を持つ必要があります。\nexport default { _widgetLabel: \u0026#39;Message subscriber\u0026#39;, _action_query_label: \u0026#39;Query\u0026#39; } "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/unit-testing/",
	"title": "単体テスト",
	"tags": [],
	"description": "単体テストの方法について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Unit Testing\n単体テストの一般原則 良い単体テストを行うためには、テスト可能なコードを書くことが重要です。シンプルな設計原則を適用することが助けになります\n 適切な命名規則を使用し、コードにはコメントを付けましょう（「どのように」ではなく「なぜ」）。コメントは、名前やデザインの悪さの代用にはならないことを覚えておいてください。 DRY：Don\u0026rsquo;t Repeat Yourself（同じことを繰り返さない） - コードの重複を避ける。 単一責任：各オブジェクト/機能は、単一のタスクに集中しなければならない。 同じコンポーネント内では、1つの抽象度にとどめる。例えば、同じメソッドの中で、ビジネスロジックと低レベルの技術的詳細を混在させないようにします。 コンポーネント間の依存関係の最小化：コンポーネント間の情報のカプセル化と交換を少なくする。 ハードコーディングではなく、コンフィギュラビリティをサポートする。そうすることで、テスト時に全く同じ環境を再現する必要がなくなります。  ArcGIS Experience Builder での単体テスト 単体テストのファイルは .test.ts(x) または .spec.ts(x) で終わり、tests フォルダに置く必要があります。 単体テストは、行動駆動型開発（BDD）スタイルで記述する必要があります。たとえば、以下のようになります。\ndescribe(\u0026#39;calculator\u0026#39;, function() { // Describes a module with nested \u0026#34;describe\u0026#34; functions  describe(\u0026#39;add\u0026#39;, function() { // Specify the expected behavior  it(\u0026#39;should add 2 numbers\u0026#39;, function() { // Use assertion functions to test the expected behavior  expect(foo).toBeTruthy(); expect(foo).toBe(\u0026#39;bar\u0026#39;); }) }) })  Experience Builder は、テストフレームワークとして Jest を使用しています。 Experience Builder では、React コンポーネントのテストに @testing-library/react を使用しています。  Experience Builderで単位テストを書く 一般的には、以下の3種類のコードに対して単位テストを書く必要があります。\n TypeScript のネイティブコード：この種のコードでは、Jest のみを使用することができるかもしれません。ほとんどの場合、単体テストを書きやすくするために、いくつかのコンポーネントをモックする必要があります。 ネイティブな React コンポーネント：この種のコードでは、Jest と @testing-library/react を使用する必要があります。テストフレームワークとしてJestを使用し、テスティングライブラリを使用してReactコンポーネントをレンダリングし、そのレンダリング結果を確認します。 Experience Builder ウィジェット：エクスペリエンス・ビルダー・ウィジェットには、jimu-for-test からエクスポートされた wrapWidget と wrapWidgetSetting を使用する必要があります。  上記のような種類のコードに対して、jimu-for-test はテストを簡単に書くためのいくつかのヘルパーユーティリティー関数を提供します。例えば、以下のようなものです。\n 状態の初期化：getInitState() と getDefaultAppConfig() を使って、このようにストアを初期化することができます。  getAppStore().dispatch(appActions.updateStoreState(getInitState().merge({ appConfig: getDefaultAppConfig().merge({ widgets: { w1: { label: \u0026#39;W 1\u0026#39; } } }) })))  フィーチャーサービスをモックするには、次のようにモックデータを使って mockFeatureLayer を呼び出します。  mockFeatureLayer(mockData) フィーチャ レイヤーをモックアップした後は、単体テストのリクエストがネットワークリクエストを行わないため、テストがより安定して高速になります。\n React コンポーネントをレンダリングするには、次のようにしてレンダリングします。  const {queryByText} = render(\u0026lt;Component/\u0026gt;) const {queryByText} = withStoreRender(\u0026lt;Component/\u0026gt;)  そして、レンダリング結果を次のようにチェックします。  expect(queryByText(\u0026#39;the text\u0026#39;)).toBeInTheDocument();  ウィジェットをレンダリングするには、次のようにします。  // Get the widget render, you can pass in store/theme/locale optionally const render = widgetRender(); // Wrap the widget to inject some props into widget component const Widget = wrapWidget(_Widget, {config: {}}); // Then, you can render the widget like a native react component const {queryByText} = render(\u0026lt;Widget/\u0026gt;) ArcGIS Maps SDK for JavaScript を使用するモジュールのテスト コンポーネントで使用したモジュールをモックする必要があります。loadArcGISJSAPIModule でモジュールをロードした場合は、以下のようにモックを作成します。\njest.mock(\u0026#39;jimu-core\u0026#39;, () =\u0026gt; { return { ...jest.requireActual(\u0026#39;jimu-core\u0026#39;), loadArcGISJSAPIModule: jest.fn().mockImplementation(moduleId =\u0026gt; { let module if(moduleId === \u0026#39;esri/layers/FeatureLayer\u0026#39;){ module = jest.fn().mockImplementation(() =\u0026gt; { return { queryFeatureCount: () =\u0026gt; Promise.resolve(5) } }) } return Promise.resolve(module) }) } }) モジュールをインポートすると、jade.mock() が使えるようになります。\n単体テストの実行 client フォルダで npm test を実行します。\n単体テストの例は show-unit-tests サンプルをご覧ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/use-assets/",
	"title": "assets の使用",
	"tags": [],
	"description": "assets の使用について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Use assets\nassets の使用に関する一般的なガイドライン ウィジェットでは、画像や動画などのアセットを使用する必要があります。以下では、ArcGIS Experience Builder ウィジェットで assets を使用する方法について説明します。\n一般的に、assets を使用する方法は 2 つあります。\n assets のインライン化 assets を動的にロードする  インライン assets 画像などの小さな assets の場合、ネットワークパフォーマンスへの悪影響が限定的であるため、この方法は妥当な方法です。assets をインライン化するには、次のように assets をrequire() します。\nconst smallImage = require(\u0026#39;./small-image.png\u0026#39;) \u0026lt;img style={{width: \u0026#39;200px\u0026#39;, height: \u0026#39;200px\u0026#39;}} src={smallImage}/\u0026gt; .svg ファイルの場合、インラインで SVG DOM としてレンダリングしたい場合は、assets/icons フォルダにファイルを置き、次のように require() します。\nconst svg = require(\u0026#39;./assets/icons/mysvg.svg\u0026#39;) \u0026lt;Icon icon={svg} color=\u0026#34;red\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;200px\u0026#34;/\u0026gt; ダイナミックに読み込む 動画や大きな画像の場合、ネットワークのパフォーマンスに悪影響を与える可能性があるため、インラインではなくダイナミックにアセットをロードするのが妥当な方法です。\nアセットを動的にロードするには、2つの方法があります。アセットがランタイムで使用される場合は、ファイルを runtime/assets フォルダに配置します。それ以外の場合は、assets をsetting/assets フォルダに配置します。そうすれば、次のようにアセットを使用することができます。\n\u0026lt;img style={{width: \u0026#39;200px\u0026#39;, height: \u0026#39;200px\u0026#39;}} src={`${props.context.folderUrl}dist/runtime/assets/large-image.jpg`}/\u0026gt; or \u0026lt;Icon icon={`${props.context.folderUrl}dist/runtime/assets/mysvg.svg`} color=\u0026#34;red\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;200px\u0026#34;/\u0026gt; 後者（上図）は、.svg ファイルを SVG DOM としてレンダリングします。\nアセットの使用方法やその他の詳細については，use-assets サンプル ウィジェットを参照してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/deployment-topics/",
	"title": "デプロイ",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) で作成したアプリケーションをダウンロードし、独自のサーバーにホストする手順を紹介します。",
	"content": "ArcGIS Experience Builder で作成したエクスペリエンスは、ダウンロードして Web サーバーにホストすることができます。プライベート コンテンツを使用しているエクスペリエンスは、ArcGIS Online または ArcGIS Enterprise にアプリを登録する必要があります。エンド ユーザーに最適なユーザー エクスペリエンスを提供するために、エクスペリエンスを展開する前にシステム要件を参照してください。\nエクスペリエンスのダウンロード エクスペリエンス ギャラリーのホームページでエクスペリエンスをダウンロードするには、以下のように ● (3 つのドット) をクリックして ダウンロード をクリックします。ZIP ファイルが作成され、ローカル ドライブにダウンロードされます。ZIP ファイルは、お使いのブラウザ用に定義されたダウンロード ディレクトリにあります。\nアプリケーションをダウンロードするには事前にアプリケーションを公開する必要があります。ダウンロードされたエクスペリエンスには Web サーバーのいくつかのデフォルトの設定を構成する web.config ファイルが付属しており、このデフォルト web.config に ArcGIS Maps SDK for JavaScript の設定が含まれるようになりました。\n\rエクスペリエンスのデプロイ エクスペリエンスを Web サーバーにデプロイするには、次の手順を実行します。\n ダウンロードしたエクスペリエンスを解凍し、フォルダーを Web サーバーにコピーします。 アプリにプライベート コンテンツがある場合は、手順 3 ～ 6 を完了し、そうでない場合はエクスペリエンスのデプロイは完了です。 アプリを追加して登録します。詳細については、ArcGIS Online/ArcGIS Enterprise を使用した Client ID の作成 を参照してください。 AppID をコピーし、Experience アプリのルート ディレクトリ (例：\u0026lt;.zip ファイル ルート\u0026gt;\\cdn\\0\\config.json) にある config.json ファイルを開きます。 attributes オブジェクトの下に clientId プロパティを作成します。 config.json ファイルの clientId プロパティに AppID を貼り付けます。再度ファイルを保存します。  \u0026#34;attributes\u0026#34;: { \u0026#34;portalUrl\u0026#34;: \u0026#34;https://exb.maps.arcgis.com\u0026#34;, \u0026#34;clientId\u0026#34;: \u0026#34;EXBAPPsag0XSRtpj\u0026#34; }, server/app name/index.html にアクセスすることでアプリを利用することができます。\nデプロイの自動化 Experience Builder サーバーを実行せずにターミナルからアプリの ZIP エクスポートを自動で生成するには、zipApp コマンドを使用します。これは自動デプロイのための DevOps ワークフローでよく使用されます。\nターミナルで Experience Builder (Developer Edition) がインストールされた解凍済みのルート ディレクトリ (\u0026ldquo;client\u0026rdquo; フォルダーと \u0026ldquo;server\u0026rdquo; フォルダーが含まれるディレクトリ) を参照し、次のコマンドを実行します。\nnode -e \u0026#34;require(\u0026#39;./server/src/middlewares/dev/apps/app-download.js\u0026#39;).zipApp(\u0026#39;0\u0026#39;, \u0026#39;app.zip\u0026#39;, \u0026#39;my_client_id\u0026#39;);\u0026#34;  \u0026lsquo;0\u0026rsquo; はエクスポートしたいアプリの ID に置き換えてください。 \u0026lsquo;app.zip\u0026rsquo; は生成したい ZIP ファイルの名前に置き換えてください。 my_client_id を ArcGIS Online または ArcGIS Enterprise の有効な AppID で置き換えます。詳細については、ArcGIS Online/ArcGIS Enterprise を使用した Client ID の作成 を参照してください。 環境変数 NODE_ENV が production に設定されていることを確認し、最小化された (より小さな) ファイルを生成する production ビルドを作成します。  サービス ワーカー キャッシュ Experience Builder ではサービス ワーカーを使用してアセットのキャッシュ先読みし、アプリケーションのロード時間を改善します。デプロイ済みのアプリケーションのソース コード、config.json、またはその他の変更の更新が必要な場合は、Experience Builder (Developer Edition) で更新を行い、アプリケーションを再ダウンロードしてデプロイできます。ただし、ダウンロード パッケージを直接更新する必要がある場合は、次の手順を実行してサービス ワーカー キャッシュを更新する必要があります。\n app ディレクトリで、cdn/0 を cdn/1 にリネームします。 アプリに必要なソース コードの修正や変更を行います。 アプリケーションのルート フォルダーで index.html を開きます。  \u0026lt;base href=\u0026quot;./cdn/0/\u0026quot;/\u0026gt; を \u0026lt;base href=\u0026quot;./cdn/1/\u0026quot;/\u0026gt; に変更します。 buildNumber = '0' を buildNumber = '1' に変更します。    より良いパフォーマンスのためのキャッシュ ヘッダーの推奨設定は以下のとおりです。\n index.html を 1 分など非常に短い期間キャッシュするか、キャッシュしない。 cdn フォルダーを 1 年間など長期間キャッシュする。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/map-scene-view/",
	"title": "マップ/シーン ビュー（Map/Scene View）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Map/Scene View\nマップ/シーン ビュー（Map/Scene View） ビューの概念はArcGIS Maps SDK for JavaScript と同じですが、Experience Builder では、ウィジェットやメッセージ/アクションなどを作成する際に一貫した拡張性モデルを確保するために、ビューは JimuMapView としてラップされます。JimuMapView オブジェクトを作成するには、ウィジェットは JimuMapViewManager.createJimuMapView() メソッドを使用します。JimuMapView オブジェクトは、主に以下のプロパティを持っています。\n view: マップ/シーン ビュー オブジェクト datasourceId: ビューを作成するデータソース (webmap/webscene) mapWidgetId: オブジェクトを作成するビュー jimuLayerViews: レイヤー ビュー オブジェクトのラッパー  Experience Builder では、マップ ウィジェットが JimuMapView オブジェクトを作成します。ウィジェットが JimuMapView オブジェクトを使用する必要がある場合、設定ページの MapWidgetSelector コンポーネントを使用して マップ ウィジェットを選択することができます。マップ ウィジェットの ID を取得した後、ウィジェットは JimuMapViewComponent を使って、作成された JimuMapView オブジェクトを取得することができます。JimuMapView オブジェクトを選択するには、設定ページの JimuMapViewSelector コンポーネントを利用します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/tutorials/",
	"title": "チュートリアル",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) のチュートリアルでは、カスタム ウィジェットの作成方法について説明しています。",
	"content": "ArcGIS Experience Builder のチュートリアルでは、カスタム ウィジェットの作成方法について説明しています。各チュートリアルの完了には、約 15 分かかります。カスタム ウィジェットの作成方法と API の使用方法について理解することができます。\n スターター ウィジェットの作成 (Esri Community ブログ) マップの座標を取得 (Esri Community ブログ) Add layers to a map (英語)  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/extension-points/",
	"title": "拡張ポイント（Extension points）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Extension points\n拡張ポイント（Extension points） Jimu ライブラリを使用すると、ArcGIS Experience Builder を拡張することができます。多くの場合、カスタム ウィジェットやテーマを作成することで Experience Builder を拡張します。また、Jimu エクステンションにより、より深いカスタマイズを行うことができます。\nJimu ライブラリでは、特定の拡張ポイントが定義されています。エクステンションポイントとは、エクステンションが準拠すべきインターフェースを定義したものです。エクステンションとは、エクステンションポイントのインターフェースを実装したクラスのことです。このインターフェースは、jimu-core からエクスポートされた extensionSpec です。ウィジェットでエクステンションを提供するには、ウィジェットの manifest.json ファイルでエクステンションを宣言する必要があります。\n\u0026#34;extensions\u0026#34;: [ { \u0026#34;point\u0026#34;: \u0026#34;\u0026lt;Extension point name\u0026gt;\u0026#34;, \u0026#34;uri\u0026#34;: \u0026#34;\u0026lt;Extension uri, relative to src folder\u0026gt;\u0026#34; } ] Jimu では、API ドキュメントで定義されている様々な拡張ポイントが定義されています。よく使われる拡張ポイントは以下の 2 つです。\n  AppConfigProcessor - この拡張ポイントのエクステンションは、AppConfig を受け取り、処理された app config を解決するプロミスを返す必要があります。これは、文字列の翻訳（Translation サンプルを参照）のように、app config を実行時に修正するために使用できます。この処理は、app config がロードされた直後に起動されます。\n  DependencyDefine - この拡張機能を使用すると、初期化が必要なサードパーティのライブラリを使用できます。\n  ReduxStore - この拡張機能を使用すると、ウィジェットの Redux 状態の actions と reducers を定義できます。\n  サンプル 拡張機能の作成例として、Translation サンプルをご紹介します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/migrating-from-web-appbuilder/",
	"title": "Web AppBuilder からの移行",
	"tags": [],
	"description": "Web AppBuilder から ArcGIS Experience Builder (Developer Edition) への移行方法について説明しています。",
	"content": "出典：ArcGIS Experience Builder - Guide - migrating-from-web-appbuilder\nはじめに ArcGIS Experience Builder は、Web AppBuilder とはさまざまな点で異なります。これらの違いから、Web AppBuilder から Experience Builder へカスタム ウィジェットやテーマを直接変換することはできません。手動のプロセスですが、Experience Builder 用にウィジェットやテーマを再構築する際に考慮すべきヒント、テクニック、および推奨プラクティスを紹介します。\nこれは網羅的なものではありませんし、開発者が手動で書き直す作業であることに変わりはありません。これらの手順は、Experience Builder 内でウィジェットを再ビルドする際の準備と計画に役立つように提供されます。\n\rスタートアップ まず、Experience Builder のドキュメントを確認し、ウィジェット開発のスタート ドキュメントに従って TypeScript、React、JSX、Jimu を学びます。\nウィジェットの新規作成 コア技術の概念に慣れたら、ブランク/スターターの Experience Builder のウィジェットを作成し、ビルド環境が正しく設定されていることを確認します。次に、Web AppBuilder のカスタム ウィジェットから新しい Experience Builder のカスタム ウィジェットにコードを移動し、次の点に注意してください。\n  どちらのウィジェットにも manifest.json がありますが、Experience Builder のものは若干異なりますので、新しい manifest.json の形式を確認し、適宜更新してください。\n  dojo 固有のモジュールはすべて置き換える必要があります。 - たとえば、dojo/domClass モジュールの domClass 関数を次のように使用する場合\ndomClass.contains(domNode, \u0026#34;myClassName\u0026#34;); この場合、Dojo 以外の選択肢でそれを書き直す必要があります。\ndomNode.classList.contains(\u0026#34;myClassName\u0026#34;);   Dojo はブラウザのサポートを標準化してくれますが、ネイティブの JavaScript の機能を使うことはできませんので、MDN や CanIUse などのサイトで、使用する機能のブラウザ サポートを確認する必要があります。この場合、例えば CanIUse によると、classList はすべての主要なブラウザでサポートされていると述べています。\n\r ウィジェットのライフサイクル メソッドは、同じようには動作しません。一般的に、ウィジェット起動時に発生するウィジェットのライフサイクル メソッド (constructor、postMixinProperties、buildRendering、postCreate) は、おそらく componentDidMount() 関数(またはフックを使用する場合は同等の useEffect())に移動できます。\n  今まで widget.html にあったテンプレートは、Experience Builder のカスタムウィジェット (React コンポーネント) の render() 関数で JSX に変換されるようになります。\n DOM ノードに data-dojo-attach-point で名前を付けている場合、React でそれに相当するものは Refs です。 国際化/翻訳に NLS を使用している場合、テンプレート（例：\u0026lt;div\u0026gt;${nls.label1}.\u0026lt;/div\u0026gt; では、「translations folder」パターンを使用するようになります）。    Map/Scene オブジェクトへのアクセス - this.map を使用している場合、Experience Builder では 1 つのエクスペリエンスに複数のマップまたはシーンを持つことができるようになったため、このパターンはまったく同じようには動作しません（Web AppBuilder アプリごとに 1 つのマップしか持つことができませんでした）。MapWidgetSelector と JimuMapViewComponent を参照してください。\n  カスタム設定パネル（/setting フォルダ内）がある場合、それに相当するのは Experience Builder カスタムウィジェットの src/setting 内です。設定 UI の作成に関する詳細情報\n  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/code-linting/",
	"title": "コードリンティング",
	"tags": [],
	"description": "コードリンティングについて紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Code linting\nバージョン 1.7 から、Experience Builder Developer Edition は、コードエディタがコードのフォーマットと lint (エラーチェック) に使用できる ESLint ルール (.eslintrc.js ファイル形式) を含むようになりました。\nこれらは、standard-with-typescript に基づいて、Experience Builder チームが使用しているルールです。ご自身のコードにどの ESLint ルールを使うかについては、好みがあるかもしれません。もしこれらのルールを使いたくない場合は、以下のルールを無効にする方法を参照してください。ルールを変更したい場合は、.eslintrc.js ファイルを修正することができます。\n これらの ESLint のルールでコードをチェックしたい場合は、client フォルダで、コマンドラインから、npm run lint. を実行します。また、ESLint 拡張機能をコードエディタにインストールすることもできます。 この ESLint のルールを無視したい場合は、以下のどちらかをお試しください。  コードエディタの ESLint 拡張を無効にする client/.eslintrc.js ファイルを削除する    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/override-webpack-config/",
	"title": "webpack config のオーバーライド",
	"tags": [],
	"description": "webpack config をオーバーライドする方法について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Override webpack config\nExperience Builder Developer Edition バージョン 1.9 から、カスタム ウィジェットの webpack config のオーバーライドがサポートされるようになりました。\nこれを行うには、client/webpack/widget-webpack-override.js にオーバーライド処理を配置するだけです。このファイルによってエクスポートされた関数では、デフォルトの webpack config オブジェクトが入力パラメーターとして渡され、このオブジェクトを変更して返却することができます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/copy-files-to-dist-folder/",
	"title": "dist フォルダーへのファイルのコピー",
	"tags": [],
	"description": "dist フォルダーへファイルをコピーする必要がある場合の方法について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Copy files to dist folder\nデフォルトでは、コンパイル時に src/runtime/assets フォルダーと src/setting/assets フォルダー内のすべてのファイルが dist/runtime/assets フォルダーと dist/setting/assets フォルダーのそれぞれにコピーされます。Experience Builder Developer Edition バージョン 1.13 から、カスタム ウィジェットのコンパイル時に dist フォルダーに他のファイルをコピーすることをサポートしています。これを行う理由は、ウィジェットがサード パーティのライブラリを使用しており、ライブラリから dist フォルダーにファイルをコピーする必要があるためです。\nこれを行うには、copy-files.json という名前のファイルをウィジェットのルート フォルダーに配置し、コピーする必要のあるファイルをこのフォルダーに置くだけです。以下は、copy-files.json ファイルの記述例です。\n[ { \u0026#34;from\u0026#34;: \u0026#34;node_modules/folderOrFile\u0026#34;, \u0026#34;to\u0026#34;: \u0026#34;folderOrFile\u0026#34; } ] from と to はいずれもウィジェット フォルダーからの相対パスです。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/share-code-between-widgets/",
	"title": "ウィジェット間のコードの共有",
	"tags": [],
	"description": "ウィジェット間で同じコードを共有して利用する方法を紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Share code between widgets\n1 つのビジネス ドメインに対して複数のウィジェットを開発する場合、それらの間でコードを共有したいケースがあります。このページでは、このような場合に Experience Builder がどのように役立つかを紹介します。\nExperience Builder には、ウィジェット間でコードを共有するための 2 つの方法が用意されています。\n ダイナミック ローディング：この方法は実装が簡単です。しかし、共有するコードを動的に読み込む必要があるため、よく使われる ES6 の import {} from '' は使用できません。 また、共有するコードは \u0026lsquo;chunks\u0026rsquo; フォルダーにコンパイルされますが、このフォルダーには多数のファイルが含まれているため、メンテナンスが困難になる可能性があります。 共有エントリー：この方法では、標準の ES6 の import を使用して共有コードを読み込むことができ、よりクリーンな構造を提供します。ただし、追加のセットアップ手順が必要になります。  ダイナミック ローディング この方法でウィジェット間でコードを共有する必要がある場合、ベスト プラクティスはフォルダーを作成することです。コードを共有する必要があるウィジェットをフォルダーに配置し、共有コードを格納する共通フォルターを作成します。フォルダー構造は次のようになります。\nwidgets/\ryour-folder/\rcommon/\rwidget1/\rwidget2/\rcommon フォルダーでは、export const sharedFunction = () =\u0026gt; {} のように一般的な ES6 の export を使って共有するコードをエクスポートできます。widget1 と widget2 フォルダーでは、import('../../../common/my-module').then() のようにダイナミック ローディングを使用して共有するコードを読み込めます。\nコンパイル後、共有コードは widgets/chunks フォルダーに配置されます。\n完成例については、ダイナミック ローディングを参照してください。\n共有エントリー この方法でウィジェット間でコードを共有する必要がある場合は、以下の手順を行います。\n widgets フォルダーの下に shared-code フォルダーを作成します。フォルダー名は shared-code でなければならないことに注意してください。 共有するコードを shared-code フォルダーに配置します。フォルダー内のすべての .ts および .tsx ファイルは共有エントリーとしてコンパイルされます。ベスト プラクティスのフォルダー構造は以下の通りです。  shared-code/\rentry1.ts\rentry2.tsx\rlib/\rentry1/\rmodule1.ts\rmodule2.ts\rentry2/\rmodule1.ts\rmodule2.ts\r上記のフォルダー構造では、entry1 と entry2 はコンパイル時に自動的に作成されます。\n国際化をサポートするには、shared-code フォルダー内、または各 entry フォルダー内に、例えば shared-code/translations や shared-code/lib/entry1/translations のように、translations フォルダーを作成してください。translations フォルダーの構造は、ウィジェットの translations フォルダーと同じです。\n 最後に、一般的な ES6 の import を使用して、次のように共有コードを読み込みます。  import { sampleFunction } from \u0026#39;widgets/shared-code/entry1\u0026#39; コンパイル後、共有エントリーは widgets/shared-code フォルダーに配置されます。\n完成例については、共有エントリーを参照してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/create-startup-app-wab/",
	"title": "スタートアップ ガイド",
	"tags": [],
	"description": "",
	"content": "ArcGIS Web AppBuilder とは？ ArcGIS Web AppBuilder（以下、Web AppBuilder）は、コーディング不要、インタラクティブな操作で Web アプリを作成可能なアプリケーション ビルダーです。\nWeb AppBuilder は、Web マップと呼ばれる、さまざまなデータを地図上に重ね合わせ、表示スタイルやポップアップを定義したマップをもとにアプリを作成します。\nアプリの外観を決めるテーマと、機能を提供するウィジェットを選択していくことで、独自のアプリを作成していきます。\nWeb アプリの作成   Web マップの作成\nハッカソン向け資料 - 地図にデータを可視化する を参考に、アプリで使用する Web マップを作成します。\n  Web AppBuilder の起動\n作成した Web マップを保存したら、[共有] をクリックします。[Web アプリの作成] から [Web AppBuilder] を選択、[開始] をクリックして Web AppBuilder を起動します。   テーマの選択\nアプリの外観は、テーマと呼ばれるテンプレートによって決められます。テーマには、色を設定するスタイルや、ウィジェットの配置を定義するレイアウトなどが含まれます。\n  ウィジェットの追加\nアプリの機能は、ウィジェットを選択することで追加していきます。追加したい機能を持つウィジェットを選択して、アプリ固有の設定は構成パネルで決めます。ウィジェットを組み合わせることで、さまざまな目的に適したアプリを作成することができます。   アプリの保存、起動\nアプリを作成できたら保存して起動してみましょう。   ArcGIS Web AppBuilder (Developer Edition) ポータルサイトに組み込まれた Web AppBuilder を利用してアプリを作成するほかに、開発者向けに Developer Edition が提供されています。\nDeveloper Edition は、テーマやウィジェットを開発可能で、Web AppBuilder に独自の機能を追加することができます。 Web AppBuilder が提供するテーマやウィジェットを活用したアプリを作成できるので、コストを抑えたアプリ開発を実現します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/",
	"title": "ArcGIS Developers 開発リソース集",
	"tags": [],
	"description": "",
	"content": "\r\rArcGIS Developers 開発リソース集 本サイトは、ArcGIS の API / SDK を利用して開発する方向けに、開発をよりスムーズにスタートしていただけるよう、ArcGIS Platform を利用した開発、開発環境の構築から簡単なアプリケーション作成までのガイド、開発に役立つ 技術 Tips 集を紹介しています。\nArcGIS Platform は、ロケーションサービスを提供する PaaS（Platform as a Service）です。サービスの詳細は ESRIジャパン製品ページをご覧ください。\nArcGIS Developers が提供するサービスの詳細は ESRIジャパン製品ページをご覧ください。\n目次\r  スタートアップガイド\n 開発を始める方のために必要なアカウントの作成、API キーの取得、ロケーションサービスの利用、各 API / SDK を使った開発の基本的な流れからセキュリティ、デプロイまでと ArcGIS Platform を利用した開発手順にそって学べる情報をまとめています。    もっと学ぶ\n スタートアップガイドをひととおり学び終えた方は、次のステップとして、何を見て学習すれば良いのか、より深く学べるように情報をまとめています。米国 Esri 社が無償で提供している学習素材や、ESRIジャパンのスタッフが作成したサンプル プログラム、過去に実施したセミナーやハンズオンの資料、ブログ記事など、多くの情報をまとめています。    技術 Tips 集\n 各 API / SDK を使用した開発をサポートするドキュメント（インストール ガイド、アプリケーションの配布など）や、データの可視化に関する技術 Tips をまとめています。    \r\rプライバシーポリシー  ESRIジャパン Web サイトポリシー  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]
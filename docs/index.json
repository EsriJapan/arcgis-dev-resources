[
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/python-api-concepts/",
	"title": "ArcGIS API for Python のコンセプト",
	"tags": [],
	"description": "ArcGIS API for Python のプロダクト コンセプトと動作要件について紹介します。",
	"content": "ArcGIS API for Python のコンセプト ArcGIS API for Python (以下、Python API) は、Web GIS (ArcGIS Online / ArcGIS Enterprise) を活用してマップと地理空間データを扱うための Python ベースの API です。\nPython のベスト プラクティスに基づき、標準的なイディオムやデータ構造を用いた、シンプルで使いやすい設計になっており、GIS データの可視化や解析の実行だけでなく、ユーザー、グループ、アイテムなどを管理するためのシンプルで使いやすいツールを提供します。 さらに、自身が所有しているデータだけでなく、Esri 等が提供するすぐに使えるマップやデータにアクセスすることも可能です。 また、Pandas や Jupyter Notebook といった、他の Python 向けのライブラリやツールとの連携で、より豊富な機能を活用することが可能です。\n\rArcGIS API for Python がどのようなモジュールから成り立っているのかを解説します。\r* [動作要件](#動作要件)\rOS などシステム要件と推奨する開発環境をご紹介します。\r* [ガイドページとサンプルコード](#ガイドページとサンプルコード)\r用途別に、初めの一歩として有用なサンプルをご紹介します。 --\r Python API のアーキテクチャ Python API は、Web GIS プラットフォームを使用する目的で実装されています。 Python API には、ArcGIS プラットフォーム上で利用するデータやユーザの認証情報など、各オブジェクトを管理して作業するためのモジュール、クラス、関数、およびタイプがあります。\nPython API は arcgis パッケージとして配布されています。 このパッケージの中には、最も基本になる gis モジュールを中心に、Web GIS で使用できる機能がさまざまなモジュールとして編成されています。\nPython API のモジュールを表したダイアグラム\n\rgisは最も重要なモジュールで、Web GIS への入口となり、ユーザー、グループ、およびコンテンツを管理 (作成、読み込み、更新、削除) する機能を提供します。Web GIS の管理者権限をもつユーザーは、自身の組織のメンバー、グループなどの管理にこのモジュールを使用します。\n緑色のモジュールは、さまざまな空間解析に用いる地理情報データセットにアクセスするために使用します。これらのモジュールには、特定のタイプの空間データを操作するための関数、ジオプロセシング処理、ArcGIS で使用できる様々なデータに対応したクラス、およびそれらを補助するようなヘルパー クラスなどが含まれています。\n青色のモジュールは、GIS のワークフローをサポートする追加的な機能を提供します。住所から緯度経度を特定するジオコーディング モジュール、フィーチャのジオメトリを表すモジュール、そしてサード パーティーのジオプロセシング ツールをインポートして使用するためのジオプロセシング モジュール等が含まれています。\nオレンジ色のモジュールは、GIS データの分析結果を可視化して共有することを可能にします。 widgets モジュールには、Jupyter Notebook でマップとレイヤーを可視化する機能を実装しています。 mapping モジュールには、Web マップと Web シーンに対応し、それぞれのレイヤーを操作するためのタイプと関数があり、apps モジュールは ArcGIS で構築された Web アプリケーションの作成と管理に役立ちます。\n各モジュールの詳しい内容は、米国Esri ガイドページ（英語）をご覧ください。\n 動作要件 Python API は次の環境と動作要件が必要です。\n  オペレーティング システム\n Windows (32 /64 ビット) /macOS/ Linux ※macOS/Linux は国内サポート対象外となります    Python バージョン 3.5+\n  開発環境\n Jupyter Notebook※ Jpyter Lab※ 他、Python 開発環境/テキスト エディター    ※ Jupyter Notebook および Jupyter Lab はオープンソースとして利用できる開発環境のひとつです。 Python API はこれらの開発ツールでの地図出力をサポートしてます。利用可能なブラウザは次の通りですが、詳細については Jupyter Notebook のシステム要件をご覧ください。\n Google Chrome FireFox Safari  サポートする最新の動作環境につきましては米国Esri システム要件（英語）または、動作環境もご参照ください。\n Esri サンプル ガイド ページ\n\r* [`gis`を使って、ユーザー情報やコンテンツを検索してみる](https://developers.arcgis.com/python/guide/using-the-gis/#Using-the-GIS)\r* [【開発者向け】:ノートブックをはじめる](https://developers.arcgis.com/python/sample-notebooks/your-first-notebook/)\r* [【管理者向け】:グループをバッチで作成する](https://developers.arcgis.com/python/sample-notebooks/batch-creation-of-groups/)\r* [【GISデータ解析者向け】:自然現象を解析する](https://developers.arcgis.com/python/sample-notebooks/chennai-floods-analysis/)\r* [【コンテンツ公開者向け】:シェープファイルや CSV からコンテンツを作成する](https://developers.arcgis.com/python/sample-notebooks/publishing-sd-shapefiles-and-csv/) --\r次は、Python API を利用するArcGIS API for Python のための基礎環境：conda入門についてご紹介します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/",
	"title": "ArcGIS Experience Builder (Developer Edition)",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) の開発に役立つガイド集です。",
	"content": "ArcGIS Experience Builder (Developer Edition) の開発に役立つガイド集です。\n コア コンセプト\nArcGIS Experience Builder (Developer Edition) のコア コンセプトについて紹介します。\n\r インストール ガイド\nArcGIS Experience Builder (Developer Edition) をインストールする手順を紹介します。\n\r カスタム ウィジェット開発ガイド\nカスタム ウィジェットを開発する手順を紹介します。\n\r デプロイ パターン\nArcGIS Experience Builder (Developer Edition) で作成したアプリやウィジェットのデプロイ パターンを紹介します。\n\r デプロイ\nArcGIS Experience Builder (Developer Edition) で作成したアプリケーションをダウンロードし、独自のサーバーにホストする手順を紹介します。\n\r チュートリアル\nArcGIS Experience Builder (Developer Edition) のチュートリアルでは、カスタム ウィジェットの作成方法について説明しています。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-js/",
	"title": "ArcGIS Maps SDK for JavaScript",
	"tags": [],
	"description": "ArcGIS Maps SDK for JavaScript を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。",
	"content": "マップを表示する このチュートリアルでは ArcGIS Maps SDK for JavaScript を使用して、マップとベースマップ レイヤーを表示する方法を紹介します。\nマップには、地理データのレイヤーが含まれています。マップには、ベースマップ レイヤーと、オプションで1つ以上のデータレイヤーを追加できます。マップビューを使用し、場所とズームレベルを設定することで、マップの特定の領域を表示できます。\nこのチュートリアルでは、地形ベースマップレイヤーを使用して、富士山付近を表示する地図を作成します。\n前提条件 このチュートリアルを実施するには、以下が必要です。\n API キーにアクセスするための ArcGIS 開発者アカウント。アカウントをお持ちでない場合は、サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。  ステップ 新しい Pen の作成 CodePen にアクセスして、マッピングアプリケーション用の新しい Pen を作成します。\nHTML の作成 HTML ページを定義して、Web ブラウザのウィンドウの幅と高さをフル利用してマップを作成します。\n  CodePen ＞ HTML で、HTML と CSS を追加し、viewDiv 要素を持つページを作成します。viewDiv は地図を表示する要素で、その CSS はブラウザの設定をリセットして、ブラウザの幅と高さをフルに利用できるようにしています。\nCodePenでは、\u0026lt;!DOCTYPE html\u0026gt; タグは必要ありません。他のエディタを使用している場合や、ローカルサーバでページを実行している場合は、必ずこのタグを HTML ページの先頭に追加してください。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;ArcGIS Maps SDK for JavaScript Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   API の参照   \u0026lt;head\u0026gt; タグ内に、CSS ファイルと JS ライブラリへの参照を追加します。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;ArcGIS Maps SDK for JavaScript Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;!-- CSS ファイルと JS ライブラリへの参照を追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.18/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.18/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   モジュールの追加 ArcGIS JS API には AMD モジュールが含まれています。require ステートメントで Map モジュールと MapView モジュールを参照します。\n  \u0026lt;head\u0026gt; タグ内に、\u0026lt;script\u0026gt; タグと AMD の require ステートメントを追加して、Map モジュールと MapView モジュールを読み込みます。\nJavaScript のコードを HTML パネルではなく、CodePen ＞ JS パネルに追加することもできます。その場合は、\u0026lt;script\u0026gt; タグを削除してください。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;ArcGIS Maps SDK for JavaScript Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;!-- CSS ファイルと JS ライブラリへの参照を追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.18/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.18/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;!-- モジュールの追加 --\u0026gt; \u0026lt;script\u0026gt; require([\u0026#34;esri/config\u0026#34;,\u0026#34;esri/Map\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;], function (esriConfig,Map, MapView) { }); \u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   API キーの取得 ArcGIS サービスにアクセスするには、API キーが必要です。\n developer dashboardにアクセスして、API キーを取得します。 次のステップで使用しますので、キーをコピーしてください。  マップの作成 Map を使ってベースマップレイヤーを設定し、API キーを適用します。\n  CodePen に戻ります。\n  require 文の中で、新しい Map を作成し、basemap プロパティに arcgis-topographic を設定します。ベースマップ レイヤーサービスへのアクセスを可能にするために、Map の apiKey() プロパティを設定します。\n  マップには、データ レイヤとベースマップ レイヤがあります。ベースマップ レイヤーサービスからベースマップ レイヤーにアクセスするためには、API キーが必要です。キーは、Map の作成時に前のステップから設定できます。\n  マップおよびマップ ビューが Map（2D）でどのように機能するかについては、マッピングとロケーションサービス を参照してください。\n  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;ArcGIS Maps SDK for JavaScript Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;!-- CSS ファイルと JS ライブラリへの参照を追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.18/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.18/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;!-- モジュールの追加 --\u0026gt; \u0026lt;script\u0026gt; require([\u0026#34;esri/config\u0026#34;,\u0026#34;esri/Map\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;], function (esriConfig,Map, MapView) { // API キーの追加  esriConfig.apiKey = \u0026#34;YOUR-API-KEY\u0026#34;; // マップの作成  const map = new Map({ basemap: \u0026#34;arcgis-topographic\u0026#34; // Basemap layer service  }); }); \u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   マップ ビューの作成 MapView クラスを使って、表示する地図の位置を設定します。\n  MapView を作成し、map プロパティを設定します。マップビューを中央に表示するために、center プロパティを 138.727363, 35.360626 に、zoom プロパティを 13 に設定します。マップの内容を表示するために、container のプロパティを viewDiv に設定します。\n  MapView は、地図の内容を表示します。center と zoom のプロパティは、ロード時にマップの位置と表示されるズームレベルを決定する。\n  zoom プロパティは、マップのズームレベルを設定します。値の範囲は通常 0〜20 で、0 が地表から最も遠く、20 が最も近くなります。ベースマップ レイヤーの中には、さらに 23 までのズーム・レベルをサポートするものもあります。\n  MapView は、クリックやダブルクリックなどのいくつかのタッチイベントもサポートしています。これらのイベントを利用して、マップの位置を変更したり、レイヤー内のフィーチャーを探したりすることができます。\n  Maps（2D）でのマップとマップビューの仕組みについては、マッピング API とロケーションサービス のガイドを参照してください。\n  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;ArcGIS Maps SDK for JavaScript Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;!-- CSS ファイルと JS ライブラリへの参照を追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.18/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.18/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;!-- モジュールの追加 --\u0026gt; \u0026lt;script\u0026gt; require([\u0026#34;esri/config\u0026#34;,\u0026#34;esri/Map\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;], function (esriConfig, Map, MapView) { // API キーの追加  esriConfig.apiKey = \u0026#34;YOUR-API-KEY\u0026#34;; // マップの作成  const map = new Map({ basemap: \u0026#34;arcgis-topographic\u0026#34; // Basemap layer service  }); // マップ ビューの作成  const view = new MapView({ map: map, center: [138.727363, 35.360626], // Longitude, latitude  zoom: 13, // Zoom level  container: \u0026#34;viewDiv\u0026#34; // Div element  }); }); \u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   アプリを実行する CodePen で、作成したコードを実行して地図を表示します。\nマップには、富士山を中心とした地形ベースマップレイヤーが表示されます。\nWeb マップを表示する 「Web マップの作成」のガイドで Web マップを作成している場合は、作成した Web マップも基本的に同じステップで表示できます。\n  require ステートメントにて、WebMap モジュールを追加で読み込みます。\n\u0026lt;!-- モジュールの追加 --\u0026gt; \u0026lt;script\u0026gt; require([\u0026#34;esri/config\u0026#34;,\u0026#34;esri/Map\u0026#34;, \u0026#34;esri/WebMap\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;], function (esriConfig, Map, WebMap, MapView) { // .....  }); \u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt;   Map オブジェクトを下記のように書き換えます。\n// Web マップの参照  const map = new WebMap({ portalItem: { id: \u0026#34;\u0026lt;Web マップ ID\u0026gt;\u0026#34; //id: \u0026#34;d3ffea931f4a455f9c3b6c2102e66eda\u0026#34;  } });   Web マップに置き換えた全体のコードは下記の通りです。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;ArcGIS Maps SDK for JavaScript Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;!-- CSS ファイルと JS ライブラリへの参照を追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.18/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.18/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!--追加終了 --\u0026gt; \u0026lt;!-- モジュールの追加 --\u0026gt; \u0026lt;script\u0026gt; require([\u0026#34;esri/config\u0026#34;, \u0026#34;esri/Map\u0026#34;, \u0026#34;esri/WebMap\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;], function (esriConfig, Map, WebMap, MapView) { // API キーの追加  esriConfig.apiKey = \u0026#34;YOUR-API-KEY\u0026#34;; // マップの作成  /* const map = new Map({ basemap: \u0026#34;arcgis-topographic\u0026#34; // Basemap layer service }); */ // Web マップの参照  const map = new WebMap({ portalItem: { id: \u0026#34;\u0026lt;Web マップ ID\u0026gt;\u0026#34; //id: \u0026#34;d3ffea931f4a455f9c3b6c2102e66eda\u0026#34;  } }); // マップ ビューの作成  const view = new MapView({ map: map, center: [138.727363, 35.360626], // Longitude, latitude  zoom: 13, // Zoom level  container: \u0026#34;viewDiv\u0026#34; // Div element  }); }); \u0026lt;/script\u0026gt; \u0026lt;!-- 追加終了 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;    アプリの動作が確認できたら ArcGIS の セキュリティと認証について学びましょう！\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/",
	"title": "ArcGIS Maps SDK for JavaScript",
	"tags": [],
	"description": "ArcGIS Maps SDK for JavaScript の開発に役立つガイド集です。",
	"content": "ArcGIS Maps SDK for JavaScript の開発に役立つガイド集です。\n インストールおよびセットアップ方法\nインストールおよびセットアップの方法を紹介します。\n\r インストール ガイド\nArcGIS Maps SDK for JavaScript ライブラリのインストール方法を紹介します。\n\r バージョン 4.x と 3.x の選択\n3.x と 4.x で提供されている機能の比較表です。\n\r バージョン 3.x から 4.x への移行\nバージョン 3.x の API で作成した既存のアプリケーションを 4.x に移行するために必要な情報を紹介します。\n\r ウィジェット開発\nウィジェットと呼ばれる、再利用可能な UX コンポーネント作成の基礎を紹介します。\n\r Arcade\nArcGIS プラットフォーム標準で利用できる条件式のためのスクリプト言語 Arcade について紹介します。\n\r カスタム フォント\n独自のフォントを使用する手順を紹介します。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/learn/github/",
	"title": "Esri Japan GitHub",
	"tags": [],
	"description": "Esri Japan GitHub",
	"content": "各 API や SDK のサンプルプログラムに加えて、ハンズオンや開発者セミナーで実施内容を GitHub で共有しています。\nワークショップ  workshops  過去のウェビナーやセミナー、ハンズオンで使用した資料をまとめています。    ArcGIS Maps SDK for JavaScript   maps-app-javascript\n このリポジトリでは、ArcGIS API for JavaScript にて構築された地図アプリをすぐに使用できる Maps App というアプリを提供します。 Maps App をそのまま使うことや、ArcGIS API for JavaScript を使用して拡張することができます。    arcgis-samples-4.0-js\n ArcGIS API 4.x for JavaScript のサンプル集です。Esri Community などで紹介したサンプルなどもございます。    arcgis-samples-js\n ArcGIS API for JavaScript のサンプル集です。    webmap-startup-template-js\n Web マップを使用した開発手法を伝えるためのアプリケーション テンプレートのサンプルです。    ArcGIS Maps SDKs for Native Apps   nearby-android\n このリポジトリでは、Android SDK で構築された Android デバイス用の Nearby Places というサンプル アプリを提供しています。そのまま使用したり、多少のカスタマイズで、表示する場所の種類を変更することができます。    find-route-ios\n 宮蘭航路フェリーハッカソン用に作成したオフラインで観光ルート検索を行う iOS アプリケーションです。写真から行ってみたい観光スポットを選択すると、最短時間で周れる最適ルートと移動時間を検索・表示します。検索したルートはお気に入りに登録して、後から確認することもできます。    startup-sample-dotnet\n .NET SDK をはじめて使用される方に、開発キットの基本的な使い方や主要な機能を紹介するためのサンプル アプリケーションです。    enc-viewer-dotnet\n ENC (Electronic Navigational Charts: 航海用電子海図) を表示するビューアーです。 S-57 形式の ENC のセルをサポートしています。    flightsim-game-monitor-dotnet\n Web Socket を利用した双方向通信によりマルチユーザー プレイを実現したフライト シミュレーター ゲームのスコア モニター用アプリです。 フライト シミュレーター ゲームの機体を動かしてゲームをプレイできるコントローラー用のWeb アプリと連携します。    webmap-startup-template-dotnet\n Web マップを使用した開発手法を伝えるためのサンプル アプリケーションです。    ArcPy   arcgis-samples-py\n ArcPy サイト パッケージのサンプル集です。ArcMap 用と ArcGIS Pro 用のサンプルがあります。個々のサンプル リポジトリに tbx ファイルがある場合は、ArcMap や ArcGIS Pro でジオプロセシング ツールとしてそのまま利用することが可能です。    ejpyconv-py\n EJPyConv ツールは ArcPy で書かれた ArcGIS Pro 用の複数の便利なツールが含まれている「サンプル ジオプロセシング ツールボックス」です。 ArcGIS Pro へツールボックスを追加することで、各種ジオプロセシング ツールとして利用が可能です。    arcpy-resources\n ArcGIS ユーザーのための Python/ArcPy を用いた基礎的な学習用の資料を公開しています。    gcf2018-arcpy-demo\n これは第14回 GISコミュニティフォーラムのプレフォーラム・セミナー「Python で始める自動化処理」で行ったデモのソースコードです。    gdb-archived-data-copy\n 履歴管理が有効なフィーチャクラスの過去の一時点の状態を、シェープファイルとして出力します。    gcf2015sde-demo\n これは第11回 GISコミュニティフォーラムのプレフォーラム・セミナー「Python でエンタープライズ ジオデータベースを管理しよう！」で行ったデモのソースコードです。    ArcGIS API for Python   arcgis-samples-python-api\n ArcGIS API for Python のサンプル集です。    arcgis-python-api\n Esri が提供している ArcGIS API for Python リポジトリをフォークし、Esri Community で投稿した記事と、guide 下にある一部のノートブックをローカライズしたものを置いてあります。    ArcGIS Pro SDK   arcgis-samples-pro-sdk\n ArcGIS Pro SDK for .NET のサンプル集です。    arcgis-pro-sdk\n ArcGIS Pro SDK for .NET で ArcGIS Pro を拡張します。ArcGIS Pro SDK for .NET は、アドインおよび構成の拡張性パターンに基づいています。タスク非同期プログラミング（TAP）、LINQ、WPF バインディング、MVVM などの最新の .NET 機能およびパターンを活用し、Pro の新しい API を使用して統合された 2D/3D アドインを記述します。    arcgis-pro-sdk-community-samples\n このリポジトリには、ArcGIS Pro 2.7 SDK for Microsoft .NET Framework 用の ArcGIS Pro Add-In Samples が含まれています。    arcgis-pro-sdk-tools\n ArcGIS Pro SDK を使用したツールを公開しています。ArcGIS Pro SDK の様々な API を使用しているので、開発時の参考リソースとしてもご使用ください。    ArcObjects  maps-app-gislight  Maps App GISLight10 は、ArcObjects SDK for .NETとWindows フォームを使用した、スタンドアロン アプリケーションの実装およびセットアップのサンプルを提供しています。    ArcGIS 全般  arcgis-install-batch  ダウンロード形式で提供されている製品本体（exe）を解凍し、フォルダ階層にパッチファイルを含めて再整理後、大量のPCに一括でインストールを行うためのバッチファイルのサンプル、およびインストールしたものをアンインストールを行うためのバッチファイルのサンプルです。    その他   3D-CityModel-ConversionTools-for-ArcGIS\n 「3D 都市モデルデータ変換ツール for ArcGIS」 は、PLATEAU で整備し、G 空間情報センターで公開している 3D 都市モデル（CityGML）のデータを、ArcGIS で利用可能なファイル ジオデータベース へ変換するツールです。    gsi-wmts\n 地理院地図の layers.txt に含まれるレイヤーのうち、WMTS で配信可能なレイヤーのみを取得したメタデータです。「地理院タイル目録」より情報が取得可能なレイヤーには範囲を指定するエクステント情報を付加しています。    developer-support\n ここは、Esri の開発者ライブラリを使用している GIS 開発者を共同でサポートする場所です。    i3s-spec\n この GitHub リポジトリでは、シーンレイヤーの仕様を公開しています。    arcgis-enterprise-sdk-resources\n このリポジトリでは、10.8.1 ArcGIS Enterprise SDK で構築されたサーバ オブジェクト エクステンション（SOE）およびサーバ オブジェクト インターセプター（SOI）のサンプルおよびコード スニペットを提供しています。    arcgis-saml-samples\n ArcGIS Online / ArcGIS Enterprise は、エンタープライズ ログインのアカウント構成に SAML (Security Assertion Markup Language) 2.0 をサポートしています。SAML は、認証サーバーである ID プロバイダーとサービスを提供するアプリケーションであるサービス プロバイダーとの間で認証/認可データを安全に交換するためのオープン規格です。    sdgs-sample\n Esri が提供する SDGs に関連する以下のプロジェクトを日本語にし、集約しました。    tokyochallenge\n リアルタイム列車遅延マップは第1回 東京公共交通オープンデータチャレンジ向けに開発した Web アプリです。このリポジトリでは、開発したソース コードおよび設定用の必要なデータを公開しています。    gcf2018-geoevent-twitter\n GISコミュニティフォーラム2018年 GeoEvent デモ用    gcf2018-webappbuilder-demo\n 本リポジトリでは、第14回 GISコミュニティフォーラムのプレフォーラム・セミナー「プログラミングゼロ！ ～Web GIS アプリ 3 分メイキング～ 」で紹介したアプリの作成手順を公開しています。    data-visualization-lab\n ArcGIS のオープンなプラットフォームを基盤とした様々なデータ ビジュアライゼーションとそれを支えるオープンなテクノロジーを紹介します。    resas2arcgis\n このサービスは RESAS API から取得できるデータを ArcGIS へ簡単に入力できるようにした開発したサービスです。    photospot-finder\n 室蘭市の2016年11月14日に開催された企業・団体対抗 観光ハッカソン向けに作成したアプリです。    esri-leaflet-tips\n Esri Leaflet のサンプルです。    arcgis-d3-components\n ArcGIS API for JavaScript で作成した地図との連携のための D3 コンポーネントです。    flightsim-game-controller-js\n Web Socket を利用した双方向通信によりマルチユーザー プレイを実現したフライト シミュレーター ゲームの操作アプリです。 全機の位置とスコア ランキングを管理するモニター用のネイティブ アプリと連携します。    data-visualization-js\n ArcGIS API for JavaScript を用いてデータ ビジュアライゼーションの手法とそれを実現する機能について紹介していく「JavaScript で始めるデータ ビジュアライゼーション」シリーズにおいて使用しているサンプル コード集です。    esri-react-components-js\n ArcGIS API for JavaScript の Web アプリ開発に利用可能なモジュールとして React で実装したコンポーネントを集約します。    esrijapan.github.io\n ESRIジャパンあるいは Esri が公開しているオープンソース プロジェクトのランディング ページです。    contributing\n ESRIジャパン GitHub アカウントにおけるオープンソースへの貢献について    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/calcite-design-system/get-started/",
	"title": "はじめに",
	"tags": [],
	"description": "次の手順に従って、すぐに Calcite Components を使い始めることができます。",
	"content": "出典：Calcite Design System - Get Started\nはじめに Calcite Components は、Web アプリケーションを構築するための、柔軟でフレームワークに依存しない Web コンポーネントの豊富なライブラリです。Web コンセプトのページ では、Calcite Design System の構成要素について説明しています。\n例題、プロパティ、スロット、スタイル、イベント、モードなどの API リファレンスについては、コンポーネント ドキュメントをご覧ください。以下の手順で、Calcite Components を使い始めることができます。\nまず、Calcite Components を使用するには、ArcGIS アカウントが必要です。アカウントをお持ちでない場合は、無料で作成することができます。\n作成方法は、開発者アカウントの作成をご覧ください。\n次に、CDN（Content Delivery Network）または NPM（Node Package Manager）ライブラリを使用して、Calcite Components を読み込みます。\nCDN で利用する Calcite Components を読み込むための最も一般的な方法は、ArcGIS CDN でホストされているバージョンを使用する方法です。コンポーネントは、HTML ドキュメントの先頭にある script および link タグを使用して読み込むことができます。\n\u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;https://js.arcgis.com/calcite-components/1.0.5/calcite.esm.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;https://js.arcgis.com/calcite-components/1.0.5/calcite.css\u0026#34; /\u0026gt; これらのタグを追加すると、他の HTML 要素と同様にコンポーネントを使用することができます。アプリケーションで使用されるコンポーネントのみが読み込まれます。\nNPM パッケージで利用する Calcite Components は、NPM パッケージとしても提供されています。使い始めるには、まずパッケージをインストールし、以下のステップに従います。また、様々なフレームワークやビルドツールを使用したサンプルはこちらでご覧いただけます。\nnpm install @esri/calcite-components ビルドの選択 Calcite Components が提供する2つのビルドから1つを選択します。\nカスタム要素 フロントエンド フレームワークを活用する場合は、カスタム要素 の構築を推奨します。このビルドを使用するには、Calcite Components のアセットへのパスを設定する必要があります。この後のステップで説明するローカル アセットと、CDN でホストされているアセットのどちらかを使用することができます。\nimport { setAssetPath } from \u0026#34;@esri/calcite-components/dist/components\u0026#34;; // CDN ホスティング アセット setAssetPath(\u0026#34;https://js.arcgis.com/calcite-components/1.0.5/assets\u0026#34;); // ローカル アセット // setAssetPath(PATH); // PATH はフレームワークによって異なります。 次に、カスタム要素ビルドから、使用する各コンポーネントをインポートする必要があります。これにより、ウィンドウにカスタム要素が自動的に定義されます。\nimport \u0026#34;@esri/calcite-components/dist/components/calcite-button\u0026#34;; import \u0026#34;@esri/calcite-components/dist/components/calcite-icon\u0026#34;; import \u0026#34;@esri/calcite-components/dist/components/calcite-slider\u0026#34;; ディストリビューション ディストリビューション ビルドを使用する場合、ウィンドウ上でカスタム要素を定義する必要があります。また、ローカルと CDN にホストされたアセットのどちらかを選択することができます。\nimport { defineCustomElements } from \u0026#34;@esri/calcite-components/dist/loader\u0026#34;; // CDN ホスティング アセット defineCustomElements(window, { resourcesUrl: \u0026#34;https://js.arcgis.com/calcite-components/1.0.5/assets\u0026#34; }); // ローカル アセット // defineCustomElements(window); カスタム エレメントはウィンドウ上で定義したため、個々のコンポーネントをインポートする必要はありません。\nアセットの読み込み calcite-icon や calcite-date-picker などの一部のコンポーネントは、特定のパスで利用可能なアセットに依存しています。前述の通り、NPM パッケージでは、ローカルパスまたは CDN でホストされているアセットへの URL を指定するオプションがあります。CDN でホストされたアセットを使用することで、ディスク上のビルド サイズを減らすことができます。\nローカルで使用するためには、ビルド ツールや NPM スクリプトを使用して、アセットをコピーする必要があります。ローカル アセットのディレクトリは、コピー処理を容易にするために、assets という名前にする必要があります。例えば、/public/calcite/assets は動作しますが、/public/calcite-assets は動作しません。\nCalcite Components のサンプル集では、様々な JavaScript フレームワークやビルド ツールでローカル アセットを使用することを実証しています。各例には、フレームワークやビルド ツール固有の説明を含む README があります。\ncp -r node_modules/@esri/calcite-components/dist/calcite/assets/* ./public/assets/ スタイルのインポート 最後に、カスケーディング スタイル シート（CSS）を読み込みます。これもフレームワークやビルド ツールに依存しますが、多くの場合、JavaScript で読み込むことができます。\nimport \u0026#34;@esri/calcite-components/dist/calcite/calcite.css\u0026#34;; "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/android/install-android-100.x/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Runtime SDK for Android のインストールとセットアップ手順を紹介します。",
	"content": "このインストール ガイドでは、ArcGIS Runtime SDK for Android (バージョン 100.x) のインストールとセットアップ手順を紹介します。マップを表示する方法については「アプリの作成」のチュートリアルをご覧ください。\nGradle を使用して ArcGIS Runtime アプリケーションをビルドする場合、Maven リポジトリの URL が https://esri.jfrog.io/artifactory/arcgis であることに注意して下さい。旧 URL の https://esri.bintray.com/arcgis はサポートされていません。詳細は Announcement to developers using ArcGIS Runtime SDKs for Android and Java をご参照ください。\n\rインストールとセットアップ ArcGIS Runtime for Android をインストールする前に、開発マシンがシステム要件を満たしていることを確認してください。アプリを実行するすべてのターゲット デバイスには、Android API レベルの最小バージョンが必要です。詳細については、システム要件を参照してください。\nGradle を使用してインストールすることをお勧めします。これにより、Esri の Maven リポジトリから必要な依存関係と SDK バイナリがインストールされます。Gradle を利用できない場合は、代わりに SDK をダウンロードしてから、AAR ライブラリと依存関係アーティファクトを含めることでプロジェクトに依存関係を手動で追加できます。\n注：制限された開発環境で作業していて、ユーザーディレクトリにファイルを書き込むためのオンラインアクセスまたは権限がない場合は、ダウンロードオプションを選択してください。\n Gradle で API を取得する API を手動で取得する  Gradle で API を取得する 既存の Android Studio プロジェクトか新しいプロジェクトを作成して、次のセットアップ手順を実行します。\n  settings.gradle ファイルの repositories ブロック内で、Esri の Maven リポジトリ URL を追加します。Esri のリポジトリはオープンソースではないため、google() や mavenCentral() からは使用できないため、この URL を指定する必要があります。\ndependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { google() mavenCentral() // Esri の Maven リポジトリを追加します \tmaven { url \u0026#39;https://esri.jfrog.io/artifactory/arcgis\u0026#39; \t} } }   module レベルの build.gradle ファイルの dependencies ブロック内で、ArcGIS Runtime SDK for Android の依存関係をアプリに追加します。\n注：この依存関係を、ArcGIS Runtime SDK for Android を使用する各モジュールに追加する必要があります。\ndependencies { implementation \u0026#39;com.esri.arcgisruntime:arcgis-android:100.15.1\u0026#39; ... } `\n  module レベルの build.gradle ファイルの android ブロック内で、Java 8 の言語機能との互換性を設定するために、以下のディレクティブがあることを確認してください。\nandroid { . . . compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } . . . } `\n  module レベルの build.gradle ファイルの android ブロック内に、ビュー バインディングを有効にするブロックがあることを確認します。ビュー バインディングの詳細については、ビュー バインディング を参照してください。\nandroid { . . . buildFeatures { viewBinding true } }   module レベルの build.gradle ファイルの android ブロック内に、META-INFDEPENDENCIES ファイルの複製を除外する packagingOptions ブロックを追加します。この設定により、META-INF ディレクトリにある同じファイルを出力に複数回含めようとした場合に発生するコンパイラー エラーを防ぐことができます。パッケージング オプションの詳細については、PackagingOptions を参照してください。\nandroid { . . . packagingOptions { exclude \u0026#39;META-INF/DEPENDENCIES\u0026#39; } }   API を手動で取得する パブリック Gradle リポジトリを利用できない場合は、代わりに SDK をダウンロードし、ローカル AAR とすべての依存関係アーティファクトを含めることで、依存関係をプロジェクトに手動で追加できます。\n  ArcGIS Developers にサインインします。\nサインインには ArcGIS 開発者アカウントが必要です。アカウントをお持ちでない場合は、サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。\n  ダッシュボード上で、Download をクリックし、最新バージョンの ArcGIS Runtime SDK for Android を選択します。\n  ダウンロードしたファイルを開発マシン上に解凍します。\n  依存関係を ArcGIS Runtime SDK for Android に手動で追加するか、ダウンロードに含まれる他のリソースを使用します。libs フォルダにある Android ライブラリ モジュール（.aar）には、API の jar ライブラリ arcgis-android-api とそのサードパーティの依存関係およびコア ネイティブ ライブラリが含まれています。\nArcGIS Android API がローカルの Maven リポジトリで動作するように設定する 以下のセットアップ手順では、インターネットから切り離された開発環境で作業していることを想定しています。たとえば、インターネット上でホストされている Maven リポジトリへのアクセスを許可しないファイアウォールの内側などです。インターネット アクセスを使用して開発している場合は、代わりに Gradle で API を取得する の手順に従ってください。以下の手順は、ローカルマシン上の Maven リポジトリでのセットアップを説明していますが、ネットワーク上に Maven サーバーをセットアップしている場合も同様に適用できます。\nSDK およびその依存関係をコンピュータにデプロイする   arcgis-runtime-sdk-android-100.15.1.zip ファイルをダウンロードします。\n  アーカイブの内容をディスク上の任意の場所に解凍します。\n  解凍した場所から、libs/aar ディレクトリの内容をディスク上の以下の場所にコピーします。（ローカル Maven リポジトリは、ユーザー ディレクトリの .m2repository をルートとするディレクトリ ツリーであることに注意してください）。\nmac: /Users/[user-name]/.m2/repository/com/esri/arcgisruntime/arcgis-android/100.15.1/\nWindows: %USERPROFILE%\\.m2\\repository\\com\\esri\\arcgisruntime\\arcgis-android\\100.15.1\\\n  ディレクトリのパスは以下のようになっているはずです。\nmac (2 ファイル):\n/Users/[user-name]/.m2/repository/com/esri/arcgisruntime/arcgis-android/100.15.1/arcgis-android-100.15.1.aar\n/Users/[user-name]/.m2/repository/com/esri/arcgisruntime/arcgis-android/100.15.1/arcgis-android-100.15.1.pom\nWindows (2 ファイル):\n%USERPROFILE%\\.m2\\repository\\com\\esri\\arcgisruntime\\arcgis-android\\100.15.1\\arcgis-android-100.15.1.aar\n%USERPROFILE%\\.m2\\repository\\com\\esri\\arcgisruntime\\arcgis-android\\100.15.1\\arcgis-android-100.15.1.pom\n  これらの依存関係のリストと、それらをダウンロードできる URL は以下のとおりです。作業環境のセキュリティ対策と互換性のある方法でこれらを取得する必要があります。\n gson 2.9.0: https://search.maven.org/artifact/com.google.code.gson/gson/2.9.0/jar androidx.browser 1.4.0: https://maven.google.com/web/index.html?q=browser#androidx.browser:browser:1.4.0 androidx.localbroadcastmanager 1.1.0: https://maven.google.com/web/index.html?q=localbroadcastmanager#androidx.localbroadcastmanager:localbroadcastmanager:1.1.0 httpcore5 5.0.4: https://search.maven.org/artifact/org.apache.httpcomponents.core5/httpcore5/5.0.4/jar httpcore5-h2 5.0.4: https://search.maven.org/artifact/org.apache.httpcomponents.core5/httpcore5-h2/5.0.4/jar slf4j-api 1.7.32: https://search.maven.org/artifact/org.slf4j/slf4j-api/1.7.32/jar commons-codec 1.15: https://search.maven.org/artifact/commons-codec/commons-codec/1.15/jar conscrypt-openjdk-uber 2.2.1 https://search.maven.org/artifact/org.conscrypt/conscrypt-openjdk-uber/2.2.1/jar spymemcached 2.12.3 https://search.maven.org/artifact/net.spy/spymemcached/2.12.3/jar ehcache-api 3.4.0 https://search.maven.org/artifact/org.ehcache.modules/ehcache-api/3.4.0/jar    前の手順でダウンロードした依存関係をデプロイします。Maven を使用して、ローカルの Maven リポジトリに依存関係をインストールします。\n  mvn maven ツールをインストールします。\nmac:\nbrew install mvn\nWindows:\nhttps://maven.apache.org/guides/getting-started/windows-prerequisites.html を参照してください。\n  androidx の依存関係（browser と localbroadcastmanager）については、下記を実行してください。\nmvn install:install-file -Dfile=\u0026lt;aar ファイルのパス\u0026gt; -DgroupId=\u0026lt;グループ ID\u0026gt; -DartifactId=\u0026lt;アーティファクト ID\u0026gt; -Dversion=\u0026lt;バージョン\u0026gt; -Dpackaging=aar -DgeneratePom=true\n  他のすべての依存関係については、下記を実行してください。\nmvn install:install-file -Dfile=\u0026lt;jar ファイルのパス\u0026gt; -DgroupId=\u0026lt;グループ ID\u0026gt; -DartifactId=\u0026lt;アーティファクト ID\u0026gt; -Dversion=\u0026lt;バージョン\u0026gt; -Dpackaging=jar -DgeneratePom=true\n    ローカルの Maven リポジトリを設定する必要があります。次のセクションで、ローカルの Maven リポジトリを使用するようにビルド ファイルを変更します。\n  Gradle のビルド設定とスクリプトの編集   プロジェクトの gradle.settings ファイルを編集して、ローカルの Maven リポジトリを参照する必要があります。これを行うには、次のように mavenLocal() を追加します。\ndependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { google() mavenCentral() mavenLocal() } } `\n  module レベルの build.gradle ファイルに以下の依存関係を追加します。\ndependencies { ... implementation \u0026#39;com.esri.arcgisruntime:arcgis-android:100.15.1\u0026#39; implementation \u0026#39;com.google.code.gson:gson:2.9.0\u0026#39; implementation \u0026#39;androidx.browser:browser:1.4.0\u0026#39; implementation \u0026#39;androidx.localbroadcastmanager:localbroadcastmanager:1.1.0\u0026#39; implementation \u0026#39;org.apache.httpcomponents.core5:httpcore5:5.0.4\u0026#39; implementation \u0026#39;org.apache.httpcomponents.core5:httpcore5-h2:5.0.4\u0026#39; implementation \u0026#39;org.slf4j:slf4j-api:1.7.32\u0026#39; implementation \u0026#39;commons-codec:commons-codec:1.15\u0026#39; implementation \u0026#39;org.conscrypt:conscrypt-openjdk-uber:2.2.1\u0026#39; implementation \u0026#39;net.spy:spymemcached:2.12.3\u0026#39; implementation \u0026#39;org.ehcache.modules:ehcache-api:3.4.0\u0026#39; } `\n  module レベルの build.gradle ファイルの android ブロック内に、Java 8 言語機能との互換性を設定する次のディレクティブがあることを確認します。\ncompileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } `\n  module レベルの build.gradle ファイルの android ブロック内に、ビュー バインディングを有効にするブロックがあることをを確認します。ビュー バインディングの詳細については、ビュー バインディング を参照してください。\nandroid { . . . buildFeatures { viewBinding true } }   module レベルの build.gradle ファイルの android ブロック内に、META-INFDEPENDENCIES ファイルの複製を除外する packagingOptions ブロックを追加します。この設定により、META-INF ディレクトリにある同じファイルを出力に複数回含めようとした場合に発生するコンパイラー エラーを防ぐことができます。パッケージング オプションの詳細については、PackagingOptions を参照してください。\nandroid { . . . packagingOptions { exclude \u0026#39;META-INF/DEPENDENCIES\u0026#39; } }   必要な権限と機能 Android は、権限が分離されたオペレーティング システムです。アプリで使用する ArcGIS の機能によっては、マニフェストに権限を追加する必要がある場合があります。アプリに含まれていない機能の権限を含めないようにしてください。\nアプリが Android API バージョン 22 以前で実行されている場合、インストール時にすべての権限が要求されます（許可または拒否）。アプリが Android API バージョン 23 以降で実行されている場合、アクセス許可が要求され、インストール時に自動的に付与されます。ただし、潜在的に危険な権限は実行時にリクエストする必要があり、そのためにはアプリにコードを追加する必要があります。まだ許可されていない場合は、Android フレームワークまたは Android サポート ライブラリが、権限を確認して要求するために使用されます。詳細については、アプリの権限を宣言するとアプリの権限をリクエストするをご覧ください。\nアクセス許可が必要な ArcGIS Runtime SDK for Android の機能：\n インターネットへのアクセス（ほとんどのアプリはこれを必要とします）：Android API 23 以降の標準の権限 デバイスの GPS にアクセスするには、FINE_LOCATION の権限が必要です：Android API 23 以降での危険な権限  次のコード例（AndroidManifest.xml ファイルの場合）には、これらの権限が含まれています。\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_COARSE_LOCATION\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_FINE_LOCATION\u0026#34; /\u0026gt; Android のストレージと権限 Android API Level 30 では、すべてのアプリは Android デバイスのファイルシステムにアクセスするためにスコープ付きストレージを使用します。スコープ付きストレージを使用すると、アプリは (1)自身のファイル、および (2)メディア ストア内の共有ファイルにアクセスすることができます。下記のパーミッションの宣言は、サポートされていません。\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.WRITE_EXTERNAL_STORAGE\u0026#34; /\u0026gt; Android のストレージは、API レベル 29 以降、劇的に変化しています。Android のストレージとパーミッションの詳細については、次のリンクを参照してください。\n データ ストレージとファイル ストレージの概要 Android ストレージのユースケースとおすすめの方法 共有ストレージからメディア ファイルにアクセスする ストレージ デバイスのすべてのファイルを管理する  OpenGL ES バージョンの宣言 Android マニフェストに uses-feature 要素を追加すると、Play ストアでアプリを正しいタイプのデバイスで利用できるようになります。\nMapView（2D）を使用するアプリには、最小でも OpenGL ES 2.x が必要です。\n\u0026lt;uses-feature android:glEsVersion=\u0026#34;0x00020000\u0026#34; android:required=\u0026#34;true\u0026#34; /\u0026gt; SceneView（3D）を使用するアプリには、OpenGL ES 3.x が必要です。\n\u0026lt;uses-feature android:glEsVersion=\u0026#34;0x00030000\u0026#34; android:required=\u0026#34;true\u0026#34; /\u0026gt; androidx の依存関係 DefaultAuthenticationChallengeHandler は、OAuth 認証の認証情報の入力をユーザーに求めるために、デフォルトで Chrome カスタムタブ を使用するようになりました。これにより、外部ブラウザ ウィンドウで資格情報の入力を求めるよりも優れたユーザーエクスペリエンスが提供されます。Chrome カスタムタブのサポートにより、androidx.browser:browser の新しい推移的依存関係が導入されました。 この依存関係は、gradle ビルドスクリプトから arcgis-android ライブラリを参照すると自動的に構成されます。API を手動でダウンロードする場合は、androidx の依存関係をサポートするように自分でプロジェクトを構成する必要があります。\nプロジェクトが Google でサポートされていない Android サポート ライブラリに依存している場合は、androidx ライブラリでコンパイルまたはランタイムの問題が発生するため、プロジェクトを androidx に移行する必要があります。\n追加のダウンロード サンプル コード ArcGIS Runtime アプリで実行できる、機能についてはサンプル コードを参照してください。\nサンプル ビューアー アプリは、Google Play か、ArcGIS Online（.apk ファイル） からも入手できます。\nArcGIS Runtime SDK for Android Toolkit ArcGIS Runtime SDK for Android Toolkit には、アプリの開発を簡略化するためのコントロールやユーティリティが含まれています。例えば、以下のようなものがあります。\n ArcGISArView: SceneView を ARCore と統合し、拡張現実（AR）を実現します。 ブックマーク: ウェブ マップに保存されているブックマークを表示します。 コンパス: 北を指すコンパスのアイコンを表示して、マップやシーンの現在の向きを示します。 スケールバー: 地図上での正確な直線計測の表現を表示します。  スタンドアロンの開発者向けドキュメント ダウンロード ページ から、開発者向けドキュメント（任意の ArcGIS Runtime SDK 用）をアーカイブとしてダウンロードできます。アーカイブには、ローカル Web サーバからドキュメントを提供する手順が含まれているため、インターネットに接続しなくてもドキュメントにアクセスできます。スタンドアロン ドキュメントには、開発者ガイド、API リファレンス、チュートリアル、およびサンプル ドキュメントが含まれています。このドキュメントは、ローカルのスタンドアロン コンピューターまたは内部ネットワーク上で実行するように設計されており、パブリックなインターネット上では実行できません。\nローカルでドキュメントを公開する方法：\n 使用する ArcGIS Runtime SDK のドキュメントをダウンロードします。ダウンロードしたファイルは、.zip アーカイブ形式になっています。 アーカイブをローカル フォルダに解凍します。解凍されたアーカイブには、public と install という 2 つのサブフォルダがあります。 install フォルダ内の README.md ファイルを開き、選択した Web サーバーの指示に従います。  注：ライブ ドキュメント サイトはリリース時及びリリースの間に定期的に更新されますが、スタンドアロン ドキュメントは静的で、最初のリリース後は更新されません。\n追加のデータ グリッド ベースの地理座標変換を使用している場合は、ダウンロード ページからサポートする Projection Engine ファイルをダウンロードしてください。\n航海用電子海図 (ENC) を使用する場合は、ダウンロード ページから hydrography directory をダウンロードします。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/dotnet/install-dotnet-200.x/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for .NET のインストールとセットアップ手順を紹介します。",
	"content": "このインストール ガイドでは、ArcGIS Maps SDK for .NET のインストールとセットアップ手順を紹介します。\n  ArcGIS Developers のダッシュボードから各インストーラーやデータをダウンロードするには、ArcGIS 開発者アカウントでログインする必要があります。アカウントをお持ちでない場合は、サインアップ (無料) してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。\n  ArcGIS Maps SDK for .NET がサポートする最新の動作環境については system requirements をご覧ください。\n  マップを表示する方法については「アプリの作成」チュートリアルをご覧ください。\n  インストールとセットアップ ArcGIS Maps の機能を .NET アプリケーションに組み込むには、1 つ以上の ArcGIS Maps SDK for .NET NuGet パッケージ への参照を Visual Studio プロジェクト内に追加します。ArcGIS Maps SDK for .NET がサポートするアプリケーション プラットフォームおよび UI フレームワークのそれぞれに対応するプロジェクト テンプレート セットは、Visual Studio 拡張機能 として提供されています。\nオンライン ソースの ArcGIS Runtime NuGet パッケージを参照する方法 ArcGIS Maps SDK for .NET NuGet パッケージは、NuGet.org でホストされています。NuGet を使用して Visual Studio でパッケージを使用するには、Microsoft のドキュメントにある Visual Studio にパッケージをインストールして使用する (Windows) または Visual Studio にパッケージをインストールして使用する (Mac) を参照してください。\n  Visual Studio で NuGet パッケージ マネージャーを開きます (例えば、[プロジェクト] メニュー \u0026gt; [NuGet パッケージの管理])。\n  [NuGet パッケージ マネージャー] ウィンドウで、[パッケージ ソース] に「nuget.org」が選択されていることを確認します。\n  [参照] タブを選択して、[検索] テキスト ボックスに「Esri」と入力します。ArcGIS Maps SDK for .NET でサポートされているフレームワークに一致するものがいくつか表示されます。\n  インストールする NuGet パッケージを選択し、[インストール] ボタンをクリックします。NuGet パッケージ マネージャの詳細については、Microsoft ドキュメントの NuGet パッケージ マネージャーを使用して Visual Studio にパッケージをインストールして管理する を参照してください。\n  [変更のプレビュー] ダイアログで内容を確認し、「OK」を選択してインストールを進めてください。\n  インストールが完了すると、NuGet パッケージ マネージャーの [インストール済み] タブに追加したパッケージが表示され、ArcGIS Maps SDK for .NET を使用して開発できるようになります。\n  Toolkit ArcGIS Maps SDK for .NET Toolkit は、ArcGIS Maps SDK for .NET 開発チームによって管理されているオープンソース プロジェクトで、アプリ開発を簡素化するためのコントロールとユーティリティが含まれています。ツールキットは NuGet パッケージとしてプロジェクトに含めるか、GitHub リポジトリ からソース コードをダウンロードしてローカルでビルドできます。\nVisual Studio プロジェクト テンプレート 拡張機能イのンストール（オプション） Visual Studio（Windows）用の ArcGIS Maps SDK for .NET プロジェクト テンプレート 拡張機能は、Android、iOS、および Windows 用のアプリケーション プロジェクト テンプレートを提供します。プロジェクト テンプレートは、各プラットフォームに適した NuGet パッケージを参照し、Model-View-ViewModel（MVVM）デザイン パターンを使用します。拡張機能の使用方法の詳細については、Microsoft のドキュメントの Visual Studio の機能拡張を管理する のトピックを参照してください。\n注: .NET Framework プロジェクト テンプレートなど、すぐに使用できる Visual Studio テンプレートの一部は PackageReference をサポートしていますが、現在、プロジェクトによって参照されるパッケージのリストを維持するために packages.config が既定になっています packages.config このような状況を軽減するには、Microsoft の推奨に従って、packages.config から PackageReference に移行 することを検討してください。\n  Visual Studio で、[拡張機能] メニュー \u0026gt; [拡張機能の管理] を選択して、[拡張機能の管理] ダイアログを表示します。\n  [検索] テキスト ボックスに、「ArcGIS」と入力します。\n  「ArcGIS Maps SDK for .NET Project Templates」拡張機能を選択し、[ダウンロード] を選択します。すぐにダウンロードされ、再起動時に拡張機能がインストールされることを示すメッセージが表示されます。\n  [拡張機能の管理] ダイアログを閉じます。\n  Visual Studio を閉じ、拡張機能をインストールします。\n  Visual Studio を閉じた時に表示される [VSIX インストーラー] ダイアログで [変更] をクリックします。\n  インストールが完了したら、インストーラー ダイアログで [閉じる] をクリックします。\n  次回、Visual Studio で [新しいプロジェクトの作成] を選択すると、使用可能なすべてのプラットフォームの ArcGIS のプロジェクト テンプレートが表示されます。\n  注: ArcGIS Maps SDK App, Packaged (WinUI 3 in Desktop) テンプレートでは、Single-project MSIX Packaging Tools for VS 2022 もインストールされている必要があります。\n追加のダウンロード サンプルコード、データ、コンポーネント の追加のリソースを利用できます。また、ガイドを ダウンロード して、オフラインで利用することも可能です。\nサンプル コード アプリケーションに追加できるさまざまな ArcGIS Maps の強力な機能を説明するサンプル コードを入手できます。サンプルを検索し、サンプル ドキュメント で関連するコードを参照するか、サンプル リポジトリ からソース コードをダウンロードして、サンプルをローカルに構築および実行できます。\nコンパイル済みのサンプル ビューアー アプリ (WPF 版) は、Microsoft ストア から入手できます。 アプリを実行する前に、システム要件を参照して、正常に実行できることを確認してください。\nArcGIS Runtime Local Server ArcGIS Runtime Local Server SDK では、オフラインでジオプロセシング タスクを実行して、アプリケーションで高度な空間解析とデータ操作を行うことができます。これらのタスクは、ArcGIS Enterprise で実行されるジオプロセシング タスクと同じように動作します。 アプリケーションでオフラインでジオプロセシング タスクを実行する場合は、Local Server のトピックの手順に従って Local Server をインストールします。\n追加のデータ Projection Engine データ 測地系変換は、ある空間基準から別の空間基準へジオメトリを投影する際に、2つの空間基準の基礎となる測地系に違いがある場合に使用されます。測地系変換は、数学的に定義する（方程式ベースの変換）ことも、外部のサポート ファイルに依存する（グリッド ベースの変換）ことも可能です。アプリでグリッドベースの変換を使用する場合、Projection Engine ファイルが存在する必要があります。API は、必要なファイルがローカルのファイルシステムで利用可能かどうかを検出することができます。Projection Engine ファイルが無い状態で変換をしようとすると、エラーが発生します。API は、必要なファイルがローカル ファイル システムで利用可能かどうかを検出できます。\nグリッド ベースの変換を使用している場合は、ダウンロード ページからサポートする Projection Engine ファイルをダウンロードしてください。座標系、投影法、測地系変換の操作の詳細については、Spatial references のトピックを参照してください。\nElectronic Navigational Charts (ENC) 航海用電子海図（ENC）は、水路や海上の情報を可視化し、分析するためのジオリファレンスされたベクター データセットです。SDK は、国際水路機関（IHO）の S-57 規格 に準拠した ENC をサポートしています。\n航海用電子海図 (ENC) を使用する場合は、Esri.ArcGISRuntime.Hydrography NuGet パッケージをアプリに追加するか、ダウンロード ページから hydrography データをダウンロードします。ENC データの操作の詳細については、Display electronic navigational charts のトピックを参照してください。\nArcGIS Maps SDK for .NET を使用したオフライン環境での開発 NuGet パッケージとプロジェクト テンプレート オンライン アクセスが制限された環境でアプリを開発している場合は、ローカルの NuGet パッケージ フィードから ArcGIS Maps SDK for .NET を参照することができます。 NuGet.org で公開されている NuGet パッケージのサブセットを含む、追加の Visual Studio (Windows) 拡張機能を利用できます。 この拡張機能をインストールすると、ユーザー プロファイルの %localappdata%\\Esri\\NuGet の下にローカル NuGet パッケージ ソースが構成されます。 詳細については、Microsoft のドキュメントの ローカル NuGet パッケージ フィード を参照してください。\nVisual Studio 拡張機能をダウンロードしてインストールする プロジェクト テンプレート 拡張機能（ArcGIS_Maps_SDK_DotNet_Templates_200_0_0.vsix）と NuGet パッケージ 拡張機能（ArcGIS_Maps_SDK_DotNet_200_0_0.vsix）の両方を、ArcGIS Developers ダッシュボード からダウンロードできます。\n  開発マシンからアクセスできる場所にファイルを保存します。\n  ダウンロードした Visual Studio 拡張機能をインストールするには、.vsix ファイルをダブルクリックします (またはファイルを選択して Enter キーを押します)。\n  複数のバージョンの Visual Studio がインストールされている場合、VSIX インストーラー ダイアログには、拡張機能をインストールするために使用できる Visual Studio 製品 (Visual Studio Enterprise 2022 など) のリストが表示されます。 ターゲットの Visual Studio インスタンスを選択し、ライセンス条項を確認して [インストール] を選択します。\n  インストールが完了すると、選択した製品の確認が表示されます。 [閉じる] を選択して、インストールを終了します。 インストールしたら、Visual Studio の [拡張機能の管理] ダイアログを使用して、拡張機能を有効化、無効化、またはアンインストールします。 詳細については、Microsoft ドキュメントのトピック [拡張機能の管理] ダイアログ ボックスを使用しないインストール を参照してください。\n  ローカルの Esri パッケージ ソースから NuGet パッケージをインストールする   Visual Studio ソリューション エクスプローラー ウィンドウで、[プロジェクト] を右クリックし、[NuGet パッケージの管理] を選択します。\n  [参照] タブを選択し、パッケージ ソースとして Esri を選択します。\n  ArcGIS Maps SDK for .NET でサポートされているさまざまなフレームワーク用の NuGet パッケージがいくつか表示されます。\n  インストールする NuGet パッケージを選択し、[インストール] ボタンをクリックします。 NuGet パッケージ マネージャーの詳細については、Microsoft ドキュメントの NuGet パッケージ マネージャーを使用して Visual Studio にパッケージをインストールして管理する を参照してください。\n  [変更のプレビュー] ダイアログの内容を確認し、[OK] を選択してインストールを続行します。\n  インストールが完了すると、追加されたパッケージが NuGet パッケージ マネージャーの [インストール済み] タブに表示され、ArcGIS Maps SDK for .NET を使用して開発できるようになります。\n  スタンドアロンの開発者向けドキュメント ダウンロード ページ から、開発者向けドキュメントをアーカイブとしてダウンロードできます。アーカイブには、ローカル Web サーバからドキュメントを提供する手順が含まれているため、インターネットに接続しなくてもドキュメントにアクセスできます。スタンドアロン ドキュメントには、開発者ガイド、API リファレンス、チュートリアル、およびサンプル ドキュメントが含まれています。このドキュメントは、パブリックなインターネット上ではなく、ローカルのスタンドアロン コンピューターまたは内部ネットワーク上で実行するように設計されています。\nローカルでドキュメントを公開する方法：\n 使用する ArcGIS Runtime SDK のドキュメントをダウンロードします。ダウンロードしたファイルは、.zip アーカイブ形式になっています。 アーカイブをローカル フォルダに解凍します。解凍されたアーカイブには、public と install という 2 つのサブフォルダがあります。 install フォルダ内の README.md ファイルを開き、選択した Web サーバーの指示に従います。  注：ライブ ドキュメント サイトはリリース時及びリリースの間に定期的に更新されますが、スタンドアロン ドキュメントは静的で、最初のリリース後は更新されません。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/ios/install-ios-100.x/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Runtime SDK for iOS のインストールとセットアップ手順を紹介します。",
	"content": "このインストール ガイドでは、ArcGIS Runtime SDK for iOS (バージョン 100.x) のインストールとセットアップ手順を紹介します。インストールを進める前に、ご使用のマシン（macOS）に Xcode をインストールしてください。\nArcGIS Runtime SDK for iOS がサポートする最新の動作環境につきましては動作環境をご覧ください。\nマップを表示する方法については「アプリの作成」のチュートリアルをご覧ください。\nインストールとセットアップ Xcode プロジェクトに API をインストールして使用するには、いくつかの方法があります。Swift Package Manager か CocoaPods を使用するか、手動でダウンロードしてインストールできます。\n Swift Package Manager を使用する CocoaPods を使用する 手動でダウンロードする  Swift Package Manager を使用する Swift Package Manager を使用して Xcode プロジェクトに簡単に統合できます。\n  Xcode プロジェクトを開きます。メニューバーで、[File] \u0026gt; [Add Package\u0026hellip;] を選択します。\n  パッケージ リポジトリの URL として https://github.com/esri/arcgis-runtime-ios を入力します。\n  オプションとして、正確なバージョンまたは使用するバージョンの範囲を指定したい場合は、Dependency Rule オプションを選択します。\n  [Add Package] をクリックします。\n  ArcGIS の API を使用するには、次のインポートステートメントを任意の Swift コード（.swift）ファイルに追加します。\nimport ArcGIS CocoaPods を使用する 公開済みの CocoaPod を利用できます。CocoaPods を初めて使用する場合は、CocoaPods の使用方法を確認してから、次の手順に従って iOS プロジェクト内でこの Pod を使用してください。\n  プロジェクトの Podfile に下記を追加します。\npod \u0026#39;ArcGIS-Runtime-SDK-iOS\u0026#39;   オプションとして、正確なバージョンまたは使用するバージョンの範囲を指定することができます。pod syntax を参照してください。\n  ターミナル アプリケーションを使用して、Podfile 上で pod install コマンドを実行します。これにより、ArcGIS フレームワークがマシンにダウンロードされ、プロジェクトの Pod ディレクトリ内に配置されます。また、ArcGIS フレームワークを正しく参照するために、プロジェクトのビルド設定に必要な変更が加えられて、新しい Xcode ワークスペース（.xcworkspace ファイル）を作成されます。\n  ArcGIS の API を使用するには、新しく作成した Xcode ワークスペースを開き、次のインポートステートメントを任意の Swift コード（.swift）ファイルに追加します。\nimport ArcGIS 手動でダウンロードする 手動ダウンロードは、すべての iOS プロジェクト用に一度だけ API をインストールします。\n  SDK パッケージ インストーラーをダウンロードします。\nダウンロードには ArcGIS 開発者アカウントが必要です。アカウントをお持ちでない場合は、サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。\n  ${HOME}/Library フォルダへの書き込み権限があることを確認してください。\n  マシンに以前のバージョンの ArcGIS Runtime SK for iOS がインストールされている場合は、それをアンインストールします。アンインストールしないと、以前のインストールが上書きされます。アンインストールするには、ターミナル アプリケーションで ${HOME}/Library/Application Support/AGSiOSRuntimeSDK/uninstallAGSiOSSDK スクリプトを実行します。\n  SDK をダウンロードしたら、ダウンロードした .pkg ファイルをダブルクリックします。インストール ウィザードの指示に従って、インストール手順を完了します。\n  プロジェクトを構成するための追加の手順を実施します。\n  デフォルトでは、SDK は ${HOME}/Library/SDKs/ArcGIS にインストールされます。このフォルダーには、Frameworks、Legal、Samples のサブフォルダーが含まれています。\n  Samples フォルダーに移動し、Objective-C または Swift サンプルのいずれかを実行して、すべてがマシンに正しくインストールされていることを確認できます。\n注：${HOME}/Library フォルダは、デフォルトでは非表示になっています。ターミナル アプリケーションで chflags nohidden ~/Library/ コマンドを実行することで表示できます。\nインストールエラーが発生した場合は、/var/log/install.log の install.log ファイルで詳細を確認してください。失敗の一般的な理由は、ダウンロード中にインストール パッケージが破損することです。パッケージをもう一度ダウンロードしてみてください。まれに、インストーラーがインストール中にユーザー名/パスワードを要求する場合があります。これが発生すると、インストーラーは正常に終了しますが、SDK はホームディレクトリではなくルートディレクトリにインストールされます。この問題を解決するには、SDKs フォルダをルート /Library ディレクトリからユーザープロファイルの $HOME/Library ディレクトリに手動でコピーします。\nプロジェクトを構成する この手順は、SDK を手動でインストールした場合のみ必要です。Swift Package Manager または CocoaPods を使用してインストールしている場合は、この手順は不要です。 SDK を手動でインストールした後に、API を使用するために各 Xcode プロジェクトを構成します。\nプロジェクトに ArcGIS フレームワークを追加する   Xcode プロジェクトを開くか、新しいプロジェクトを作成します。\n  左側の Navigator ペインでプロジェクト名を選択して、[TARGETS (プロジェクト名)] \u0026gt; [General] タブを選択します。\n  [Frameworks, Libraries, and Embedded Content] セクションに $(HOME)/Library/SDKs/ArcGIS/Frameworks ディレクトリにある ArcGIS.xcframework と Runtimecore.xcframework ファイルをドラッグアンドドロップします。\n  注：${HOME}/Library フォルダは、デフォルトでは非表示になっています。ターミナル アプリケーションで chflags nohidden ~/Library/ コマンドを実行して表示するか、Finder メニューの [移動] \u0026gt; [フォルダへ移動] を使用して移動することもできます。\n以上でプロジェクトの構成は完了です。ArcGIS の API を使用するには、次のインポートステートメントを任意の Swift コード（.swift）ファイルに追加します。\nimport ArcGIS 追加のダウンロード サンプル コード ArcGIS Runtime アプリで実行できる、機能についてはサンプル コードを参照してください。\nサンプル ビューアー アプリは、App Store からも入手できます。\nArcGIS Runtime SDK for iOS Toolkit ArcGIS Runtime SDK for iOS Toolkit は ArcGIS Runtime SDK for iOS 開発チームによって管理されているオープンソース プロジェクトで、アプリ開発を簡素化するためのコントロールとユーティリティが含まれています。これらのコンポーネントの動作を確認するには、サンプルやドキュメントを参照してください。\nスタンドアロンの開発者向けドキュメント ダウンロード ページ から、開発者向けドキュメント（任意の ArcGIS Runtime SDK 用）をアーカイブとしてダウンロードできます。アーカイブには、ローカル Web サーバからドキュメントを提供する手順が含まれているため、インターネットに接続しなくてもドキュメントにアクセスできます。スタンドアロン ドキュメントには、開発者ガイド、API リファレンス、チュートリアル、およびサンプル ドキュメントが含まれています。このドキュメントは、ローカルのスタンドアロン コンピューターまたは内部ネットワーク上で実行するように設計されており、パブリックなインターネット上では実行できません。\nローカルでドキュメントを公開する方法：\n 使用する ArcGIS Runtime SDK のドキュメントをダウンロードします。ダウンロードしたファイルは、.zip アーカイブ形式になっています。 アーカイブをローカル フォルダに解凍します。解凍されたアーカイブには、public と install という 2 つのサブフォルダがあります。 install フォルダ内の README.md ファイルを開き、選択した Web サーバーの指示に従います。  注：ライブ ドキュメント サイトはリリース時及びリリースの間に定期的に更新されますが、スタンドアロン ドキュメントは静的で、最初のリリース後は更新されません。\n追加のデータ グリッド ベースの地理座標変換を使用している場合は、ダウンロード ページからサポートする Projection Engine ファイルをダウンロードしてください。\n航海用電子海図 (ENC) を使用する場合は、ダウンロード ページから hydrography directory をダウンロードします。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/install-guide/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Web AppBuilder (Developer Edition) をインストールする手順を紹介します。",
	"content": "ArcGIS Web AppBuilder は ArcGIS Online あるいは Portal for ArcGIS に組み込まれた機能として提供されており、ウィジェット（機能）やテーマ（デザイン）を組み合わせることにより、GIS やプログラミングなどの専門知識がなくても誰でも簡単に Web アプリケーションを作成できるソフトウェアです。 Developer Edition（開発者向けエディション）はこれらの機能に加え、開発者のためにウィジェットやテーマを独自に開発するためのフレームワークを提供します。また、作成したアプリケーションをダウンロードし、独自のサーバーにホストすることも可能です。\nここでは、ArcGIS Web AppBuilder (Developer Edition) (以下 Web AppBuilder) のインストール手順を説明します。\n インストール Web AppBuilder の起動 ポータル URL の指定 アプリケーション ID の設定 インストールの確認  インストール  Web AppBuilder の ZIP ファイルをローカルにダウンロードし、解凍します。\nサインイン ページが表示される場合は、ArcGIS Developers 開発者アカウント（あるいは ArcGIS Online 組織向けプランのアカウント）のユーザー名およびパスワードを入力しサインインします。 Web AppBuilder は Node.js 上で動作するため、インストールする端末に Node.js が必要です。Web AppBuilder のインストール ファイルには Windows バージョンの Node.js が含まれていますが、Mac や Linux など他の OS をお使いの場合は Web AppBuilder を起動する前に Node.jsをインストールする必要があります。  ArcGIS API for JavaScript の参照先を変更する（オプション） Web AppBuilder はデフォルトでは Esri の CDN で配信されている ArcGIS API for JavaScript を参照します。そのため、インターネットに接続できない環境で Web AppBuilder を使用する場合、ArcGIS API for JavaScript の参照先を変更する必要があります。ここでは Portal for ArcGIS に内蔵されている ArcGIS API for JavaScript へ参照先を変更する手順を説明します。\n \u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\client\\stemapp\\env.js ファイルをテキストエディターで開きます。 //apiUrl を検索します。   API のバージョンは Web AppBuilder のバージョンにより異なります。通常、Web AppBuilder がリリースされた時点の最新バージョンの API が使われています。  apiUrl= \u0026quot;https://\u0026lt;ポータル URL\u0026gt;/jsapi/jsapi/\u0026quot; に書き換え、上書き保存します。   Portal for ArcGIS が内蔵する API を使用する際は、内蔵されている API のバージョンに注意が必要です。Web AppBuilder が使用する API のバージョンと異なるバージョンの API の利用はサポートされません。\nWeb AppBuilder のバージョンと API のバージョンの関係については About release versions を参照ください。  Web AppBuilder の起動  Web AppBuilder を起動します。   Windows 端末\nWindows をお使いの場合、解凍したフォルダーにある startup.bat ファイルをダブルクリックします。このバッチファイルはコマンド プロンプト上で Node.js サーバーを起動します。 その他の端末 Windows 以外のマシンにインストールする場合は、直接 Node.js サーバーを起動するコマンドを実行します。\nコマンド プロンプトを開き、\u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\server のパスを指定します。続けて node server.js と入力します。\nWeb AppBuilder は Web ブラウザーで http://[マシン名]:3344/webappbuilder にアクセスすると起動します。コマンド プロンプト上で Node.js が起動している間はいつでも、どの Web ブラウザーからでも Web AppBuilder を開くことができます。利用するマシンがドメインに参加しているとき、Web AppBuilder へのアクセスにドメインを含める必要がある場合があります。その際は、http://[マシン名].[ドメイン]:3344/webappbuilder のようにドメインを含めてアクセスしてください。  Node.js がデフォルトで使用するポート番号は 3344 です。パラメーターを追加したり、他のポート番号を割り当てたり、Windows サービスとして起動したりしたい場合は、以下の手順を参照してください。    パラメーターを追加し、他のポート番号を割り当てる\n コマンド プロンプトを開き、Web AppBuilder のサーバー ディレクトリ（\u0026lt;Web AppBuilderのインストール ディレクトリ\u0026gt;\\server）へ移動します。割り当てたいポート番号と必要に応じてプロキシの URL を入力します。  64 ビット版 Windows\nnode_x64.exe server.js [-port=value] [-proxy=value] 32 ビット版 Windows\nnode_x32.exe server.js [-port=value] [-proxy=value] その他のマシン\nnode server.js [-port=value] [-proxy=value]   Web ブラウザーを開き、上記で設定したポート番号を指定し、Web AppBuilder を起動します。\nhttp://[マシン名]:[ポート番号]/webappbuilder    Windows サービスとして起動する\nWeb AppBuilder は、startup.bat ファイルをクリックして起動させるほかに、Windows サービスとして起動させることもできます。\n Windows プラットフォームに Node.js をインストールします。 管理者としてコマンドプロンプトを開きます。 Web AppBuilder のサーバー ディレクトリ（\u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\server）へ移動します。 npm install コマンドを実行します。 npm run-script install-windows-service コマンドを実行します。 Windows の [サービス] ウィンドウを開き、ArcGISWebAppBuilder サービスを起動します。 ArcGISWebAppBuilder サービスを削除するには、npm run-script uninstall-windows-service コマンドを実行します。 プロキシを利用したい場合は、/~server/package.json ファイルを開き、\u0026quot;start\u0026quot;: \u0026quot;node server.js\u0026quot; を \u0026quot;start\u0026quot;: \u0026quot;node server.js -proxy=\u0026lt;http://your proxy\u0026gt;\u0026quot; に変更してください。    ポータル URL の指定   Web AppBuilder で使用するアカウントに紐づく ArcGIS Online またはPortal for ArcGIS の URL を指定します。開発者アカウントをご利用の方は、ArcGIS for Developers の [Account Settings] ページにて URL をご確認ください。\n  [続行] をクリックします。Web 層認証を使用している場合、次のセクションはスキップしてください。ログイン後、インストールの確認をしてください。\nArcGIS Online または Portal for ArcGIS で OAuth2 認証を使用する場合は、次のセクションでアプリケーション ID を設定する必要があります。\n  アプリケーション ID の設定 上記で指定した ArcGIS Online または Portal for ArcGIS ではじめて Web AppBuilder を使用する場合、OAuth2 認証を利用できるようにするため、アプリケーション ID を設定する必要があります。\nアプリケーション ID を入手するには ArcGIS Online または Portal for ArcGIS に Web AppBuilder をアイテムとして追加します。\n  指定したポータルへログインします。\n  コンテンツ ページの[マイコンテンツ] を開きます。[新しいアイテム] をクリックし、[アプリケーション] を選択します。\n  ダイアログボックスで、[アプリケーションタイプ] に Web マッピング、[URL] オプションに Web AppBuilder の URL を入力し [次へ] をクリックします。\n   任意のタイトル、保存先のフォルダー、タグとサマリーを設定し、 [保存] をクリックします。これで Web AppBuilder はアイテムとしてポータルに追加されました。\n  アイテムの追加が完了すると、追加したアイテムの詳細情報のページが表示されます。\n ArcIGS Online：[設定] タブをクリックします。[アプリケーションの登録] セクションまでスクロールし、[登録] をクリックします。 Portal for ArcGIS：[アプリケーションの登録] セクションまでスクロールし、[登録] をクリックします。    [登録] ダイアログが表示されます。[リダイレクト URI] オプションに http://[マシン名] または https://[マシン名] を入力して、[追加] をクリックします。HTTP と HTTPS プロトコルは異なる URI として認識されることに注意してください。リダイレクトに関する問題を避けるため、両方のプロトコルを登録することを推奨しています。\n  [登録] をクリックします。これでアプリケーションの登録は完了です。\n  Web AppBuilder の起動画面に戻ります。[アプリケーション ID] オプションに入手したアプリケーション ID を入力し、[続行] をクリックします。\nInvalid redirect_uri エラー ページが表示される場合は、以下の手順に従ってください。\nアプリケーション ID を入手する際に登録したリダイレクト URI に誤りがある場合、アプリケーション ID オプションにアプリケーション ID を入力し、[続行] をクリックすると、エラー ページが表示されることがあります。この場合、登録したアプリケーションの情報を修正する必要があります。\n Web AppBuilder のサーバー ディレクトリ（\u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\server）を開き、signininfo.json ファイルを削除します。 手順 3 に戻り、入力したリダイレクト URI を更新するか、アプリケーションを新しく登録して、新しいアプリケーション ID を入手します。 起動中の Web AppBuilder のページを再読み込みします。 [アプリケーション ID] オプションにアプリケーション ID を入力し、[続行] をクリックします。    [権限のリクエスト] ダイアログが表示されます。表示されたアカウント情報が正しいことを確認し [承認] をクリックします。\n  アプリケーション ID は OAuth2 認証に必要です。詳細は 認証をご参照ください。ログインに関する問題は、FAQs および アプリの追加とアプリの登録をご参照ください。\nWeb AppBuilder は、デフォルトで HTTPS をサポートするために Node.js で自己署名証明書を使用しています。\n独自に用意した証明書を使用したい場合は、Web AppBuilder のサーバー ディレクトリ（\u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\server）にある cakey.pem と cacert.pem を置き換えてください。\nアプリケーション ID の登録手順の説明は以上です。これで 登録先のポータルへ OAuth2 認証を使用してサインインできるようになりました。次回からは Web AppBuilder を起動すると直接 Web AppBuilder のトップページが表示されます。\nこれで Web AppBuilder のインストールは終了です。\nインストールの確認 ここでは Web AppBuilder が正常にインストールされていることを確認するために、アプリケーションの起動確認を行います。\n Web AppBuilder を起動します。 トップページが表示されたら [新規作成] をクリックします。 [デフォルト（2D）] を選択し、[次へ] をクリックします。 新しい Web アプリの作成ページが開きます。任意のタイトルと説明を入力して [OK] をクリックします。 アプリケーションの作成のページが表示されたらインストールの確認は完了です。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/install-and-setup/",
	"title": "インストールおよびセットアップ方法",
	"tags": [],
	"description": "インストールおよびセットアップの方法を紹介します。",
	"content": "出典：ArcGIS Maps SDK for JavaScript - Install and set up\nインストールおよびセットアップ API へのアクセス ArcGIS Maps SDK for JavaScript をアプリに導入するには、複数のオプションがあります。AMD および ES モジュールの詳細については、Introduction to Tooling を参照してください。\nArcGIS CDN による AMD モジュール API にアクセスする最も一般的な方法は、ホスト型のバージョンを使用することです。Esri の CDN から API と CSS を参照して、アプリでの API の使用を開始してください。\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.25/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.25/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; NPM による ES モジュール JavaScript API は、npm（JavaScriptのパッケージマネージャー）を使っても利用できます。ローカルに API をインストールして、React や Angular などの JavaScript フレームワークや、webpack や rollup.js などのモジュールバンドルラーで利用することができます。\nインストール方法：\nnpm install @arcgis/core モジュールのインポート：\nimport Map from \u0026#34;@arcgis/core/Map\u0026#34;; 詳細については、以下のガイドを参照してください。\n ツールの紹介 ES モジュールの構築  CDN による ES モジュール ※ この方法は、現在のところ、開発やプロトタイピングにのみ推奨されています。\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.25/@arcgis/core/assets/esri/themes/light/main.css\u0026#34;\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import Map from \u0026#34;https://js.arcgis.com/4.25/@arcgis/core/Map.js\u0026#34;; // Use the Map class \u0026lt;/script\u0026gt; ローカルにホストされる AMD モジュール 場合によっては、ArcGIS CDN を介して AMD モジュールのローカルにホストされたバージョンを使用する必要があります。この例は、インターネットにアクセスできない制限されたネットワーク環境で作業している場合です。また、API リファレンス、チュートリアル、およびサンプルを含むドキュメントをダウンロードしてインストールすることもできます。ダウンロード可能なドキュメントは、バージョン 4.25 のリリース日からのスナップショットであり、最新のサンプル アップデートやドキュメントの修正などは含まれていません。\nArcGIS Maps SDK for JavaScript およびそのドキュメントをダウンロードするには、ArcGIS Maps SDK for JavaScript のダウンロード ページに移動し、Esri グローバル アカウントでログインします。\nWeb サーバーのホスティング設定 ArcGIS Maps SDK for JavaScript をホストする Web サーバのホスティング構成では、以下の MIME/type 登録が必要です。\n   エクステンション MIME/type 説明     .ttf application/octet-stream True Type フォント   .wasm application/wasm WebAssembly   .woff application/font-woff Web Open Font Format   .woff2 application/font-woff2 WOFF File Format 2.0   .wsv application/octet-stream Scene View の星の可視化に対応    なお、HTTPSをサポートするWebサーバーでは、SSL Webサーバー証明書を使用する必要があります。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/",
	"title": "スタートアップ ガイド",
	"tags": [],
	"description": "開発を始める方のために必要なアカウントの作成、API キーの取得、ロケーションサービスの利用、各 API / SDK を使った開発の基本的な流れからセキュリティ、運用（ライセンス認証）まで手順にそって学べる情報をまとめています。",
	"content": "開発を始める方のために「開発者アカウントの作成、API キーの取得、ロケーションサービスの利用、API / SDK を利用したアプリ開発、セキュリティ、運用（ライセンス認証）」と ArcGIS Platform を利用した開発の基本的な流れを紹介しています。\n 開発者アカウントの作成\nArcGIS Developers の利用を開始するために新規アカウントを作成する手順を紹介します。\n\r\r\r API キーの取得\nアプリケーションを公開するために必要な API キーを取得する手順について紹介します。\n\r\r\r ロケーションサービスの利用\nArcGIS Platform をはじめて使う方向けにロケーションサービスの紹介やフィーチャ サービス、Web マップを作成する方法について紹介します。\n\r\r フィーチャサービスの作成\nデータの検索や編集が可能な地図サービス (REST API) の配信方法を紹介します。\n\r Web マップの作成\nさまざまなフォーマットのデータを 1 つのマップとして集約し、それを可視化する方法を紹介します。\n\r\r アプリ開発\nシンプルな地図アプリの作成方法を紹介します。\n\r\r ArcGIS Maps SDK for JavaScript\nArcGIS Maps SDK for JavaScript を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。\n\r Esri Leaflet\nEsri leaflet を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。\n\r MapLibre GL JS\nMapLibre GL JS を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。\n\r OpenLayers\nOpenLayers を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。\n\r Android\nArcGIS Runtime SDK for Android を用いたモバイル地図アプリの作成方法を紹介します。\n\r iOS\nArcGIS Runtime SDK for iOS を用いたモバイル地図アプリの作成方法を紹介します。\n\r .NET\nArcGIS Maps SDK for .NET を用いたネイティブ地図アプリの作成方法を紹介します。\n\r\r セキュリティと認証\n有償のサービスやプライベート コンテンツへアクセスするアプリに必要な認証について紹介します。\n\r\r\r デプロイ\n開発したアプリをデプロイするために必要なライセンスや利用規約などについて紹介します。\n\r\r\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/visualization/workflow-with-arcgis/",
	"title": "データ可視化のワークフロー",
	"tags": [],
	"description": "マップ ビューアーを使用した地図上でのデータ可視化のプロセスを紹介します。",
	"content": "ArcGIS 開発者向けクラウド サービス（ArcGIS for Developers）で提供されているビジュアライゼーション ツール（マップ ビューアー）を使用した地図上でのデータ可視化のプロセスを紹介します。最終的には地図作成にとどまらず、サードパーティのチャートなどのコンポーネントを組み合わせたアプリ開発をゴールとしています。\n本ワークフローで伝える方法はあくまで作成済みのデータに簡単な加工を施して可視化を行うことをクラウド上で実施することを前提としています。よって、デスクトップ GIS ソフトウェアなどを使ったデータ編集は除外しています。\nワークフロー ５ステップをベースに、各ステップで使用するツールやプラットフォームとその簡単な使用方法を以下で紹介していきます。\n データ取得   データ可視化のテーマとなるデータを取得します。  データ加工   取得したデータを地図上にプロットします。必要に応じてデータ変換を行います。  データ処理   必要に応じてテーマとなるデータをもとに解析処理を施します。  グラフィック表現   可視化対象であるデータをテーマに従って表現を加えます。  アプリ作成/ページ埋め込み   ステップ４までに作成した Web マップをページ上に表示し、データ可視化によるテーマを伝えるためにページの編集を行います。  以下は上記５ステップをチャートで表現した図です。必ずしもすべてのステップを踏む必要はなく、また柔軟なアウトプットを行うために開発が担う作業範囲を大きくすることも考えられますが、ここでは、もっとも簡易で効率的な手段として、ステップ４までのプロセスをクラウド上で完了できるようなフローを紹介します。\nデータ取得 ArcGIS のクラウド サービスが提供するビジュアライゼーション ツールではさまざまなデータ形式をサポートしており、異なる形式のデータをインポートし、地図上に可視化することができます。\nサポートするデータ形式は以下の通りです。\n ArcGIS Server サービス（GeoServices） シェープファイル GeoJSON CSV TXT GPX GeoRSS KML OGC  上記の形式で座標情報あるいは住所情報があればお好きなデータ カタログから取得したデータをすぐに地図上に可視化できます。特に ArcGIS Web サービスを使うことで、動的な属性/空間検索が可能な API を経由したデータ可視化が可能なため、より柔軟な可視化に対応できます。\n以下は、ArcGIS Web サービスを配信しているデータ元の参考です。\n ArcGIS Online ArcGIS Open Data Koop  データ加工 ここで紹介するデータ加工はさまざまなデータ形式を１つの地図上に重ねて可視化する作業にあたります。前のステップで取得したデータをデータ ビジュアライゼーション ツールを使って地図上に可視化します。\n  Web サービス（ArcGIS Server サービス、GeoRSS、KML、OGC）の場合\n  静的ファイル（シェープファイル、CSV、TXT、GPX）の場合\n  ArcGIS Online で全世界に配信されているデータの検索および可視化\rデータ処理 可視化したデータをもとに GIS の空間解析を実施することで、より高度な分析結果を２次データとしてそのまま地図上で扱うことができます。\n例：ポイントの集約 たとえば、喫茶店の場所を示すポイント フィーチャと区のエリア フィーチャがあり、喫茶店の売上を区別にまとめるとします。喫茶店に TOTAL_SALES 属性情報があれば、区ごとの TOTAL_SALES の合計値、各区の TOTAL_SALES の最小値または最大値、各区における総売上の標準偏差を取得できます。\nこのプロセスは必須ではないので、必要に応じて行ってください。\nArcGIS の解析サービスの利用については「解析の実行 | ArcGIS Online ヘルプ」を参照してください。\nグラフィック表現 可視化対象であるデータをテーマに従って表現を加えます。データ ビジュアライゼーション ツールには直感的な操作で地図上のデータの表現を操作するための機能が備わっています。主な表現方法は以下の通りです。\n 場所（単一シンボル）   単一シンボルを使用してデータを描画すると、フィーチャの分布状態 (クラスター化されているか分散されているか) を把握し、隠れているパターンを明らかにできます。\n ヒート マップ   ヒート マップはレイヤー内のポイントを使用して、マップ上のポイントの相対的な密度を計算し、寒色 (ポイントの密度が低い) から暖色 (ポイントの密度が高い) まで滑らかに変化する一連の色の配列で表示します。\n 種類（個別値シンボル）   個別値シンボルを使用すると、数値測定の数ではなく、さまざまな種類 (カテゴリ データ) を表示できます。たとえば、さまざまな色を使用して、レストランが提供する料理の種類を表すことができます。レイヤーに表示するカテゴリを 10 種類未満にするのが理想的です。\n 数と量（色）   数値データが存在する場合、色のグラデーションによってフィーチャを区別できます。使用できる色のグラデーションには、さまざまな種類があります。たとえば、薄い色から濃い色に変化する単純な方式は、年齢や収入など、高低を表すデータ値の表示に適しています。\n 数と量（サイズ）   数値データまたはランク付けされたカテゴリを表すために、順序付けできる異なるサイズの並びを使用します。この方法を使用して、ポイント、ライン、およびエリアをすべて描画できます。この比例シンボル マップでは、シンボルが大きいほど大きい数値を表すという直感的な論理を使用します。伝えたい内容を明確に表すようにシンボルのサイズを調整します。たとえば、等級シンボルを使用して、各都市の相対的な人口密度を表示できます。\n 色とサイズ   データ内の 2 つの属性を選択し、マップ上のポイント シンボルの色とサイズを完了します。または、同じ属性を 2 回使用して、強調するデータの部分に基づき、シンボルのサイズを設定し、色を設定できます。これは、一人親の世帯数などの数情報を、貧困率などの比率で陰影処理して表示する場合に適したスタイルです。\n 個別値シンボルとサイズ   学士号を持つ人などの数属性を表示し、郡名など別のフィールドの値ごとに一意の色を使用する場合に使用します。一意の値を持つテキストまたは数値フィールドと、数値フィールドを選択し、必要に応じて、各属性のマップ シンボル設定を調整します。\n A を B と比較   2 つの数値の比率をマッピングして、その関係をパーセンテージまたは単純な比率で表現できます。たとえば、総人口に対する大学の学位を持つ人の比率をマッピングできます。\nスタイリング機能を使った地図データにもとづくグラフィック表現\rアプリ作成/ページ埋め込み 上記ステップまでに作成した Web マップは１つの完結した地図データとして管理が可能です。Web マップには対応する一意の ID が割り当てられており、JavaScript API を使って ID を参照するだけで可視化した地図をそのまま Web ページ上に表示することができます。\nvar webmap = new WebMap({ portalItem: { id: \u0026#34;\u0026lt;Web マップ ID\u0026gt;\u0026#34; } }); var view = new MapView({ map: webmap, container: \u0026#34;viewDiv\u0026#34; }); \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 参照した地図上のデータをスクリプトで取得し、D3.js などのサードパーティのチャート コンポーネントと容易に連携が可能です。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/get-dev-account/",
	"title": "開発者アカウントの作成",
	"tags": [],
	"description": "ArcGIS Developers の利用を開始するために新規アカウントを作成する手順を紹介します。",
	"content": "ArcGIS Developers とは ArcGIS Developers は、開発者が ArcGIS アプリケーションを構築してデプロイするために必要なリソースを集めた Web サイトです。API および SDK のドキュメントやチュートリアル、ロケーションサービスの概要、価格、ヘルプなどが用意されています。このサイトに開発者としてアカウントを作成することで、開発キット（SDK）をダウンロードして ArcGIS アプリケーションの開発を開始することができます。\nArcGIS Developers に開発者アカウントを作成すると ArcGIS Developer Subscription が有効になり、開発キットのダウンロードとアプリの開発を無償で開始することができます。また、ArcGIS Platform が提供するロケーションサービスであるベースマップの利用やジオコーディング サービス（住所⇄緯度経度）、ネットワーク サービス（ルート検索、到達圏解析）などの様々な GIS サービスを利用したり、お手持ちのデータを GIS サービスとして配信したりすることが、無料枠/月の範囲で利用可能です。\nArcGIS Developer Subscription の各プランの詳細や提供しているサービスについては ESRIジャパン製品ページをご参照ください。\nアカウントの作成 ArcGIS Developers 開発者アカウントの作成 以下の手順で ArcGIS Developers に新規アカウントを作成します。アカウントの作成中に問題が発生した場合は、ESRI ジャパンまでお問い合わせください。\n  ArcGIS Developers のサイト（英語）にアクセスし、[Sign Up For Free] をクリックします。\n  名前（※名前には半角英字のみを使用してください）、E メールアドレス、組織名（任意）、ユーザー名、パスワード、秘密の質問を入力します。\n  利用規約とプライバシー ポリシーに同意する場合は、同意欄にチェックを入れ、[Create developer account] をクリックします。\n  手順 2 で入力したユーザ名にて ArcGIS Developers にログインされ、登録確認の E メール（Confirmation email）を確認する旨のメッセージが表示されます。また、受信ボックスに Esri から登録の確認メールが届きます（メールが届くまで時間がかかる場合があります）。\n  手順 2 にて入力した、Eメールアドレスの受信ボックスに届いた Esri からのメールを開き、メール本文にある [Confirm your email] をクリックします。\n  以上で ArcGIS Developers の開発者アカウントの作成は完了です。 また、GitHub、Facebook、Google および Apple アカウントと連携することで、ArcGIS Developers を利用することができます。各種アカウントとの連携方法に関しましては、それぞれの連携先の手順に従い行ってください。\n従量制プラン ArcGIS Platform では、お手持ちのデータを GIS サービスとして配信したりすることが、無料枠/月の範囲で利用可能です。それを超えてサービスを利用する場合に、従量制プラン（Pay as you go） の有効化が必要となります。\n※ 従量制プラン（Pay as you go）を有効化する際には、クレジットカードの情報が必要になります。\n従量制プランの有効化 以下の手順で従量制プランを有効化します。\n ArcGIS Developers（https://developers.arcgis.com/） のサイトで、開発者アカウントでログインします。アカウントのメニューから [Billing] をクリックします。  Pay as you go の欄で、[Enable pay as you go] をクリックします。  ポップアップで表示される画面で、クレジットカード情報等の必要な情報を入力し、[Continue] ボタンをクリックします。  table {\rborder-collapse: collapse;\rwidth: 60%;\rmargin-left:auto;\rmargin-right:auto;\r}\rtable, th, td {\rborder: 1px solid black;\r}\r\r   項目 入力内容      Name on Card（カード名義） カード記載の名義人   Credit Card Number（クレジットカード番号） \u0026mdash;- \u0026mdash;- \u0026mdash;- \u0026mdash;- 形式   Expiration Date（有効期限） mm/yy（月/年）形式   CVV（セキュリティコード：カード裏面の右端３ケタ） \u0026mdash; 形式   Street Address（住所） 例：2-7-1 Hirakawa-Cho   City（市区町村） 例：Chiyoda-Ku   Country（国） 選択形式   Region（都道府県） 選択形式   Postal Code（郵便番号） 例：1020093    表示されている内容を確認し、「I have read agree to the terms and conditions of this license」のチェックボックスにチェックを入れ、[Enable pay as you go] をクリックします。  Pay as you go が有効化されていることを確認します。  以上で従量制プランの有効化は完了です。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/get-api-key/",
	"title": "API キーの取得",
	"tags": [],
	"description": "アプリケーションを公開するために必要な API キーを取得する手順について紹介します。",
	"content": "API キーとは すぐに使える特定のサービスやプライベート コンテンツへのアクセスを公開アプリケーションに許可範囲と許可を定義する永続的なアクセストークンです。\n既に ArcGIS アカウントを持っている場合は、サインインしてデフォルトの API キーを表示したり、新しい API キーを作成したりすることができます。API キーは、ArcGIS 開発者アカウントにサインアップしたときに作成されます。\n詳細は API keys のサイト（英語）をご覧ください。\nAPI キーの取得方法 以下の手順で新規の API キーを取得します。API キーの取得中に問題が発生した場合は、ESRI ジャパンまでお問い合わせください。\n  ArcGIS Developers のサイト（英語）にアクセスし、ご自身のアカウントでサインインをします。\n  サインインしたアカウントの専用ページに遷移したら、ヘッダー部にある [API keys] タブまたは、メイン コンテンツ内の API keys にある [Manage] をクリックします。   API keys ページに遷移したらページ上部にある [+ New API key] をクリックします。   入力フォームが出力されたらタイトルと説明を入力して [Create API key] をクリックします。   以上で API キーの取得は完了です。\n取得した API キーは、専用ページの Overview タブページの上方に表示されているため、コピーをしてご利用ください。\nまた、API キーを各種開発キットで利用するためのコードも用意されていますので併せてご利用ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/python-api-conda/",
	"title": "ArcGIS API for Python のための基礎環境：conda入門",
	"tags": [],
	"description": "conda の基本について簡単に紹介します。",
	"content": "ArcGIS API for Python (以下、Python API) を使用する際、conda を利用すると Python の環境やパッケージを管理することが容易になります。 ここでは、conda の基本について簡単に説明します。conda について基本的な事項を把握しておきますと、この後のインストールガイドでの環境作成を行いやすくなります。\n\rconda の基本 conda の基本について説明します。conda は Python と Python で使用できるライブラリのインストールやバージョンを管理するためのツールです。 conda を使用する場合、次の 2 つの選択肢があります。\n Anaconda Distribution : Python とデータサイエンス向けの Python パッケージなどを提供するプラットフォームです (以下、Anaconda)。 Miniconda : Anaconda をコンパクトにしたもので、Python、conda、それらの依存パッケージ、その他の最小限のパッケージをインストールします。ArcGIS Pro をインストールした場合、Miniconda も同時にインストールされます。  Anaconda と Miniconda の詳しい違いは Anaconda or Miniconda (英語) のページをご覧ください。 ※ pip でも Python API をインストールすることができますが、初心者には conda が推奨されています。参考: ArcGIS API for Python - Install and set up (英語)\nconda をより深く理解したい方は Getting Started with Conda (英語) チュートリアルをご覧ください。\n conda の環境 conda をインストールすると、Python のインタープリターと環境にインストールしたパッケージを隔離するディレクトリが作成されます。これにより、Python を含む異なるバージョンのソフトウェアを持つ複数の環境を作成することが可能になります。新しい環境は簡単に作成することができ、他の環境に影響を与えることなくそれらを切り替えて使用することができます。詳細な説明と手順については、環境の管理に関する conda のドキュメント (英語)を参照してください。\nインストール手順は次章で詳しくご説明しますが、以降では ArcGIS Pro を通じて conda をインストールした場合と、Anaconda でインストールした場合のデフォルトの環境について説明します。\nAnaconda 上の仮想環境イメージ\n --\rデフォルトの環境 conda をどのようにインストールしたか (ArcGIS Pro 経由か Anaconda 経由か) によってデフォルトの環境は異なります。 コマンド プロンプト等で conda env list とコマンドを入力することで作成されている環境の一覧を確認することができます。\nArcGIS Pro の場合 ArcGIS Pro をインストールした後で環境を確認すると、以下の 2 つが作成されています。\n  arcgispro-py3 この環境には、Python、ArcPy の機能を含む arcgispro パッケージが含まれています。\n  root この環境には、必要最小限の conda、Python、依存するパッケージなどが含まれる Minaconda がインストールされています。\n  ArcGIS Pro の conda 上の初期環境\n\rconda の環境を ArcGIS Pro で管理する ArcGIS Pro の conda の環境は、次の 3 つの方法を使用して管理できます。どの方法でも、それぞれパッケージのインストール、更新、削除などを行うことができます。\n  Python パッケージ マネージャー ArcGIS Pro プロジェクトタブからアクセス可能な GUI ツール。\n  Python コマンド プロンプト 上述した arcgispro-py3 の環境に直接アクセスしアクティブにするコマンドライン ショートカット。\n  コマンド プロンプト (windows) 標準の MS-DOS Windows コマンドライン アプリケーション。\n  (左) Python パッケージ マネージャー、(中) Python コマンド プロンプト、(右) コマンド プロンプト (windows)\r\rAnaconda の場合 Anaconda をインストールすると Python、conda、その他多数のパッケージが base という 1 つの環境にインストールされます。\nAnaconda Prompt 初期の環境\r\rconda の環境を Anaconda で管理する 主に以下の 2 つの方法で conda の環境を管理することができます。\n ターミナル アプリケーション  標準的なコマンドラインターミナルアプリケーション。\n※ Anaconda をインストールすると Anaconda Prompt が一緒にインストールされます。Anaconda Prompt を使用すると環境変数を操作せずに conda のコマンドを利用できます。\n Anaconda Navigator conda の環境を包括的に管理するための GUI アプリケーション。  Anaconda Navigator (左) と Anaconda Prompt (右)\r\r 環境をアクティベートする 環境を利用するためには、対象となる環境をアクティベートする必要があります。以下のコマンドを実行することで対象の環境をアクティベートできます。\n activate \u0026lt;環境名\u0026gt;  ArcGIS Pro と共にインストールした場合は、Python コマンド　プロンプトから以下のコマンドで環境を切り替えることができます。\n proswap \u0026lt;環境名\u0026gt;  ` --\rその他のコマンドの詳細については、環境のアクティブ化 (英語)を参照してください。\n 新しいパッケージを追加する アクティベートした環境に新しいパッケージを追加したい場合は次のコマンドを使用します。\nconda install \u0026lt;package_name\u0026gt;\nまた、--name や --channel オプションを使用して、特定の環境およびチャネルを指定することもできます。\nconda install --name \u0026lt;environment_name\u0026gt; --channel \u0026lt;channel_name\u0026gt; \u0026lt;package_name\u0026gt;\nconda コマンドや 他オプションの使用方法の詳細についてはパッケージの管理 (英語)を参照してください。\n 参考：conda からパッケージをインストールできる仕組み\nConda は、プラットフォームに依存しないパッケージ マネージャー アプリケーションで、Python パッケージをインストール、更新、および削除できます。 パッケージは、チャネルと呼ばれるさまざまなリポジトリのいずれかに格納されているソフトウェアおよびサポートファイルのバンドルです。 チャネルは、Anaconda クラウドなどの既定のクラウド ロケーションのセット、または個人または組織によって作成されたプライベートレポジトリである場合があります。 condaは、パッケージのリスト表示またはインストール時にデフォルトのチャネルセットを検索します。\narcgis パッケージを格納するために esri という名前のチャネルに conda リポジトリが作成されています。 conda install コマンドは、チャネルにアクセスし、特定の conda 環境にパッケージをインストールしています。\nAnaconda クラウド上の esri チャネル\r\r このページの内容の詳細については 米国Esri ガイドページ：Understanding Conda (英語)をご覧ください。\n次の章では、ArcGIS API for Python の環境構築方法を紹介します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/",
	"title": "ArcGIS Web AppBuilder (Developer Edition)",
	"tags": [],
	"description": "ArcGIS Web AppBuilder (Developer Edition) の開発に役立つガイド集です。",
	"content": "ArcGIS Web AppBuilder (Developer Edition) の開発に役立つガイド集です。\n インストール ガイド\nArcGIS Web AppBuilder (Developer Edition) をインストールする手順を紹介します。\n\r カスタム ウィジェット開発ガイド\nカスタム ウィジェットを開発する手順を紹介します。\n\r デプロイ パターン\nArcGIS Web AppBuilder (Developer Edition) で作成したアプリやウィジェットのデプロイ パターンを紹介します。\n\r Web アプリケーションのデプロイ\nArcGIS Web AppBuilder (Developer Edition) で作成したアプリケーションをダウンロードし、独自のサーバーにホストする手順を紹介します。\n\r ウィジェット一覧表\nArcGIS Web AppBuilder で提供されているウィジェットの一覧表です。\n\r\rカスタム ウィジェットのサンプル集（外部サイト）  ArcGIS Web AppBuilder (Developer Edition) を使用して開発されたカスタム ウィジェットのサンプルを確認できるサイトです。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/learn/developer-community/",
	"title": "ArcGIS 開発者コミュニティ",
	"tags": [],
	"description": "ArcGIS 開発者コミュニティ",
	"content": "ESRIジャパンのスタッフが Esri Community 上で開発者、SIer (エスアイヤー)、ポータル管理者向けの技術ブログを発信しています。毎年多くの記事を配信していますので、初めての方は欲しい情報を探す時間が長くなりがちです。年代別にイベント資料やブログ記事を中心に、API/SDK などのカテゴリー別にまとめていますので、参考にしていただければと思います。紹介している内容のレベルの目安として、【基礎】、【応用】 のフラグを付けています。\n2022 年  最新の記事についてはこちらから確認していただけます。  2021 年  マッピング \u0026amp; ロケーション開発 (ArcGIS Developer) 2021 振り返り  2020 年  マッピング \u0026amp; ロケーション開発 (ArcGIS for Developers) 2020 振り返り  2019 年  マッピング \u0026amp; ロケーション開発 (ArcGIS for Developers) 2019 振り返り  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-esrileaflet/",
	"title": "Esri Leaflet",
	"tags": [],
	"description": "Esri leaflet を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。",
	"content": "マップを表示する このチュートリアルでは、Esri Leaflet と ベースマップ レイヤー サービス を使用して、マップを表示する方法を紹介します。\nマップには、ベースマップ レイヤー サービスのベクター タイル ベースマップ レイヤーを使用しています。ベクター タイル ベースマップ レイヤーには、レイヤーをレンダリングするためのスタイル、レイヤー、フォントグリフ(Font Glyphs)、およびアイコンが含まれています。\nこのチュートリアルでは、ベースマップ レイヤー サービスの地形ベースマップ レイヤーを使用して、富士山周辺の地図を作成します。\nマップとレイヤーの詳細については、Mapping APIs and services のガイドをご覧ください。\n前提条件 このチュートリアルを実施するには、以下が必要です。\n 開発者ダッシュボードにアクセスして API キーを作成するには、ArcGIS アカウントが必要です。アカウントの作成手順については「開発者アカウントの作成」を参照してください。  ステップ 新しい Pen の作成 CodePen にアクセスして、マッピング アプリケーション用の新しい Pen を作成します。\nHTML の作成と各 JS ライブラリへの参照を追加する Leaflet、Esri Leaflet への参照を含む HTML ページを作成します。 これらは、ベクター タイル ベースマップ レイヤーにアクセスして表示するために必要です。\n \u0026lt;head\u0026gt;の中に、ライブラリを参照するための\u0026lt;script\u0026gt;要素を追加します。 \u0026lt;head\u0026gt;に，ページとマップのスタイルを決めるための\u0026lt;style\u0026gt;要素も追加します。 \u0026lt;body\u0026gt;の中に、マップ用の\u0026lt;div\u0026gt;要素を追加します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1,maximum-scale=1,user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Esri Leaflet\u0026lt;/title\u0026gt; \u0026lt;!-- Leaflet の jsライブラリ と css ファイルの参照を追加--\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/leaflet@1.7.1/dist/leaflet.css\u0026#34; integrity=\u0026#34;sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==\u0026#34; crossorigin=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/leaflet@1.7.1/dist/leaflet.js\u0026#34; integrity=\u0026#34;sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==\u0026#34; crossorigin=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- Esri Leaflet の js ライブラリ と ベクタータイル対応の js ライブラリへの参照を追加--\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/esri-leaflet@3.0.0/dist/esri-leaflet.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/esri-leaflet-vector@3.0.0/dist/esri-leaflet-vector.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; body { margin:0; padding:0; } #map { position: absolute; top:0; bottom:0; right:0; left:0; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; マップの表示 \u0026lt;body\u0026gt;要素に、コードを含む\u0026lt;script\u0026gt;要素を追加してマップを作成します。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1,maximum-scale=1,user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Esri Leaflet\u0026lt;/title\u0026gt; \u0026lt;!-- Leaflet の jsライブラリ と css ファイルの参照を追加--\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/leaflet@1.7.1/dist/leaflet.css\u0026#34; integrity=\u0026#34;sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==\u0026#34; crossorigin=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/leaflet@1.7.1/dist/leaflet.js\u0026#34; integrity=\u0026#34;sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==\u0026#34; crossorigin=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- Esri Leaflet の js ライブラリ と ベクタータイル対応の js ライブラリへの参照を追加--\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/esri-leaflet@3.0.0/dist/esri-leaflet.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/esri-leaflet-vector@3.0.0/dist/esri-leaflet-vector.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; body { margin:0; padding:0; } #map { position: absolute; top:0; bottom:0; right:0; left:0; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- Leaflet でのマップの作成 --\u0026gt; \u0026lt;script\u0026gt; const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; const basemapEnum = \u0026#34;ArcGIS:Topographic\u0026#34;; const map = L.map(\u0026#39;map\u0026#39;, { minZoom: 2 }).setView([35.362752, 138.729858], 12); L.esri.Vector.vectorBasemapLayer(basemapEnum, { apiKey: apiKey }).addTo(map); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; API キーの設定 ロケーションサービスにアクセスするには、API キーまたは OAuth2.0 アクセストークンが必要です。API キーの作成手順については「API キーの取得」を参照してください。\n認証方法とアクセストークンの取得方法の詳細については、「セキュリティと認証」を参照してください。\n  開発者ダッシュボードにアクセスして、API キーを取得します。このチュートリアルで使用するサービスにアクセスするには API キーのスコープを設定する必要があります。\n  CodePen で、キーを使用するため、apiKey を更新します。\n  \u0026lt;script\u0026gt; const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; const basemapEnum = \u0026#34;ArcGIS:Topographic\u0026#34;; const map = L.map(\u0026#39;map\u0026#39;, { minZoom: 2 }).setView([35.362752, 138.729858], 12); L.esri.Vector.vectorBasemapLayer(basemapEnum, { apiKey: apiKey }).addTo(map); \u0026lt;/script\u0026gt; アプリを実行する CodePen で、コードを実行してマップを表示します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/learn/",
	"title": "もっと学ぶ",
	"tags": [],
	"description": "ArcGIS の開発に役立つ情報を配信しています。",
	"content": "　開発に役立つ情報 GitHub   Esri GitHub\n 米国 Esri 社のスタッフが作成したサンプル プログラムを GitHub で共有しています。    Esri Japan GitHub\n 各 API や SDK のサンプルプログラムに加えて、ハンズオンや開発者セミナーで実施内容を GitHub で共有しています。    Esri Community   Esri Community\n 米国 Esri 社が運営する ArcGIS ユーザー コミュニティ サイトです。世界中のユーザーと ArcGIS に関する技術情報を探索・共有することができます。    ArcGIS 開発者コミュニティ\n ESRIジャパンのスタッフが Esri Community 上で開発者、SIer (エスアイヤー)、ポータル管理者向けの技術ブログを発信しています。    Esri Video、Event、Webinar   Esri Video\n 米国 Esri 社のイベント動画サイトもあり、毎年開催されている開発者向けイベント「ESRI Developer Summit」のテクニカルセッションの動画なども公開されています。    GeoDev Events, Webinars, and Meetups\n 米国ESRI の開発者がお届けする Webinar 等も定期的に開催されています。    Learn ArcGIS  Learn ArcGIS  Esri が提供している無償の自習用コンテンツで、実世界の様々な事例をもとにしたレッスンが多数用意されています。    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/android/distribution-android-100.x/",
	"title": "アプリケーション配布ガイド",
	"tags": [],
	"description": "ArcGIS Runtime SDK for Android を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を紹介します。",
	"content": "ArcGIS Runtime SDK for Android (バージョン 100.x) を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を説明します。\nAPI キーの設定 ArcGIS Platform のロケーションサービスを使用する場合は、アプリで API キーを設定する必要があります。API キーの詳細はAPI キーの取得を、APIキーの設定方法はアプリの作成のAPI キーを設定するをご覧ください。\nライセンス認証のステップ 開発したアプリケーションのライセンス認証のステップは以下の通りです。\n 使用するライセンスの選択 ライセンスの認証方法  Lite ライセンスの認証方法 Basic ライセンスの認証方法 Standard ライセンスの認証方法 Analysis Extension ライセンスの認証方法   ライセンスの認証  Lite ライセンスキーを使用した認証 配布パックのライセンスキーを使用した認証 指定ユーザー アカウントを使用した認証    使用するライセンスの選択 ArcGIS Runtime SDK for Android には Lite、Basic、Standard の 3 つのライセンス レベルと Analysis エクステンションがあります。開発したアプリケーションが使用する機能に応じて、適切なライセンス レベルを選択してください。\n各ライセンスで利用可能な機能の概要は以下の表をご参照ください。\n   ライセンス 利用できる機能     Lite ・地図表示（2D/3D）\n・フィーチャの表示/検索\n・フィーチャのオンライン/オフライン編集（パブリックなフィーチャ サービス）\n・ルート検索/到達圏解析/最寄り施設検索\n・住所検索/リバース ジオコーディング   Basic ・Lite ライセンスで利用できるすべての機能\n・フィーチャのオンライン/オフライン編集（セキュアなフィーチャ サービス）\n・モバイル ジオデータベースの編集\n・ArcGIS Online/Portal for ArcGIS のコンテンツの編集   Standard ・Basic ライセンスで利用できるすべての機能\n・シェープファイルの表示/編集\n・GeoPackage の表示/編集\n・KML（ローカル ファイル）の表示\n・ラスター データの表示/解析\n・航海用電子海図（ENC）の表示   Analysis Extension ・Standard ライセンス以上で利用可能なエクステンション\n・オフラインでの到達圏解析/最寄り施設検索    ライセンスの詳細はESRIジャパン製品ページをご参照ください。\nライセンスの認証方法 ライセンスの認証は次の2つの方法があります。\n  ライセンスキーを使用した認証\n ライセンスキーを使用した認証は、ArcGIS Runtime の配布パックを購入し、取得したライセンスキーを利用して、アプリケーションを認証します。    指定ユーザーによるアカウント認証\n 指定ユーザーによるアカウント認証とは、ArcGIS Online または ArcGIS Enterprise の組織のメンバーである ArcGIS 組織アカウントを使用してログイン認証を行います。 ログインを行う指定ユーザーアカウントのタイプによって関連付けられたライセンスのレベルが異なり、また認証はランタイムアプリにコードを含める必要があります。    指定ユーザーのユーザータイプとライセンスレベルの対比表 ■ ArcGIS Online または ArcGIS Enterprise バージョン 10.8 以降をご利用の場合\n   User Type Runtime Level     Viewer Lite   Editor / Field Worker Basic   Creator / GIS Professional Basic Standard ※1   GIS Professional Standard / GIS Professional Advanced Advanced ※1,2    ※1 Standard/Advanced は ArcGIS Runtime (Android/iOS/.NET) 100.7 以降から対応しております。\n※2 ArcGIS Runtime SDK for Android には Advanced ライセンスはありません。\n■ ArcGIS Enterprise 10.7 以前をご利用の場合\n   User Type Runtime Level     レベル1 または Viewer タイプ以上 Lite   レベル2 または Editor タイプ以上 Basic    Lite ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Lite のライセンスキーを取得する必要があります 認証の方法は、Lite ライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Lite ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Basic ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Basic の配布パックを購入する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Basic ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Standard ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Standard の配布パックを購入する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証 注意：この認証は、ArcGIS Runtime 100.7 より以前のバージョンでは使用できません。また、Protal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Standard ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Analysis Extension ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Analysis Extension の配布パックを購入する必要があります 基本ライセンス（Standard）と併せて認証する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、ArcGIS Runtime 100.7 より以前のバージョンでは使用できません。また、Protal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Analysis アドオンライセンス拡張機能を割り当てられた）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    ライセンスの認証 以下の認証に応じた作業を行ってください。\nLite ライセンスキーを使用した認証 ArcGIS Runtime Lite のライセンスキーを ArcGIS Developers のサイトから取得し、取得したライセンスキーを利用して、アプリケーションを Lite ライセンスで認証することができます。 最初に以下の手順で Lite レベルのライセンスキーを取得します。\n  ArcGIS Developers: ArcGIS Runtime license ページにアクセスします\n ArcGIS Developers にサインインしてない場合は [Sign in to retrieve your Runtime license string] をクリックします。 ArcGIS 開発者アカウントでサインインします。アカウントをお持ちでない場合は、サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。    表示されたライセンスキーをコピーします   次に、アプリケーションのコードにおいて ArcGIS Runtime SDK の機能が呼び出される前に、以下のコードを使用してアプリケーションにコピーしたライセンスキーを設定します。\n// 取得したライセンス文字列でアプリのライセンスを設定します ArcGISRuntimeEnvironment.setLicense(\u0026#34;runtimelite,1000,rud#########,none,####################\u0026#34;);   配布パックのライセンスキーを使用した認証 ArcGIS Runtime の配布パックを購入し、取得したライセンスキーを利用して、アプリケーションを認証することができます。\nArcGIS Runtime の配布パックの購入についてはESRIジャパンにお問合せください。ArcGIS Runtime の配布パックをご購入頂いた場合、ESRIジャパンよりライセンスキーをメールにてお送りします。\nアプリケーションのコードにおいて ArcGIS Runtime SDK の機能が呼び出される前に、以下のコードを使用して配布パックのライセンスキーを設定します。\n// 取得したライセンス文字列でアプリのライセンスを設定します ArcGISRuntimeEnvironment.setLicense(\u0026#34;runtimestandard,1000,rud#########,day-month-year,####################\u0026#34;); Analysis Extension ライセンスを認証する場合は以下のコードを使用します。\n// 基本ライセンスとエクステンション ライセンスのリストを設定します ArcGISRuntimeEnvironment.setLicense(\u0026#34;runtimestandard,1000,rud#########,day-month-year,####################\u0026#34;, Arrays.asList(\u0026#34;runtimeanalysis,1000,rud#########,day-month-year,####################\u0026#34;)); 指定ユーザー アカウントを使用した認証 アプリケーションの実行時に、アプリケーションを利用するユーザーが保有する ArcGIS Online 組織向けプランもしくは Portal for ArcGIS の指定ユーザー アカウントを使用して ArcGIS Online / Portal for ArcGIS にログインすることで、ライセンスを取得することができます。\nアプリケーションのコードにおいて ArcGIS Runtime SDK の機能が呼び出される前に、ライセンスを取得・設定します。以下のコードは、指定ユーザーのユーザー名とパスワードをコードに埋め込んで認証する簡単な例です。また、プロセスの一環として、アプリがオフライン環境で最大 30日 間使用されることに備えて、ライセンス情報を保存します。\n認証方法の詳細については、「License your app with a named user account（英語）」や「Security and authentication（英語）」も併せてご覧ください。\n// 指定ユーザーとして ArcGIS Online または ArcGIS Portal に接続します // 以下のコードは、トークンベースのセキュリティの使用を示していますが // ArcGIS Online の場合、Oauth 認証の使用を検討する必要があります UserCredential credential = new UserCredential(\u0026#34;\u0026lt;ユーザー名\u0026gt;\u0026#34;, \u0026#34;\u0026lt;パスワード\u0026gt;\u0026#34;); // ArcGIS Online または Portal で認証する URL を指定します Portal portal = new Portal(\u0026#34;https://www.arcgis.com\u0026#34;); portal.setCredential(credential); // ポータルをロードし、完了したロードイベントをリッスンします portal.loadAsync(); portal.addDoneLoadingListener(() -\u0026gt; { // ポータルが正しくロードされていることを確認してください  if (portal.getLoadStatus() == LoadStatus.LOADED) { // ポータルからライセンス情報を取得します  ListenableFuture\u0026lt;LicenseInfo\u0026gt; licenseFuture = portal.fetchLicenseInfoAsync(); // サーバーからのライセンス情報をリッスンします  licenseFuture.addDoneListener(() -\u0026gt; { try { LicenseInfo licenseInfo = licenseFuture.get(); // JSON 文字列としてライセンスを取得します  String licenseJson = licenseInfo.toJson(); // ネットワーク接続がない場合にアプリを起動するには  // ライセンス文字列をローカルに保存する必要があります。  //ライセンスを適用します  ArcGISRuntimeEnvironment.setLicense(licenseInfo); } catch (InterruptedException e) { // エラーコードはここで取得します  } catch (ExecutionException e) { // エラーコードはここで取得します  } }); } }); 注意：上記のコードスニペットは、ArcGIS Runtime 100.7 で導入された新しい fetchLicenseInfoAsync() APIを使用しています。バージョン 100.6 以前では Portal.getPortalInfo().getLicenseInfo() を使用します。\nライセンス情報をローカルストレージに保存した場合、保存したライセンス情報を使用して、オフライン環境でアプリを起動してライセンスを取得できます。ストレージからライセンスを取得し、アプリのライセンスを取得します。\n// デバイスに保存されているライセンスの JSON を取得します String storedLicense = getLicenceFromStorage(); // JSON 文字列から LicenseInfo を作成します LicenseInfo licenseInfo = LicenseInfo.fromJson(storedLicense); // ライセンス情報を使用してアプリのライセンスを設定します ArcGISRuntimeEnvironment.setLicense(licenseInfo); "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/dotnet/distribution-dotnet-200.x/",
	"title": "アプリケーション配布ガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for .NET を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を紹介します。",
	"content": "API キーの設定 ArcGIS Platform のロケーションサービスを使用する場合は、アプリで API キーを設定する必要があります。API キーの詳細はAPI キーの取得を、APIキーの設定方法はアプリの作成のAPI キーを設定するをご覧ください。\nライセンス認証のステップ 開発したアプリケーションのライセンス認証のステップは以下の通りです。\n 使用するライセンスの選択 ライセンスの認証方法  Lite ライセンスの認証方法 Basic ライセンスの認証方法 Standard ライセンスの認証方法 Advanced ライセンスの認証方法 Analysis Extension ライセンスの認証方法   ライセンスの認証  Lite ライセンスキーを使用した認証 配布パックのライセンスキーを使用した認証 指定ユーザー アカウントを使用した認証    使用するライセンスの選択 ArcGIS Maps SDK for .NET には Lite、Basic、Standard、Advanced の 4 つのライセンス レベルと Analysis エクステンションがあります。開発したアプリケーションが使用する機能に応じて、適切なライセンス レベルを選択してください。\n各ライセンスで利用可能な機能の概要は以下の表をご参照ください。\n   ライセンス 利用できる機能     Lite ・地図表示（2D/3D）\n・フィーチャの表示/検索\n・フィーチャのオンライン/オフライン編集（パブリックなフィーチャ サービス）\n・ルート検索/到達圏解析/最寄り施設検索\n・住所検索/リバース ジオコーディング   Basic ・Lite ライセンスで利用できるすべての機能\n・フィーチャのオンライン/オフライン編集（セキュアなフィーチャ サービス）\n・モバイル ジオデータベースの編集\n・ArcGIS Online/Portal for ArcGIS のコンテンツの編集   Standard ・Basic ライセンスで利用できるすべての機能\n・シェープファイルの表示/編集\n・GeoPackage の表示/編集\n・KML（ローカル ファイル）の表示\n・ラスター データの表示/解析\n・航海用電子海図（ENC）の表示\n・ローカル サーバーの標準的な機能   Advanced ・Standard ライセンスで利用できるすべての機能\n・ローカル サーバーの高度な機能   Analysis Extension ・Standard ライセンス以上で利用可能なエクステンション・オフラインでの到達圏解析/最寄り施設検索\n・ArcGIS Desktop（Spatial/3D/Network エクステンション）で利用可能なジオプロセシング ツールの一部    ライセンスの詳細はESRIジャパン製品ページをご参照ください。\nライセンスの認証方法 ライセンスの認証は次の2つの方法があります。\n  ライセンスキーを使用した認証\n ライセンスキーを使用した認証は、ArcGIS Runtime の配布パックを購入し、取得したライセンスキーを利用して、アプリケーションを認証します。    指定ユーザーによるアカウント認証\n 指定ユーザーによるアカウント認証とは、ArcGIS Online または ArcGIS Enterprise の組織のメンバーである ArcGIS 組織アカウントを使用してログイン認証を行います。 ログインを行う指定ユーザーアカウントのタイプによって関連付けられたライセンスのレベルが異なり、また認証はアプリにコードを含める必要があります。    指定ユーザーのユーザータイプとライセンスレベルの対比表 ■ ArcGIS Online または ArcGIS Enterprise バージョン 10.8 以降をご利用の場合\n   ユーザータイプ ライセンスレベル     Viewer Lite   Editor / Field Worker Basic   Creator / GIS Professional Basic Standard ※1   GIS Professional Standard / GIS Professional Advanced Advanced ※1    ※1 Standard/Advanced は、バージョン 100.7 以降から対応しております。\n■ ArcGIS Enterprise 10.7 以前をご利用の場合\n   ユーザータイプ ライセンスレベル     レベル1 または Viewer タイプ以上 Lite   レベル2 または Editor タイプ以上 Basic    Lite ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Lite のライセンスキーを取得する必要があります 認証の方法は、Lite ライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Lite ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Basic ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Basic の配布パックを購入する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Basic ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Standard ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Standard の配布パックを購入する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、バージョン 100.7 より以前のバージョンでは使用できません。また、Protal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Standard ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Advanced ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Advanced の配布パックを購入する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、バージョン 100.7 より以前のバージョンでは使用できません。また、Protal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Advanced ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Analysis Extension ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Analysis Extension の配布パックを購入する必要があります 基本ライセンス（Standard または Advanced）と併せて認証する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、バージョン 100.7 より以前のバージョンでは使用できません。また、Protal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Analysis アドオンライセンス拡張機能を割り当てられた）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    ライセンスの認証 以下の認証に応じた作業を行ってください。\nLite ライセンスキーを使用した認証 ArcGIS Runtime Lite のライセンスキーを ArcGIS Developers のサイトから取得し、取得したライセンスキーを利用して、アプリケーションを Lite ライセンスで認証することができます。 最初に以下の手順で Lite レベルのライセンスキーを取得します。\n  ArcGIS Developers: License and deployment ページにアクセスします\n ArcGIS Developers にサインインしてない場合は [Sign in to retrieve your Runtime license string] をクリックします。 ArcGIS 開発者アカウントでサインインします。アカウントをお持ちでない場合は、サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。    表示されたライセンスキーをコピーします   次に、アプリケーションのコードにおいて SDK の機能が呼び出される前に、以下のコードを使用してアプリケーションにコピーしたライセンスキーを設定します。\n// 取得したライセンス文字列でアプリのライセンスを設定します string licenseKey = \u0026#34;runtimelite,1000,rud#########,none,####################\u0026#34;; ArcGISRuntimeEnvironment.SetLicense(licenseKey);   配布パックのライセンスキーを使用した認証 ArcGIS Runtime の配布パックを購入し、取得したライセンスキーを利用して、アプリケーションを認証することができます。\nArcGIS Runtime の配布パックの購入についてはESRIジャパンにお問合せください。ArcGIS Runtime の配布パックをご購入頂いた場合、ESRIジャパンよりライセンスキーをメールにてお送りします。\nアプリケーションのコードにおいて SDK の機能が呼び出される前に、以下のコードを使用して配布パックのライセンスキーを設定します。\n// 取得したライセンス文字列でアプリのライセンスを設定します string licenseKey = \u0026#34;runtimestandard,1000,rud#########,day-month-year,####################\u0026#34;; ArcGISRuntimeEnvironment.SetLicense(licenseKey); Analysis Extension ライセンスを認証する場合は以下のコードを使用します。\n// 基本ライセンスとエクステンション ライセンスのリストを設定します string licenseKey = \u0026#34;runtimestandard,1000,rud#########,day-month-year,####################\u0026#34;; string[] extensions = { \u0026#34;runtimeanalysis,1000,rud#########,day-month-year,####################\u0026#34; }; ArcGISRuntimeEnvironment.SetLicense(licenseKey, extensions); 指定ユーザー アカウントを使用した認証 アプリケーションの実行時に、アプリケーションを利用するユーザーが保有する ArcGIS Online 組織向けプランもしくは Portal for ArcGIS の指定ユーザー アカウントを使用して ArcGIS Online / Portal for ArcGIS にログインすることで、ライセンスを取得することができます。\nアプリケーションのコードにおいて SDK の機能が呼び出される前に、ライセンスを取得・設定します。以下のコードは、ArcGIS Online の指定ユーザーのライセンスを取得する方法を示しています。コードの前半で、ArcGIS Online ポータルを登録し、チャレンジ ハンドラーと OAuth 認証ハンドラーを設定することによって、AuthenticationManager を構成します。\n認証方法の詳細については、「License your app with a named user account（英語）」や「Security and authentication（英語）」も併せてご覧ください。\n// ポータルの認証情報をユーザーに要求します (arcgis.com の OAuth 認証情報のリクエスト) CredentialRequestInfo loginInfo = new CredentialRequestInfo(); // OAuth の暗黙的なグラントフローを使用します loginInfo.GenerateTokenOptions = new GenerateTokenOptions { TokenAuthenticationType = TokenAuthenticationType.OAuthImplicit }; // 認証する URL（ポータル）を指定します（ArcGIS Online） loginInfo.ServiceUri = new Uri(\u0026#34;http://www.arcgis.com/sharing/rest\u0026#34;); try { // AuthenticationManager の GetCredentialAsync を呼び出し、チャレンジハンドラを起動します  Credential cred = await AuthenticationManager.Current.GetCredentialAsync(loginInfo, false); AuthenticationManager.Current.AddCredential(cred); // 認証情報を使用してポータル（ArcGIS Online）に接続します  ArcGISPortal arcgisPortal = await ArcGISPortal.CreateAsync(loginInfo.ServiceUri); // ポータルから LicenseInfo を取得します  LicenseInfo licenseInfo = await arcgisPortal.GetLicenseInfoAsync(); // ... アプリをオフラインにするためにライセンス（JSON 文字列）を保存したり、すぐにアプリを認証するためにコードをここに記述します ...  // ライセンス情報を使ってアプリを認証します  ArcGISRuntimeEnvironment.SetLicense(licenseInfo); } catch (Exception ex) { // 例外処理を記述します。  Console.WriteLine(\u0026#34;ライセンス認証中の例外:\u0026#34; + ex); } 注意：上記のコードスニペットは、バージョン 100.7 で導入された新しい GetLicenseInfoAsync() APIを使用しています。バージョン 100.6 以前では Portal.PortalInfo.LicenseInfo を使用します。\nライセンス情報をローカルストレージに保存した場合、保存したライセンス情報を使用して、オフライン環境でアプリを起動してライセンスを取得できます。ストレージからライセンスを取得し、アプリを認証します。\n// icenseInfo を JSON 形式のテキストとして取得します string licenseJson = licenseInfo.ToJson(); // ... テキスト文字列をローカルに保存します ...  // (起動時) ... デバイスに保存されているライセンス JSON を取得します ... // 保存した JSON 文字列からライセンス情報を設定します LicenseInfo license = LicenseInfo.FromJson(licenseJson); "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/ios/distribution-ios-100.x/",
	"title": "アプリケーション配布ガイド",
	"tags": [],
	"description": "ArcGIS Runtime SDK for iOS を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を紹介します。",
	"content": "ArcGIS Runtime SDK for iOS (バージョン 100.x) を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を説明します。\nAPI キーの設定 ArcGIS Platform のロケーションサービスを使用する場合は、アプリで API キーを設定する必要があります。API キーの詳細はAPI キーの取得を、APIキーの設定方法はアプリの作成のAPI キーを設定するをご覧ください。\nライセンス認証のステップ 開発したアプリケーションのライセンス認証のステップは以下の通りです。\n 使用するライセンスの選択 ライセンスの認証方法  Lite ライセンスの認証方法 Basic ライセンスの認証方法 Standard ライセンスの認証方法 Analysis Extension ライセンスの認証方法   ライセンスの認証  Lite ライセンスキーを使用した認証 配布パックのライセンスキーを使用した認証 指定ユーザー アカウントを使用した認証    使用するライセンスの選択 ArcGIS Runtime SDK for iOS には Lite、Basic、Standard の 3 つのライセンス レベルと Analysis エクステンションがあります。開発したアプリケーションが使用する機能に応じて、適切なライセンス レベルを選択してください。\n各ライセンスで利用可能な機能の概要は以下の表をご参照ください。\n   ライセンス 利用できる機能     Lite ・地図表示（2D/3D）\n・フィーチャの表示/検索\n・フィーチャのオンライン/オフライン編集（パブリックなフィーチャ サービス）\n・ルート検索/到達圏解析/最寄り施設検索\n・住所検索/リバース ジオコーディング   Basic ・Lite ライセンスで利用できるすべての機能\n・フィーチャのオンライン/オフライン編集（セキュアなフィーチャ サービス）\n・モバイル ジオデータベースの編集\n・ArcGIS Online/Portal for ArcGIS のコンテンツの編集   Standard ・Basic ライセンスで利用できるすべての機能\n・シェープファイルの表示/編集\n・GeoPackage の表示/編集\n・KML（ローカル ファイル）の表示\n・ラスター データの表示/解析\n・航海用電子海図（ENC）の表示   Analysis Extension ・Standard ライセンス以上で利用可能なエクステンション・オフラインでの到達圏解析/最寄り施設検索    ライセンスの詳細はESRIジャパン製品ページをご参照ください。\nライセンスの認証方法 ライセンスの認証は次の2つの方法があります。\n  ライセンスキーを使用した認証\n ライセンスキーを使用した認証は、ArcGIS Runtime の配布パックを購入し、取得したライセンスキーを利用して、アプリケーションを認証します。    指定ユーザーによるアカウント認証\n 指定ユーザーによるアカウント認証とは、ArcGIS Online または ArcGIS Enterprise の組織のメンバーである ArcGIS 組織アカウントを使用してログイン認証を行います。 ログインを行う指定ユーザーアカウントのタイプによって関連付けられたライセンスのレベルが異なり、また認証はランタイムアプリにコードを含める必要があります。    指定ユーザーのユーザータイプとライセンスレベルの対比表 ■ ArcGIS Online または ArcGIS Enterprise バージョン 10.8 以降をご利用の場合\n   User Type Runtime Level     Viewer Lite   Editor / Field Worker Basic   Creator / GIS Professional Basic Standard ※1   GIS Professional Standard / GIS Professional Advanced Advanced ※1,2    ※1 Standard/Advanced は ArcGIS Runtime (Android/iOS/.NET) 100.7 以降から対応しております。\n※2 ArcGIS Runtime SDK for iOS には Advanced ライセンスはありません。\n■ ArcGIS Enterprise 10.7 以前をご利用の場合\n   User Type Runtime Level     レベル1 または Viewer タイプ以上 Lite   レベル2 または Editor タイプ以上 Basic    Lite ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Lite のライセンスキーを取得する必要があります 認証の手順は、Lite ライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Lite ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Basic ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Basic の配布パックを購入する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Basic ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Standard ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Standard の配布パックを購入する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証 注意：この認証は、ArcGIS Runtime 100.7 より以前のバージョンでは使用できません。また、Protal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Standard ライセンスレベルを保有する）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    Analysis Extension ライセンスの認証方法   ライセンスキーを使用した認証\n ArcGIS Runtime Analysis Extension の配布パックを購入する必要があります 基本ライセンス（Standard）と併せて認証する必要があります 認証の手順は、配布パックのライセンスキーを使用した認証をご参照ください    ArcGIS Online / Portal for ArcGIS へのログインによる認証\n注意：この認証は、ArcGIS Runtime 100.7 より以前のバージョンでは使用できません。また、Protal for ArcGIS をご利用の場合は、ArcGIS Enterprise 10.7 以前のバージョンでは使用できません。\n アプリケーションを使用するユーザーごとに ArcGIS Online 組織向けプラン/ Portal for ArcGIS の指定ユーザー アカウント（ArcGIS Runtime Analysis アドオン ライセンス拡張機能を割り当てられた）が必要です アプリケーションが少なくとも 30 日に 1 回は ArcGIS Online 組織向けプラン/ Portal for ArcGIS へログインする必要があります 認証の手順は、指定ユーザー アカウントを使用した認証をご参照ください    ライセンスの認証 以下の認証に応じた作業を行ってください。\nLite ライセンスキーを使用した認証 ArcGIS Runtime Lite のライセンスキーを ArcGIS Developers のサイトから取得し、取得したライセンスキーを利用して、アプリケーションを Lite ライセンスで認証することができます。 最初に以下の手順で Lite レベルのライセンスキーを取得します。\n  ArcGIS Developers: ArcGIS Runtime license ページにアクセスします。\n ArcGIS Developers にサインインしてない場合は [Sign in to retrieve your Runtime license string] をクリックします。 ArcGIS 開発者アカウントでサインインします。アカウントをお持ちでない場合は、サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。    表示されたライセンスキーをコピーします。   次に、アプリケーションのコードにおいて ArcGIS Runtime SDK の機能が呼び出される前に、以下のコードを使用してアプリケーションにコピーしたライセンスキーを設定します。\n// 取得したライセンス文字列でアプリのライセンスを設定します do { let result = try AGSArcGISRuntimeEnvironment.setLicenseKey(\u0026#34;runtimelite,1000,rud#########,none,####################\u0026#34;) print(\u0026#34;License Result : \\(result.licenseStatus)\u0026#34;) } catch let error as NSError { print(\u0026#34;error: \\(error)\u0026#34;) }   配布パックのライセンスキーを使用した認証 ArcGIS Runtime の配布パックを購入し、取得したライセンスキーを利用して、アプリケーションを認証することができます。\nArcGIS Runtime の配布パックの購入についてはESRIジャパンにお問合せください。ArcGIS Runtime の配布パックをご購入頂いた場合、ESRIジャパンよりライセンスキーをメールにてお送りします。\nアプリケーションのコードにおいて ArcGIS Runtime SDK の機能が呼び出される前に、以下のコードを使用して配布パックのライセンスキーを設定します。\n// 取得したライセンス文字列でアプリのライセンスを設定します do { let result = try AGSArcGISRuntimeEnvironment.setLicenseKey(\u0026#34;runtimestandard,1000,rud#########,day-month-year,####################\u0026#34;) print(\u0026#34;License Result : \\(result.licenseStatus)\u0026#34;) } catch let error as NSError { print(\u0026#34;error: \\(error)\u0026#34;) } Analysis Extension ライセンスを認証する場合は以下のコードを使用します。\n// 基本ライセンスとエクステンション ライセンスのリストを設定します do { let result = try AGSArcGISRuntimeEnvironment.setLicenseKey(\u0026#34;runtimestandard,1000,rud#########,day-month-year,####################\u0026#34;, extensions: [\u0026#34;runtimeanalysis,1000,rud#########,day-month-year,####################\u0026#34;]) print(\u0026#34;License Result : \\(result.licenseStatus)\u0026#34;) } catch let error as NSError { print(\u0026#34;error: \\(error)\u0026#34;) } 指定ユーザー アカウントを使用した認証 アプリケーションの実行時に、アプリケーションを利用するユーザーが保有する ArcGIS Online 組織向けプランもしくは Portal for ArcGIS の指定ユーザー アカウントを使用して ArcGIS Online / Portal for ArcGIS にログインすることで、ライセンスを取得することができます。\nアプリケーションのコードにおいて ArcGIS Runtime SDK の機能が呼び出される前に、以下のコードを使用してライセンスを取得します。プロセスの一環として、アプリがオフライン環境で最大 30日 間使用されることに備えて、ライセンス情報を保存します。\n認証方法の詳細については、「License your app with a named user account（英語）」や「Security and authentication（英語）」も併せてご覧ください。\n// Portal クラスを作成し、指定ユーザーが資格情報を提供するようにします let theURL = URL(string: \u0026#34;https://www.arcgis.com\u0026#34;) // 指定ユーザーが資格情報を使用してログインするように要求します self.portal = AGSPortal(url: theURL!, loginRequired: true) // ポータルをロードします self.portal.load { (error) in if let error = error { print(error) } else { // ポータルからユーザーのライセンス情報を取得します self.portal.fetchLicenseInfo { (licenseInfo, error) in if let error = error { print(\u0026#34;ユーザーのライセンスの取得中にエラーが発生しました... \\(error)\u0026#34;) return } // 指定ユーザーの licenseInfo を使用してライセンスを設定します do { let result = try AGSArcGISRuntimeEnvironment.setLicenseInfo(licenseInfo!) } catch let error as NSError { print(\u0026#34;error: \\(error.localizedDescription)\u0026#34;) } // これでアプリがライセンス認証されました // アプリを起動してオフラインでライセンスを取得できるように、ライセンス情報を保存します // この例では、licenseDictionary をキーチェーンに保存します var licenseDictionary: NSDictionary? do {licenseDictionary = try licenseInfo?.toJSON() as! NSDictionary? } catch { print(\u0026#34;LicenseInfo は利用できません\u0026#34;) } let keychainItem = AGSKeychainItem(identifier: \u0026#34;com.your_org.your_app_name\u0026#34;, accessGroup: nil, acrossDevices: false) keychainItem.writeObject(toKeychain: licenseDictionary!, completion: { (writeError) in if let error = writeError { print(\u0026#34;キーチェーンへの書き込み中にエラーが発生しました... \\(error)\u0026#34;) } }) } } } 注意：上記のコードスニペットは、ArcGIS Runtime 100.7 で導入された新しい fetchLicenseInfoWithCompletion() API を使用しています。バージョン 100.6 以前では AGSPortal.portalInfo.licenseInfo を使用します。\nライセンス情報をローカルストレージに保存した場合、保存したライセンス情報を使用して、オフライン環境でアプリを起動してライセンスを取得できます。ストレージからライセンスを取得し、アプリのライセンスを取得します。\n// キーチェーンを取得します let keychainItem = AGSKeychainItem(identifier: \u0026#34;com.your_org.your_app_name\u0026#34;, accessGroup: nil, acrossDevices: false) // キーチェーンからライセンスの JSON を取得します let licenseDictionary = keychainItem.readObjectFromKeychain() as? NSDictionary // JSON からライセンス情報を作成します let licenseInfo = try! AGSLicenseInfo.fromJSON(licenseDictionary!) as? AGSLicenseInfo // ライセンス情報を使用してアプリのライセンスを設定します AGSArcGISRuntimeEnvironment.setLicenseInfo(licenseInfo!, error: errorPointer) "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/install-jsapi/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Maps SDK for JavaScript ライブラリのインストール方法を紹介します。",
	"content": "ArcGIS Maps SDK for JavaScript のライブラリを Windows® Server の IIS（インターネット インフォメーション サービス）上に配置して Web アプリからアクセスできる環境を作るまでの流れを紹介します。API の詳細についてはインストールおよびセットアップ方法を参照してください。なお、IIS 以外の Web サーバーや Linux 上の Web サーバー（Apache Tomcat® など）へインストールする場合も基本的な流れは変わりません。\nEsri がホストしている CDN にインターネット経由で参照する場合には、ライブラリをインストールする必要はありません。\nライブラリのダウンロード ライブラリとヘルプ ドキュメントは ArcGIS Developers の Downloads ページからダウンロードできます。[Product] のドロップダウン リストから [ArcGIS Maps SDK for JavaScript] を選択し、ダウンロードしたいバージョンの [API] ボタンをクリックするとダウンロードが開始します。\n※ バージョンによってはインストール方法が本手順とは異なる場合があります。詳しくはダウンロード フォルダ内にあります install.html をご参照ください。\n [arcgis_js_v425_sdk.zip] ボタンをクリックすると https://developers.arcgis.com/javascript/ で公開されているヘルプ ドキュメントとサンプル一式をダウンロードできます。\n Web サーバー（IIS）に配置 まずはダウンロードしたサンプル コードを実行してみましょう。\n ダウンロードしたライブラリの zip ファイルを解凍します。 \\arcgis_js_v424_api\\arcgis_js_api\\javascript\\4.25\\ とすべてのコンテンツをコピーして Web サーバー上に配置します。例 : (C:\\inetpub\\wwwroot\\javascript\\api\\4.25\\)  必要条件 ArcGIS Maps SDK for JavaScript ライブラリおよびドキュメントのデフォルトのホスティング構成は、いずれも HTTPS です。\n  HTTPS では、Web サーバーに Web サーバー証明書を使用する必要があります。\n  IIS には、以下の MIME タイプの登録が必要です。\n   拡張 MIME/type 説明     .ttf application/octet-stream True Typeフォント   .wasm application/wasm WebAssembly   .woff application/font-woff Web Open Font Format   .woff2 application/font-woff2 WOFF File Format 2.0   .wsv application/octet-stream SceneViewの星の可視化に対応      Google: HTTPSが重要な理由\n  Google: HTTPS でサイトを保護する\n  インストールのテスト 以下のサンプルは、ArcGIS Maps SDK for JavaScript のダウンロード版に含まれています。 ArcGIS Maps SDK for JavaScript のダウンロード版から /arcgis_js_v425_api/arcgis_js_api/javascript/4.25/ およびそのすべてのコンテンツを Web サーバにコピーした後、サポートされている Web ブラウザでアプリケーション https://www.example.com/javascript/4.25/index.html を開くことにより、API をテストすることができます。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1,maximum-scale=1,user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Test local installation of ArcGIS Maps SDK for JavaScript\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 93%; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./esri/themes/light/main.css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;./init.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; require([\u0026#34;esri/Basemap\u0026#34;, \u0026#34;esri/layers/TileLayer\u0026#34;, \u0026#34;esri/Map\u0026#34;, \u0026#34;esri/views/SceneView\u0026#34;], function ( Basemap, TileLayer, Map, SceneView ) { // --------------------------------------------------------------------  // If you do not have public internet access, change the layer URL to  // point to your own locally accessible cached service.  // --------------------------------------------------------------------  const layer = new TileLayer({ url: \u0026#34;https://services.arcgisonline.com/arcgis/rest/services/World_Street_Map/MapServer\u0026#34; }); const customBasemap = new Basemap({ baseLayers: [layer], title: \u0026#34;My Basemap\u0026#34; }); const myMap = new Map({ basemap: customBasemap }); const view = new SceneView({ container: \u0026#34;viewDiv\u0026#34;, map: myMap }); checkThisOne(\u0026#34;./esri/views/3d/environment/resources/stars.wsv\u0026#34;, \u0026#34;wsv mimetype\u0026#34;); checkThisOne(\u0026#34;./esri/t9n/basemaps.json\u0026#34;, \u0026#34;json mimetype\u0026#34;); checkThisOne(\u0026#34;./esri/themes/base/icons/fonts/CalciteWebCoreIcons.ttf\u0026#34;, \u0026#34;ttf mimetype\u0026#34;); checkThisOne(\u0026#34;./esri/themes/base/icons/fonts/CalciteWebCoreIcons.woff\u0026#34;, \u0026#34;woff mimetype\u0026#34;); function checkThisOne(url, desc) { fetch(url, { method: \u0026#34;HEAD\u0026#34; }) .then(function (response) { if (response.ok) { logDiv.innerHTML += \u0026#34;* OK: \u0026#34; + desc + \u0026#34;\u0026lt;br/\u0026gt;\u0026#34;; if (response.status !== 200) { logDiv.innerHTML += \u0026#34;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;status: \u0026#34; + response.status + \u0026#34;\u0026lt;br/\u0026gt;\u0026#34;; } return response.blob(); } else { // response not ok  logDiv.innerHTML += \u0026#34;* HTTP error \u0026#34; + response.status + \u0026#39; for \u0026lt;a href=\u0026#34;\u0026#39; + url + \u0026#39;\u0026#34;\u0026gt;\u0026#39; + url + \u0026#34;\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt;\u0026#34;; alert(\u0026#34;Problem accessing \u0026#34; + desc); } }) .catch(function (error) { logDiv.innerHTML += \u0026#39;* BAD: \u0026lt;a href=\u0026#34;\u0026#39; + url + \u0026#39;\u0026#34;\u0026gt;\u0026#39; + url + \u0026#34;\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt;\u0026#34;; }); } }); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;logDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 以下のスクリーンショットのような結果が表示されます。(X.YZの部分は4.25となります。) "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/development-guide/",
	"title": "カスタム ウィジェット開発ガイド",
	"tags": [],
	"description": "カスタム ウィジェットを開発する手順を紹介します。",
	"content": "はじめに このガイドについて このガイドは ArcGIS Web AppBuilder (Developer Edition) （以下、Web AppBuilder）で使用するカスタム ウィジェットを作成する方法を説明します。\nWeb AppBuilder のインストール方法に関しては、ArcGIS Web AppBuilder (Developer Edition) インストールガイドをご参照ください。\nまた Esri Japan GitHub では、Web AppBuilder のカスタム ウィジェット/テーマが共有されています。このガイドで作成するウィジェットの完成版も公開されています。\n既成ウィジェットのソースコードの確認 Web AppBuilder で使われる全てのウィジェットは \u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\client\\stemapp\\widgets に格納されていて、ソースコードを確認できます。開発したカスタム ウィジェットも同様にこのディレクトリに配置します。\n上記ディレクトリにある samplewidgets フォルダーには簡易機能のサンプル ウィジェットが用意されています（本ガイドではウィジェット作成の雛形となるコードが記述されたテンプレートである CustomWidgetTemplate を使用します）。\nウィジェットのフォルダー構成 カスタム ウィジェットを作成する際に使用するファイルは以下です。全ファイルが必須ではなく、ウィジェットの UI を設ける、ウィジェットをローカライズする、設定画面を設ける等の目的に応じてファイルを準備します。\nカスタム ウィジェットの開発 1. ウィジェット ボタンを配置する Web AppBuilder のウィジェットは2 種類に分けられます。1 つは「描画」ウィジェットのようなパネルを表示して使用するウィジェットです（Web AppBuilder では In-Panel ウィジェットと呼びます）。もう 1 つは、「現在位置」ウィジェットのように画面上にボタンのみを配置するパネルを表示しないウィジェットです（Off-Panel ウィジェットと呼びます）。\n本ガイドでは簡単なバッファー検索を行う In-Panel ウィジェットを開発していきます。ウィジェットを追加するには \u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\client\\stemapp\\widgets にウィジェットのフォルダーを配置します。\n`\\client\\stemapp\\widgets\\samplewidgets` にある `CustomWidgetTemplate` フォルダーを `\\client\\stemapp\\widgets` にコピーします。\r`CustomWidgetTemplate` フォルダーの名前を `Buffer` に変えます。\nフォルダー名は半角英数字である必要があります。\n\r`Buffer` フォルダー直下にある `manifest.json` ファイルを開きます。\r`name` 属性の値を `Buffer` に変更します。\r文字コードに UTF8 を指定して、`manifest.json` ファイルを保存します。 以降で紹介する手順においてもファイルを保存する際は、文字コードを UTF8 に指定して保存するようにしてください。\r\rmanifest.json ウィジェットの名前やバージョンなどのウィジェットの属性を設定するファイルです。properties 属性でカスタム ウィジェットのプロパティを構成できます。inPanel を false に設定すると Web AppBuilder のウィジェットの追加画面に表示されなくなります。ウィジェットのプロパティについてはWidget manifestをご参照ください。\nWeb AppBuilder のウィジェットの追加画面で表示されるウィジェット名をローカライズします。ウィジェットのローカライズは `Buffer` フォルダーの直下にある `nls` フォルダーで設定します。`Buffer\\nls` フォルダーにある `strings.js` ファイルを開き、以下のコードを入力し保存します。 define({\rroot: ({\r_widgetLabel: \"Buffer\"\r}),\r\"ja\": 1\r});\r\r`nls` フォルダー直下に `ja` フォルダーを作成します。\r`ja` フォルダーに `strings.js` ファイルを作成し、以下のコードを入力し保存します。 define({\r_widgetLabel: \"バッファー検索\"\r});\r\rWeb AppBuilder を起動してアプリケーションを作成すると、ウィジェットの追加画面に「バッファー検索」というウィジェットが新しく表示されます。\n※ 作成する Web アプリに表示するウィジェット名は Web AppBuilder のウィジェット構成画面で変更可能です。\r\r\rnls フォルダー カスタム ウィジェットを多言語化する場合に使用します（アクセスするブラウザーのロケールにより該当する言語が表示されます）。_widgetLabel はウィジェット追加時に表示されるラベルをローカライズするための固有の属性です。\n使用例\n nls\\strings.js：「Widget.html」でローカライズするストリングを指定  define({ root: ({ label1: \u0026#34;Hello\u0026#34; }), \u0026#34;ja\u0026#34;: 1 // 日本語ロケールを使用する場合に 1 と設定 });  nls\\ja\\strings.js：各言語フォルダーにある strings.js ファイルで表示する文字を設定  define({ label1: \u0026#34;こんにちは\u0026#34; });  Widget.html：文字を表示  \u0026lt;label\u0026gt;${nls.label1}\u0026lt;/label\u0026gt; images\\icon.png カスタム ウィジェットのボタンのアイコンを変更したい場合は、このファイルを置き換えます。\n2. ウィジェットの構成画面を作成する Web AppBuilder でウィジェットの構成を行う画面を作成します。ここでは検索に使用するバッファーの距離単位を設定する画面を作成します。\n  Buffer フォルダーに setting フォルダーを作成します。\n  setting フォルダーに Setting.html ファイルを作成し、以下のコードを入力します。\n  \u0026lt;div\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;td\u0026gt;距離単位\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;div\u0026gt; \u0026lt;select data-dojo-attach-point=\u0026#34;selectLengthUnit\u0026#34; data-dojo-type=\u0026#34;dijit/form/Select\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;kilometers\u0026#34; selected=\u0026#34;selected\u0026#34;\u0026gt;キロメートル\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;meters\u0026#34;\u0026gt;メートル\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; setting フォルダーに Setting.js ファイルを作成し、以下のコードを入力します。  define([ \u0026#39;dojo/_base/declare\u0026#39;, \u0026#39;dijit/_WidgetsInTemplateMixin\u0026#39;, \u0026#39;jimu/BaseWidgetSetting\u0026#39;, \u0026#39;esri/units\u0026#39;, \u0026#39;dijit/form/Select\u0026#39; ], function(declare, _WidgetsInTemplateMixin, BaseWidgetSetting, esriUnits) { return declare([BaseWidgetSetting, _WidgetsInTemplateMixin], { baseClass: \u0026#39;jimu-widget-buffer-setting\u0026#39;, startup: function() { this.inherited(arguments); if (!this.config.measurement) { this.config.measurement = {}; } this.setConfig(this.config); }, setConfig: function(config) { this.config = config; if (this.config.measurement.LengthUnit) { this.selectLengthUnit.set(\u0026#39;value\u0026#39;, this.config.measurement.LengthUnit); } else { // デフォルトで表示される単位をキロメートルに設定  this.selectLengthUnit.set(\u0026#39;value\u0026#39;, \u0026#39;kilometers\u0026#39;); this.config.measurement.UnitLabel = \u0026#39;キロメートル\u0026#39;; } }, getConfig: function() { // ユーザーが単位を変更した時に config.json にその値を格納  this.config.measurement.LengthUnit = this.selectLengthUnit.value; // ウィジェットのパネルに表示する単位ラベルに使用  if (this.config.measurement.LengthUnit === \u0026#39;kilometers\u0026#39;) { this.config.measurement.UnitLabel = \u0026#39;キロメートル\u0026#39;; } else { this.config.measurement.UnitLabel = \u0026#39;メートル\u0026#39;; } return this.config; } }); }); Buffer フォルダーの config.json ファイルを開き、以下のコードを入力します。  { \u0026#34;measurement\u0026#34;: {} } Buffer\\manifest.json を開き hasSettingLocale と hasSettingStyle 属性を false にします。\nsetting フォルダーに css や nls フォルダーを作成することで、構成画面用のスタイル定義、ローカライズが可能ですが、ここでは使用しないため false にします。 ブラウザーを更新して、バッファー検索ウィジェットを追加すると、ウィジェットの構成画面が表示されます。\n変更を反映するために Web AppBuilder を再起動（Node.js の再起動およびブラウザーで Web AppBuilder を更新）する必要がある場合があります。   Setting\\Setting.html Web AppBuilder でウィジェットの設定を行う画面を作成します。\nSetting\\Setting.js Web AppBuilder でウィジェットの設定を行う際の処理を実装します。jimu/BaseWidgetSetting の子クラスを作成し、baseClass に jimu-widget-\u0026lt;ウィジェット名\u0026gt;-setting を指定します。以下のイベントが用意されています。\n setConfig：設定画面の初期化時 getConfig：設定変更時（変更内容を config.json のオブジェクトに格納）  config.json JSON 形式のオブジェクト格納ファイルです。Web AppBuilder でウィジェットの設定を行う場合は、config.json に用意した空のオブジェクトに値を格納して、 Widget.html や Widget.js からそのオブジェクトを取得します。 3. ウィジェットの処理を実装する   Buffer フォルダーにある Widget.html ファイルを開き編集します。バッファーの半径（inputNode）とマップ上にあるレイヤーから検索対象のレイヤーを選択（layerSelectNode）する画面を作成します。\n\u0026lt;div\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;半径を入力（${config.measurement.UnitLabel}）\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;input class=\u0026#34;jimu-input\u0026#34; data-dojo-attach-point=\u0026#34;inputNode\u0026#34; value=\u0026#34;1000\u0026#34;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;検索レイヤーを選択\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;div data-dojo-attach-point=\u0026#34;layerSelectNode\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt;   Buffer フォルダーにある Widget.js ファイルを開き編集します。\n  define([ \u0026#39;dojo/_base/declare\u0026#39;, \u0026#39;dojo/_base/lang\u0026#39;, \u0026#39;jimu/BaseWidget\u0026#39;, \u0026#39;jimu/LayerStructure\u0026#39;, \u0026#39;esri/geometry/geometryEngine\u0026#39;, \u0026#39;esri/symbols/SimpleMarkerSymbol\u0026#39;, \u0026#39;esri/symbols/SimpleLineSymbol\u0026#39;, \u0026#39;esri/symbols/SimpleFillSymbol\u0026#39;, \u0026#39;esri/Color\u0026#39;, \u0026#39;esri/graphic\u0026#39;, \u0026#39;esri/tasks/query\u0026#39;, \u0026#39;dijit/form/Select\u0026#39; ], function(declare, lang, BaseWidget, LayerStructure, geometryEngine, SimpleMarkerSymbol, SimpleLineSymbol, SimpleFillSymbol, Color, Graphic, Query, Select) { return declare([BaseWidget], { baseClass: \u0026#39;jimu-widget-buffer\u0026#39;, ckickfunction: null, layerList: null, layerId: null, // スタートアップ時に実行されるメソッド  startup: function() { this.inherited(arguments); // マップ上のレイヤーを取得し、レイヤー一覧を作成  var options = []; var layerStructure = LayerStructure.getInstance(); layerStructure.traversal(function(layerNode) { layerNode.getLayerType() .then(function(type) { if (type === \u0026#39;FeatureLayer\u0026#39;) { var option = { value: layerNode.id, label: layerNode.title }; options.push(option); } }) .catch(function(err) { console.log(err); }); }); this.layerList = new Select({ options: options }, this.layerSelectNode); this.layerList.startup(); // レイヤー一覧を変更したときのイベント  this.layerList.on(\u0026#34;change\u0026#34;, lang.hitch(this, function(val) { this.layerId = val; })); }, // ウィジェットのパネルを開くときに実行されるメソッド  onOpen: function() { this.inherited(arguments); // マップをクリックしたときのイベント ハンドラ  this.ckickfunction = this.map.on(\u0026#34;click\u0026#34;, lang.hitch(this, this._clickHandler)); }, // ウィジェットのパネルを閉じるときに実行されるメソッド  onClose: function() { this.inherited(arguments); // マップに表示されているグラフィックを削除  this.map.graphics.clear(); // マップのクリック イベントを削除  this.ckickfunction.remove(); }, // マップのクリック イベント  _clickHandler: function(evt) { // マップ コンストラクタを取得  var map = this.map; // マップに表示されているグラフィックを削除  map.graphics.clear(); // inputNode に入力された半径の値を取得  var distance = this.inputNode.value; // ウィジェット構成時に設定した半径の単位を config.json から取得  var unit = this.config.measurement.LengthUnit; // クリック地点から指定した半径のバッファーを作成  var bufferGeometry = geometryEngine.buffer(evt.mapPoint, distance, unit); // 作成したバッファーをマップに表示  var sfs = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASHDOT, new Color([255, 0, 0]), 2), new Color([255, 255, 0, 0.25])); var graphic = new Graphic(bufferGeometry, sfs); map.graphics.add(graphic); // バッファー内のフィーチャを検索  var query = new Query(); query.geometry = graphic.geometry; query.spatialRelationship = Query.SPATIAL_REL_CONTAINS; // マップからレイヤー ID を指定してフィーチャ レイヤーを取得  var layer = map.getLayer(this.layerId); // フィーチャ レイヤーに対してクエリを実行  layer.queryFeatures(query) .then(function(featureSet) { // ポイント、ライン、ポリゴンごとにシンボルを設定  var highlightSymbol; if (layer.geometryType == \u0026#34;esriGeometryPoint\u0026#34;) { highlightSymbol = new SimpleMarkerSymbol(); highlightSymbol.setColor(new Color(\u0026#34;#f00\u0026#34;)); highlightSymbol = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE, 16, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([255, 0, 0]), 1), new Color([255, 0, 0, 0.5])); } else if (layer.geometryType == \u0026#34;esriGeometryPolyline\u0026#34;) { highlightSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([255, 0, 0, 0.5]), 6); } else { highlightSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([255, 0, 0]), 3), new Color([125, 125, 125, 0.5])); } // 結果を表示  featureSet.features.forEach(function(feature) { var queryGraphic = new Graphic(feature.geometry, highlightSymbol); map.graphics.add(queryGraphic); }); }); } }); }); Web AppBuilder で新しくアプリケーションを作成します。 Web AppBuilder でフィーチャ サービスをレイヤーとして追加した Web マップを表示します（このウィジェットはフィーチャ レイヤーに対してバッファー検索を行います）。 バッファー検索ウィジェットを追加し、バッファー検索ウィジェットのボタンをクリックして、半径とレイヤーを設定します。\n マップ上をクリックすると、バッファー内にあるフィーチャがハイライト表示されます。\n  Widget.html ウィジェットの画面を作成します。Web AppBuilder には、デフォルトでいくつかの css クラスが含まれており、アプリのデザインを統一させることができます。各クラスの詳細は css ファイル（jimu.js/css/jimu.css）を参照ください。\n使用例：\n\u0026lt;input class=\u0026#34;jimu-input\u0026#34; data-dojo-attach-point=\u0026#34;inputNode\u0026#34; value=\u0026#34;10000\u0026#34;\u0026gt;\u0026lt;/input\u0026gt; css\\style.css Widget.html のスタイル定義ファイルです。\n使用例：\njimu-widget-\u0026lt;ウィジェット名\u0026gt; div:first-child { color: red; } Widget.js ウィジェットの機能を実装するファイルです。jimu/BaseWidget の子クラスを作成し、\u0026quot;baseClass\u0026quot; に jimu-widget-\u0026lt;ウィジェット名\u0026gt; を指定します。\n\u0026quot;baseClass\u0026quot; は、ウィジェットの css クラスとして適用されるためスタイルの競合を避けることができ、スタイルを定義する際に役立ちます。\nウィジェットのプロパティ Web AppBuilder で表示しているマップには map プロパティを使用してアクセスします。\n使用例：\n Widget.js：  this.mapIdNode.innerHTML = \u0026#39;マップのID：\u0026#39; + this.map.id;  Widget.html：  \u0026lt;div data-dojo-attach-point=\u0026#34;mapIdNode\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; その他に利用可能なプロパティは以下です。\n id label icon uri position config（config.json のオブジェクト） appConfig（アプリの構成ファイルのオブジェクト） folderUrl state（ウィジェットの状態：\u0026quot;opened\u0026quot;、\u0026quot;closed\u0026quot; または \u0026quot;active\u0026quot;） windowState（ウィジェット ウィンドウの状態：\u0026quot;normal\u0026quot;、\u0026quot;minimized\u0026quot; または \u0026quot;maximized\u0026quot;） started（ウィジェットの起動状態） name baseClass templateString  ウィジェットのメソッド ウィジェットは、読み込みやウィジェットの開閉などのイベントの発生で実行されるメソッドが定義されています（ウィジェット ライフサイクル）。このメソッド内に処理を追加することで、ウィジェットをカスタマイズしていきます。\n例えば、ウィジェットが開かれた時に処理を実行するには onOpen メソッドを使用します。\n使用例：\nonOpen: function() { var map = this.map; // ... } その他に利用可能なメソッドは以下です。\n onOpen onClose onNormalize onMinimize onMaximize onActive onDeActive onSignIn onSignOut onPositionChange  利用可能な Dojo のウィジェット Web AppBuilder では Dojo Toolkit が提供しているウィジェット（dijit）を使用することができます。\nさらに、Web AppBuilder 独自のウィジェット（jimu.js/dijit）も提供されています。\nヘルプに使用方法は記載されていませんが、Web AppBuilder に含まれている以下のウィジェットも使用できます。\n CheckBox RadioBtn DrawBox ColorPicker Popup ImageChooser TabContainer ExtentChooser Message LayerFieldChooser PopupConfig SymbolChooser  nls ウィジェットで表示されるメニューを多言語化する場合に使用します。ウィジェット名をローカライズした方法と同様の手順でローカライズできます。\nウィジェットの更新 Web AppBuilder に追加する場合 \u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\client\\stemapp\\widgets にフォルダーを配置します。ウィジェットの構成用ファイルを更新した場合は、ブラウザーで Web AppBuilder を更新することで、更新内容が Web AppBuilder に反映されます。\n※ 更新前に作成したアプリケーションには更新内容は反映されません。新たに設置したカスタム ウィジェットを利用したい場合は、新たにアプリケーションを作成する必要があります。\nダウンロードした Webアプリケーションに追加する場合 ダウンロードしたアプリケーションの widgets フォルダーの直下にカスタム ウィジェットのフォルダーを配置し、アプリケーションのルート フォルダーにある config.json の widgetOnScreen（マップ上に表示）または widgetPool（ツールバー上に表示）セクションの widgets 属性にウィジェットの参照先等を設定します。\nwidgetPool にウィジェットを追加する例：\n{ \u0026#34;name\u0026#34;: \u0026#34;\u0026lt;ウィジェット名\u0026gt;\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;\u0026lt;アプリで表示する名前\u0026gt;\u0026#34;, \u0026#34;uri\u0026#34;: \u0026#34;widgets/\u0026lt;ウィジェット名\u0026gt;/Widget\u0026#34; } ウィジェット開発時の Tips Web AppBuilder では新規にアプリケーションを作成するときに、\u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\client\\stemapp\\widgets フォルダーに配置されたウィジェットが読み込まれます。作成済みの既存アプリケーションには、ウィジェットの更新内容は反映されないため、ウィジェットを更新する度に新規にアプリケーションを作成する作業が発生してしまい、非常に面倒です。\n開発段階でウィジェットの更新や動作確認を行うには、以下の手順が便利です。\n Web AppBuilder で新規にアプリケーションを作成します。 \u0026lt;Web AppBuilder のインストール ディレクトリ\u0026gt;\\server\\apps フォルダーを開きます。このフォルダーには Web AppBuilder で作成したアプリケーションが配置されています。\nフォルダー名にはアプリケーションの作成順に数字が割り当てられます。\n 手順1で作成したアプリケーションのフォルダーを開き、ウィジェットの構成ファイルを更新します。アプリケーション名は、各アプリケーションのルート フォルダーにある config.json ファイルに記載された JSON の title 属性で確認できます。\n Web AppBuilder で該当するアプリケーションを開きます。既に開いている場合はブラウザーを更新します。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/calcite-design-system/core-concepts/",
	"title": "コア コンセプト",
	"tags": [],
	"description": "Web コンポーネントを活用するための基本的な概念とパターンを学びます。",
	"content": "出典：Calcite Design System - core concepts\nCalcite Components は、Stencil.js を使用して構築された、再利用可能な Web コンポーネントのライブラリです。Calcite Components を使用すると、ブランド力のある、軽量でアクセスしやすい Web アプリケーションをすばやく構築できます。\nWeb コンポーネントはブラウザのネイティブ規格であり、Calcite Components で開発するために必要な技術的概念の多くは、このライブラリに固有のものではありません。このページでは、効果的な開発を行うために必要な、Web の主要コンセプトを紹介しています。さらに詳しい情報について、このページにあるすべての概念は、MDN Web Docs やその他の Web 標準ドキュメントのソースで見つけることができます。\nカスタム要素 カスタム要素は、Web コンポーネント標準の一部であり、HTML と任意の JavaScript ライブラリまたは Web フレームワークを使用して、モダン ブラウザ全体で動作します。カスタム要素は機能をカプセル化するため、他のコードとのコンフリクトを防ぐことができます。\nCalcite Components はカスタム要素であり、ネイティブの HTML 要素と同様に使用することができます。\n\u0026lt;calcite-tip heading=\u0026#34;Platypus\u0026#34;\u0026gt;\u0026lt;/calcite-tip\u0026gt;  スロット スロットはプレースホルダー要素であり、スロットの名前を参照することで独自のコンテンツを追加することができます。スロットは一般的な Web コンポーネントの概念であり、あなたもすでに使用している可能性があります。例えば、次のような HTML を考えてみましょう。\n\u0026lt;select\u0026gt; \u0026lt;option value=\u0026#34;platypus\u0026#34;\u0026gt;Platypus\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;sloth\u0026#34;\u0026gt;Sloth\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;armadillo\u0026#34;\u0026gt;Nine-banded armadillo\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; Web コンポーネントの用語で、option 要素は select のデフォルト スロットに配置されます。また、「Platypus」、「Sloth」、「Nine-banded」のテキストは、それぞれの option のデフォルト スロットに配置されます。\nまた、多くの Calcite Components は、デフォルトのスロットを利用しています。例えば、下の calcite-tip では、デフォルトのスロットに p コンテンツが追加されています。\n\u0026lt;calcite-tip heading=\u0026#34;Platypus\u0026#34;\u0026gt; \u0026lt;img slot=\u0026#34;thumbnail\u0026#34; src=\u0026#34;platypus.jpg\u0026#34; alt=\u0026#34;A platypus sensing its prey using electrical fields.\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;A platypus is a mammal with a bill, similar to a duck. They use their bill to sense prey via electrolocation.\u0026lt;/p\u0026gt; \u0026lt;/calcite-tip\u0026gt; 多くの場合、デフォルトのスロットがあれば十分です。しかし、コンポーネントが複雑になればなるほど、子要素の位置やスタイルを変える必要が出てきます。そこで活躍するのがネームドスロットです。上の例では、チップの thumbnail スロットに画像が配置されています。これは、画像がデフォルトスロットの要素とは異なる方法で処理されるべきであることをコンポーネントに通知するものです。\nもしコンポーネントにスロットがあれば、slots for calcite-card のように、ドキュメントに記載されます。また詳細については、slots on MDN で学ぶこともできます。\n Shadow DOM カスタム要素はカプセル化され、そのマークアップ構造、スタイル、動作はページ上の他のコードから隠され、分離された状態に保たれます。Shadow DOM は、カスタム要素をカプセル化する仕組みです。その結果、Shadow DOM は Web コンポーネントの DOM 要素を隠して分離するため、ブラウザでレンダリングされますが、他のコードとぶつかることはありません。\nShadow DOM のカプセル化により、アプリケーション間で永続的なスタイルと機能を実現し、ユーザーに一貫したユーザー エクスペリエンスを提供することができます。\n CSS 変数 Calcite Components は、スタイルを上書きするための CSS 変数を提供しています。Web コンポーネントの Shadow DOM のため、CSS 変数がないと簡単にスタイルを変更することができません。トークンには CSS 変数があり、color や typography など、デザインシステム全体で使用されます。\nさらに、一部の Calcite Components には、コンポーネント固有のスタイルを変更するための独自の CSS 変数があります。これらの CSS 変数は、CSS variables for cacite-loader のように、コンポーネントのドキュメントで見つけることができます。\n使用例としては、CSS 変数を使用して、calcite-notice の前景色と文字色を入れ替えることができます。\ncalcite-notice { --calcite-ui-foreground-1: #151515; --calcite-ui-text-1: #ffffff; } CSS variable MDN documentation に、機能の詳細が説明されています。\n コンポーネント ロード Web コンポーネントはプレーンなHTML要素として始まり、その実装がブラウザで定義されると同時にアップグレードされます。Calcite Components は、インポートされ、アプリケーションで使用されると、自動的に定義されます。しかし、特定のコードを実行する前に、コンポーネントが定義されるまで待つ必要がある場合があります。\nハイドレーション Stencil.js では、コンポーネントとそのすべての子コンポーネントのハイドレーションが終了したときに、フラグを追加するオプションが用意されています。これにより、様々なコンポーネントのダウンロードとレンダリングが非同期に行われるため、FOUC（Flash of Unstyled Content）を防止することができます。Calcite Components では、一度ハイドレーションされたコンポーネントに calcite-hydrated というCSSクラスが追加され、アプリケーションをデバッグする際に便利です。\n定義されたとき customElementRegistry インターフェースの whenDefined() メソッドは、指定された要素が定義されたときに満たされる Promise を返します。\nPromise が満たされると、次のようにコンポーネントの定義を必要とするコードを実行できるようになります。\ncustomElements .whenDefined(\u0026#34;calcite-button\u0026#34;) .then(() =\u0026gt; document.querySelector(\u0026#34;calcite-button\u0026#34;).setFocus());  イベント Calcite Components は、CustomEvent() コンストラクターを使用してイベントの作成とトリガーを行います。\nCustomEvent は Event と似たような振る舞いをします。これは button をクリックしたときなどの HTML 要素から放出されます。例えば、イベント ペイロードの target プロパティで要素にアクセスすることは可能です。また、一部の CustomEvent のペイロードは、detail プロパティにイベント固有の情報を含みます。\nコンポーネントのドキュメント ページを表示すると、calcite-pagination event のようなイベントを持つかどうかを確認することができます。\ndocument.addEventListener(\u0026#34;calcitePaginationChange\u0026#34;, (event) =\u0026gt; { console.log(\u0026#34;Pagination\u0026#39;s starting item:\u0026#34;, event.detail.start); console.log(\u0026#34;Number of items per page:\u0026#34;, event.target.num); });  テーマ Calcite Components にはライトとダークのテーマがあり、対応する CSS クラスである calcite-theme-light と calcite-theme-dark を使って変更することができます。また、calcite-theme-auto クラスがあり、ブラウザの prefers-color-scheme CSS メディア クエリに従い、明るいテーマか暗いテーマを使用するかを決定します。\nある要素にテーマ クラスを設定すると、そのすべての子ノードも変更されます。したがって、アプリケーション全体を明るい状態から暗い状態に切り替えるには、次のようにします。\n\u0026lt;body class=\u0026#34;calcite-theme-dark\u0026#34;\u0026gt; \u0026lt;!-- Your application content --\u0026gt; \u0026lt;/body\u0026gt; "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/",
	"title": "コア コンセプト",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) のコア コンセプトについて紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Core concepts\nはじめに Experience Builder は、カスタム ウィジェットの作成、カスタム テーマの作成、カスタム データソース、メッセージ/アクションの作成を通じて拡張することが可能です。これらはすべて、以下のコンポーネントで構成されているjimu と呼ばれる Experience Builder の拡張フレームワークを使用することで可能になります。\n ArcGIS Maps SDK for JavaScript 4.x React + Redux フレームワーク Bootstrap 4 （UI用） HTML5  Experience Builderでウィジェットやテーマなどを開発するには、TypeScript が必要になります。TypeScript を利用するのは、次のようなメリットがあります。\n 型宣言によるエラー検出 よりよい IDE 体験 セルフ-ドキュメント コード より読みやすく、わかりやすい  Experience Builder アプリケーションは多くのパーツで構成されています。これらのコンセプトは、アプリケーションの構造を理解するのに役立ちます。\n ページ（Page） \n ウィンドウ（Window） \n セクションとビュー（Section and view） \n 画面グループ（Screen groups） \n レイアウト（Layout） \n テーマ（Theme） \n ウィジェット（Widget） \n Jimu \n データ ソース（Data source） \n データアクション（Data action） \n メッセージ と アクション（Message and action） \n マップ/シーン ビュー（Map/Scene View） \n 拡張ポイント（Extension points） \n\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/visualization/data-visualization-procedure/",
	"title": "データ可視化の手順",
	"tags": [],
	"description": "ArcGIS Online 上のデータを可視化するための方法を紹介します。",
	"content": "ArcGIS Online 上のデータを可視化するための方法  マップを作成したい シンボルを変更したい ラベルを変更したい  マップを作成したい マップ ビューアー → [追加] → [保存]\n緯度経度の情報を持ったCSV ファイルなどを、レイヤーとしてマップに追加し、様々なレイヤーを組み合わせてマップを作成することができます。マップの保存には、コンテンツを作成する権限が必要です（権限を持っていない場合でもマップは作成できますが、保存することはできません）。\n  マップ ビューアーを開きます。マップ ビューアーを開いた時点でベースとなる背景地図(ベースマップ)は自動的に表示されます。\n  [追加] をクリックします。\n  [レイヤーの検索]、[Living Atlas レイヤーの参照]、[Web からレイヤーを追加]、[ファイルからレイヤーを追加]、[マップ メモの追加] いずれかのレイヤーの追加方法を選択します。\n  それぞれのレイヤー追加方法は、以下の通りです。\nレイヤーの検索   [検索] ボックスにキーワードを入力し、[検索] をクリックします。 [検索先] ドロップダウン リストでは、検索する場所を限定することができ、また、[マップ エリア内] のチェックボックスをオンにすると、マップ ビューアーの表示範囲にあるレイヤーを検索することができます。\n  検索結果は下部のボックス内に表示され、レイヤー名の右にある [追加] をクリックするか❶、レイヤー名をクリックしたのちに❷、[マップに追加] ❸をクリックします。\n  [レイヤーの追加を完了] をクリックし、レイヤーの追加を終了します。\n  Living Atlas レイヤーの参照 米国 Esri 社やほかのユーザーが提供する高品質マップ レイヤーをマップに追加します。レイヤーの詳細は、アイテム説明で確認できます。レイヤーによっては、組織向けアカウントでのサイン インが必要であったり、クレジットを消費するものがあります。\nWeb からレイヤーの追加 URL を指定して、ArcGIS Server Web サービス、OGC WMS Web サービス、OGC WMTS Web サービス、Web サーバー上にあるタイル レイヤー、KML ファイル、GeoRSS ファイル、および CSV ファイルのレイヤーを追加することができます。\nファイルからレイヤーを追加  [ファイルを選択] をクリックして、コンピューター上のファイル（区切りテキスト ファイル（.csv または .txt）、GPS Exchange Format（.gpx）ファイル、またはシェープファイル（.zip に圧縮済み））を選択します。  この方法で追加できるレイヤーのフィーチャ数の上限は、1,000フィーチャです。\r1,000フィーチャ以上のデータを持つファイルを追加する場合、[マイ コンテンツ] ページの [アイテムの追加] で行う方法があります。\r[レイヤーのインポート] をクリックします。 [CSV レイヤーの追加] ダイアログが表示された場合は、緯度/経度あるいは住所の情報を含んでいるフィールドを選択します。[レイヤーの追加] をクリックして、レイヤーの追加を終了します。  マップ メモの追加   [マップ メモの追加] ダイアログで、[名前] フィールドでレイヤー名を、[テンプレート] ドロップダウン リストから任意のマップ メモのテンプレートを選択します。\n  [マップ メモの追加] ダイアログで、名前を入力し、テンプレートをドロップダウン リストから選択して、[作成] をクリックします。\n  フィーチャの追加パネルが表示されるので、マップに追加するシンボルを選択します。\n  マップの任意の位置をクリックすると、その位置にシンボルが表示されると同時にポップアップが開き、タイトルや説明などを入力することができます。\n  コンテンツ パネルでレイヤーが追加されたことを確認し、追加されたレイヤー名にマウス オンするかレイヤー名をクリックし、から [レイヤーの保存] をクリックします。\n  [アイテムの作成] ダイアログでレイヤーのタイトル、タグ、サマリー（説明）を入力し、保存するフォルダーを選択して [アイテムの作成] をクリックします。\n~~~~\rタグを入力して、Enter キーを押すと、入力文字を確定できます。\r~~~~\r  マップを保存するために、[保存] → [保存] をクリックします。\nマップの保存では、マップ ビューアー上で参照しているレイヤーやその表示設定などが保存されます。\rマップ上で設定したレイヤーのシンボルなどは、レイヤー自体には保存されないため、他のマップでそのレイヤーを追加したときには、\r再度、シンボルの設定等を行う必要があります。\r  タイトル、タグ、サマリー（説明）を入力し、保存するフォルダーを選択し、[マップの保存] をクリックします。\n  [マイ コンテンツ] ページに移動し、マップが のような地図のアイコンで保存されていることを確認できます。\n緯度経度、または住所情報を含むテキスト ファイル（ *.txt、 *.csv）であれば、マップ表示エリアにファイルをドラッグ \u0026amp; ドロップすることで、ポイント フィーチャ レイヤーとしてマップに追加できます。フィールドはカンマ、セミコロン、またはタブで区切る必要があり、その他の区切り文字はサポートされていません。また、緯度経度は、10進度である必要があります。Google Chrome、Mozilla Firefox、Internet Explorer 10以降で利用可能です。\n 日本語を含むテキストファイルを使用するためには、Windows の「メモ帳」でファイルを開き、[ファイル] メニュー → [名前を付けて保存] をクリックし、[名前を付けて保存] ダイアログの下部に表示される [文字コード] ドロップダウン リストから [UTF-8] を指定して [保存] ボタンをクリックします。  保存したファイルを、マップ ビューアー上にドラッグ \u0026amp; ドロップします。  [CSV レイヤーの追加] 画面が表示されます。住所が入力されている場合は、[使用しているフィーチャの特定] では [住所] を指定し、[国] ドロップダウン リストから 「日本」 を選択します。 住所が入力されているフィールド名をクリックし、[場所フィールド] で [住所/大字町丁目以降] を選択します。 [レイヤーの追加] ボタンをクリックします。    シンボルを変更したい マップ ビューアー → [詳細] → [コンテンツ] → レイヤー名にマウス オン / クリック → [スタイルの変更]\nシンボルの色や形を変更します。コンテンツを作成する権限を持っている場合に可能です。\n  マップ ビューアーの [詳細] が選択されていることを確認し、[コンテンツ] をクリックします。\n  シンボルを変更したいレイヤー名にマウス オン / クリックし、[スタイルの変更] のアイコンをクリックします。\n  [スタイルの変更] パネルが表示されます。\n  [①表示する属性を選択] ドロップダウン リストから、シンボルの設定をする属性フィールドを選択します。 属性値でシンボル設定をしない場合は、[場所のみ表示] を選択します。\n  [②描画スタイルの選択] で、変更したい描画方法の [選択] をクリックします。既に選択されている描画スタイルは [オプション] と表示されます。\n一種類の属性フィールドによるシンボル設定 場所（単一シンボル） すべてのフィーチャを同じシンボルで表現します。\n種類 (個別値シンボル) 樹木の種類、道路クラス、都道府県名など、属性のカテゴリごとにシンボルを割り当てて描画します。\n数と量（サイズ） 数値またはランク付けされたデータをシンボルの大きさで表現します。データの数値が大きいほど、シンボルの大きさも大きく表示されます。\n数と量（色） 数値またはランク付けされたデータを色の濃淡で表現します。データの数値が大きいほど濃い色で、小さいほど淡い色で表示することなどができます。\nヒート マップ ポイントが集中しているエリアを一目で確認できるような表現ができます。\n日付データによるシンボル設定 属性フィールドに日付データを含むフィールドを選択すると、時系列データのスタイルの変更が提示されます。\n連続タイムライン（サイズ） 日付データをシンボルの大きさで表現します。新しい日付から古い日付をシンボルの大きさで表示することができます。\n連続タイムライン（色） 日付データを色の濃淡で表現します。新しい日付から古い日付を濃い色から薄い色で表示することなどができます。また、特定の日付の前後で色を変えることもできます。\n期間（サイズ） 設定した開始と終了日の期間の長さをシンボルの大きさで表現します。期間が長いほどシンボルの大きさも大きく表示されます。\n期間（色） 設定した開始と終了日の期間の長さを色の濃淡で表現します。期間の長さを濃淡で表現したり、所定日の前後で色を変える設定ができます。\n※レイヤーが持つ属性フィールドのタイプに応じて選択できる種類が異なります。例えば、文字列型のフィールドのみで構成されるレイヤーでは、[種類] ドロップダウン リストでサイズや色の指定はできません。\n  [オプション] をクリックすると、シンボルの詳細な設定をすることができます。\n  場所（単一シンボル）の場合 [シンボル] をクリックし、形状や大きさ、塗りつぶし色、アウトラインの設定などを行います。\n種類（個別値シンボル）の場合  ❶ 各シンボルの形状や大きさ、塗りつぶし色、アウトラインの設定などを行うことができます。 ❷ 凡例で表示するラベル名を直接入力して変更することができます。 ❸ ドラッグし、目的の位置でドロップすることで、各シンボルの順序を変更できます。 ❹ チェックボックスをオンにすると、シンボルが設定されている値以外の図形（例えば、属性値が入力されていない図形）が「その他」として表示されます。\n※個別値が11種類以上ある場合は、一部のデータが「その他」にグループ化されます。ラベル欄の「その他」の右にある をクリックすると、一括してグループ化を解除できます。また、「その他」の中にはグループ化された個別値が表示され、各個別値の をクリックすることで、個々にグループから除外することもできます。  数と量（サイズ）の場合 - ❺ スライダーの上部、下部のバーを動かして、最大 / 最小クラスの閾値を変更できます。また、数値をクリックして、直接入力することもできます。 - ❻ ポイントのシンボルを変更できます。 - ❼ 最小/最大クラスのポイントのサイズを変更できます。 - ❽ チェックボックスをオンにすると、クラスの分類数や分類方法、各クラスの閾値を設定することができます。各クラスの閾値は、スライダーを動かして変更するか、クラスの閾値の数値をクリックして、直接、入力することもできます❾。\r数と量（色）の場合  ❿ スライダーの上部、下部のバーを動かして、最小/ 最大クラスの閾値を変更できます。また、数値をクリックして、直接入力することもできます。 ⓫ ここをクリックすることで、色のパターンなどを変更できます。 ⓬ チェックボックスをオンにすると、クラスの分類数や分類方法、各クラスの閾値を設定することができます。設定方法は「数と量（サイズ）（16ページ）」をご参照ください。  ヒートマップの場合  ⓭ スライダーの上部、下部のバーを動かして、密集度の高いエリアや低いエリアを変更できます。 ⓮ 色のパターンを選択できます。 ⓯ スライダーを左右に動かして、影響範囲を変更できます。  二種類の属性フィールドによるシンボル設定 各パネルにおいて [OK] をクリックし、[完了] をクリックします。 一つ目の属性フィールドを選択すると表示される、[属性の追加] をクリックします。\n※数値型および文字列型のフィールド タイプを持つレイヤーに対してのみ、 [属性の追加] が表示されます。ここで、二つ目の属性フィールドを選択します。（一つ目に選択する属性フィールドを A、二つ目に選択する属性フィールドは B とします。）  [②描画スタイルの選択] で、変更したい描画方法の [選択] をクリックします。既に選択されている描画スタイルは [オプション] と表示されます。  色とサイズ Ａの属性は、色の濃淡で数値を表現し、Bの属性に対してはシンボルのサイズで数値を表現します。 選択した属性フィールドが日付型の場合は、時系列表示のシンボル設定がおこなえます。\n色 (期間) とサイズ A の属性は、期間を色の濃淡で表現し、B の属性に対しては日付の新旧をシンボルのサイズで表現します。\n色とサイズ (期間) A の属性は、日付の新旧をシンボルのサイズで表現し、B の属性に対しては期間を色の濃淡で表現します。\nA を B と比較 Bの属性に対し、Ａの属性の比率や割合を表現します。また、二つの属性の合計に対するAの属性の割合を表示します。\nタイプとサイズ 一意のシンボル（個別値）をサイズで表現します。A、B どちらかが文字列型の属性である場合は、文字列型の属性の方に個別値シンボルが自動的に適用され、他方の属性にサイズが適用されます。 選択した属性フィールドが日付型の場合は、時系列表示のシンボル設定がおこなえます。\nタイプとサイズ (期間) 一意のシンボル（個別値）ごとに期間の長さをシンボルの大きさで表現します。 A、B どちらかが文字列型の属性である場合は、その属性の方に個別値シンボルが自動的に適用され、日付型の属性にサイズが適用されます。\n主要カテゴリ 複数の属性フィールドの値を比較して、一番高い値を持つ属性フィールドに設定した色を表示します。同時に、他の値と比べてどれほど優位かを透過で表現します。\n主要カテゴリおよびサイズ 上記の「主要カテゴリ」に加え、複数の属性値の合計を円の大きさで表します。 10.\t[オプション] をクリックすると、シンボルの詳細な設定をすることができます。 11.\t設定後、各パネルにおいて [OK] をクリックし、[完了] をクリックします。\n※独自のシンボルを表示したい場合は、シンボルとして表示させたい画像をあらかじめWeb 上にアップロードしておき、[スタイルの変更] パネル → [場所（単一シンボル）] あるいは [種類（個別値シンボル）] → [選択] → [オプション] で、シンボルをクリックし、[画像の使用] をクリックします。参照する URL をボックス内に入力し、プラスマークをクリックすると、独自のシンボルとして利用することができます。 ラベルを変更したい マップ ビューアー → [詳細] → [コンテンツ] → レイヤー名にマウス オン / クリック → [その他のオプション] → [ラベルの作成]\nマップ上のフィーチャに簡単にテキストを追加することができます。ラベルのテキスト文字列はフィーチャの属性情報を利用して設定することができます。コンテンツを作成する権限を持っている必要があります。\n  マップ ビューアーの [詳細] が選択されていることを確認し、[コンテンツ] をクリックします。\n  ラベルを変更したいレイヤー名にマウス オン / クリックし、[その他のオプション] から [ラベルの作成] を選択します。\n  [ラベル フィーチャ] パネルが表示されます。[ラベル フィーチャ] チェックボックスをオンにして、ラベルを表示します❶。\n  [テキスト] フィールドに、ラベルとして表示したい属性を持つフィールドを入力します。複数の属性を表示したい場合は、右の ボタンで任意のフィールドを追加することができます❷。｛｝(中かっこ)でフィールド名を囲むと各フィーチャの属性が表示されます。\n  テキストのサイズ、太字、斜体、アンダーライン、色を変更することができます❸。\n  [整列] で、ラベル配置を指定します❹。\n  [OK] をクリックし、ラベルの設定を終了します。\n  ラベルの設定をした状態でレイヤーを保存することで、他のマップでもラベルが設定された状態でレイヤーを利用することができます。そのためには、レイヤー名にマウス オン / クリックし、[その他のオプション] から [レイヤーの保存] を選択します。\n  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/services/create-feature-service/",
	"title": "フィーチャサービスの作成",
	"tags": [],
	"description": "データの検索や編集が可能な地図サービス (REST API) の配信方法を紹介します。",
	"content": "配信可能な地図サービス ArcGIS Platform では、お手持ちの地図データや、住所・緯度経度を含む CSV などのテキスト データをもとに地図 (GIS) サービスを配信することが可能です。ArcGIS の地図サービスはさまざまな機能ごとに種類が分かれています。配信可能な基本的な地図サービスは以下の 2 種類です。\n フィーチャ サービス (レイヤー)   緯度経度および属性情報をフィーチャ (文字列) として配信 (クライアントでベクター データのグラフィックとして描画されます)\n  クライアント側でクエリを実行してデータを取得したり、編集したりする場合に利用\n\n機能 : 表示 (地図と属性) / 検索 / 作成 / 更新 / 削除    タイル サービス (レイヤー)  あらかじめ作成しておいたタイル状に分割された地図画像を配信 (クライアントで画像として描画されます) 描画速度が速く、背景地図などの広範囲のデータを利用したい場合に最適 機能 : 表示 (地図のみ)    Esri は無償で利用できるタイル サービスとして、全世界の背景地図サービス (道路地図、地形図、衛星画像 など) を配信しています。 なお、自分でタイル サービスを生成する場合は、10,000 タイルにつき 1 クレジットを消費して生成できます。 生成したタイル サービスを公開する方法は ArcGIS Online ヘルプのホスト タイル レイヤーの公開をご覧ください。\n以下では、主題データとして利用頻度のもっとも高いフィーチャ サービスの公開および配信方法をご紹介します。\nフィーチャ サービスの作成・公開 フィーチャ サービスの公開には以下の 2 つの方法があります。\n 空のフィーチャ サービスを公開  データがない状態のフィーチャ サービスを公開し、マップ ビューアーを使って手動でデータを追加していきます。    地図データおよび住所データを使ってフィーチャ サービスを公開   地図データが持つ座標情報や住所情報をもとにフィーチャ サービスを公開します。ArcGIS Developers のサイトを使用して公開が可能なデータは以下の通りです。\n CSV Excel (*.xlsx または *.xls) Google Sheets GeoJSON シェープファイル (Zip 形式に圧縮) ファイル ジオデータベース (Zip 形式に圧縮)  詳細は ArcGIS Online ヘルプのホスト フィーチャ レイヤーの公開をご覧ください。\n    以下は空のフィーチャ サービスを公開するまでのステップを紹介します。\n地図データや住所データを使ってフィーチャ サービスを公開する方法は「Import data as a feature layer」をお読みください。\n1. フィーチャ サービスの作成を開始する  ArcGIS Developers のサイト上で [Dashboard] をクリックし、[Layers] を選択します。 [+ Create Data] をクリックし、[New Hosted Layer (Feature Layer)] を選択します。   2. フィーチャ サービスのデータ構造を設定   [Data Structure] 画面で、以下の情報を設定します。\n Geometry Type: Point Fields:  フィールド 1:  Name: ID Display name (alias): ID Type: Integer   フィールド 2:  Name: NAME Display name (alias): 名前 Type: String   フィールド 3:  Name: ADDRESS Display name (alias): 住所 Type: String     Coordinate System: Latitude/Longitude (WGS 84/EPGS 4326)    入力が完了したら、[Next] をクリックして次へ進みます。   各データ構造の詳細は以下をご覧ください。\n  Geometry Type (ジオメトリ タイプ)\n フィーチャの図形の種類で、ポイント、ライン、ポリゴンの三種類から構成されています。  ポイント: 地物を点のデータで表し、観測地点などを表示するために使われます ライン: 地物を線のデータで表し、河川や道路などのフィーチャを表示するために使用されます ポリゴン: 地物を面のデータで表し、建物などを表示するために使用されます。   1 つのフィーチャ サービスに対して選択できるジオメトリ タイプはいずれか 1 つです。    Fields (属性情報)\n フィーチャに関する様々な情報のことで、属性テーブルと呼ばれるデータベースに保存することができます。属性テーブルの列のことを属性フィールドと呼びます。例えば、公共施設の属性には名称や所在地、分類、電話番号などを含めることができます。この属性情報をもとにシンボルやラベルを表示したり、フィーチャを検索したりすることが可能です。   Field Name (フィールド名)\n フィールドの名前をコンピューター用に定義したものです。コンピューターが理解しやすいように英数字で記載するなど使用できる文字に制限があります (スペースや特殊文字は使用できません) 。    Display name (エイリアス)\n フィールドの名前を人間にもわかりやすく定義したものです。例えば、人口の情報であれば Field Name を「POP」、Display name を「Population」や「人口数」と使い分けます。    Type (データ型)\n 格納する情報の種類によって以下の 4 つのデータ型から選択します。属性フィールドに設定されたデータ型と異なるデータ型の値を格納することはできません。  String: 文字型。文字列を格納します。 Integer: 整数型。自然数を格納します。 Double: 倍精度浮動小数点型。小数点を持つ有理数やパーセント値などを格納します。 Date: 日付型。日付、または日付と時間を格納します。          Coordinate System (座標系)\n 地球上の特定の位置を座標で表すための原点や座標の単位などの取り決めのことです。 フィーチャ レイヤーの ID (WKID) を入力します。  「4326 (WGS 84 緯度経度)、「3857 (Web メルカトル)」が推奨されています。      3. フィーチャ サービスの基本情報を設定   [Item Details] 画面で、以下の情報を設定します。\n Title: customerpoint Tags: customer Description: 顧客情報のポイント    入力が完了したら、[Next] をクリックして次へ進みます。\n\n  各情報の詳細は以下をご覧ください。\n  Title (タイトル)\n 新しく作成するフィーチャ サービスのタイトルを入力します。    Tags (タグ)\n ArcGIS Developers のサイト上でフィーチャ サービスを検索する際に利用します。作成するフィーチャー サービスのキーワードとなる語句を入力し、Enter キー を押すとタグが作成されます。    Description (説明)\n 新しく作成するフィーチャ サービスの説明を入力します。    4. 設定した情報の確認   [Review] 画面で、ここまで設定した内容を確認します。\n  問題がなければ、[Create Layer] をクリックしてフィーチャ サービスを公開します。\n  公開が完了すると、ArcGIS Developers のサイト上にフィーチャ サービスのアイテム ページが作成され、フィーチャ サービスの URL などが確認できます。\n\n  5. フィーチャ サービスの詳細情報を設定   作成したフィーチャ サービスのアイテム ページから、サービスの共有・編集権限を設定します。\n  ページ上部の [Settings] をクリックして以下にチェックを入れます。\n Layer access (sharing): Private (authentication required) Editing settings:  Allow editting (編集の有効化) Track new features and updates (作成および更新されたフィーチャを記録) Track authors of new features and updates (フィーチャの作成者および最終更新者を記録)      [Save setting] をクリックし、設定した内容を保存します。\n\n  ### 2. フィーチャ サービスの編集\r1. [編集] をクリックして、[フィーチャの追加] ウィンドウから追加するデータのシンボルを選択します。\r1. 選択後に、地図上の任意の場所をクリックすることで新しいデータが追加されます。\r1. フィーチャを追加すると、ポップアップが自動で開き、フィーチャの属性情報を編集することが可能です。\r--\rここまで作成してきたフィーチャ サービスは「Web マップの作成」で 1 レイヤーとして扱うことができます。自身が複数のデータをお持ちで、複数のレイヤーとして地図に表示したい場合でも、自由に追加して独自の地図をデザインすることが可能です。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/page/",
	"title": "ページ（Page）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - page\nページ（Page） エクスペリエンスの中のページは、物理的な HTML Web ページでなく、概念的なページですが、実際のHTML Web ページのように振る舞います。これは div HTMLタグを使って実装されます。エクスペリエンスは少なくとも1つのページを持たなければならず、複数のページを持つこともできます。Experience Builder のページレイアウトにはフルスクリーンのアプリページと直線的なスクロールページの2種類があり、前者はアプリのように見え、後者はウェブページのように見えます。\nページの内容（ウィジェット/セクション）は、固定レイアウトやフローレイアウトなどのレイアウトルールで整理されています。異なる画面サイズでもページが反応するようにするために、Experience Builderはサイズモードによるレイアウトの設定をサポートしています。これらは Large, Medium, Small で定義されています。各レイアウトの設定はエクスペリエンスの適応であり、アプリケーションをよりカスタマイズし、画面サイズをより有効に利用できるようにすることで、より大きな柔軟性を提供します。このデザインの良い例としては、City Explorerのテンプレートがあります。アプリケーションを大・中画面で見た場合、地図は表示され、構成に含まれていますが、モバイルデバイスで見た場合、地図ウィジェットは最初のページから削除され、ユーザーがリストウィジェットで機能を選択した後、2番目のページにのみ表示されるようになります。\napp config では、ページは pages で定義され、ページ構造は pageStructure で定義されます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/dotnet/",
	"title": "ArcGIS Maps SDK for .NET",
	"tags": [],
	"description": "ArcGIS Maps SDK for .NET の開発に役立つガイド集です。",
	"content": "ArcGIS Maps SDK for .NET の開発に役立つガイド集です。\n インストール ガイド\nArcGIS Maps SDK for .NET のインストールとセットアップ手順を紹介します。\n\r アプリケーション配布ガイド\nArcGIS Maps SDK for .NET を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を紹介します。\n\r バージョン 100.x から 200.x への移行\n今まで ArcGIS Runtime SDK for .NET バージョン 100.x を使用してアプリケーションを開発されていた開発者向けのガイドです。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-maplibre/",
	"title": "MapLibre GL JS",
	"tags": [],
	"description": "MapLibre GL JS を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。",
	"content": "マップを表示する このチュートリアルでは、MapLibre GL JS と ベースマップ レイヤー サービスを使用して、マップを表示する方法を紹介します。\nベースマップ レイヤー サービスのベクター タイル ベースマップ レイヤーを使用して、MapLibre GL JS にマップを表示できます。ベクター タイル ベースマップレイヤーは、ソース、レイヤー、フォントグリフ(Font Glyphs)、およびレイヤーをレンダリングするためのアイコンを含む MapLibre GL スタイルです。\nこのチュートリアルでは、ベースマップ レイヤー サービスの地形ベースマップ レイヤーを使用して、富士山周辺の地図を表示します。\nマップとレイヤーの詳細については、Mapping APIs and servicesのガイドのDisplay maps, scenes, and layersにアクセスしてください。\n前提条件 この機能を使うには、ArcGIS アカウントが必要です。アカウントの作成手順については「開発者アカウントの作成」を参照してください。\n手順 新しい Pen の作成 CodePen にアクセスして、マッピング アプリケーション用の新しい Pen を作成します。\nHTML の作成 HTML ページを定義して、Web ブラウザの幅と高さにあわせたマップを作成します。\n CodePen \u0026gt; HTML で、HTML と CSS を追加して、map という id 属性を持つ div 要素のあるページを作成します。 map id は、マップを表示するために使用される id 属性です。CSS はブラウザの設定をリセットして、マップがブラウザの幅と高さ全体に表示されるようにします。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;MapLibre GL JS Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; API の参照  \u0026lt;head\u0026gt;タグで、MapLibre GL JS CSS および JS ライブラリへの参照を追加します。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;MapLibre GL JS Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- maplibre gl js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=https://unpkg.com/maplibre-gl@2.1.9/dist/maplibre-gl.js\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=https://unpkg.com/maplibre-gl@2.1.9/dist/maplibre-gl.css rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; APIキーの設定 ロケーションサービスにアクセスするには、API キーまたは OAuth2.0 アクセストークンが必要です。API キーの作成手順については「API キーの取得」を参照してください。\n認証方法とアクセストークンの取得方法の詳細については、「セキュリティと認証」を参照してください。\n 開発者ダッシュボードに移動して、API キーを取得します。これは、次の手順で使います。  マップの作成 Map クラスを使用して、指定したベースマップを使用してマップを追加します。 Map クラスは、map の HTML 要素 を使用して、マップのコンテンツを表示し、対話するためのユーザーインターフェイスを提供します。地図のクリック、ズーム、パン、回転、視点の変更をサポートします。また、マウスがクリックされた場所のフィーチャの検索など、マップデータに関する情報を操作および検出することもできます。また、新しいソースを追加したり、レイヤープロパティを変更したりして、表示されるデータを変更することもできます。 詳細については、MapLibre GL JS のドキュメントを参照してください。\n \u0026lt;body\u0026gt;タグ内に\u0026lt;script\u0026gt;タグを追加します。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;MapLibre GL JS Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- maplibre gl js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=https://unpkg.com/maplibre-gl@2.1.9/dist/maplibre-gl.js\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=https://unpkg.com/maplibre-gl@2.1.9/dist/maplibre-gl.css rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script のタグを追加--\u0026gt; \u0026lt;script\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; API キーを格納するための apiKey 変数を作成します。YOUR_API_KEY を、API キーの設定で開発者ダッシュボードからコピーした API キーに置き換えます。アクセスする各 ArcGIS サービスの URL にこれを含める必要があります。なお、ここでは maplibre.accessToken を設定する必要はありません。使用するベースマップ ArcGIS:topographic を格納する basemapEnum 変数を作成します。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;MapLibre GL JS Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- maplibre gl js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=https://unpkg.com/maplibre-gl@2.1.9/dist/maplibre-gl.js\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=https://unpkg.com/maplibre-gl@2.1.9/dist/maplibre-gl.css rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script のタグを追加--\u0026gt; \u0026lt;script\u0026gt; // API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ベースマップの指定  const basemapEnum = \u0026#34;ArcGIS:Topographic\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 表示と動作を制御するオプションを使用して Map を作成します。container プロパティを、作成した div の id に設定します。style プロパティは、ベースマップレイヤーサービスの場所を参照し、ベースマップ識別子と API キーを含みます。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;MapLibre GL JS Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- maplibre gl js のライブラリと css ファイルを指定 --\u0026gt; \u0026lt;script src=https://unpkg.com/maplibre-gl@2.1.9/dist/maplibre-gl.js\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=https://unpkg.com/maplibre-gl@2.1.9/dist/maplibre-gl.css rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--script 要素を追加--\u0026gt; \u0026lt;script\u0026gt; // API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ベースマップの指定  const basemapEnum = \u0026#34;ArcGIS:Topographic\u0026#34;; const map = new maplibregl.Map({ container: \u0026#34;map\u0026#34;, // div 要素内の id を指定  style: `https://basemaps-api.arcgis.com/arcgis/rest/services/styles/${basemapEnum}?type=style\u0026amp;token=${apiKey}`, zoom: 12, // マップ初期表示時点でのズームレベル  center: [138.729858, 35.362752] // マップ初期表示時の位置  }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; アプリの実行 CodePen で、作成したコードを実行して地図を表示します。\n地図には、日本の富士山のエリアの地形ベースマップ レイヤーが表示されています。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-openlayers/",
	"title": "OpenLayers",
	"tags": [],
	"description": "OpenLayers を用いた Web ブラウザー向け地図アプリの作成方法を紹介します。",
	"content": "マップを表示する このチュートリアルでは、OpenLayers と ベースマップ レイヤー サービス を使用して、マップを表示する方法を紹介します。\nマップには、地理データのレイヤーが含まれています。マップには、ベースマップ レイヤーと、オプションで1つ以上のデータ レイヤーが含まれます。マップ ビューを使用し、場所とズームレベルを設定することで、マップの特定の領域を表示できます。\nこのチュートリアルでは、地形 ベースマップ レイヤーを使用して、 OpenLayers で富士山周辺の地図を表示します。\n前提条件 このチュートリアルを実施するには、以下が必要です。\n 開発者ダッシュボードにアクセスして API キーを作成するには、ArcGIS アカウントが必要です。アカウントの作成手順については「開発者アカウントの作成」を参照してください。  ステップ 新しい Pen の作成 CodePen にアクセスして、マッピング アプリケーション用の新しい Pen を作成します。\nHTML の作成 HTML ページを定義して、Web ブラウザの幅と高さにあわせたマップを作成します。\n  CodePen ＞ HTML で、HTML と CSS を追加して、map という id 属性をもつ div 要素のあるページを作成します。\nHTML を使って、マップを表示する Web ページを作成します。この時マップは map div 内に表示します。CSS を使って、マップを全幅・全高で表示されるようにします。\nCodePenでは、\u0026lt;!DOCTYPE html\u0026gt;タグは必要ありません。他のエディタを使用している場合や、ローカルサーバでページを実行している場合は、必ずこのタグを HTML ページの先頭に追加してください。\n  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ライブラリの読み込み OpenLayers と ol-mapbox-style の JavaScript と CSS ファイルを参照するために、\u0026lt;script\u0026gt;と\u0026lt;link\u0026gt;タグを追加します。\n \u0026lt;head\u0026gt;要素の中に、OpenLayers の CSS と JavaScript ライブラリへの参照を追加します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/css/ol.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/build/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ol-mapbox-style ライブラリへの参照を追加します。これは、OpenLayers でベク​​タータイル スタイルを使用してベクタータイル レイヤーをロードおよびスタイル設定するために必要です。\nolms.js は、OpenLayers の開発者によって提供されています。\u0026ldquo;olms\u0026rdquo; は OpenLayers Mapbox Style の略です。詳しくは、ol-mapbox-style のドキュメントをご覧ください。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/css/ol.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/build/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@6.1.4/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Map と View の作成 OpenLayers マップを作成するには、Map クラスと View クラスを使用します。\nOpenLayers の Map クラスは、マップのコンテンツを表示し、それを操作するためのユーザーインターフェースを提供します。マップのクリック、ズーム、パン、回転、視点の変更をサポートしています。また、マップデータの可視コンテンツを操作することもでき、例えば、マウスカーソルでフィーチャを見つけることができます。また、新しいソースを追加したり、レイヤーのプロパティを変更したりして、表示されるデータを修正することもできます。OpenLayers は、レイヤーの変更に応じて、必要に応じて自動的に再レンダリングを行います。\n詳細については、OpenLayers のドキュメントを参照してください。\n \u0026lt;body\u0026gt;要素の中に\u0026lt;script\u0026gt;要素を追加します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/css/ol.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/build/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@6.1.4/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Map クラスを使用して、表示や動作を制御するオプション付きのマップを作成します。target プロパティには、div 要素の id として \u0026ldquo;map\u0026rdquo; を設定します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/css/ol.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/build/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@6.1.4/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 地図を表示するタグの id 属性を指定  const map = new ol.Map({ target: \u0026#34;map\u0026#34; }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; View を作成し、setView を使ってマップに適用します。マップビューを中央に配置するために、center プロパティを [138.729858,35.362752] に、zoom プロパティを12に設定します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/css/ol.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/build/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@6.1.4/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 地図を表示するタグの id 属性を指定  const map = new ol.Map({ target: \u0026#34;map\u0026#34; }); // 地図を表示する位置と初期のズームレベルの指定  map.setView( new ol.View({ center: ol.proj.fromLonLat([138.729858, 35.362752]), zoom: 12 }) ); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; APIキーの設定 ロケーションサービスにアクセスするには、API キーまたは OAuth2.0 アクセストークンが必要です。API キーの作成手順については「API キーの取得」を参照してください。\n認証方法とアクセストークンの取得方法の詳細については、「セキュリティと認証」を参照してください。\n  開発者ダッシュボードに移動して、API キーを取得します。\n  次の手順に使うため API キーをコピーします。\n  ベースマップ レイヤーの追加 OpenLayers はベクター ベースマップやベクター スタイル ファイルを直接サポートしていないので、openlayers-mapbox-style (olms) JavaScript ライブラリを使用して、ベースマップ レイヤー サービスから Mapbox スタイルをロードし、OpenLayers でレンダリングします。\nMapbox スタイルは、スタイルで使用されるベクター タイル レイヤーへの参照と、それらのタイル内の1つまたは複数のデータ レイヤーに適用される表示スタイル ルールを含む JSON ファイルです。\n API キーを変数として保存します。ArcGIS サービスを呼び出す際には、必ずこの API キーを含める必要があります。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/css/ol.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/build/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@6.1.4/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 地図を表示するタグの id 属性を指定  const map = new ol.Map({ target: \u0026#34;map\u0026#34; }); // 地図を表示する位置と初期のズームレベルの指定  map.setView( new ol.View({ center: ol.proj.fromLonLat([138.729858, 35.362752]), zoom: 12 }) ); // API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; basemapId 変数を作成し、それを ArcGIS:Topographic に設定します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/css/ol.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/build/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@6.1.4/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 地図を表示するタグの id 属性を指定  const map = new ol.Map({ target: \u0026#34;map\u0026#34; }); // 地図を表示する位置と初期のズームレベルの指定  map.setView( new ol.View({ center: ol.proj.fromLonLat([138.729858, 35.362752]), zoom: 12 }) ); // API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ベースマップの設定  const basemapId = \u0026#34;ArcGIS:Topographic\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; basemapId と API キーに基づいてベースマップの URL を作成します。  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/css/ol.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/build/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@6.1.4/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 地図を表示するタグの id 属性を指定  const map = new ol.Map({ target: \u0026#34;map\u0026#34; }); // 地図を表示する位置と初期のズームレベルの指定  map.setView( new ol.View({ center: ol.proj.fromLonLat([138.729858, 35.362752]), zoom: 12 }) ); // API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ベースマップの設定  const basemapId = \u0026#34;ArcGIS:Topographic\u0026#34;; // ベースマップの URL を設定  const basemapURL = \u0026#34;https://basemaps-api.arcgis.com/arcgis/rest/services/styles/\u0026#34; + basemapId + \u0026#34;?type=style\u0026amp;token=\u0026#34; + apiKey; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; olms を使用して、ベースマップ スタイルをマップに適用します。olms 関数は、マップ要素と Mapbox ベースマップ スタイル ファイルの URL の2 つの入力を受け取ります  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;OpenLayers Tutorials: Display a map\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html, body, #map { padding: 0; margin: 0; height: 100%; width: 100%; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #323232; } \u0026lt;/style\u0026gt; \u0026lt;!-- openlayers の css ファイルと js ライブラリの参照追加 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/css/ol.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/build/ol.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- ベクタータイル レイヤーを地図で表示するために olms.js ライブラリへの参照を追加 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ol-mapbox-style@6.1.4/dist/olms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 地図を表示する要素の id 属性を指定  const map = new ol.Map({ target: \u0026#34;map\u0026#34; }); // 地図を表示する位置と初期のズームレベルの指定  map.setView( new ol.View({ center: ol.proj.fromLonLat([138.729858, 35.362752]), zoom: 12 }) ); // API キーの追加  const apiKey = \u0026#34;YOUR_API_KEY\u0026#34;; // ベースマップの設定  const basemapId = \u0026#34;ArcGIS:Topographic\u0026#34;; // ベースマップの URL を設定  const basemapURL = \u0026#34;https://basemaps-api.arcgis.com/arcgis/rest/services/styles/\u0026#34; + basemapId + \u0026#34;?type=style\u0026amp;token=\u0026#34; + apiKey; // olms 関数でベクター タイル レイヤー をベースマップに適用  olms(map, basemapURL); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; アプリを実行する CodePen で、作成したコードを実行して地図を表示します。\n地図には、日本の富士山のエリアの地形ベースマップ レイヤーが表示されているはずです。パンとズームで地図を探索してみましょう。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/services/create-webmap/",
	"title": "Web マップの作成",
	"tags": [],
	"description": "さまざまなフォーマットのデータを 1 つのマップとして集約し、それを可視化する方法を紹介します。",
	"content": "Web マップとは Web マップとは背景地図や主題となる地図データを追加し、表示方法などを設定してクラウド上に JSON 形式で保存される Web 上の地図です。Web マップの作成には ArcGIS クラウド サービスが提供する地図作成ツール（マップ ビューアー）を使用します。クラウド上に保存された Web マップを使えば、地図上に何をどのように表示するかを一つ一つコーディングする必要がなく、非常にローコストで地図アプリを作成することができます。\nWeb マップに含まれる情報は以下の JSON 仕様で確認できます。\n Web マップ仕様 (Web Map JSON)  Web マップの作成 1. Web マップの作成とレイヤーの追加 マップ ビューアーで Web マップを作成していきましょう。\n  マップ ビューアーを開きます。\n  開発者アカウントでサインインします（サインインをしないと地図作成機能を利用できません）。\n  インターネットで公開されている ArcGIS クラウド サービスで共有中のレイヤーを追加します。[追加] をクリック後、[レイヤーの検索] を選択します。\n  レイヤーの検索を行います。検索先を「ArcGIS Online」とし、検索フォームにお好きなキーワードを入力して検索してみましょう。\n  検索結果が表示されたら、追加したいレイヤーの [追加] リンクをクリックして、[レイヤーの追加を完了] ボタンを押してレイヤーの追加は完了です。\n   画像はトイレ調査と南海トラフ巨大地震の被害想定（震度/最大クラス）のレイヤーを追加しています。  2. レイヤーの表示方法の設定   レイヤーの表示設定を変えてみましょう。レイヤー リストから表現を変更したいレイヤーを選び、[スタイルの変更] アイコンをクリックします。なお、レイヤーの種類によって設定できる項目が異なります。 レイヤーの種類はいくつかありますが、ArcGIS のクラウド サービスで配信する主なレイヤーは以下の 2 つです。フィーチャ レイヤーは Web ブラウザー上のグラフィックとして描画されるためスタイルの変更が可能です。\n タイル レイヤー：データを画像で配信 フィーチャ レイヤー：データを文字列（位置座標と属性）で配信    [表示する属性を選択] で表示に利用する属性情報を選択し、それに応じた描画スタイルを [描画スタイルの選択] から選択します。表示する属性のタイプに応じて選択できる描画スタイルは自動的に変更されます。\n  個別値シンボルの場合は、属性値ごとに表示したいシンボルを設定することができます。シンボルを設定してみましょう。\n  レイヤー リスト上の透過率を設定したいレイヤー下にある [\u0026hellip;] アイコンをクリックして、メニューから [透過表示] にカーソルを合わせると、スライダ－で透過率を設定できます。 これで背景地図が見えるので場所の特定はできるようになりましたが、地震の被害想定は見たい人だけに見てほしい。そんな場合には、初期状態で非表示にしておくことができます。   非表示にしたいレイヤー左にあるチェックボックスの✔を外すと、レイヤーは非表示になります。\n  3. Web マップの保存 最後にここまで設定を行ってきた Web マップの保存を行います。保存すると Web マップには ID が割り当てられます。開発の際に、この ID を参照することで、設定を行った状態の地図をそのまま表示することができます。\n  [保存] ボタンをクリックし、マップの情報を入力します。入力し終わったら、[マップの保存] ボタンをクリックして、保存は完了です。タイトル、タグの入力は必須項目です。\n  保存が完了すると、URL が自動的に変更されます。URL 末尾の ?webmap=\u0026lt;Web マップ ID\u0026gt; が Web マップの ID です。メモしておきましょう。    アプリの作成を始めましょう！お使いの開発環境からお選びください。\n JavaScript Android iOS .NET  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/install-guide/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) をインストールする手順を紹介します。",
	"content": "ArcGIS Experience Builder は、モダンな Web アプリ構築のための新しいビルダーで、コードを記述することなく Web アプリケーションを作成することができます。豊富なウィジェット セットから必要なツールを選択したり、独自のテンプレートをデザインしたり、2D コンテンツや 3D コンテンツを操作したりすることができます。Developer Edition (開発者向けエディション)は、これらの機能に加え、ウィジェットやテーマを独自に開発するなどのアプリをカスタマイズするためのフレームワークを提供します。また、作成したアプリケーションをダウンロードして、Web サーバーなどの独自のサーバーにホストすることが可能です。\nArcGIS Experience Builder (Developer Edition) で使用されている技術は、ArcGIS Maps SDK for JavaScript 4.x に加えて、React + Redux といったフレームワークや Bootstrap 4 などのコンポーネントライブラリ等を使用しています。開発に必要な情報は ArcGIS Experience Builder (Developer Edition) のコア コンセプト (Core concepts) を参照してください。\nインストール ArcGIS Experience Builder (Developer Edition) は、ArcGIS Online および ArcGIS Enterprise 10.6 以降をサポートしています。 Experience Builder (Developer Edition) は server と client の 2 つのサービスを使用しています。\n server サービス  Experience Builder (Developer Edition) の本体を起動します。   client サービス  独自のウィジェットやテーマを開発するためには client サービスを使用する必要があります。通常、server サービスを起動することで、Experience Builder (Developer Edition) を動作させることはできますが、開発したウィジェットなどを配置したり、デバッグするには、client サービスを起動しておく必要があります。    両方のサービスを実行しておくことで、Experience Builder での更新を自動的に反映することができます。 ここでは、Experience Builder (Developer Edition) の server と client のインストール手順について説明します。また、インターネットに接続していない環境で Experience Builder をインストールする必要がある場合は、offlineでのインストール手順を参照してください。\nServer インストール 1. Client ID の作成 はじめに Client ID を作成する必要があります。Client ID は、このあとの server サービスを起動して立ち上がるアプリケーションで指定します。 Client ID の作成は、ArcGIS Developers 、もしくは ArcGIS Online/ArcGIS Enterprise を使用して作成します。ご使用の環境に応じて作成を行ってください。\n 1-1. ArcGIS Developers を使用した Client ID の作成 1-2. ArcGIS Online/ArcGIS Enterprise を使用した Client ID の作成  1-1. ArcGIS Developers を使用した Client ID の作成 ArcGIS Developers を使用している場合は、以下の手順を行います。\nインストール手順については Esri が公開しているインストール動画 (英語)でも確認することができます。\n\r ArcGIS Developers にサイン インします。 サイン イン後にダッシュボードが表示されますので OAuth 2.0 タブをクリックします。 + New Application をクリックし、アプリケーションの詳細を入力して、新しいアプリケーションを登録します。 Redirect URLs のセクションまでスクロール ダウンします。 + Add URI をクリックして、https://localhost:3001/ を追加します。  Client ID は、このあとの手順で使用するため、コピーなどをして控えておきます。  1-2. ArcGIS Online/ArcGIS Enterprise を使用した Client ID の作成 ArcGIS Online または ArcGIS Enterprise を使用している場合は、以下の手順を行います。\n※ インストール手順については Esri が公開しているインストール動画 (英語)でも確認することができます。\n\r ArcGIS Online または ArcGIS Enterprise ポータルにログインし、コンテンツ ページの マイ コンテンツ タブに移動して、新しいアイテム をクリックし、アプリケーション を選択します。 アプリケーション タイプ で 他のアプリケーション を選択します。 ダイアログボックスで、以下のパラメータを入力し、保存 をクリックします。  タイトル - 例えば、Experience Builder credentials などの任意のタイトルをを入力します。 フォルダー - アイテムを保存する任意のフォルダーを選択します。 タグ - Experience Builder のような内容を入力します。 サマリー - アイテムのサマリーを入力します。    設定 タブをクリックします。アプリケーションの登録の項目までスクロールして、更新 をクリックします。 登録情報 ダイアログ ボックスで、次のように、リダイレクト URI に https://localhost:3001/ と入力し、追加をクリックして、更新 をクリックします。アプリケーション ID は、このあとの手順で使用するため、コピーなどをして控えておきます。   2. server サービスのインストール Client ID の作成が完了したら以下の手順で server サービスのインストールを行います。\nExperience Builder は、Node.js を使用します。長期サポート (LTS) バージョン v12 以上がサポートされています。お使いの OS に対応した最新の Node.js LTS バージョンをダウンロードしてインストールを行ってください。\n Experience Builder (Developer Edition) の ZIP ファイルをローカルにダウンロードして、解凍します。 ※ ダウンロードページでサイン イン ページが表示される場合は、ArcGIS Developers 開発者アカウント（あるいは ArcGIS Online 組織向けプランのアカウント）のユーザー名およびパスワードを入力しサイン インします。 コマンド プロンプト、またはターミナル ウィンドウを開き、Experience Builder の /server ディレクトリに cd コマンドで移動して npm ci と入力し、Enter キーを押して、必要なモジュールをインストールします。 ※ npm ci でのインストールは初回のみになります。次回以降は Experience Builder (Devloper Edition) の起動のみになりますので、npm start で実行します。 npm start と入力して server を起動します。  カスタムポートを使用するには、次のようにオプションとしてポートを指定します。： npm start -- --port 81 --https_port 443 .\nサブディレクトリ（例：https://localhost:3001/subfolder）でサーバーを実行するには、次のように path オプションを指定します： npm start -- --path /subfolder .\n\r次の URL https://localhost:3001/ を指定して Experience Builder をブラウザで開きます。  Experience Builder は、Node.js の自己署名証明書を使用して HTTPS をサポートしています。この証明書を信頼して Experience Builder を実行することもできますし、独自の証明書を使用することもできます。独自の証明書を使用するには、server/cert ディレクトリのこれら 2 つのファイル server.key と server.cert を置き換えます。また、次のように証明書ファイル (server.cert および server.key) が存在するフォルダへのカスタムパスを指定することもできます。：npm start \u0026ndash; \u0026ndash;cert_folder \u0026lt;フォルダパス\u0026gt;\n\rポータルの URL には ArcGIS Online または ArcGIS Enterprise の組織サイトの URL を指定し、クライアント ID には「1-1. ArcGIS Developers を使用した Client ID の作成」で作成した client ID」、または「1-2. ArcGIS Online/ArcGIS Enterpriseを使用した Client ID の作成」で作成したアプリケーション ID を指定します。 すべてを指定したらサイン インをクリックします。  Safari で、PKI、Kerberos、IWA、または LDAP 認証タイプを使用して Experience Builder Developer Edition にサインインするには、Safari の開発メニューにある「Cross-Origin Restrictions を無効にする」を選択する必要があります。\n\rサイン インをクリックすると、以下のように「権限のリクエスト画面」、もしくは、「ArcGIS ログイン画面」が表示されます。\r● 権限のリクエスト画面\r権限のリクエスト画面は、使用しているブラウザですでに ArcGIS Online などにログインしているため、ログインした組織のアカウントが表示されます。許可をクリックすることで、Experience Builder の初期画面が表示されます。もし、他のアカウントでサイン インする場合は、別のアカウントでサイン インをクリックしてください。以下の ArcGIS ログイン画面が起動しますので、目的のユーザー名、パスワードを入力してサイン インします。\r● ArcGIS ログイン画面\r使用しているブラウザで ArcGIS Online などにログインしていない場合は、ArcGIS ログイン画面が表示されます。目的のユーザー名、パスワードを入力してサイン インをクリックしてください。認証に成功すると、Experience Builder の初期画面が表示されます。\r\r6. 次のステップで [client](#client-install) インストールを行います。\rClient インストール Experience Builder の開発では、ローカルの Experience Builder で使用しているカスタム ウィジェットやテーマをバンドルしてロードするため webpack を起動する必要があります。webpack を起動するために client サービスをインストールする必要があります。\n コマンド プロンプト、またはターミナル ウィンドウを開き、Experience Builder の /client ディレクトリに cd コマンドで移動して npm ci と入力し、Enter キーを押して、必要なモジュールをインストールします。 ※ npm ci でのインストールは初回のみになります。次回以降は Experience Builder (Devloper Edition) の起動のみになりますので、npm start で実行します。 ※ npm ci でのインストール時は Visual Studio C++ Build Tools と Python が端末上にある必要があります。 npm start と入力して client を起動します。 ※ client のサービスを起動することで、カスタム ウィジェットやテーマは https://localhost:3001 で表示した Experience Builder 上で使用することが可能となります。  /client/your-extensions ディレクトリに新しいファイルやフォルダを作成した場合は、client サービスの再起動が必要になります。\n\r同じマシンで複数のバージョンの Developer edition を持つことができます。お使いのマシンがシステム要件を満たしていることを確認してください。\nOffline インストール   インターネットに繋がらない環境では、ArcGIS API JavaScript (JSAPI) CDN にアクセスすることはできません。このシナリオでは、JSAPI をダウンロードしてローカルにインストールする必要があります。\n  Experience Builder は、Node.js 12+.x 以上のバージョンで動作します。 Experience Builder のインストール環境に Node.js (v12+.x) をダウンロードしてインストールを行います。\n  Experience Builder の機能強化や新機能をサポートするために、最新版の ArcGIS API JavaScript をインストールすることが推奨されています。Esri が公開しているオフライン インストール動画（英語）](https://youtube.com/watch?v=1rO1cZNEr0E) を参照してください。ホストされた JSAPI のために、サーバーで CORS サポートを設定することが推奨されます。例えば、Windows OS の場合、HTTPSレスポンスヘッダーにAccess-Control-Allow-Original アクションを追加することができます。\n\r Experience Builder (Developer Edition) の ZIP ファイルをローカルにダウンロードして、解凍します。 Experience Builder (Developer Edition) 用の npm-cache zip をローカルにダウンロードして、解凍します。 コマンド プロンプト(例えば、Windows OS c:\\Users\\exbuser)、またはターミナル(例えば、macOS /Users/installExB)で、ユーザーフォルダを開き、npm config get cache と入力します。 npm config get cache の実行で表示された npm-cache のフォルダのパスをコピーして、そのディレクトリを Windows のエクスプローラーか Mac の場合は Finder で開きます。 ダウンロードした Experience Builder (Developer Edition) 用 の npm-cache ディレクトリをコピーして、4 で参照しているディレクトリに貼り付けます。 コマンド プロンプト、またはターミナル ウィンドウを開き、Experience Builder インストールの client ディレクトリに cd コマンドで移動して、npm install --offline と入力して Enter キーを押します。 別のコマンド プロンプト、またはターミナル ウィンドウを開き、Experience Builder インストールの server ディレクトリに cd コマンドで移動して、npm install -- offline と入力して Enter キーを押します。 Experience Builder の client ディレクトリを以下のパス \u0026lt;install folder\u0026gt;/client/dist で開きます。 変数 ARCGIS_JS_API_URL をローカルで JSAPI を参照している URL に更新する必要が4箇所あります。例えば、以下の各ファイルで var ARCGIS_JS_API_URL = 'https://js.arcgis.com/4.16/' を var ARCGIS_JS_API_URL = 'https://exb.esri.com/4.16/' に置き換えてください。  \u0026lt;install folder\u0026gt;/client/dist/index.html \u0026lt;install folder\u0026gt;/client/dist/experience/index.html \u0026lt;install folder\u0026gt;/client/dist/template/index.html \u0026lt;install folder\u0026gt;/client/dist/builder/index.html   コマンド プロンプト、またはターミナル ウィンドウを開き、Experience Builder のインストール先の client ディレクトリに cd コマンドで移動して、npm start と入力して client サービスを起動します。 コマンド プロンプト、またはターミナル ウィンドウを開き、Experience Builder のインストール先の server ディレクトリに cd コマンドで移動して、npm start と入力して server サービスを起動します。  Experience Builder (Developer Edition) を使用するために Client ID が必要になります。Client ID を作成するために ArcGIS Online または ArcGIS Enterprise に接続します。\n\rここでは、ArcGIS Online または ArcGIS Enterprise を使用した Client ID の作成手順について示します。\n  ArcGIS Online または ArcGIS Enterprise ポータルにログインし、コンテンツ ページの マイ コンテンツ タブに移動して、新しいアイテム をクリックし、アプリケーション を選択します。\n  アプリケーション タイプ で 他のアプリケーション を選択します。\n  ダイアログボックスで、以下のパラメータを入力し、保存 をクリックします。\n タイトル - 例えば、Experience Builder credentials などの任意のタイトルをを入力します。 フォルダー - アイテムを保存する任意のフォルダーを選択します。 タグ - Experience Builder のような内容を入力します。 サマリー - アイテムのサマリーを入力します。     設定 タブをクリックします。アプリケーションの登録の項目までスクロールして、更新 をクリックします。\n  登録情報 ダイアログ ボックスで、次のように、リダイレクト URI に https://localhost:3001/ と入力し、追加をクリックして、更新 をクリックします。アプリケーション ID は、このあとの手順で使用するため、コピーなどをして控えておきます。   次の URL https://localhost:3001/ を指定して Experience Builder をブラウザで開きます。\n  ポータルの URL には、ArcGIS Online または ArcGIS Enterprise の組織サイトの URL を指定し、5. で作成した アプリケーション ID を指定します。すべてを指定したらサイン インをクリックします。\n  サイン イン後の流れについては、2. server サービスのインストールのステップ5 以降を参照してください。\n  Windows サービスとしてインストール   お使いの OS に対応した最新の Node.js LTSバージョンをダウンロードし、インストールしてください。\n  Windows のコマンドプロンプトを管理者権限で開きます。\n  Experience Builder の /server ディレクトリにディレクトリを変更 (cd) します。\n  npm ci  コマンドを実行し、依存関係をインストールします。\n  npm run install-windows-service のコマンドを実行します。\n  Windows サービスアプリを開き、Experience Builder サービス（デフォルト名：exb-server）を起動します。\n  Experience Builder サービスを削除するには、 npm run uninstall-windows-service  というコマンドを実行します。\n  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/python-api-install/",
	"title": "インストール ガイド",
	"tags": [],
	"description": "ArcGIS API for Python の環境構築方法を紹介します。",
	"content": "ArcGIS API for Python (以下、Python API) を使用するための環境構築は主に 2 つあります。一つは ArcGIS Pro でインストールする方法、もう一つは Anaconda でインストールする方法です。 Python API は、arcgis という名前のパッケージで Anaconda Cloud 等で配布されています。Anaconda Cloud 上のパッケージは conda を使用してインストールやバージョン管理を行うことができます。conda の詳細については ArcGIS API for Python のための基礎環境：conda入門 を参照してください。\nPython API は ArcGIS Pro 経由でインストールするか、Anaconda 経由でインストールする方法がありますが、PATH の問題を引き起こす可能性があるため、ベストプラクティスとしては、単一のマシンに ArcGIS Pro と Anaconda の両方をインストールすることは推奨されません。\nArcGIS Pro と Anaconda の違いについては以下のブログもご参照ください。\n ArcGIS API for Python のコアコンセプト その 2：Anaconda、Conda、Jupyter Notebook、そしてArcGIS Pro  \rSTEP 1: Python API をインストールする  ArcGIS Pro でインストールする Anaconda 経由でインストールする  STEP 2: arcgis パッケージをアップグレードする  ArcGIS Pro 2.3 以上の環境の場合 Anaconda 環境の場合  STEP 3: ArcGIS API for Python を実行する  Jupyter Notebook を起動する Jupyter Notebook で地図を表示してみる  参考  1. オフライン時のインストール方法   Python API をインストールする ArcGIS Pro でインストールする ArcGIS Pro では、2.1 以降のリリースから conda と arcgis パッケージが最初からインストールされています。 ArcGIS API for Python を実行するを試してみましょう。バージョンが最新でない場合はarcgis パッケージをアップグレードするを参照して Python API を更新します。\nAnaconda 経由でインストールする ArcGIS Pro をお持ちでない場合は、Anaconda をインストールします。 Anaconda は Python とデータサイエンス向けの Python パッケージなどを提供するプラットフォームです。  Python API は Python 3.5 以降を必要とするため、Anaconda ダウンロードページから、適切なバージョンをダウンロードしてください。  ※ Python API は、国内では Windows 版のサポートを提供しています。\nターミナルアプリケーション（ここでは Anaconda Prompt）を開き、次のコマンドを使用して arcgis パッケージをインストールします。\nconda install -c esri arcgis\r --\rインストールされる Python API のバージョンは基本的に最新バージョンとなりますが、古いバージョンがインストールされた場合は以下のようにバージョン番号を指定することで指定したバージョンがインストールされます。\nconda install -c esri arcgis=2.x.x\rAnaconda で Python API の環境構築をした場合、内部ではデータの書き出し等に pyshp を利用しています。2022 年 2 月現在の最新版である pyshp 2.2.0 ではフィールド名が Unicode に対応して日本語が扱えるようになる等、機能が改善されていますが、Python API 1.7.1 以前のバージョンでは古いバージョンの pyshp を使っています。そのため、Anaconda で環境構築する際は 1.8.0 以降の Python API のインストールを推奨します。\n\rインストールが完了したら、ArcGIS API for Python を実行するを試してみましょう。\n arcgis パッケージをアップグレードする ArcGIS Pro 2.3 以上の環境の場合 ArcGIS Pro 2.3 以上では Python API が最初からインストールされています。 ArcGIS Pro をインストールすると、デフォルトで \u0026ldquo;arcgispro-py3\u0026rdquo; という読み取り専用の conda 環境が作成されています。Python API を最新のバージョンに更新するには、Python パッケージ マネージャー (ArcGIS Pro の機能のひとつ) を使用して、デフォルトの環境をクローンし、クローンした環境の Python API を最新バージョンにアップグレードします。\n ArcGIS Pro を起動し、スタートアップ画面の左下にある [設定] をクリックします。 ArcGIS Pro 3.x の場合は[パッケージマネージャー]メニューを、 ArcGIS Pro 2.x の場合は[Python]メニューオプションを選択します。 ArcGIS Pro 3.x の場合は[環境マネージャー]ボタンを、ArcGIS Pro 2.x の場合は[環境の管理]ボタンをクリックし、「環境の管理」ウィンドウを開いて、[デフォルトのクローン]ボタンを選択します。  (ArcGIS Pro 3.x)①[環境マネージャー]ボタンと環境の②[デフォルトのクローン]ボタン\n(ArcGIS Pro 2.x)①[環境の管理]ボタンと環境の②[デフォルトのクローン]ボタン\n\r デフォルト環境のクローンが作成されます。  [名前]の入力ボックスへ入力する ※日本語は推奨しません。半角英数で入力します。\n --\r クローンの作成中は下部にインストール中のパッケージ名が表示されます。すべてのパッケージのインストールが完了すると、クローンされた環境が格納されているディレクトリ名が表示されます。※完了前に操作をすると、作成した環境が正常に動作しない可能性があります。  クローンの作成中の様子(ArcGIS Pro 2.x)\n\r ArcGIS Pro 3.x の場合は、作成した環境をダブルクリック、もしくはアクティブ化をクリックし、ArcGIS Pro 2.x の場合は、作成した環境のラジオボタンをクリックして、環境をアクティブにします。  (ArcGIS Pro 3.x)環境をアクティベート\n(ArcGIS Pro 2.x)環境をアクティベート\n\r 環境の管理ダイアログを閉じ、ArcGIS Pro を閉じます Python コマンドプロンプトを開きます。\nスタートメニュー\u0026gt;すべてのプログラム\u0026gt; ArcGIS\u0026gt; Python コマンドプロンプトで開くことができます。 次のコマンドを入力します。  conda upgrade -c esri arcgis\rコマンドの入力\n\r インストール、アップグレードするパッケージの名前とバージョン番号が表示されるので、問題がなければ y を入力し、実行します。 ArcGIS Pro のバージョンによっては、最新の Python API のバージョンが表示されない場合があります。その場合、一度 n を入力・実行し、以下のコマンドを再入力してください。  conda upgrade -c esri arcgis --no-pin\rArcGIS Pro のバージョンによってはデフォルトの設定で、アップグレードできる Python API のバージョンの上限が指定がされています。 conda upgrade -c esri --no-pin arcgis のうち、--no-pin がバージョンの指定を外して最新版までアップグレードするためのオプションです。 ただし、デフォルトの設定が変更されるわけではないため、アップグレード後に他のパッケージをインストールしようとすると、設定された上限のバージョンにダウングレードするように conda で計画されます。 その場合、そのパッケージをインストールした後に再度上記のコマンドを入力し arcgis パッケージをアップグレードしてください。\n*以下の操作はデフォルトで想定されているパッケージ管理の制御を変更するため、必ず事前に環境を複製しておく等、適切なバックアップの処置をしてください。*\r *また、以下操作の実行による不具合等はサポートの対象としかねますので、ご承知おきください。*\r 永続的に設定を変更するには conda 環境の中の pinned ファイルを書き換える必要があります。\r  C:\\Users\\ (ユーザー名) \\AppData\\Local\\ESRI\\conda\\envs\\ (複製した環境名) \\conda-meta\\pinned\r 上記ファイルをテキストエディタで開くと、`arcgis 1.5.*` と記載されているので、数字部分を `2` など、アップグレードしたいバージョン以上の数字に書き換え保存します。\r 他の記載されているパッケージの設定を変更すると、予期しない不具合を招く恐れがありますので注意してください。 --\r\rインストールされるパッケージの確認\n\r アップグレードしたバージョンを確認するには、次のコマンドを入力します。  conda list arcgis\r Python API を含む ArcGIS 関連のパッケージとそのバージョン番号が表示されます。  \n\rアップデートが完了したら、ArcGIS API for Python を実行するを試してみましょう。\nArcGIS Pro をインストールすると、デフォルトで \"arcgispro-py3\" という読み取り専用の conda 環境が作成されています。Python API を最新のバージョンに更新するには、Python パッケージ マネージャー (ArcGIS Pro の機能のひとつ) を使用して、デフォルトの環境をクローンし、クローンした環境の Python API を最新バージョンにアップグレードします。\r* 新しい空のプロジェクトで ArcGIS Pro を開きます。\r* [プロジェクト]タブを選択して、ArcGIS Pro の詳細オプションを表示します。（下記のスクリーンショットを参照）\r* [Python]メニューオプションを選択します。\r* [環境の管理]ボタンをクリックしウィンドウを開いて、[新規作成]ボタンを選択します。 [環境の管理]ボタンと環境の[新規作成ボタン]\n\r* 新しい環境の名前を入力して[保存]を選択します。\r[名前]の入力ボックスへ入力する ※日本語は推奨しません。半角英数で入力します。\n\r* ダイアログの下部にある青色の進行状況バーが消えたら完了です。この表示が完了してから、次の操作に進んでください。※完了前の操作は正しい環境が作成・動作しない可能性があります。\r青色の進行状況バー\n\r* 作成した環境のラジオボタンを選択して、環境をアクティブにします。ここでの操作は、Anacondaで仮想環境をアクティベートする操作に値します。\r仮想環境を指定する\n\r* 環境の管理ダイアログを閉じ、ArcGIS Pro を閉じます\r* Python コマンドプロンプトを開きますまたはスタートメニューすべてのプログラム ArcGIS Python コマンドプロンプトで開きます。\r* 次のコマンドを入力します。\r```\rconda upgrade -c esri arcgis\r```\rコマンドの入力\n\r* 「Proceed([y]/n)?」 の表示は `y` を入力して実行します。\rインストールするパッケージ計画が表示され、この計画でよい場合は\"y\"を選択します\n\r* アップグレードしたバージョンを確認するには次のコマンドを入力します。\r```\rconda list arcgis\r```\rPython API を含む ArcGIS 関連のパッケージとそのバージョン番号が表示できます\n\rアップデートが完了したら、[ArcGIS API for Python を実行する](#arcgis-api-for-python-を実行する)を試してみましょう。 --\rAnaconda 環境の場合 Anaconda Prompt のようなターミナルアプリケーションを開き、次のコマンドを使用して arcgis を実行してアップグレードします。\nconda upgrade -c esri arcgis\rインストールするパッケージの計画が表示されるので、y を選択し、アップグレードします。\nアップデートが完了したら、ArcGIS API for Python を実行するを試してみましょう。 上記以外の ArcGIS API for Python を実行環境の構築については、Install and Setup(英語)でご確認ください。\n ArcGIS API for Python を実行する Jupyter Notebook を起動する  Pythonコマンドプロンプト (ArcGIS Pro でインストールした場合)、もしくは Anaconda Prompt (Anaconda でインストールした場合) を起動します。 cd コマンドを使用して、ノートブックがあるディレクトリ、またはノートブックを作成したいディレクトリに移動します。 次のように入力して Jupyter Notebook を起動します。  jupyter notebook\r 起動しなかった場合は、以下を試してください。  jupyter-notebook\rまたは、スタートメニュー\u0026gt;すべてのプログラム\u0026gt; ArcGIS\u0026gt;Jupyter Notebook を選択しても起動することができます。\nJupyter Notebook の詳しい操作は Jupyter Notebook を使ってみようもご覧ください。 Python API バージョン 1.5.0 以降からは、Jupyter Lab からも操作が可能です。Jupyter Lab を使ってみようも是非ご覧ください。\nJupyter Notebook で地図を表示してみる 次の手順で、地図を表示するための新しいノートブックを作成します。\n Click New \u0026gt; Python 3  Python[default] --\r\r次のコードを入力します。\nfrom arcgis.gis import GIS my_gis = GIS() my_gis.map() \rJupyter Notebook から使用している Python API のバージョンを確認する場合、次のコードを実行することで、現在お使いのバージョンを確認することができます。\nimport arcgis arcgis.__version__ もしくは、先頭に ! を付けて以下のようにコマンドを実行して確認することも可能です。\n!conda list arcgis\r\r 参考 1. オフライン時のインストール方法 インターネットに接続していない環境の場合、次の手順で Python API のインストールが可能です。\nただし、この場合、すべての依存パッケージがインストールされるわけではないため、Jupyter Notebook の利用など、一部の機能が制限される可能性があります (※ 組織やコンテンツの管理など特定のタスクは以下手順でインストールする six パッケージのみで可能です。)\n依存パッケージについては米国Esri 社のガイドページ：System requirements を参照ください。\nインターネットに接続できる環境で以下の必要なソフトウェアをダウンロードします。  最新の Python 3.x 用の Anaconda 適切なバージョンの Python API のファイル  Anaconda クラウドの Esri のチャネルからダウンロード可能です。 ファイル名は以下のパターンに従います  OS/arcgis-x.x.x-pyZZyyyyyyy-y.tar.bz2.  OS: 使用するマシンの OS x.x.x: API のバージョン ZZ: 使用する Python のバージョン yyyyyyy-y: チャネルにアップロードされた conda のパッケージに付与されるハッシュ ナンバー     例えば、Windows 64 bit のマシンで、Python API 1.6.0 の Python 3.7 版をダウンロードする場合は、\u0026quot;win-64/arcgis-1.6.0-py37h62639d4_1.tar.bz2\u0026quot; をクリックしてダウンロードします。    \rオフライン環境で Anaconda を設定  Anaconda をインストールします。 次のコマンドでオフライン モードに設定します。  conda config --set offline True\r 次のコマンドで新しい環境を作成します。  conda create -n \u0026lt;環境名\u0026gt; python six\r 環境をアクティベートします。  conda activate \u0026lt;環境名\u0026gt;\r ArcGIS API for Python をインストールします。  conda install \u0026lt;事前にダウンロードしたファイルのパス\u0026gt;\r\u0026ldquo;done\u0026quot;が表示されればインストール完了です。\nより詳しい情報は 米国Esri ガイドページ：Install-Offline をご覧ください。\n現在国内では ArcGIS API for Python の Linux での利用は未サポートです。ご利用そのものを妨げるものではありませんが、利用される際は ESRIジャパンの提供するサポート サービス等の対象とならない可能性がある点に留意してください。\r\r##### Anaconda をインストール\rLinux では ArcGIS Pro を利用できないため、Anaconda から ArcGIS API for Python をインストールします。\r* Linux 版の Anaconda の [ダウンロード URL](https://www.anaconda.com/distribution/#download-section) を確認し、wget でファイルをダウンロードします\r* ここでは Anaconda 2019.10 for Linux をダウンロードします。\r```\rwget https://repo.anaconda.com/archive/Anaconda3-2019.10-Linux-x86_64.sh\r```\r\r* ダウンロードしたインストーラーを以下のコマンドで実行します。\r```\rsh Anaconda3-2019.10-Linux-x86_64.sh\r```\r\r* インストールするディレクトリは任意のディレクトリを選ぶことができます。ここではデフォルトの設定である、ログイン ユーザーのホーム ディレクトリにインストールすることにします。\r\r* 最後に PATH を通すか確認されます。ここでは [Anaconda のドキュメント](https://docs.anaconda.com/anaconda/user-guide/faq/#id2)に従い、yes として進めます。\r\r変更を反映させるためには一度 シェル を閉じて再度開く必要があります。\r\r##### `arcgis` パッケージをインストール\rArcGIS API for Python (arcgis) をインストールします。\rAnaconda の base 環境にインストールしてもよいですが、ここでは conda で新しい環境を作成してインストールします。\r* 新しい Python 環境を作成\r* 以下のコマンドで新しい Python 環境を作成します。\r*  には識別しやすい任意の環境名を指定します。また、ここではインストールする Python のバージョンとして 3.7 を指定しています。\r```\rconda create -n  python=3.7\r```\r* 作成した環境をアクティベート\r* 以下のコマンドで作成した環境に切り替えます\r```\rconda activate \r```\r* ArcGIS API for Python をインストール\r* 以下のコマンドで ArcGIS API for Python をインストールします。\r* 以下では ArcGIS API for Python 1.7.1 をインストールするよう指定しています。\r```\rconda install -c esri arcgis=1.7.1\r```\r* インストールの確認\r* インストールが終了したら以下のコマンドで正常にインストールされているか確認しましょう。\r* 正常にインストールされていれば、arcgis というパッケージ名とインストールしたバージョン番号が表示されます。\r```\rconda list arcgis\r```\r --\rESRIジャパンが運営する GIS アプリ開発者のためのコミュニティ グループ では、Python API の機能や実際のコードをブログでご紹介しています。 また、GitHub にも日本語による解説付きのコードを公開していますので、是非ご参照ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/window/",
	"title": "ウィンドウ（Window）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Window\nウィンドウ（Window） ウィンドウはページに似ていて、任意のウィジェットを追加することができ、コンテンツを表示するための2つの設定（固定とアンカー設定）があります。 固定ウィンドウはモーダルを作成し、メインウィンドウを無効にしますが、ユーザーがエクスペリエンスに戻る前にウィンドウと対話できるように表示を維持します。固定ウィンドウはスプラッシュスクリーンとして使用したり、ページで開いたり、ウィジェットから開いたりすることができます。アンカー ウィンドウは、ボタンやテキストウィジェットなどのウィジェットからトリガーされます。\napp config では、ウィンドウは dialogs で定義されます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/calcite-design-system/tutorials/",
	"title": "チュートリアル",
	"tags": [],
	"description": "Calcite の開発パターンを学び、ワークフローやアプリケーションを構築します。",
	"content": "出典：Calcite Design System - Tutorials\n段階的な手順に従って、ArcGIS Maps の機能と Calcite Design System のコンポーネントやパターンを組み込んだアプリケーションを構築します。\nコンセプト コア コンセプトを適用し、Calcite Design System の機能を確認します。\n  地図アプリの作成\nCalcite Components を使ってインタラクティブな地図アプリケーションを作成します。\n  ダークモードスイッチの作成\nCalcite Components と ArcGIS Maps SDK for JavaScript をライトモードとダークモードを切り替えるダークモードスイッチを構築します。\n  アプリケーションパターン 基本的な概念とパターンに基づいて構築し、それらをエクスペリエンスとワークフローに適用します。\n  コア コンセプトの適用\nインタラクティブなアプリケーションを作りながら、Calcite Components の基本的な概念を学びます。\n  最近の地震をフィルタリング\nCalcite Design System でユーザー インターフェース(UI)を作成します。\n  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/deploy-pattern/",
	"title": "デプロイ パターン",
	"tags": [],
	"description": "ArcGIS Web AppBuilder (Developer Edition) で作成したアプリやウィジェットのデプロイ パターンを紹介します。",
	"content": "トピック  概要 Web アプリケーションをデプロイ ウィジェットをデプロイ テンプレートをデプロイ  概要 ArcGIS Web AppBuilder (Developer Edition) (以下 Developer Edition) では ArcGIS Web AppBuilder を拡張して、独自の Web アプリケーションやウィジェット、テンプレートを作成することが可能です。エンド ユーザーの利用形態や要件により最適なデプロイは異なりますが、このページでは以下の 3 つの主要なデプロイ パターンと、それぞれのデプロイ方法についてご紹介します。\n Web アプリケーションをデプロイ 全体像  Web アプリケーションを作成し、独自のサーバーでホストすることができます。特定の業務で継続的に利用されるアプリ等、ユーザーによる設定変更が不要な場合や、ユーザーに設定変更をさせたくない場合等に活用できます。   必要なコンポーネント  開発時  Node.js Developer Edition   運用時  ArcGIS Enterprise または ArcGIS Online Web サーバー (ArcGIS Enterprise の Web サーバーと併用も可)    手順概要 以下は Web アプリケーション作成から、デプロイ、実際の運用までの流れの概要です。\n カスタム ウィジェットを含む web アプリケーションを作成  Developer Edition を用いたウィジェットの開発や web アプリケーションの作成には Node.jsが必要です。 詳しくはインストールガイドをご覧下さい。 カスタム ウィジェットを開発する際は、カスタム ウィジェット開発ガイドをご覧ください。   作成した web アプリケーションを自身で用意した Web サーバーに配置  ArcGIS Enterprise で使用している Web サーバーと併用することも可能です。 ※ ArcGIS Online を使用してホストすることはできません。 詳しくは、アプリケーションのデプロイをご覧ください。   ユーザーが作成された web アプリケーションを利用  ユーザーが web アプリケーションにアクセスして利用します。 ArcGIS Enterprise や ArcGIS Online のポータルにアイテムとして表示させたい場合はアプリの URL をアイテムに登録する必要があります。  詳細は「アプリの追加」及びその後の「アプリの登録」をご覧ください。   内部的には、アプリは ArcGIS Online もしくは ArcGIS Enterprise の Web マップを参照してアプリ上に地図を表示します。     ウィジェットをデプロイ  WebApp Builder で使用できるウィジェットのみを開発し、独自のサーバーでホストすることも可能です。ユーザーが ArcGIS Online や ArcGIS Enterprise を使用して独自に web アプリケーションを作成することを想定しているものの、デフォルトの ArcGIS Web AppBuilder のウィジェットには無い機能を拡張したい場合に活用できます。   必要なコンポーネント  開発時  Node.js Developer Edition   運用時  ArcGIS Enterprise Web サーバー (ArcGIS Enterprise の Web サーバーと併用も可)    手順概要 以下はカスタムウィジェットの作成から、デプロイ、実際の運用までの流れの概要です。\n カスタムウィジェットを作成  Developer Edition を用いたウィジェットの作成には Node.jsが必要です。 詳しくはインストールガイドをご覧下さい。 カスタムウィジェット開発の詳細については、カスタム ウィジェット開発ガイドをご覧下さい。   作成したカスタムウィジェットを自身で用意した Web サーバーに配置  ArcGIS Enterprise で使用している Web サーバーと併用することも可能です。 ※ ウィジェットを配置するサーバーが自己署名証明書を使用している場合、Portal for ArcGIS に証明書をインポートする必要があります。詳しい方法はポータルへの証明書のインポートをご覧ください。 Web サーバーに配置後、ArcGIS Enterprise に組み込まれている ArcGIS Web AppBuilder にカスタムウィジェットを追加します。  詳しくは、カスタム ウィジェットの追加をご覧ください。 ※ ArcGIS Online に追加することはできません。     ウィジェットを使った web アプリケーションの作成・利用  ユーザーが ArcGIS Enterprise に組み込まれている ArcGIS Web AppBuilder を利用してカスタムウィジェットを使用した web アプリケーションを作成・利用します。 内部的には、アプリは Web サーバーでホストされているカスタムウィジェットを参照して動作します。     テンプレートをデプロイ  Esri が用意している web アプリケーションのテンプレートとは別に、Developer Edition で作成した web アプリケーションをベースに独自のテンプレートを作成できます。テンプレートを用いることで、ユーザー自身がマップや簡易な設定の変更のみで web アプリケーションを作成することができるようになります。テンプレートを作成しておくと、必要な機能が共通している複数の業務に対して、異なるマップや設定を適用するだけですぐ各業務向けのアプリを作成できます。 ここでご紹介する方法では開発環境と運用環境が同じである点にご注意ください。   必要なコンポーネント  開発時  Node.js Developer Edition   運用時  Node.js Developer Edition ArcGIS Online または ArcGIS Enterprise    手順概要 以下はテンプレートの作成から、デプロイ、実際の運用までの流れの概要です。\n カスタムウィジェットを含む web アプリケーションを作成  Developer Edition を用いたウィジェットの作成には Node.jsが必要です。 詳しくはインストールガイドをご覧下さい。 カスタム ウィジェットを開発する際は、カスタム ウィジェット開発ガイドをご覧ください。   web アプリケーションをテンプレートとして保存 (登録)  Developer Edition で作成した web アプリケーションを組織にエクスポートします。  Developer Edition でアプリを作成し、[保存] ボタンをクリックした後 [テンプレートとしてエクスポート] をクリックします。  構成可能にするパラメーターを設定した後、組織にエクスポートをクリックします。  ※ テンプレートは、組織が設定するテンプレート グループに共有される必要があります。管理権限を持っていない場合、権限が無いことと別途マニュアルで追加する必要がある旨がダイアログで表示されます。 組織の管理者権限がある場合、以下の手順でテンプレート グループを設定できます。  [組織] → [設定] → [マップ] の順にクリック  [テンプレート] の中でテンプレートを共有するグループを指定  [Esri のデフォルトの構成可能なアプリをグループで共有します] をクリックすると、Esri がデフォルトで用意しているテンプレートも通常どおり使用できます。         テンプレートを使った web アプリケーションの作成・利用  ユーザーが ArcGIS Online もしくは ArcGIS Enterprise のテンプレートから web アプリケーションを作成・利用します。 内部的には、アプリは Developer Edition のテンプレートを参照して動作します。 ※ 上記理由から、運用時においてもユーザーが Developer Edition にアクセスできる必要があります。    3つのデプロイ パターンの総括表    パターン 開発時に必要なコンポーネント 運用時に必要なコンポーネント ArcGIS Online での利用可否 ArcGIS Enterprise での利用可否     Web アプリケーションをデプロイ Node.js、Developer Edition Web サーバー、ArcGIS Online もしくは ArcGIS Enterprise 〇 〇   ウィジェットをデプロイ Node.js、Developer Edition Web サーバー、 ArcGIS Enterprise × 〇   テンプレートをデプロイ Node.js、Developer Edition Developer Edition、ArcGIS Online もしくは ArcGIS Enterprise 〇 〇    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/android/migration-android-100.x/",
	"title": "バージョン 10.2.x から 100.x への移行",
	"tags": [],
	"description": "今まで ArcGIS Runtime SDK for Android バージョン 10.2.x を使用してアプリケーションを開発されていた開発者向けのガイドです。",
	"content": "ArcGIS Runtime SDK バージョン 100.x は新しいアーキテクチャを使用してゼロから開発された次世代の ArcGIS Runtime です。このバージョンアップに伴い API の再設計が行なわれています。このドキュメントでは、バージョン 100.x の変更点について説明します。\nArcGIS Runtime SDK for Android に関しては、ESRIジャパン 製品ページをご参照ください。\n以下は、バージョン 100.x の主な変更点です。\n Gradle 参照プロジェクトの変更 マップ ビュー レイヤー クラス名の変更 フィーチャ レイヤーの表示 フィーチャの操作 個別属性表示 グラフィックス オーバーレイ ジオメトリとジオメトリ ビルダー ローダブル パターン 新しい同期パターン 既知の制限事項  Gradle 参照プロジェクトの変更 Android Studio のビルド ツールは Gradle を使用し、maven リポジトリとライブラリの参照を変更します。\nrepositories {\rjcenter()\rmaven {\rurl 'https://esri.jfrog.io/artifactory/arcgis'\r}\r}\rdependencies {\rimplementation 'com.esri.arcgisruntime:arcgis-android:100.10.0'\r}\rArcGIS Runtime SDK for Android がサポートする最新の動作環境は、ESRIジャパン 製品ページ（動作環境）をご参照ください。\nマップ 100.x では、ArcGISMap オブジェクトを API のコアとして、ArcGIS プラットフォームの Web GIS 機能を迅速に利用できるようになりました。\nArcGISMap オブジェクトは 、それを表示する View と分離されています。ArcGISMap オブジェクトには 、操作レイヤー、ベースマップ、ブックマーク等の ArcGIS 固有のデータを設定でき、アプリケーションで利用することができます。\nビュー MapView（2D表示用）と SceneView（3D表示用）は、UI コンポーネントです。MapView クラスの map プロパティに、ArcGISMap オブジェクトを設定します。\n100.x では、以下のようにマップを表示します。\n// ベースマップを指定してマップを初期化 ArcGISMap mArcGISMap = new ArcGISMap(); mArcGISMap.setBasemap(Basemap.createTopographic()); // マップビューにマップを設定 MapView mMapView = findViewById(R.id.MapView); mMapView.setMap(mArcGISMap); レイヤー クラス名の変更 各レイヤーのクラス名が以下のように変更されています。\n   レイヤー 10.2.x のクラス名 100.x のクラス名     ArcGIS Server ダイナミック マップ サービス レイヤー ArcGISDynamicMapServiceLayer ArcGISMapImageLayer   タイル マップ サービス レイヤー ArcGISTiledMapServiceLayer ArcGISTiledLayer   タイル パッケージ レイヤー ArcGISLocalTiledLayer ArcGISTiledLayer    100.x でサポートされているレイヤーの種類については、ArcGIS Runtime SDK for Android: レイヤー（英語）をご参照ください。\n作成した各レイヤーは、以下の方法でマップに追加します。\n// 操作レイヤーとしてマップに追加する mArcGISMap.getOperationalLayers().add(arcgis_map_image_layer) // ベースマップとしてマップに追加する Basemap mBasemap = new Basemap(); mBasemap.getBaseLayers().add(arcgis_tiled_layer); フィーチャ レイヤーの表示 フィーチャ サービスや端末のローカルに格納されたジオデータベースのデータをマップに表示するにはフィーチャ レイヤーを使用します。 フィーチャ レイヤーを表示するには、はじめにフィーチャ テーブルを作成します（フィーチャ サービスのデータをフィーチャ レイヤーで表示する場合は ArcGISFeatureTable オブジェクト、ジオデータベースのデータを表示する場合は GeodatabaseFeatureTable オブジェクトを使用します）。次に作成したフィーチャ テーブルを引数として FeatureLayer オブジェクトを作成し、ArcGISMap オブジェクトの OperationalLayers に追加します。\n次のコードは、フィーチャ サービスのデータを FeatureLayer としてマップに追加する方法を示しています。\n// フィーチャ サービスの URL からフィーチャ テーブルを作成 ServiceFeatureTable serviceFeatureTable = new ServiceFeatureTable(\u0026#34;https://services.arcgis.com/wlVTGRSYTzAbjjiC/arcgis/rest/services/all_Japan_shikuchoson/FeatureServer/0\u0026#34;); // フィーチャ テーブルからフィーチャ レイヤーを作成 FeatureLayer featureLayer = new FeatureLayer(serviceFeatureTable); // フィーチャ レイヤーをマップの操作レイヤーに追加 mArcGISMap.getOperationalLayers().add(featureLayer); フィーチャの操作 フィーチャの検索や編集はフィーチャ テーブル （ServiceFeatureTable または GeodatabaseFeatureTable）に対して行います。\nフィーチャ サービスから作成したフィーチャ テーブル（ServiceFeatureTable）の場合、フィーチャ テーブルのフィーチャは、マップ上にレンダリングするために必要最小限の情報だけを含むように最適化されています。これにより、フィーチャを表示するための待機時間と帯域幅の消費が削減されます。フィーチャの編集やすべての属性情報を表示するような場合は完全な情報を取得するために、ローダブル パターン等を使用して、フィーチャを明示的にロードしておく必要があります。\nフィーチャのリクエスト モード フィーチャ サービスからフィーチャを取得する場合は、 リクエスト モードの設定によってフィーチャの取得頻度とや端末上でのデータのキャッシュ方法を制御します。リクエスト モードには、ON_INTERACTION_CACHE、 ON_INTERACTION_NO_CACHE、MANUAL_CACHE  があります。リクエスト モードはフィーチャ テーブルが初期化される前に、ServiceFeatureTable の setFeatureRequestMode メソッドを使用して設定できます。\n ON_INTERACTION_CACHE : ユーザーの操作によりマップの表示領域が変更されると、フィーチャが自動的にリクエストされます。リクエストされたすべてのデータはローカルにキャッシュされます。データがキャッシュされルため、既に表示された領域にマップが移動しても、再度フィーチャはリクエストされません。サーバー上のデータが変更される可能性が少ない静的なデータに適したモードです。 ON_INTERACTION_NO_CACHE : ユーザーの操作によりマップの表示領域が変更されると、フィーチャが自動的にリクエストされますが、キャッシュはされません。既に表示された領域にマップが移動すると、再度フィーチャがリクエストされます。サーバー上のデータが継続的に更新される可能性がある場合に適したモードです。 MANUAL_CACHE : ユーザーによるマップ操作では、フィーチャは自動的にリクエストされません。このモードを使用する場合は、ServiceFeatureTable の populateFromServiceAsync メソッドを使用して明示的にデータをリクエストする必要があります。  以下のコードは populateFromServiceAsync メソッドを使用して、サーバー上のすべてのフィーチャを取得する方法の例です。\n// フィーチャの検索パラメーターを設定 QueryParameters queryParameters = new QueryParameters(); // すべてのフィーチャを取得するように条件を設定 queryParameters.setWhereClause(\u0026#34;1=1\u0026#34;); // 検索結果にフィーチャのすべての属性情報（outFields の配列に \u0026#34;*\u0026#34; を指定）を含める ArrayList\u0026lt;String\u0026gt; outFields = new ArrayList\u0026lt;\u0026gt;(); outFields.add(\u0026#34;*\u0026#34;); serviceFeatureTable.populateFromServiceAsync(queryParameters,true,outFields); フィーチャの編集 フィーチャの編集はフィーチャ テーブルに対して行います。フィーチャ サービスまたはジオデータベースのデータから作成したフィーチャ テーブルのどちらを編集する場合も実装方法に違いはありません。\nフィーチャの編集方法は、 ArcGIS Runtime SDK for Android: フィーチャの編集（英語）をご参照ください。\nフィーチャの検索 フィーチャの検索はフィーチャ テーブルに対して行います。フィーチャ サービスまたはジオデータベースのデータから作成したフィーチャ テーブルのどちらを編集する場合も実装方法に違いはありません。検索を行うには ServiceFeatureTable または GeodatabaseFeatureTable クラスの queryFeaturesAsync メソッドを使用します。\n次のコードは、フィーチャ サービスから作成したフィーチャ テーブルからフィーチャを検索する方法を示しています。\nfinal ListenableFuture\u0026lt;FeatureQueryResult\u0026gt; queryResult = serviceFeatureTable.queryFeaturesAsync(queryParameters); queryResult.addDoneListener(()-\u0026gt;{ // call get on the future to get the result  try { FeatureQueryResult result = queryResult.get(); for (Iterator\u0026lt;Feature\u0026gt; features = result.iterator(); features.hasNext();) { // 検索結果のフィーチャを取得  Feature feature = features.next(); ・・・ } } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } }); 個別属性表示 マップ上で特定の場所をタップして、その位置にあるフィーチャをすべてのレイヤーから検索して取得することができます。この操作はビューに対して行います。次のコードは、MapView クラスの identifyLayersAsync メソッドを使用してフィーチャを取得する方法を示しています。\nfinal ListenableFuture\u0026lt;List\u0026lt;IdentifyLayerResult\u0026gt;\u0026gt; identifyLayersResult = mapView.identifyLayersAsync(screenPoint,10,true); identifyLayersResult.addDoneListener(()-\u0026gt;{ try { List\u0026lt;IdentifyLayerResult\u0026gt; identifyResult = identifyLayersResult.get(); for(IdentifyLayerResult identifyLayerResult : identifyResult){ // GeoElement オブジェクトの取得  List\u0026lt;GeoElement\u0026gt; geoElement = identifyLayerResult.getElements(); ・・・ } } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } }); グラフィックス オーバーレイ グラフィックは、マップ上に一時的なデータを表示するために使用されます。MapView オブジェクトにはグラフィックを表示するためのグラフィックス オーバーレイ（GraphicsOverlay）が含まれています。 グラフィックス オーバーレイを使用することで、マップ上のレイヤーの順序が変更されても、グラフィックが常に最上位に表示されます。\n次のコードは、MapView オブジェクトに、グラフィックス オーバーレイを使用してグラフィックを追加する方法を示しています。\n// ジオメトリとシンボルを設定してグラフィックを作成 Graphic graphic = new Graphic(geometry,symbol); // グラフィックス オーバーレイに作成したグラフィックを追加 GraphicsOverlay graphicsOverlay = new GraphicsOverlay(); graphicsOverlay.getGraphics().add(graphic); // MapView の GraphicsOverlays に作成したグラフィックス オーバーレイを追加 mapView.getGraphicsOverlays().add(graphicsOverlay); ジオメトリとジオメトリ ビルダー Geometry オブジェクトのコンストラクタを使用すると、既知の座標を使用してジオメトリを作成できますが、作成後にそのジオメトリを変更することはできません。\nジオメトリ ビルダー（GeometryBuilder）を使用すると、ゼロから新しいジオメトリを作成したり、既存のジオメトリを基に、ジオメトリを変更することができます。\nローダブル パターン データを非同期でロードして状態を初期化するマップやレイヤー等のリソースは、ローダブル パターンが採用されています。各リソースのプロパティにアクセスするには、ローダブル パターンを使用して、リソースがロードされた後にアクセスすることが推奨されます。ローダブル パターンは、ロード状態の振る舞いをより均一にして且つ一貫性を持たせることで、非同期性をより明示的にします。ローダブル パターンでは、各リソースは自動的にリソースの状態をロードしません。それらは、開発者が明示的に実行したときに、遅延ロードします。 各リソースの状態は、NotLoaded（ロードが開始していない、Loading（ロード中）、Loaded（ロードに成功）、FailedToLoad（ロードに失敗） のいずれかで監視することもできます。\n詳細は、ArcGIS Runtime SDK for Android: ローダブル パターン（英語）をご参照ください。\n次のコードは、ローダブル パターンの基本的な使用方法の例を示しています。\nFeatureLayer featureLayer = new FeatureLayer(serviceFeatureTable); if(featureLayer.getLoadStatus().equals(LoadStatus.FAILED_TO_LOAD)){ Log.e(\u0026#34;eTag\u0026#34;,\u0026#34;error\u0026#34;); }else{ // フィーチャ レイヤーのロードに成功 } 新しい同期パターン Java 言語で ListenableFuture というインターフェースで馴染みのある Future パターンが拡張されました。この新しい API は、メソッドの完了時に必要な数のリスナーを追加できます。\n既知の制限事項 本バージョンでの既知の制限事項が、ArcGIS Runtime SDK for Android: リリース ノート（英語）に記載されていますので、ご参照ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/ios/migration-ios-100.x/",
	"title": "バージョン 10.2.x から 100.x への移行",
	"tags": [],
	"description": "今まで ArcGIS Runtime SDK for iOS バージョン 10.2.x を使用してアプリケーションを開発されていた開発者向けのガイドです。",
	"content": "ArcGIS Runtime SDK バージョン 100.x は新しいアーキテクチャを使用してゼロから開発された次世代の ArcGIS Runtime です。このバージョンアップに伴い API の再設計が行なわれています。このドキュメントでは、バージョン 100.x の変更点について説明します。\nArcGIS Runtime SDK for iOS に関しては、ESRIジャパン 製品ページをご参照ください。\n以下は、バージョン 100.x の主な変更点です。\n マップとシーン ビュー レイヤー クラス名の変更 フィーチャ レイヤーの表示 フィーチャの操作 個別属性表示 グラフィックス オーバーレイ ジオメトリとジオメトリ ビルダー スケッチ エディター ローダブル パターン ブロックを使用した非同期プログラミング 既知の制限事項  マップとシーン 100.x では、AGSMap オブジェクト（2D表示用）と AGSScene オブジェクト（3D表示用）を API のコアとして、ArcGIS プラットフォームの Web GIS 機能を迅速に利用できるようになりました。\nAGSMap オブジェクトと AGSScene オブジェクトは 、それらを表示する View と分離されています。AGSMap オブジェクトと AGSScene オブジェクトには 、操作レイヤー、ベースマップ、ブックマーク等の ArcGIS 固有のデータを設定でき、アプリケーションで利用することができます。\nビュー AGSMapView（2D表示用）と AGSSceneView（3D表示用）は、UI コンポーネントです。AGSMapView クラスの map プロパティに、AGSMap オブジェクトを、AGSMapSceneView クラスの scene プロパティには AGSScene オブジェクトを設定します。\n100.x では、以下のようにマップを表示します。\n// ベースマップを指定してマップを初期化 let map = AGSMap(basemap:AGSBasemap.imagery()) // マップビューにマップを設定 self.mapView.map = map レイヤー クラス名の変更 各レイヤーのクラス名が以下のように変更されています。\n   レイヤー 10.2.x のクラス名 100.x のクラス名     ArcGIS Server ダイナミック マップ サービス レイヤー AGSDynamicMapServiceLayer AGSArcGISMapImageLayer   タイル マップ サービス レイヤー AGSTiledMapServiceLayer AGSArcGISTiledLayer   タイル パッケージ レイヤー AGSLocalTiledLayer AGSArcGISTiledLayer    作成した各レイヤーは、以下の方法でマップに追加します。\n// 操作レイヤーとしてマップに追加する self.map.operationalLayers.add(arcgis_map_image_layer) // ベースマップとしてマップに追加する self.map.basemap = AGSBasemap(baseLayer: arcgis_tiled_layer) フィーチャ レイヤーの表示 フィーチャ サービスや端末のローカルに格納されたジオデータベースのデータをマップに表示するにはフィーチャ レイヤーを使用します。 フィーチャ レイヤーを表示するには、はじめにフィーチャ テーブルを作成します（フィーチャ サービスのデータをフィーチャ レイヤーで表示する場合は AGSArcGISFeatureTable オブジェクト、ジオデータベースのデータを表示する場合は AGSGeodatabaseFeatureTable オブジェクトを使用します）。次に作成したフィーチャ テーブルを引数として AGSFeatureLayer オブジェクトを作成し、AGSMap オブジェクトの OperationalLayers に追加します。\n次のコードは、フィーチャ サービスのデータを AGSFeatureLayer としてマップに追加する方法を示しています。\n// フィーチャ サービスの URL からフィーチャ テーブルを作成 let featureTable = AGSServiceFeatureTable(url: URL(string: \u0026#34;https://services.arcgis.com/wlVTGRSYTzAbjjiC/arcgis/rest/services/all_Japan_shikuchoson/FeatureServer/0\u0026#34;)!) // フィーチャ テーブルからフィーチャ レイヤーを作成 let featureLayer = AGSFeatureLayer(featureTable: featureTable) // フィーチャ レイヤーをマップの操作レイヤーに追加 self.map.operationalLayers.add(featureLayer) フィーチャの操作 フィーチャの検索や編集はフィーチャ テーブル （AGSArcGISFeatureTable または AGSGeodatabaseFeatureTable）に対して行います。\nフィーチャ サービスから作成したフィーチャ テーブル（AGSArcGISFeatureTable）の場合、フィーチャ テーブルのフィーチャは、マップ上にレンダリングするために必要最小限の情報だけを含むように最適化されています。これにより、フィーチャを表示するための待機時間と帯域幅の消費が削減されます。フィーチャの編集やすべての属性情報を表示するような場合は完全な情報を取得するために、ローダブル パターン等を使用して、フィーチャを明示的にロードしておく必要があります。\nフィーチャのリクエスト モード フィーチャ サービスからフィーチャを取得する場合は、 リクエスト モードの設定によってフィーチャの取得頻度とや端末上でのデータのキャッシュ方法を制御します。リクエスト モードには、OnInteractionCache、 OnInteractionNoCache、ManualCache があります。リクエスト モードはフィーチャ テーブルが初期化される前に、AGSServiceFeatureTable の featureRequestMode プロパティを使用して設定できます。\n  OnInteractionCache: ユーザーの操作によりマップの表示領域が変更されると、フィーチャが自動的にリクエストされます。リクエストされたすべてのデータはローカルにキャッシュされます。データがキャッシュされルため、既に表示された領域にマップが移動しても、再度フィーチャはリクエストされません。サーバー上のデータが変更される可能性が少ない静的なデータに適したモードです。\n  OnInteractionNoCache: ユーザーの操作によりマップの表示領域が変更されると、フィーチャが自動的にリクエストされますが、キャッシュはされません。既に表示された領域にマップが移動すると、再度フィーチャがリクエストされます。サーバー上のデータが継続的に更新される可能性がある場合に適したモードです。\n  ManualCache: ユーザーによるマップ操作では、フィーチャは自動的にリクエストされません。このモードを使用する場合は、AGSServiceFeatureTable の populateFromService メソッドを使用して明示的にデータをリクエストする必要があります。\n以下のコードは populateFromService メソッドを使用して、サーバー上のすべてのフィーチャを取得する方法の例です。\n// フィーチャの検索パラメーターを設定 let params = AGSQueryParameters() // すべてのフィーチャを取得するように条件を設定 params.whereClause = \u0026#34;1 = 1\u0026#34; // 検索結果にフィーチャのすべての属性情報（outFields の配列に \u0026#34;*\u0026#34; を指定）を含める self.featureTable.populateFromService(with: params, clearCache: true, outFields: [\u0026#34;*\u0026#34;]) {(result, error) -\u0026gt; Void in if let error = error { // フィーチャの取得に失敗  print(\u0026#34;Error:\\(error.localizedDescription)\u0026#34;) } else { // フィーチャの取得に成功（フィーチャ数を表示）  print(result?.featureEnumerator().allObjects.count ?? \u0026#34;0\u0026#34;) } }   フィーチャの編集 フィーチャの編集はフィーチャ テーブルに対して行います。フィーチャ サービスまたはジオデータベースのデータから作成したフィーチャ テーブルのどちらを編集する場合も実装方法に違いはありません。\nフィーチャの編集方法は、 ArcGIS Runtime SDK for iOS: フィーチャの編集（英語）をご参照ください。\nフィーチャの検索 フィーチャの検索はフィーチャ テーブルに対して行います。フィーチャ サービスまたはジオデータベースのデータから作成したフィーチャ テーブルのどちらを編集する場合も実装方法に違いはありません。検索を行うには AGSServiceFeatureTable または AGSGeodatabaseFeatureTable クラスの queryFeaturesWithParameters メソッドを使用します。\n次のコードは、フィーチャ サービスから作成したフィーチャ テーブルからフィーチャを検索する方法を示しています。\nfeatureTable.queryFeatures(with: queryParameters, queryFeatureFields: .loadAll, completion:{ (result, error) -\u0026gt; Void in if let error = error { print(\u0026#34;Error:\\(error.localizedDescription)\u0026#34;) } else { let enumr = result?.featureEnumerator() for feature in enumr! { // 検索結果のフィーチャを取得  let feature = feature as! AGSArcGISFeature } } }) 個別属性表示 マップ上で特定の場所をタップして、その位置にあるフィーチャをすべてのレイヤーから検索して取得することができます。この操作はビューに対して行います。次のコードは、AGSMapView クラスの identifyLayers メソッドを使用してフィーチャを取得する方法を示しています。\nself.mapView.identifyLayers(atScreenPoint: screenPoint, tolerance: 10, returnPopupsOnly: true, completion: { (results, error) -\u0026gt; Void in if let error = error { print(error) } else { for identifyLayerResult in results! { for geoElement in identifyLayerResult.geoElements { // AGSGeoElement オブジェクトの取得  } } } }) グラフィックス オーバーレイ グラフィックは、マップ上に一時的なデータを表示するために使用されます。AGSMapView と AGSSceneView オブジェクトにはグラフィックを表示するためのグラフィックス オーバーレイ（AGSGraphicsOverlay）が含まれています。 グラフィックス オーバーレイを使用することで、マップ上のレイヤーの順序が変更されても、グラフィックが常に最上位に表示されます。\n次のコードは、AGSMapView オブジェクトに、グラフィックス オーバーレイを使用してグラフィックを追加する方法を示しています。\n// ジオメトリとシンボルを設定してグラフィックを作成 let pointGraphic = AGSGraphic(geometry: pointGeometry, symbol: poitnSymbol, attributes: nil) // グラフィックス オーバーレイに作成したグラフィックを追加 let graphicsOverlay = AGSGraphicsOverlay() graphicsOverlay.graphics.add(pointGraphic) // AGSMapView の GraphicsOverlays に作成したグラフィックス オーバーレイを追加 self.mapView.graphicsOverlays.add(graphicsOverlay) ジオメトリとジオメトリ ビルダー AGSGeometry オブジェクトのコンストラクタを使用すると、既知の座標を使用してジオメトリを作成できますが、作成後にそのジオメトリを変更することはできません。\nジオメトリ ビルダー（AGSGeometryBuilder）を使用すると、ゼロから新しいジオメトリを作成したり、既存のジオメトリを基に、ジオメトリを変更することができます。\nスケッチ エディター スケッチ エディター（AGSSketchEditor）を使用すると、ユーザーがマップ上で対話的にジオメトリをスケッチすることができます。\n次のコードは、AGSSketchEditor の使用方法の例を示しています。\n// マップ ビューにスケッチ エディターを設定 self.sketchEditor = AGSSketchEditor() self.mapView.sketchEditor = self.sketchEditor // ジオメトリの種類を設定してスケッチを開始 self.sketchEditor.start(with: AGSGeometryType.polygon) // スケッチ中のジオメトリの更新を監視 NotificationCenter.default.addObserver(self, selector: #selector(ViewController.respondToGeometryChanged), name: NSNotification.Name.AGSSketchEditorGeometryDidChange, object: nil) ・・・・・・ @objc func respondToGeometryChanged() { // ジオメトリが更新された際の処理 } ローダブル パターン データを非同期でロードして状態を初期化するマップやレイヤー等のリソースは、ローダブル パターンが採用されています。各リソースのプロパティにアクセスするには、ローダブル パターンを使用して、リソースがロードされた後にアクセスすることが推奨されます。ローダブル パターンは、ロード状態の振る舞いをより均一にして且つ一貫性を持たせることで、非同期性をより明示的にします。ローダブル パターンでは、各リソースは自動的にリソースの状態をロードしません。それらは、開発者が明示的に実行したときに、遅延ロードします。 各リソースの状態は、NotLoaded（ロードが開始していない、Loading（ロード中）、Loaded（ロードに成功）、FailedToLoad（ロードに失敗） のいずれかで監視することもできます。\n詳細は、ArcGIS Runtime SDK for iOS: ローダブル パターン（英語）をご参照ください。\n次のコードは、ローダブル パターンの基本的な使用方法の例を示しています。\nself.featureLayer.load(completion: {(error) -\u0026gt; Void in if let error = error { print(error) }else { // フィーチャ レイヤーのロードに成功  } }) ブロックを使用した非同期プログラミング 非同期操作を実行するメソッドは、完了ブロックを引数として受け取ります。ブロックは操作が正常に完了したとき、または、エラーが発生したときに呼び出されます。操作が成功すると、その操作の結果がブロックに渡されます。それ以外の場合はエラーが渡されます。 これは、デリゲートを使用して各非同期操作の結果とエラーをハンドリングしていた 10.2.x のプログラミング方法を置き換えます。\n次のコードは、例として端末の GPS の位置情報の取得開始の操作結果をハンドリングする方法を示しています。\nself.mapView.locationDisplay.start(completion: { (error) -\u0026gt; Void in if let error = error { // GPS の位置情報の取得に失敗  print(\u0026#34;Error:\\(error.localizedDescription)\u0026#34;) } else { // GPS の位置情報の取得に成功  } }) 既知の制限事項 現バージョンでの既知の制限事項が、ArcGIS Runtime SDK for iOS: リリース ノート（英語）に記載されていますので、ご参照ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/dotnet/migration-dotnet-200.x/",
	"title": "バージョン 100.x から 200.x への移行",
	"tags": [],
	"description": "今まで ArcGIS Runtime SDK for .NET バージョン 100.x を使用してアプリケーションを開発されていた開発者向けのガイドです。",
	"content": "ArcGIS Runtime SDK バージョン 100.15 は、バグ修正とマイナー アップデートのみに特化した長期サポート リリースです。ArcGIS Maps SDKs for Native Apps バージョン 200.x は、100.15 の実績あるアーキテクチャをベースに、最新の開発者向けフレームワークの技術を活用するよう設計されています。このトピックでは、変更された API の領域の概要と、200.x アプリ用に 100.x コードをリファクタリングするためのガイダンスを提供します。\n基本的な移行手順 ArcGIS Runtime SDK for .NET バージョン 100.0 から 100.15 で構築した既存のアプリを ArcGIS Maps SDK for .NET バージョン 200.0 に移行するには、以下の一般的な手順に従います。\n 以下の システム要件の変更 のセクションを確認し、推奨される変更または更新を行います。 アプリケーションのソース コードを開きます。 すべての Esri.ArcGISRuntime.* NuGet リファレンスをバージョン 200.0 に更新します。 API の破壊的変更に対処します。v100.x で非推奨とマークされた API は 200.0 で削除され、これらの API を使用するとコンパイル エラーが発生します。 アップグレードされたアプリをビルドして実行し、正しく機能することを確認します。  Xamarin アプリケーションの移行 バージョン 100.15 は、Xamarin.Forms、Xamarin.Android、Xamarin.iOS をサポートする ArcGIS Runtime SDK for .NET の最後のリリースとなりました。バージョン 200.0 は、.NET MAUI、.NET for Android、.NET for iOS をサポートしています。既存の Xamarin Forms アプリケーションは .NET MAUI（Multi-platform App UI）へ、Xamarin.Android と Xamarin.iOS はそれぞれ .NET for Android と .NET for iOS へ移行する必要があります。\n.NET MAUI 用の ArcGIS Maps SDK パッケージの初期化 ArcGIS Maps SDK for .NET を .NET MAUI アプリで使用するには、アプリの初期化時に MauiAppBuilder クラスで UseArcGISRuntime() を呼び出します。下記の例は、その方法を示しています。\nMauiProgram.cs\npublic static class MauiProgram { // このクラスは、標準的な MAUI テンプレートの一部です  // MAUI アプリは、CreateMauiApp を使用してアプリを準備します  public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); builder.UseMauiApp\u0026lt;App\u0026gt;(); // この行は、ArcGIS Runtime を使用する場合に必要です  builder.UseArcGISRuntime(); return builder.Build(); } } Xamarin Forms アプリの .NET MAUI への移行については、以下のドキュメントを参照してください。\n Xamarin.Forms からアプリを移行する (Microsoft ドキュメント) Migrating from Xamarin.Forms (Preview) - Wiki  API の変更 バージョン 100.x で非推奨だった API は、バージョン 200.0 ですべて削除されました。非推奨の API を使用すると、コンパイルエラーが発生するため、バージョン 200.0 を使用してアプリケーションを正常にビルドするために対処する必要があります。\nシステム要件の変更 ArcGIS Runtime SDK for .NET を使用するアプリを開発およびデプロイするためのシステム要件がバージョン 200.0 で以下のように変更されました。詳細については、System requirements のトピックを参照してください。\nオペレーティング システム  Windows 10 SDK バージョン 2004 (ビルド 19041) 以降 macOS Big Sur 11.0 以降  統合開発環境(IDE)  Visual Studio 2022 17.3 以降 Visual Studio 2019 16.9 以降 (UWP、WPF/.NET Framework)  フレームワーク固有の要件 .NET MAUI:  .NET MAUI ワークロード  Android:  net6.0-android 以降 Android 8.0 Oreo (API レベル 26) 以降  iOS:  net6.0-ios 以降 iOS 14 以降 Mac Catalyst を使用した macOS へのデプロイメントには Big Sur 11.0 以降が必要  WPF:  net6.0-windows10.0.19041.0 以降 net472 以降  WinUI 3.0:  net6.0-windows10.0.19041.0 以降  UWP:  TargetPlatformMinVersion 10.0.17763.0 以降  よくある質問 (FAQ) 移行に関するよくある質問と回答は、以下のとおりです。\n  質問: ArcGIS Runtime SDK for .NET バージョン 100.x から ArcGIS Maps SDK for .NET バージョン 200.x にアプリをすぐに移行する必要がありますか？\n回答: ArcGIS Runtime SDK for .NET バージョン 100.15 は、長期サポート リリースです。バージョン 200.0（または将来のバージョンの 200.x リリース）で提供される新機能を必要としないアプリの場合、アプリは正常に動作します。詳細については、製品ライフサイクルのドキュメント を参照してください。\nただし、ArcGIS Maps SDK for .NET が提供する最新の機能を使用するためには、アプリを移行する必要があります。\n  質問: ArcGIS Runtime SDK for .NET バージョン 100.x で利用可能な機能で、ArcGIS Maps SDK for .NET バージョン 200.x で利用できない機能はありますか？\n回答: ArcGIS Runtime SDK for .NET 100.15 に含まれるすべての機能は、ArcGIS Maps SDK for .NET 200.0 で利用可能です。さらに、バージョン 200.0 では、100.15 では利用できなかった新しい機能が提供されています。詳細については、リリース ノート を参照してください。\n  質問: ArcGIS Runtime SDK for .NET バージョン 100.x で作成したアプリを ArcGIS Maps SDK for .NET バージョン 200.x で使用するには、アプリを書き換える必要がありますか？\n回答: ArcGIS Runtime SDK for .NET バージョン 100.15 を使用するアプリを ArcGIS Maps SDK for .NET バージョン 200.0 に更新することは、通常のバージョンアップ通りで簡単です。Xamarin.Forms アプリを .NET MAUI に移行するには、ArcGIS Maps SDK for .NET の機能とは関係なく Xamarin から MAUI アプリへ移行するための一般的な追加作業が必要です。\n  質問: ArcGIS Maps SDK for .NET はまったく新しい製品ですか？\n回答: いいえ。ArcGIS Runtime SDK として知られていた製品群は、現在 ArcGIS Maps SDK for Native Apps として提供されています。これらの SDK のバージョン 200.x は、ArcGIS Runtime 100.15 の実績あるアーキテクチャを基盤としており、最新の開発者用フレームワークの技術を活用するように設計されています。\n  既知の制限事項 現バージョンでの既知の制限事項が、ArcGIS Maps SDK for .NET: リリース ノートに記載されていますので、ご参照ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/choose-3.x-and-4.x/",
	"title": "バージョン 4.x と 3.x の選択",
	"tags": [],
	"description": "3.x と 4.x で提供されている機能の比較表です。",
	"content": "バージョン 4.x の API は、新しい機能（例えば、3D サポート、マップの回転、ポータル連携の強化等）が追加されています。しかし、バージョン 4.x に、バージョン 3.x の全ての機能が含まれているわけではありません。今後のリリースでは、バージョン 3.x と同等の機能、また、3.x を上回る多くの機能が追加されます。開発者はアプリケーションの要件を考慮して、必要な機能が現在のバージョン 4.x もしくは 3.x に実装されているかどうかを判断する必要があります。\nまた、バージョン 4.x もしくは 3.x で開発を行うか判断する際は、3.x のロードマップと技術サポートに関する FAQ も併せて参照してください。\n アプリケーションで、3D 表示が必要な場合は、バージョン 4.x を使用してください 非常に大きなフィーチャ レイヤーを扱う場合は、バージョン 4.x を使用してください。 分析ウィジェットなど、4.x ではまだ利用できない機能が必要な場合は 3.x を使用してください。     機能 3.x 4.x     3D 表示 × ○   2D 表示 ○ ○   ベクター タイル レイヤー ○ ○   ラスター タイル レイヤー ○ ○   イメージ レイヤー ○ ○   マップ イメージ レイヤー（ダイナミック レイヤー） ○ ○   フィーチャ レイヤー ○ ○   ジオメトリ エンジン ○ ○   印刷 ○ ○   ルート \u0026amp; ルート案内 ○ ○   Web マップ ○（部分的なサポート） ○（部分的なサポート）   Web シーン × ○   ポータル アイテムのレイヤーの直接参照 × ○   編集と図形描画 ○（部分的なサポート） ○（部分的なサポート）   OGC レイヤー（WMS、WMTS、KML、WFS） ○ ○   OGC API の機能（OGCFeatureLayer） × ○   時系列データ ○ ○   その他の GIS 解析ウィジェット ○ ×（今後のバージョンで対応予定）    全機能の比較は 3.x/4.x 機能比較表（英語）を参照してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/services/",
	"title": "ロケーションサービスの利用",
	"tags": [],
	"description": "ArcGIS Platform をはじめて使う方向けにロケーションサービスの紹介やフィーチャ サービス、Web マップを作成する方法について紹介します。",
	"content": "ArcGIS Platform をはじめて使う方向けにロケーションサービスの紹介やフィーチャ サービス、Web マップを作成する方法について紹介します。\nロケーションサービス ArcGIS Platform で提供されているロケーションサービスは、背景地図サービス（ベースマップレイヤー）、ジオコーディングサービス、ルーティングサービス、空間分析サービス、人口統計などのサービスがあります。ロケーションサービスを利用したアプリケーションは、Web アプリやネイティブアプリなどのクライアント APIs を使用して開発することができます。また、ロケーションサービスへ直接アクセスするには REST API を使用できます。そのため、地図アプリケーションの開発や自社のソリューション、サービス、製品などにこれらのサービスを組み込んで利用することもできます。\nチュートリアル ArcGIS Platform のチュートリアルでは、ロケーションサービスを利用したアプリケーションの構築方法を学ぶことができます。\nチュートリアルは、以下の ArcGIS、オープンソース、およびサードパーティの API を利用できます。\n Web: ArcGIS Maps SDK for JavaScript、ArcGIS REST JS、Esri Leaflet、MapBox GL JS、OpenLayers. ネイティブ: ArcGIS Runtime APIs for Android、iOS、Java、.NET、Qt.  フィーチャ サービス、Web マップの作成   フィーチャ サービスの作成\nデータの検索や編集が可能な地図サービス (REST API) の配信方法を紹介します。\n  Web マップの作成\nさまざまなフォーマットのデータを 1 つのマップとして集約し、それを可視化する方法を紹介します。\n  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/visualization/6ways-to-improve-your-maps/",
	"title": "地図上に賢くデータを可視化するための 6 つの方法",
	"tags": [],
	"description": "マップ ビューアーを使って地図データを賢く可視化するために おさえておくべき６つの方法を紹介します。",
	"content": "ArcGIS のデータ ビジュアライゼーション ツール（マップ ビューアー）を使って地図データを賢く可視化するために おさえておくべき６つの方法を紹介します。\n 色について考える パターンを発見する アウトラインを調整する 透過率を調整してパターンをハイライトする ２つの属性データをサイズと色で表現する もっとも大きい値を発見する  色について考える 主題となるデータに色を加える場合に考えるべき事項は以下の 3 つです。\n 背景地図 ストーリー カラーランプ  地図を使ったデータ可視化ではほとんどの場合、__背景地図__の上に主題となるデータが重なります。 そのため、色は背景地図の配色に応じて見やすい適切な色を選択するべきです。 ただし、データ可視化においてはむしろ背景地図を使わないという選択肢も１つのテクニックになり得ます。\nデータ可視化には必ず伝えたい__ストーリー__があります。 そのストーリーを説明するような説得力のある色を選びましょう。\n最後に__カラーランプ__ですが、数値データに対してその値の範囲をカラーランプ（色の変化）で表現します。 上記のストーリーとデータのもつ意味を照らし合わせて、どの色からどの色へ変化すべきなのか考えてみましょう。\nパターンを発見する データ可視化の主題となるデータからパターンを導き出すことは重要です。 パターンを浮かび上がらせるためにはいくつかの方法があります。 たとえば、数値データに対しての表現として以下がまず前提となる２つの項目です。\n 色を使うか？サイズを使うか？ クラスで分類するか？しないか？  たとえば、公園の面積で大中小のような３段階の規模でカテゴライズして可視化したい場合、 色よりもサイズで規模を表現したほうが意図を伝えやすいと思います。 そして、面積に比例してシンボルが変化するより、３段階でクラス分類すべきでしょう。\nArcGIS のビジュアライゼーション ツールにはヒストグラムを掛け合わせたスライダーを操作することによって、 動的に見栄えを確認しながら変化させることができます。 ストーリーとの関連から、基点となる数字に意味を持たせるのもよいと思いますが、 このスライダーを使ってあくまで地図上で可視化されたグラフィックの集合から、 あるパターンを浮かび上がらせるには便利なツールです。\n変化前（左）と変化後（右）\nアウトラインを調整する ポイントとポリゴンのシンボルはアウトライン（枠線）があります。 アウトラインはデータをそれぞれ視認するのには役立ちますが、 適切に調整をしないで使用すると視覚的には邪魔な要素となり、 地図上の主題データが伝えるストーリーを理解するための焦点を逸らしてしまいかねません。\n色と透過率を用いて、強調しないようなアウトラインの表現に調整してみてください。 場合によっては、完全にアウトラインをなくしてしまうことも選択肢として考えられます。\n調整前（左）と調整後（右）\n透過率を調整してパターンをハイライトする パターンを発見/可視化するためのシンボル表現として色あるいはサイズを選択することを伝えましたが、 もう１つ値の変化を表現する方法として透過率を利用する方法があります。 パターンや基点となるような重要な値をハイライトする際に採用することをお薦めします。\n透過率もスライダーで動的にレンジを調整することが可能です。\n２つの属性データをサイズと色で表現する 従来、地図上で属性データを可視化する場合は単一の属性値に基づいて色やサイズで表現することが基本でした。 マップ ビューアーのビジュアライゼーション機能では、 ２つのデータを色とサイズでそれぞれ表現することで１つのシンボルに対して２つの意味を含めることが可能です。\nたとえば、エリアごとの家賃相場を色、居住者の平均年収をサイズで表現することで、 家賃相場と居住者の収入の関連を単一の主題図で可視化することができます。\nもっとも大きい値を発見する ビジュアライゼーション機能のなかでもっともユニークなものとして、 複数の属性値を比較してもっとも大きい値を占める属性を可視化する機能があります。\nたとえば、選挙マップを作って各選挙区でどの政党がもっとも優勢かを表したいときに有効な表現です。 選挙区の属性値として政党ごとの得票数が A 党 100、B 党 150、C 党 50 といったように格納されている場合に、 A 党は赤、B 党は青、C 党は黄と色を割り振って、 値の割合に応じて色をブレンドして１つの色で表現します。\nB 党がもっとも優勢なので、色味としては青が強い色になり、 各政党が拮抗している場合には色彩の弱い色になります。\n以上、６つの方法を紹介してきましたが、 まずはそれぞれの機能を実際に使ってみて表現を確かめてコツをつかんでみてください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/",
	"title": "技術 Tips 集",
	"tags": [],
	"description": "開発に役立つ技術 Tips 集です。",
	"content": "　開発ドキュメント 各 API/SDK の開発をサポートするドキュメントです。\n ArcGIS Maps SDK for JavaScript ArcGIS Experience Builder (Developer Edition) ArcGIS Web AppBuilder (Developer Edition) ArcGIS Runtime SDK for .NET ArcGIS Runtime SDK for Android ArcGIS Runtime SDK for iOS ArcGIS API for Python ArcGIS Pro SDK ArcGIS AppStudio  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-android/",
	"title": "Android",
	"tags": [],
	"description": "ArcGIS Runtime SDK for Android を用いたモバイル地図アプリの作成方法を紹介します。",
	"content": "マップを表示する このチュートリアルでは ArcGIS Runtime SDK for Android (バージョン 100.x) を使用して、マップとベースマップ レイヤーを表示する方法を紹介します。\nマップには、地理データのレイヤーが含まれています。マップには、ベースマップ レイヤーと、オプションで1つ以上のデータレイヤーを追加できます。マップビューを使用し、場所とズームレベルを設定することで、マップの特定の領域を表示できます。\nこのチュートリアルでは、地形ベースマップレイヤーを使用して、富士山付近を表示する地図を作成します。\n前提条件 このチュートリアルを実施するには、以下が必要です。\n API キーにアクセスするための ArcGIS 開発者アカウント。アカウントをお持ちでない場合は、サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。 開発環境がシステム要件を満たしていることを確認します。 Kotlin で Android 開発を行うための IDE。このチュートリアルでは Android Studio を使用していますが、記述されたコードは Kotlin をサポートする任意の Android の IDE で動作します。  ステップ 新しい Android Studio プロジェクトを作成します Android Studio を使用してアプリを作成し、API を参照するように構成します。\n  Android Studio を開きます。\n  メニューバーで、[File] \u0026gt; [New] \u0026gt; [New Project\u0026hellip;.] をクリックします。\n  [Create New Project] ウィンドウで、[Phone and Tablet] タブが選択されていることを確認してから、[Empty Activity] を選択します。[Next] をクリックします。\n Gradle は、Android Studio のデフォルトのビルドツールです。Gradle を使用できない場合は、API を手動で取得する を参照してください。    [Configure your project] ウィンドウで、次の構成オプションを設定します。\n Name: Display a map Package name: com.example.app に変更します。または、組織に合わせて変更してください。 Save location: 新しいフォルダに設定します Language: Kotlin Minimum SDK: API 23: Android 6.0 (Marshmallow)      プロジェクトのツールウィンドウで、現在のビューが Android であることを確認してください。チュートリアルの説明では、そのビューを参照しています。\nビュー名が Android 以外の名前（プロジェクトやパッケージなど）の場合は、プロジェクトツールウィンドウのタイトルバーの左端のコントロールをクリックし、リストから Android を選択します。\n  プロジェクト ツールウィンドウから、[Gradle Scripts] \u0026gt; [build.gradle (Project: Display_a_map)] を開きます。ファイルの内容を次のコードに置き換えます。\nbuild.gradle (Project: Display_a_map)\n// Top-level build file where you can add configuration options common to all sub-projects/modules.  plugins { id \u0026#39;com.android.application\u0026#39; version \u0026#39;7.2.1\u0026#39; apply false id \u0026#39;com.android.library\u0026#39; version \u0026#39;7.2.1\u0026#39; apply false id \u0026#39;org.jetbrains.kotlin.android\u0026#39; version \u0026#39;1.7.0\u0026#39; apply false } task clean(type: Delete) { delete rootProject.buildDir }   プロジェクト ツールウィンドウから、[Gradle Scripts] \u0026gt; [build.gradle (Module: Display_a_map.app)] を開きます。ファイルの内容を次のコードに置き換えます。\nbuild.gradle (Module: Display_a_map.app)\nplugins { id \u0026#39;com.android.application\u0026#39; id \u0026#39;org.jetbrains.kotlin.android\u0026#39; } android { compileSdkVersion 32 defaultConfig { applicationId \u0026#34;com.example.app\u0026#34; minSdkVersion 23 targetSdkVersion 32 versionCode 1 versionName \u0026#34;1.0\u0026#34; } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(\u0026#39;proguard-android-optimize.txt\u0026#39;), \u0026#39;proguard-rules.pro\u0026#39; } } compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } kotlinOptions { jvmTarget = JavaVersion.VERSION_1_8.toString() } buildFeatures { viewBinding true } packagingOptions { exclude \u0026#39;META-INF/DEPENDENCIES\u0026#39; } } dependencies { implementation fileTree(dir: \u0026#34;libs\u0026#34;, include: [\u0026#34;*.jar\u0026#34;]) implementation \u0026#39;androidx.appcompat:appcompat:1.4.2\u0026#39; implementation \u0026#39;androidx.constraintlayout:constraintlayout:2.1.4\u0026#39; implementation \u0026#39;androidx.multidex:multidex:2.0.1\u0026#39; implementation \u0026#39;com.google.android.material:material:1.6.1\u0026#39; implementation \u0026#39;com.esri.arcgisruntime:arcgis-android:100.15.0\u0026#39; } 注: 上記の build.gradle ファイルでは、ソースとターゲットの両方で Java 8 言語互換性を指定しています。Android Studio はこの互換性設定を利用して、必要に応じて「desugaring」と呼ばれるバイトコード変換を自動で行います。別の IDE を使用している場合は、自分で Java 8 互換性を設定する必要がある場合があります。詳しくは、Java 8 言語機能と API を使用する を参照してください。\n  プロジェクト ツールウィンドウから、[Gradle Scripts] \u0026gt; [settings.gradle] を開きます。ファイルの内容を次のコードに置き換えます。\nsettings.gradle\nimport org.gradle.api.initialization.resolve.RepositoriesMode pluginManagement { repositories { gradlePluginPortal() google() mavenCentral() } } dependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { google() mavenCentral() maven { url \u0026#39;https://esri.jfrog.io/artifactory/arcgis\u0026#39;  } } } rootProject.name = \u0026#34;Display a map\u0026#34; include \u0026#39;:app\u0026#39;   Gradle の変更を同期します。[Sync now] プロンプトをクリックするか、ツールバーの更新アイコン（Sync Project with Gradle Files）をクリックします。同期に数分かかるかもしれません。\n  プロジェクトツールウィンドウから、[app] \u0026gt; [manifests] \u0026gt; [AndroidManifest.xml] を開きます。Android マニフェストを更新して、ネットワークアクセスを許可し、アプリが OpenGL2.0 以降を使用することを示します。\nこれらの新しい要素を manifest 要素内に挿入します。他のステートメントを変更または削除しないでください。追加する ArcGIS の機能によっては、マニフェストに追加のアクセス許可を追加する必要がある可能性があります。\nAndroidManifest.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; package=\u0026#34;com.example.app\u0026#34;\u0026gt; // 追加開始 \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34; /\u0026gt; \u0026lt;uses-feature android:glEsVersion=\u0026#34;0x00020000\u0026#34; android:required=\u0026#34;true\u0026#34; /\u0026gt; // 追加終了   インポートステートメントを追加する [app] \u0026gt; [java] \u0026gt; [com.example.app] \u0026gt; [MainActivity.kt] を開き、ArcGIS Runtime SDK を参照するようにインポートステートメントを追加します。\nMainActivity.kt\npackage com.example.app import androidx.appcompat.app.AppCompatActivity import android.os.Bundle // 追加開始 import com.esri.arcgisruntime.ArcGISRuntimeEnvironment import com.esri.arcgisruntime.mapping.ArcGISMap import com.esri.arcgisruntime.mapping.BasemapStyle import com.esri.arcgisruntime.mapping.Viewpoint import com.esri.arcgisruntime.mapping.view.MapView import com.example.app.databinding.ActivityMainBinding // 追加終了 マップビューの UI を追加する マップビューは、マップを表示する UI コンポーネントです。また、タッチジェスチャによるナビゲートなど、ユーザーによるマップの操作も処理します。XML を使用してマップビューを UI に追加し、メインアクティビティのソースコードで使用できるようにします。\n  [app] \u0026gt; [res] \u0026gt; [layout] \u0026gt; [activity_main.xml] で、TextView 要素全体を MapView 要素に置き換えます。\nXMLコードが表示されない場合は、[Code] タブを選択してデザインモードを切り替え、エディターに XML コードを表示します。 MapView 要素は、ArcGIS Runtime SDK for Android から MapView クラスのインスタンスを作成します。\nメインアクティビティ ソースコードでは、android:id 属性の値で宣言されている暗黙的なプロパティを使用してその MapView インスタンスにアクセスできます。この場合、プロパティの名前は mapView になります。\nactivity_main.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; // 追加開始 \u0026lt;com.esri.arcgisruntime.mapping.view.MapView android:id=\u0026#34;@+id/mapView\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; // 追加終了 \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;   MainActivity.kt で、生成された Android クラス ActivityMainBinding を参照する activityMainBinding という名前の読み取り専用ローカル変数を作成します。\nMainActivity.kt\nclass MainActivity : AppCompatActivity() { // 追加開始  private val activityMainBinding by lazy { ActivityMainBinding.inflate(layoutInflater) } // 追加終了   mapView という名前の読み取り専用変数を作成し、それを activity_main.xml で作成された mapView にバインドします。\nMainActivity.kt\nclass MainActivity : AppCompatActivity() { private val activityMainBinding by lazy { ActivityMainBinding.inflate(layoutInflater) } // 追加開始  private val mapView: MapView by lazy { activityMainBinding.mapView } // 追加終了   マップを追加する マップビューを使用して、富士山を中心としたマップを表示します。マップには、地形ベースマップレイヤーが含まれます。\n  MainActivity.kt で、MainActivity クラスに新しい setupMap メソッドを追加し、ArcGISMap を作成します。ARCGIS_TOPOGRAPHIC という名前の特定のベースマップスタイルを使用して ArcGISMap を構成します。\nMainActivity.kt\noverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } // 追加開始 // ここでマップを設定します。このメソッドは onCreate() から呼び出します private fun setupMap() { // BasemapStyle で地図を作成する  val map = ArcGISMap(BasemapStyle.ARCGIS_TOPOGRAPHIC) } // 追加終了 地形図（ARCGIS_TOPOGRAPHIC）以外にも、道路地図（ARCGIS_STREETS）、衛星画像（ARCGIS_IMAGERY）、オープンストリートマップ（OSM_STANDARD）など、様々なスタイルが用意されています。\n  mapView の map プロパティを新しい ArcGISMap に設定します。次に、ViewPoint を作成し、それを mapView に追加します。\nMainActivity.kt\n// ここでマップを設定します。このメソッドは onCreate() から呼び出します private fun setupMap() { // BasemapStyle で地図を作成する  val map = ArcGISMap(BasemapStyle.ARCGIS_TOPOGRAPHIC) // 追加開始  // レイアウトの MapView に表示されるマップを設定します  mapView.map = map // 視点の Viewpoint(緯度、経度、スケール) を設定します  mapView.setViewpoint(Viewpoint(35.360626, 138.727363, 200000.0)) // 追加終了 }   onCreate() メソッドで、Android Studio のデフォルトの呼び出しであるsetContentView(R.layout.activity_main) を setContentView(activityMainBinding.root) に置き換えます。その後、setupMap() を呼び出します。\nMainActivity.kt\noverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 変更前  // setContentView(R.layout.activity_main)  // 変更後  setContentView(activityMainBinding.root) setupMap() }   MainActivity クラスの onPause、onResume、onDestroy メソッドをオーバーライドします。\nMapView はビューを適切に管理するために、アプリがバックグラウンドになったとき、またはバックグラウンドから復元されたときを知る必要があります。ビューが不要になった時、そのリソースは dispose の呼び出しで解放される必要があります。これらのメソッドは、MainActivity クラスの定義内のどこにでも置くことができます。\nMainActivity.kt\noverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(activityMainBinding.root) setupMap() } // 追加開始 override fun onPause() { mapView.pause() super.onPause() } override fun onResume() { super.onResume() mapView.resume() } override fun onDestroy() { mapView.dispose() super.onDestroy() } // 追加終了   API キーを設定する   ArcGIS Online でホストされているサービス、Web マップ、Web シーンにアクセスできるようにするには、API キーが必要です。 まだ作成していない場合は、ArcGIS Developers ダッシュボード に移動して、API キーを取得します。作成方法は「API キーの取得」をご覧ください。\n  setApiKeyForApp() メソッドを作成し、API キーを使用して ArcGISRuntimeEnvironment の apiKey プロパティを設定します。\nMainActivity.kt\noverride fun onDestroy() { mapView.dispose() super.onDestroy() } // 追加開始 private fun setApiKeyForApp(){ // API キーを設定します  // 注：API キーをソースコードに保存することはベストプラクティスではありません。API キーが参照されます。  //チュートリアルでは便宜上ソースコードに記載しています  ArcGISRuntimeEnvironment.setApiKey(\u0026#34;\u0026lt;API キー\u0026gt;\u0026#34;) } // 追加終了   onCreate() ライフサイクル メソッド内で setApiKeyForApp() を呼び出す。\nMainActivity.kt\noverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(activityMainBinding.root) // 追加開始  setApiKeyForApp() // 追加開始  setupMap() }   [Run] \u0026gt; [Run] \u0026gt; [app] をクリックして、アプリを実行します。アプリを実行するエミュレーターが表示されます。アプリがビルドされてもエミュレーターが表示されない場合は、エミュレーターを追加する必要があります。[Tools] \u0026gt; [AVD Manager] \u0026gt; [Create Virtual Device\u0026hellip;] をクリックします。\n  富士山を中心とした地形ベースマップレイヤーのマップが表示されます。マップビューをピンチ、ドラッグ、およびダブルタップして、マップを操作します。\n完成版のプロジェクトはこちらからダウンロードできます（マップの表示場所は本チュートリアルで設定した場所とは異なります）。\nWeb マップを表示する 「Web マップの作成」のガイドで Web マップを作成している場合は、作成した Web マップも基本的に同じステップで表示できます。\n  マップを表示するのステップで作成したプロジェクトの [app] \u0026gt; [java] \u0026gt; [com.example.app] \u0026gt; [MainActivity.kt] を開き、必要なインポートステートメントを追加します。\nMainActivity.kt\nimport com.esri.arcgisruntime.portal.Portal import com.esri.arcgisruntime.portal.PortalItem   setupMap メソッドを下記のように書き換えます。\nMainActivity.kt\nval portal = Portal(\u0026#34;https://www.arcgis.com\u0026#34;, false) val itemId = \u0026#34;\u0026lt;Web マップの ID\u0026gt;\u0026#34; val portalItem = PortalItem(portal, itemId) val map = ArcGISMap(portalItem) mapView.map = map    アプリの動作が確認できたら ArcGIS の セキュリティと認証について学びましょう！\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/android/",
	"title": "ArcGIS Runtime SDK for Android",
	"tags": [],
	"description": "ArcGIS Runtime SDK for Android の開発に役立つガイド集です。",
	"content": "ArcGIS Runtime SDK for Android (バージョン 100.x) の開発に役立つガイド集です。\n インストール ガイド\nArcGIS Runtime SDK for Android のインストールとセットアップ手順を紹介します。\n\r アプリケーション配布ガイド\nArcGIS Runtime SDK for Android を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を紹介します。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/python-api-jnsetup/",
	"title": "Jupyter Notebook を使ってみよう",
	"tags": [],
	"description": "ArcGIS API for Python の実行に便利な JupyterLab の初期設定方法と使用方法を簡単に紹介します。",
	"content": "ここでは、対話的に Python コードを実行し、出力を地図やグラフとして視覚化することができる Jupyter Notebook をご紹介します。Jupyter Notebook はオープンソ－スとして公開されている開発ツールのひとつで、ArcGIS API for Python (以下、Python API)はこのツール上でマップ等を表示することができます。 Jupyter Notebook の詳細については、Jupyter の公式マニュアルおよびクイックスタートガイドを参照してください。 また、サポートされているブラウザについてもご確認ください。Jupyter Notebook がサポートしていないブラウザ（Internet Explorer 等）ではマップ等が表示されないことがあります。\nJupyter Notebook の起動 conda と Python API がインストールされたら、Python コマンドプロンプト (ArcGIS Pro 経由でインストールした場合) または、Anaconda Prompt (Anaconda でインストールした場合) 等のターミナル アプリケーションに次のコマンドを入力して Jupyter Notebook を起動します。\njupyter notebook\rもし起動できなかった場合は次のコマンドをお試しください (参考: Jupyter fails to start)。\njupyter-notebook\r他、Windows OS を実行している場合はコマンド プロンプトまたは PowerShell ウィンドウでも代用できます。以下は、Windows のコマンドプロンプトからコマンドを実行した場合の画面のスクリーンショットです。\nWindows のコマンドプロンプトからコマンドを実行した場合\n\rPython API を root 以外の仮想環境を作成しインストールした場合、Jupyter Notebook を起動する前にその仮想環境をアクティベートする必要があります。root 以外の仮想環境を使用するメリットと仮想環境の作成および管理する方法の詳細については、公式のマニュアルページを参照してください。\nEsri では GitHub 上でサンプルのノートブック (*.ipynb) を公開していますが、こうしたノートブックをダウンロードしてを実行したい場合は、Jupyter Notebook を起動する前に、ノートブックを格納したディレクトリに移動 (cd) する必要があります。 上の例では、ノートブックが C:\\code ディレクトリに配置されています。\nJupyter Notebook 起動のコマンドを実行すると Jupyter Notebook は以下のように端末のデフォルトに設定されている Web ブラウザで開きます。\nJupyert Notebook 起動画面 (Google Chrome)\n\rこのページは、ノートブック ダッシュボードと呼ばれています。\nノートブックを実行する Jupyter Notebookでは、ディレクトリを移動してノートブックをクリックすることでそのノートブックを新しいブラウザのタブまたはウィンドウで開くことができます。各セルを選択し、[セルを実行]ボタン(または shift + Enter)をクリックすることで、各セルを実行できます。以下の画像では、実行までの一通りの手順を示しています。\nノートブックを開いて実行するまで\n\rセルを実行すると、そのセルのコードを実行している間、左わきにアスタリスク (*) が表示されます。実行が完了するとセル実行番号に変わります。\n新しいノートブックの作成 Esri が提供するサンプルのノートブックを実行するだけでなく、プロジェクト用の新しいノートブックを作成することもできます。 これを行うには、ノートブックダッシュボードから、「New」ボタンをクリックし、以下の画像のように Python のカーネルを選択します。\n新しいノートブックを作成する\n\r実行中のノートブックの「ファイル」メニューから新しいノートブックを作成することもできます。 上の画像では、現在実行中のノートブックのアイコンが緑色で表示されています。\rJupyter Notebook ヘルプとキーボードショートカット その他、Jupyter Notebook の各機能や使い方は、任意のノートブックを開いて、[Help \u0026gt; User Interface Tour] から体験することができます。 また、便利なキーボード ショートカットも設定されています。ショートカット キーの一覧は、[Help \u0026gt; Keyboard Shortcuts] で表示できます。\nショートカットキー一覧\n\rショートカットの中でも、[Ctrl + Shift + P] はコマンド パレットを表示できるため、特に便利です。コマンド パレットでは、実行したい機能を入力して実行することができます。Jupyter Notebook の使い方については Five Tips To Get You Started With Jupyter Notebook（英語） のブログ記事も参考にしてください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/deploy-your-app/",
	"title": "Web アプリケーションのデプロイ",
	"tags": [],
	"description": "ArcGIS Web AppBuilder (Developer Edition) で作成したアプリケーションをダウンロードし、独自のサーバーにホストする手順を紹介します。",
	"content": "トピック  アプリのダウンロード アプリのデプロイ グループ アクセスの設定 動作環境  ArcGIS Web AppBuilder (Developer Edition)（以下 Web AppBuilder）で作成したWeb アプリケーション (以下、アプリ) はダウンロードして、独自の Web サーバーにホストすることができます。もしアプリが未共有のアイテムを参照しているとき、ダウンロードしたアプリは ArcGIS Online または Portal for ArcGIS に登録する必要があります。 アプリをデプロイする場所にかかわらず、Web マップへのアクセスは必須です。\nその他のデプロイ パターンについてはデプロイ パターンのページをご覧下さい。\nアプリのダウンロード  Web AppBuilder を起動し、トップページを開いたら、アプリのダウンロードボタンをクリックします。 アプリケーションは ZIP ファイルでダウンロードされます。保存ダイアログが表示されたら、任意のフォルダーを指定し、[保存] をクリックします。これで、アプリケーションはローカル ドライブに保存されます。  アプリのデプロイ  ダウンロードしたアプリを解凍します。 解凍したアプリを Web サーバーへ配置します。 アプリのルート ディレクトリにある config.json ファイルを開き、以下の項目を編集します。 プロキシ\n必要に応じて、使用するプロキシを proxy プロパティに追加します。プロキシの詳細は Use proxy をご参照ください。 アプリケーション ID\nアプリケーション ID を appId プロパティへ設定します。アプリケーション ID を入手するには、アプリの追加、登録が必要です。詳細はアプリの追加およびアプリの登録をご参照ください。 OAuth と SAML を用いたプラットフォーム認証を活用するために、アプリケーション ID を使用することを推奨しています。  アプリをカスタマイズするには、以下のドキュメントを参照してください。\n アプリとウィジェットの設定：App configuration ArcGIS API for JavaScript の変更：ArcGIS API for JavaScript の参照先を変更する（オプション）  グループ アクセスの設定 もしアプリがグループや異なる組織間のメンバーで共有している、パブリックではない Web マップを使用しているとき、すべてのグループのメンバーがWeb マップにアクセスできるように設定します。\n アプリの config.json ファイルを開きます。 portalUrl プロパティの値を www.arcgis.com に変更します。 map プロパティに portalUrl プロパティが含まれている場合は、値を www.arcgis.com に変更します。  動作環境 アプリがサポートしているブラウザーは以下の通りです。\n 2D  Google Chrome Firefox Safari（Mac） Edge Internet Explorer 11\nIE11 または Edge で OAuth 認証を使用してアプリを開くとき、ポップアップが表示されることがあります。はいをクリックすると、ポップアップは消えますが、アプリは読み込まれません。この場合は、ブラウザーの設定から .arcgis.com を信頼済みサイトとして追加してください。 Safari（iOS） Google Chrome（Android）   3D  Google Chrome Firefox Safari（Mac） Edge Internet Explorer 11\n3D アプリには WebGL をサポートしているデスクトップの Web ブラウザーが必要です。ほとんどの最新バージョンのデスクトップ Web ブラウザーは WebGL を内蔵しています。ご利用の Web ブラウザーが WebGL を利用可能かどうかは get.webgl.org で確認できます。WebGL に関するトラブルシューティングは WebGL Troubleshooting をご参照ください。また、シーン ビューアーについての詳細は シーン ビューアーの要件 をご参照ください。    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/",
	"title": "その他",
	"tags": [],
	"description": "開発に役立つ技術です。",
	"content": "　テーマ別ページ   データ ビジュアライゼーション\n 地図にデータを可視化する際の tips を紹介します。    サンプル集\n 開発にすぐに使えるサンプル データ/コードを紹介します。    ミートアップ\n 開発者向けのイベント用に提供したページのリンクです。    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/",
	"title": "アプリ開発",
	"tags": [],
	"description": "シンプルな地図アプリの作成方法を紹介します。",
	"content": "マップとベースマップ レイヤーを表示するシンプルな地図アプリの作成方法を紹介します。お使いの開発環境からお選びください。\nWeb APIs \r\rArcGIS Maps SDK for JavaScript\rEsri Leaflet\rMapLibre GL JS\rOpenLayers\r\r\rNative APIs \r\rAndroid\riOS\r.NET\r\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/",
	"title": "カスタム ウィジェット開発ガイド",
	"tags": [],
	"description": "カスタム ウィジェットを開発する手順を紹介します。",
	"content": "カスタム ウィジェットを開発する手順を紹介します。  ウィジェット開発のスタート\nウィジェット開発に使用しているライブラリから開発に必要な概要までを紹介します。\n\r ウィジェット manifest\nウィジェットの名前やバージョンなどのウィジェットの属性などを設定する manifest.json ファイルについて紹介します。\n\r ウィジェットの実装\nウィジェットの実装方法について紹介します。\n\r ウィジェット UI の作成\nウィジェット UI の作成方法について紹介します。\n\r ウィジェットでデータソースを使用\nウィジェットでデータソースを使用する方法について紹介します。\n\r ウィジェット間の通信\nウィジェット同士がどのように相互に通信する方法について紹介します。\n\r ウィジェット開発のデバック\nウィジェット開発におけるデバック方法について紹介します。\n\r サードパーティ製のライブラリ使用\nサードパーティ製のライブラリの使用方法について紹介します。\n\r 単体テスト\n単体テストの方法について紹介します。\n\r assets の使用\nassets の使用について紹介します。\n\r コードリンティング\nコードリンティングについて紹介します。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/create-startup-app-js3/",
	"title": "スタートアップ ガイド（3.x）",
	"tags": [],
	"description": "",
	"content": "サンプル プロジェクトのダウンロード このリポジトリ（arcgis-dev-resources）には開発を試してみたい方向けのサンプル コードが含まれています。ダウンロードする際の方法は 2 通りあります。\n リポジトリをご自身のアカウントに Fork（複製）   GitHub にログインして、arcgis-dev-resources ページを開いて [Fork] をクリックすると、ご自身のアカウントに同じリポジトリが作成されます。 Fork 後はご自身のローカル マシンにクローンを作成します。   zip ファイルでダウンロード（※GitHub アカウントをお持ちでない方向け）  arcgis-dev-resources ページを開いて [Download ZIP] をクリックするとプロジェクト ファイル一式が手に入ります。\n地図の表示 まずはダウンロードしたサンプル コードを実行してみましょう。\n  ダウンロードしたサンプル コード（arcgis-dev-resources/startup/javascript/3.x/map/index.html）を Web ブラウザーにドラッグ＆ドロップします。 Web サーバーをお持ちの方はサンプル コードを Web サーバーにホストしてアクセスすることを推奨します。http://localhost/arcgis-samples-js/simple/map.html のように localhost を指定してアクセスできます。\n  この状態では地図は表示されません。サンプル コードをテキスト エディターで開いてみましょう。\n  map.html 29 行目にある以下のコードの \u0026lt;Web マップ ID\u0026gt; と記載されている箇所に Web マップの作成で作成した Web マップ ID を上書きします。\n  var mapDeferred = arcgisUtils.createMap(\u0026#34;\u0026lt;Web マップ ID\u0026gt;\u0026#34;, \u0026#34;mapDiv\u0026#34;); まだ Web マップを作成しておらず、すぐに試してみたい方はサンプル Web マップをご利用ください。\n Web アプリを実行すると、以下のように地図が表示されます。   検索機能の追加 検索機能の実装方法はいくつかありますが、ここではもっとも簡単な方法をご紹介します。検索機能の実装には esri/dijit/Search モジュール（検索ウィジェット）を使用します。検索ソースにはサンプル Web マップに含まれる東京都 23 区のデータを使用します。\n検索ウィジェットは住所検索/属性検索機能を組み込んだ文字入力フォームの UI を提供します。\n ArcGIS Maps SDK for JavaScript から使用したいモジュールを追加します。モジュールのインポートは require 関数の第一引数に入力される配列内で行います。配列内に検索機能の実装に必要なモジュールを追加します。  require([\u0026#34;esri/arcgis/utils\u0026#34;, \u0026#34;esri/dijit/Search\u0026#34;, \u0026#34;esri/layers/FeatureLayer\u0026#34;, \u0026#34;esri/InfoTemplate\u0026#34;, \u0026#34;dojo/domReady!\u0026#34;], function(arcgisUtils, Search, FeatureLayer, InfoTemplate) { ... }); 以下は検索機能に必要なモジュール一覧です。\n * `\u0026quot;esri/dijit/Search\u0026quot;`: 検索ウィジェット\r* `\u0026quot;esri/layers/FeatureLayer\u0026quot;`: フィーチャ レイヤー（オプション）\r* `\u0026quot;esri/InfoTemplate\u0026quot;`: 情報テンプレート（オプション）\rフィーチャ レイヤーは検索ソース、情報テンプレートは検索結果の属性表示を設定するために利用します。\r ここで以下の点に注意してください。\n * 配列の一番最後のモジュールは必ず `\u0026quot;dojo/domReady!\u0026quot;` になるようにしてください\r* `require` 関数の第ニ引数の無名関数の引数にはモジュールに対応したクラス名（任意）を定義しますが、これは配列内のモジュールの順序と対応している必要があります\r  検索ウィジェット用の DOM 要素を作成します。  \u0026lt;div id=\u0026#34;searchDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ここで指定した DIV の ID は検索ウィジェットを作成する際に、JavaScript 側で使用します。\n 検索ウィジェットの表示位置を CSS で記述します。  #searchDiv { display: block; position: absolute; z-index: 2; top: 20px; left: 74px; }  mapDeffered.then の関数内で検索ウィジェット作成のスクリプトを記述します。  mapDeferred.then(function(response) { map = response.map; var search = new Search({ map: map, sources: [] }, \u0026#34;searchDiv\u0026#34;); }); \u0026quot;esri/dijit/Search\u0026quot; モジュールが定義する Search クラスは require 関数内でのみ動作します。\nマップのオブジェクトは `mapDeffered.then` の処理完了後の `Deferred` で取得できます。検索ウィジェットはマップのオブジェクトを使用するため、この位置に記述する必要があります。\r対応するマップを指定するための `map` プロパティにはマップのオブジェクトを、検索ソースを指定するための `sources` プロパティには空の配列を定義します。検索ソースがない状態でも ArcGIS のクラウド サービスが提供する住所検索サービスが標準で含まれています。\r  検索ソースに検索対象とするフィーチャ レイヤーを定義します。  var sources = search.get(\u0026#34;sources\u0026#34;); sources.push({ featureLayer: new FeatureLayer(\u0026#34;https://services.arcgis.com/wlVTGRSYTzAbjjiC/arcgis/rest/services/tokyo_23/FeatureServer/0\u0026#34;), // 検索ソースとなるフィーチャ レイヤー  placeholder: \u0026#34;検索キーワードの入力\u0026#34;, // プレースホルダー  enableLabel: false, // 検索結果ラベルの表示  searchFields: [\u0026#34;\u0026lt;フィールド名\u0026gt;\u0026#34;], // 検索対象となる属性フィールド  displayField: \u0026#34;\u0026lt;フィールド名\u0026gt;\u0026#34;, // 検索結果のポップアップに表示する属性フィールド  outFields: [\u0026#34;*\u0026#34;], // 結果として返す属性フィールド  name: \u0026#34;東京都\u0026#34;, // 検索ソースの名前  infoTemplate: new InfoTemplate(\u0026#34;東京都\u0026#34;, \u0026#34;市区町村: ${Name}\u0026#34;), // 検索結果のポップアップ表示構成  enableSuggestions: true // 検索結果の候補リスト表示  }); // 検索ソースを検索ウィジェットに設定  search.set(\u0026#34;sources\u0026#34;, sources); search.startup(); sources.featureLayer には検索ソースとなるレイヤーを定義しますが、必ずしも地図上に表示されているレイヤーを使う必要はありません。サンプルはマップ オブジェクトに存在しない別のレイヤーを検索ソースとして利用します。\nフィールド名の確認は次の手順で紹介します。\r   検索対象とするレイヤーの詳細ページにて、[レイヤー] の項目から対象とするレイヤーをクリックして [サービスの URL] を選択します。   [Fields] という項目にレイヤーのフィールド情報のリストが表示されているので、検索対象とするフィールド名をコピーして searchFields の配列に追加します。 検索結果のポップアップに表示する属性情報として利用したい場合は displayField にも入力してください。\n  Web アプリを実行すると、以下のように地図上に検索ウィジェットが表示され、設定した検索ソースでの検索が可能になります。   "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/section-view/",
	"title": "セクションとビュー（Section and view）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Section and view\nセクションとビュー（Section and view） セクションは、複数のビューを追加できる領域を占めています。ビューはレイアウトコンテナで、ページやウィンドウに似ていますが、セクションの中にしか置くことができません。ビュー・ナビゲーション・ウィジェットは、セクション内のビューをナビゲートします。メニュー \u0026ldquo;ウィジェットで複数のページを使用したり、\u0026ldquo;ビュー・ナビゲーション \u0026ldquo;ウィジェットでセクションとビューを使用して同様の操作感を得ることができますが、両者には主な違いがあります。\n レンダリングについて - 複数のページを読み込む場合、最初は現在のページのコンテンツのみがレンダリングされます。セクション内の複数のビューを読み込む場合、ビュー内のすべてのコンテンツがレンダリングされますが、現在のビューのみが表示され、他はすべて非表示になります。 アニメーションについて - セクションでのみトランジションアニメーションを定義できます。  app config では、セクションは sections で定義され、ビューは views で定義されます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/dotnet/migration-dotnet-100.x/",
	"title": "バージョン 10.2.x から 100.x への移行",
	"tags": [],
	"description": "今まで ArcGIS Runtime SDK for .NET バージョン 10.2.x を使用してアプリケーションを開発されていた開発者向けのガイドです。",
	"content": "ArcGIS Runtime SDK バージョン 100.x は新しいアーキテクチャを使用してゼロから開発された次世代の ArcGIS Runtime です。このバージョンアップに伴い API の再設計が行なわれています。このドキュメントでは、バージョン 100.x の変更点について説明します。\nArcGIS Runtime SDK for .NET に関しては、ESRIジャパン 製品ページをご参照ください。\n以下は、バージョン 100.x の主な変更点です。\n マップとシーン ビュー レイヤー クラス名の変更 フィーチャ レイヤーの表示 フィーチャの操作 個別属性表示 グラフィックス オーバーレイ ジオメトリとジオメトリ ビルダー スケッチ エディター ローダブル パターン ローカルサーバー 既知の制限事項  マップとシーン 100.x では、Map オブジェクト（2D表示用）と Scene オブジェクト（3D表示用） を API のコアとして、ArcGIS プラットフォームの Web GIS 機能を迅速に利用できるようになりました。\nMap オブジェクトと Scene オブジェクトは 、それらを表示する View と分離されています。Map オブジェクトと Scene オブジェクトには 、操作レイヤー、ベースマップ、ブックマーク等の ArcGIS 固有のデータを設定でき、アプリケーションで利用することができます。\nビュー MapView（2D表示用）と SceneView（3D表示用）は、UI コンポーネントです。MapView クラスの map プロパティに、Map オブジェクトを、MapSceneView クラスの scene プロパティには Scene オブジェクトを設定します。\n100.x では、以下のようにマップを表示します。\n// ベースマップを指定してマップを初期化 Map myMap = Map(Basemap.CreateImagery()); // マップビューにマップを設定 MyMapView.Map = myMap; レイヤー クラス名の変更 各レイヤーのクラス名が以下のように変更されています。\n   レイヤー 10.2.x のクラス名 100.x のクラス名     ArcGIS Server ダイナミック マップ サービス レイヤー ArcGISDynamicMapServiceLayer ArcGISMapImageLayer   タイル マップ サービス レイヤー ArcGISTiledMapServiceLayer ArcGISTiledLayer   タイル パッケージ レイヤー ArcGISLocalTiledLayer ArcGISTiledLayer    100.x でサポートされているレイヤーのタイプについては、ArcGIS Runtime SDK for .NET: レイヤー（英語）をご参照ください。\n作成した各レイヤーは、以下の方法でマップに追加します。\n// 操作レイヤーとしてマップに追加する myMap.OperationalLayers.Add(arcgis_map_image_layer) // ベースマップとしてマップに追加する myMap.Basemap.BaseLayers.Add(arcgis_tiled_layer); フィーチャ レイヤーの表示 フィーチャ サービスや端末のローカルに格納されたジオデータベースのデータをマップに表示するにはフィーチャ レイヤーを使用します。 フィーチャ レイヤーを表示するには、はじめにフィーチャ テーブルを作成します（フィーチャ サービスのデータをフィーチャ レイヤーとして表示するに場合は ServiceFeatureTable オブジェクト、ジオデータベースのデータ表示する場合は GeodatabaseFeatureTable オブジェクトを使用します）。次に作成したフィーチャ テーブルを引数として FeatureLayer オブジェクトを作成し、Map オブジェクトの OperationalLayers に追加します。\n次のコードは、フィーチャ サービスのデータを FeatureLayer として追加する方法を示しています。\n// フィーチャ サービスの URL からフィーチャ テーブルを作成 ServiceFeatureTable featureTable = new ServiceFeatureTable(new Uri(\u0026#34;https://services.arcgis.com/wlVTGRSYTzAbjjiC/arcgis/rest/services/all_Japan_shikuchoson/FeatureServer/0\u0026#34;)); // フィーチャ テーブルからフィーチャ レイヤーを作成 FeatureLayer featureLayer = new FeatureLayer(featureTable); // フィーチャ レイヤーをマップの操作レイヤーに追加 myMap.OperationalLayers.Add(featureLayer); フィーチャの操作 フィーチャの検索や編集はフィーチャ テーブル （ServiceFeatureTable または GeodatabaseFeatureTable）に対して行います。\nフィーチャ サービスから作成したフィーチャ テーブル（ServiceFeatureTable）の場合、フィーチャ テーブルのフィーチャは、マップ上にレンダリングするために必要最小限の情報だけを含むように最適化されています。これにより、フィーチャを表示するための待機時間と帯域幅の消費が削減されます。フィーチャの編集やすべての属性情報を表示するような場合は完全な情報を取得するために、ローダブル パターン等を使用して、フィーチャを明示的にロードしておく必要があります。\nフィーチャのリクエスト モード フィーチャ サービスからフィーチャを取得する場合は、 リクエスト モードの設定によってフィーチャの取得頻度とや端末上でのデータのキャッシュ方法を制御します。リクエスト モードには、OnInteractionCache、 OnInteractionNoCache、ManualCache があります。リクエスト モードはフィーチャ テーブルが初期化される前に、ServiceFeatureTable の FeatureRequestMode プロパティを使用して設定できます。\n  OnInteractionCache: ユーザーの操作によりマップの表示領域が変更されると、フィーチャが自動的にリクエストされます。リクエストされたすべてのデータはローカルにキャッシュされます。キャッシュされたデータは、既に表示された領域にマップが移動しても、再度リクエストされません。サーバー上のデータが変更される可能性が少ない静的なデータに適したモードです。\n  OnInteractionNoCache: ユーザーの操作によりマップの表示領域が変更されると、フィーチャが自動的にリクエストされますが、キャッシュはされません。既に表示された領域にマップが移動すると、再度リクエストされます。サーバー上のデータが継続的に更新される可能性がある場合に適したモードです。\n  ManualCache: ユーザーによるマップ操作では、フィーチャは自動的にリクエストされません。このモードを使用する場合は、ServiceFeatureTable の PopulateFromServiceAsync メソッドを使用して明示的にデータをリクエストする必要があります。\n以下のコードは PopulateFromServiceAsync メソッドを使用して、サーバー上のすべてのフィーチャを取得する方法の例です。\n  // フィーチャの取得（検索）時のパラメーターを設定 QueryParameters queryParameters = new QueryParameters(); // すべてのフィーチャを取得するように条件を設定 queryParameters.WhereClause = \u0026#34;1 = 1\u0026#34;; // 検索結果にフィーチャのすべての属性情報（outFields の配列に \u0026#34;*\u0026#34; を指定）を含める var outputFields = new string[] { \u0026#34;*\u0026#34; }; // クエリの条件に基づいてフィーチャ テーブルにデータを設定する await featureTable.PopulateFromServiceAsync(queryParameters, true, outputFields); フィーチャの編集 フィーチャの編集はフィーチャ テーブルに対して行います。フィーチャ サービスまたはジオデータベースのデータから作成したフィーチャ テーブルのどちらを編集する場合も実装方法に違いはありません。\nフィーチャの編集方法は、 ArcGIS Runtime SDK for .NET: フィーチャの編集（英語）をご参照ください。\nフィーチャの検索 フィーチャの検索はフィーチャ テーブルに対して行います。フィーチャ サービスまたはジオデータベースのデータから作成したフィーチャ テーブルのどちらを編集する場合も実装方法に違いはありません。検索を行うには ServiceFeatureTable または GeodatabaseFeatureTable クラスの QueryFeaturesAsync メソッドを使用します。\n次のコードは、フィーチャ テーブルからフィーチャを検索する方法を示しています。\ntry { // フィーチャの取得（検索）時のパラメーターを設定  QueryParameters queryParams = new QueryParameters(); // 検索条件を設定  queryParams.WhereClause = \u0026#34;upper(KEN) LIKE \u0026#39;%東京%\u0026#39;\u0026#34;; // フィーチャ テーブルから検索条件を取得  FeatureQueryResult queryResult = await _featureTable.QueryFeaturesAsync(queryParams); // 結果に問い合わせるためにリストを取得  var features = queryResult.ToList(); if (features.Any()) { // 結果から1件のフィーチャを取得  Feature feature = features[0]; } else { MessageBox.Show(\u0026#34;検索結果が見つかりませんでした。\u0026#34;); } } catch (Exception ex) { MessageBox.Show(\u0026#34;処理エラー\u0026#34;, \u0026#34;検索処理でエラーが発生しました：\u0026#34; + ex.ToString()); } 個別属性表示 マップ上で特定の場所をタップして、その位置にあるフィーチャをすべてのレイヤーから検索して取得することができます。その操作はビューに対して行います。次のコードは、MapView クラスの IdentifyLayerResult メソッドを使用してフィーチャを取得する方法を示しています。\n// MapView のすべてのレイヤーを識別し、タップしたポイント、許容値、戻り値のタイプ、最大結果数を渡します IReadOnlyList\u0026lt;IdentifyLayerResult\u0026gt; idLayerResults = await MyMapView.IdentifyLayersAsync(tapScreenPoint, pixelTolerance, returnPopupsOnly, maxLayerResults); foreach (IdentifyLayerResult idResults in idLayerResults) { // 検索されたレイヤーを取得して FeatureLayer にキャストする  FeatureLayer idLayer = idResults.LayerContent as FeatureLayer; // 反復処理を行い、検索されたレイヤー内の GeoElement を取得する  foreach (GeoElement idElement in idResults.GeoElements) { // GeoElement を Feature にキャストする  Feature idFeature = idElement as Feature; // フィーチャ レイヤーでフィーチャを選択状態にする  idLayer.SelectFeature(idFeature); } } グラフィックス オーバーレイ グラフィックは、マップ上に一時的なデータを表示するために使用されます。MapView と SceneView オブジェクトにはグラフィックを表示するためのグラフィックス オーバーレイ（GraphicsOverlay）が含まれています。 グラフィックス オーバーレイを使用することで、マップ上のレイヤーの順序が変更されても、グラフィックが常に最上位に表示されます。\n次のコードは、MapView オブジェクトに、グラフィックス オーバーレイを使用してグラフィックを追加する方法を示しています。\n// ジオメトリとシンボルを使用してグラフィックを作成 var pointGraphic = new Graphic(pointGeometry, poitnSymbol); // グラフィックス オーバーレイに作成したグラフィックを追加 var graphicsOverlay = new GraphicsOverlay(); graphicsOverlay.Graphics.add(pointGraphic); // MapView の GraphicsOverlays に作成したグラフィックス オーバーレイを追加 MyMapView.GraphicsOverlays.Add(graphicsOverlay); ジオメトリとジオメトリ ビルダー Geometry オブジェクトのコンストラクタを使用すると、既知の座標を使用してジオメトリを作成できますが、作成後にそのジオメトリを変更することはできません。\nジオメトリ ビルダー（GeometryBuilder）を使用すると、ゼロから新しいジオメトリを作成したり、既存のジオメトリを基に、ジオメトリを変更することができます。\nスケッチ エディター スケッチ エディター（SketchEditor）を使用すると、ユーザーがマップ上で対話的にジオメトリをスケッチすることができます。\n次のコードは、SketchEditor の使用方法の例を示しています。\n// 頂点の編集、サイズ変更、移動ができるようにスケッチエディタの設定を行います var config = MyMapView.SketchEditor.EditConfiguration; config.AllowVertexEditing = true; config.ResizeMode = SketchResizeMode.Uniform; config.AllowMove = true; // スケッチエディタをページのデータコンテキストとして設定する DataContext = MyMapView.SketchEditor; ・・・・・・ try { // ジオメトリの種類を設定してスケッチを開始  geometry = await MyMapView.SketchEditor.StartAsync(creationMode, true); ・・・・・・ // ジオメトリが更新された際の処理 } catch (TaskCanceledException) { // スケッチのキャンセル } catch (Exception ex) { // スケッチのエラー } ローダブル パターン データを非同期的にロードして状態を初期化するマップやレイヤー等のリソースは、ローダブル パターンを採用しています。各リソースのプロパティにアクセスするときは、ローダブル パターンを使用して、リソースがロードされた後にアクセスすることが推奨されます。ローダブル パターンは、ロード状態の振る舞いをより均一にして且つ一貫性を持たせることで、非同期性をより明示的にします。ローダブル パターンでは、各リソースは自動的にリソースの状態をロードしません。それらは、開発者が明示的に実行したときに、遅延ロードします。 ローダブル パターンを採用しているリソースの状態は、NotLoaded（ロードが開始していない、Loading（ロード中）、Loaded（ロードに成功）、FailedToLoad（ロードに失敗） のいずれかで監視することができ、ロードに失敗した場合はロードを再試行することができます。\n詳細は、ArcGIS Runtime SDK for .NET: ローダブル パターン（英語）を参照してください。\n次のコードは、ローダブル パターンの使用方法の例を示しています。\n// ローダブル時のイベント featureLayer.Loaded += (s, e) =\u0026gt; { // フィーチャ レイヤーのプロパティにアクセス  Debug.Assert(featureLayer.MinScale == 5000); Debug.Assert(featureLayer.MaxScale == 1000000); }; // フィーチャ レイヤーのロード await featureLayer.LoadAsync(); ローカルサーバー ローカル サーバーの機能を使用する場合は、ArcGIS Runtime SDK for .NET とは別に ArcGIS Runtime Local Server SDK のインストールが必要となります。インストールの詳細は、ArcGIS Runtime SDK for .NET: ローカル サーバー（英語）を参照してください。\n既知の制限事項 現バージョンでの既知の制限事項が、ArcGIS Runtime SDK for .NET: リリース ノート（英語）に記載されていますので、ご参照ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/migrating-from-3.x-to-4.0/",
	"title": "バージョン 3.x から 4.x への移行",
	"tags": [],
	"description": "バージョン 3.x の API で作成した既存のアプリケーションを 4.x に移行するために必要な情報を紹介します。",
	"content": "出典：ArcGIS Maps SDK for JavaScript - Migrating from 3.x to 4.25\nバージョン 4.x では ArcGIS Maps SDK for JavaScript の構成要素が大きく見直され、機能拡張が行われています。バージョン 3.x で開発したアプリケーションをアップデートすることも可能ですが、アプリケーションを書き換えることを検討してください。\n本トピックでは 3.x の API で作成した既存のアプリケーションを 4.x に移行するために必要な情報を解説します。API で更新された仕様はいくつかありますが、その中でも重要な項目について紹介します。\n プロパティのハンドリング View の利用 Map と Layer の仕様 モジュールとパッケージの更新 Web マップのサポート ローカライズ AMD のみ 廃止項目  バージョン 4.0 では、大幅な変更が行われました。これらの変更は、開発者がどのようなアプリケーションを作成する場合でも、より効率的かつ効果的に作業できるようにするために行われました。この変更は、コンストラクタ、プロパティ、イベントの処理方法に見られます。\nプロパティ 4.0 より前のバージョンでは、getMethodName や setMethodName を呼び出すことで、一部のプロパティを get (読み込み）または set（書き込み）することができました。API では、すべてのプロパティを取得・設定するためのシンプルで一貫した方法がサポートされているため、これらのタイプのメソッドは不要になりました。\n 例えば map.basemap = \u0026quot;oceans\u0026quot; のようにオブジェクトに直接プロパティを設定します。 例えば map.basemap.title. のようにオブジェクトから直接プロパティを取得します。  例えば、3.x ではフィーチャーレイヤーの definitionExpression 設定は、以下のようになります。\nmyFeatureLayer.setDefinitionExpression(expression); 次の行は、4.0 でフィーチャーレイヤーの definitionExpression 設定する方法を示しています。\nmyFeatureLayer.definitionExpression = expression; 4.0 では、以下のように .get() を使用して深い階層のプロパティにアクセスすることができます。\nvar basemapTitle = map.get(\u0026#34;basemap.title\u0026#34;); プロパティの変更の監視 4.0 より前のバージョンでは、プロパティの変更はイベントでハンドリングされていました。4.0 では、プロパティの変更を監視することが非常に簡単になりました。これは、.watch(property, callback) メソッドで処理されます。このコールバックは、プロパティが変更されるたびに呼び出され、プロパティの新しい値、古い値、名前を監視対象のオブジェクトと一緒に操作することができます。\n// ベースマップ \u0026#39;streets-vector\u0026#39; を定義し、新しい map オブジェクトを作成 var map = new Map({ basemap: \u0026#39;streets-vector\u0026#39; }); // map オブジェクトで定義したベースマップのタイトルが変更されるとコールバックが発生します。 var handle = map.watch(\u0026#39;basemap.title\u0026#39;, function(newValue, oldValue, property, object) { console.log(\u0026#34;新しい値: \u0026#34;, newValue, // プロパティの新しい値  \u0026#34;\u0026lt;br\u0026gt;古い値: \u0026#34;, oldValue, // プロパティの前の値（変更される前の値）  \u0026#34;\u0026lt;br\u0026gt;監視しているプロパティ: \u0026#34;, property, // この例では、この値は常に \u0026#34;basemap.title\u0026#34; になります。  \u0026#34;\u0026lt;br\u0026gt;監視しているオブジェクト: \u0026#34;, object); // この例では、この値は常に map オブジェクトになります。 }); View の利用 4.0 では、Map を 2D または 3D で表示できるようになりました。それに併い、マップの描画ロジックが変更されました。描画ロジックは、マップとレイヤーではなく、View によって制御されるようになりました。\nView は 4.0 で導入されたコンセプトです。View は 2 つのタイプがあります。\n 2D で表示する場合: MapView 3D で表示する場合: SceneView  View は、Map や Scene 内のデータを可視化するために使用されます。Map には実際に表示するデータやレイヤーが含まれていますが、View はそのデータの表示を行います。データの可視化（表示）方法は、2D か 3D かによって異なります。View は、view.map のように、Map への参照を持っています。しかし、Map は View への参照を持っていません。注意すべき点は、1 つの Map が複数の View によって消費されることがあるということです。\nこれを別の言い方をすると、Map は世界のベースマップや機能を表し、View はその地図を見るための窓ということになります。\n以下の構文は、2D View (MapView) と 3D View (SceneView) の両方を作成し、操作する方法を示しています。\n次のスニペットは、MapView を使った 2D マッピングを示しています。\nfunction (Map, MapView){ map = new Map({ basemap: \u0026#34;topo-vector\u0026#34; }); view = new MapView({ container: \u0026#34;viewDiv\u0026#34;, map: map, scale: 2400000 }); } このスニペットは、SceneView を使った 3D マッピングです。\nfunction (Map, SceneView){ map = new Map({ basemap: \u0026#34;topo-vector\u0026#34; }); view = new SceneView({ container: \u0026#34;viewDiv\u0026#34;, map: map, scale: 2400000 }); } Map と Layer の仕様 Map と Layer にはいくつかの重要なアップデートが行われましたが、その一部を以下にご紹介します。\n 4.0 からは、basemap と地図上の operational layers を分離しました。 2D または 3D の View を回転させることができるようになりました。 グラフィック レイヤーは、マップのレイヤー コレクションの中のどこにでも追加することができます。4.0 以前では、グラフィック レイヤーは他の形式のレイヤーよりも上に追加する必要がありました。 GroupLayer クラスが追加されました。  モジュールとパッケージの更新 詳細は3.x/4.x 機能比較表（英語）を確認してください。以下に挙げた項目は、その中でも重要な更新です。\n パッケージ名の変更（例: esri/dijit が esri/widgets に変更） モジュール名の短縮（例: ArcGISTiledMapServiceLayer が TileLayer に変更） モジュール名の大文字・小文字を統一し、「Map」「Graphic」「Query」など、すべてのモジュールが大文字で始まるようになりました。 サポート クラスは、API リファレンスをより組織化するために support フォルダに 移動しました(例: esri/layers/support, esri/tasks/support)。 esri/config の構成が変更され、 esriConfig.defaults のプロパティは esriConfig に移動しました。以下は、デフォルトで使用されるジオメトリ サービスの設定方法の例です。  // 3.x esriConfig.defaults.geometryService = new GeometryService(\u0026#34;\u0026lt;ジオメトリ サービスのURL\u0026gt;\u0026#34;); // 4.x esriConfig.geometryService = new GeometryService(\u0026#34;\u0026lt;ジオメトリ サービスのURL\u0026gt;\u0026#34;);  defaults.io オブジェクトは esriConfig.request に移動しました。  // 3.x esriConfig.defaults.io.alwaysUseProxy = true; // 4.x esriConfig.request.alwaysUseProxy = true;  3 つの *-all レガシー モジュールが削除されました。これは、ビルドや Website Optimizer を使用してより適切に処理されます。 各コンストラクタは JSON をサポートしなくなったため、代わりに、fromJSON() メソッド（例: Graphic.fromJSON() ）を使用してください。(注: ベータ3では、まだ 3.x のスタイルを使用したコンストラクタがいくつか含まれています。) FeatureLayer はグラフィックを保持しません。代わりに LayerView が FeatureLayer のフィーチャを表すグラフィックを描画します。  Web マップのサポート バージョン 2.x の Web マップ を読み込むことができます。WebMap の操作は部分的にサポートされています。これは、API ですでに利用可能な機能に依存していることを意味します。例えば、まだ実装されていないレイヤータイプが含まれている場合でも WebMap を読み取ることができます。このような場合、API でサポートされているレイヤータイプのみが表示されます。WebMap の保存は、バージョン 4.14 からサポートされています。\nローカライズ 4.x では、ロケールを \u0026ldquo;ar \u0026ldquo;や \u0026ldquo;he \u0026ldquo;に設定しても、right-to-left (RTL) は行われなくなりました。\n どのロケールでも RTL をオプトインできるようになりました。RTL サポートを参照してください。 \u0026lt;html\u0026gt; または \u0026lt;body\u0026gt; タグで方向を指定します。RTL サポートを参照してください。  AMD のみ 4.0 以前は、AMD とレガシー モジュールの両方を使用することができました。4.0 以降は、AMD モデルのみのサポートとなります。\n廃止項目 Geocoder ウィジェットはバージョン 3.13 で非推奨となり、4.x では提供されません。代わりに Search ウィジェットを使用してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/ios/",
	"title": "ArcGIS Runtime SDK for iOS",
	"tags": [],
	"description": "ArcGIS Runtime SDK for iOS の開発に役立つガイド集です。",
	"content": "ArcGIS Runtime SDK for iOS (バージョン 100.x) の開発に役立つガイド集です。\n インストール ガイド\nArcGIS Runtime SDK for iOS のインストールとセットアップ手順を紹介します。\n\r アプリケーション配布ガイド\nArcGIS Runtime SDK for iOS を使用して開発したアプリケーションを配布する場合に必要なライセンス認証の手順を紹介します。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-ios/",
	"title": "iOS",
	"tags": [],
	"description": "ArcGIS Runtime SDK for iOS を用いたモバイル地図アプリの作成方法を紹介します。",
	"content": "マップを表示する このチュートリアルでは ArcGIS Runtime SDK for iOS (バージョン 100.x) を使用して、マップとベースマップ レイヤーを表示する方法を紹介します。\nマップには、地理データのレイヤーが含まれています。マップには、ベースマップ レイヤーと、オプションで1つ以上のデータレイヤーを追加できます。マップビューを使用し、場所とズームレベルを設定することで、マップの特定の領域を表示できます。\nこのチュートリアルでは、地形ベースマップレイヤーを使用して、富士山付近を表示する地図を作成します。\n前提条件 このチュートリアルを実施するには、以下が必要です。\n API キーにアクセスするための ArcGIS 開発者アカウント。アカウントをお持ちでない場合は、サインアップ（無料）してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。 開発環境がシステム要件を満たしていることを確認します。 ArcGIS Runtime SDK for iOS がインストールされていること  ステップ 新しい Xcode プロジェクトを作成する Xcode を使用してシングルビュー iOS アプリを作成し、SDK を参照するように構成します。\n  Xcode を開き、メニュー バーから [File] \u0026gt; [New] \u0026gt; [Project] \u0026gt; [iOS] \u0026gt; [App] \u0026gt; [Next] をクリックします。\n [Choose options for your new project] ウィンドウで、次の値を設定します。  Product Name: \u0026lt;任意の名前\u0026gt; Language: Swift Interface: Storyboard Organization Identifier: \u0026lt;任意の組織\u0026gt;   他のすべてのオプションのチェックを外します。 [Next] \u0026gt; [Create] をクリックします。    「インストールガイドのプロジェクトの構成」の手順に従って、API への参照を追加します。\n  UI にマップビューを追加する マップビューは、マップを表示する UI コンポーネントです。また、タッチジェスチャによるナビゲートなど、ユーザーによるマップの操作も処理します。Xcode とストーリーボード エディターを使用して、マップビューを UI に追加し、それをビュー コントローラーのソースコードに接続します。iPhone のディスプレイ全体に表示されるようにマップビューのサイズを設定します。\n  Project Navigator で ViewController.swift をクリックします。\n  エディターで、API を参照するインポート ステートメントを追加し、mapViewという名前で AGSMapView タイプの @IBOutlet を追加します。これにより、ストーリーボードで作成するマップビューへの参照が提供されます。AGSMapView は UIView のサブクラスです。\nViewController.swift\nimport UIKit // 追加開始 import ArcGIS // 追加終了 class ViewController: UIViewController { // 追加開始 @IBOutlet weak var mapView: AGSMapView! // 追加終了 override func viewDidLoad() { super.viewDidLoad() } }   Project Navigator で Main.storyboard をクリックしストーリーボード エディターを開きます。\n  メニューで, [View] \u0026gt; [Show Library] をクリックしオブジェクト ライブラリを表示します。\n  オブジェクト ライブラリ上で\n uiview と入力するか、下にスクロールして View を見つけます。 新しい View をストーリーボードのメインビューにドラッグアンドドロップします。    ストーリーボード エディターの右下にある Add New Constraints をクリックします。パネル上で\n 上下左右のコンストレイントに0を入力します。 Add 4 Constraints をクリックします。  新しい View が画面いっぱいに表示されます。\n  メニューで [View] \u0026gt; [Inspectors] \u0026gt; [Identity] をクリックします。インスペクター パネルで [Custom Class] \u0026gt; [Class] を AGSMapView に設定します。これにより、新しい View のタイプが AGSMapView に設定されます。\n  ストーリーボード エディターで、黄色の View Controller アイコンを右クリックして、コネクション パネルを表示します。 mapView アウトレット コネクタをストーリーボードの新しい AGSMapView ビューにドラッグします。これにより、ストーリーボードの AGSMapView が、ViewController クラスで以前に作成されたmapView アウトレットに接続されます。\n  マップを追加する マップビューを使用して、富士山を中心としたマップを表示します。マップには、地形ベースマップレイヤーが含まれます。\n  Xcode の Project Navigator で ViewController.swift をクリックします。\n  エディタで、setupMap() という名前のプライベート メソッドを定義します。 setupMap() で AGSMap を作成します。AGSBasemapStyleArcGISTopographic という名前の地形図のベースマップスタイルを使用して ArcGISMap を構成します。\nViewController.swift\nclass ViewController: UIViewController { @IBOutlet weak var mapView: AGSMapView! // 追加開始 private func setupMap() { let map = AGSMap( basemapStyle: .arcGISTopographic ) mapView.setViewpoint( AGSViewpoint( latitude: 35.360626, longitude: 138.727363, scale: 200000 ) ) } // 追加終了 override func viewDidLoad() { super.viewDidLoad() } } 地形図（.arcGISTopographic）以外にも、道路地図（.arcGISStreets）、衛星画像（.arcGISImagery）、オープンストリートマップ（.osmStreets）など、様々なスタイルが用意されています。\n  mapView アウトレットの map プロパティを新しい AGSMap に設定します。\nViewController.swift\nprivate func setupMap() { let map = AGSMap( basemapStyle: .arcGISTopographic ) // 追加開始 mapView.map = map // 追加終了 mapView.setViewpoint( AGSViewpoint( latitude: 35.360626, longitude: 138.727363, scale: 200000 ) ) }   ViewController の viewDidLoad メソッドで、ビューがロードされたら setupMap() を呼び出します。\nViewController.swift\noverride func viewDidLoad() { super.viewDidLoad() // 追加開始 setupMap() // 追加終了 }   API キーを設定する ArcGIS Online でホストされているサービス、Web マップ、Web シーンにアクセスできるようにするには、API キーが必要です。 まだ作成していない場合は、ArcGIS Developers ダッシュボード に移動して、API キーを取得します。作成方法は「API キーの取得」をご覧ください。\n  Project Navigator で AppDelegate.swift をクリックします。\n  エディターで、API を参照するインポートステートメントを追加し、AppDelegate の application(_:didFinishLaunchingWithOptions:) メソッドで、API キーを使用して AGSArcGISRuntimeEnvironment の apiKey プロパティを設定します。\nAppDelegate.swift\nimport UIKit // 追加開始 import ArcGIS // 追加終了 @UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u0026gt; Bool { // 追加開始 // 注：API キーをソースコードに保存することはベストプラクティスではありません。 //チュートリアルでは便宜上ソースコードに記載しています AGSArcGISRuntimeEnvironment.apiKey = \u0026#34;\u0026lt;API キー\u0026gt;\u0026#34; // 追加終了 return true } }   \u0026lt;Command + R\u0026gt; を押してアプリを実行します。\n  富士山を中心とした地形ベースマップレイヤーのマップが表示されます。マップビューをピンチ、ドラッグ、およびダブルタップして、マップを操作します。\n完成版のプロジェクトはこちらからダウンロードできます（マップの表示場所は本チュートリアルで設定した場所とは異なります）。\nWeb マップを表示する 「Web マップの作成」のガイドで Web マップを作成している場合は、作成した Web マップも基本的に同じステップで表示できます。\n  マップを表示するのステップで作成したプロジェクトの ViewController.swift を開き、setupMap() メソッドを下記のように書き換えます。\nViewController.swift\nprivate func setupMap() { let portal = AGSPortal.arcGISOnline(withLoginRequired: false) let itemID = \u0026#34;\u0026lt;Web マップの ID\u0026gt;\u0026#34; let portalItem = AGSPortalItem(portal: portal, itemID: itemID) let map = AGSMap(item: portalItem) mapView.map = map }    アプリの動作が確認できたら ArcGIS の セキュリティと認証について学びましょう！\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/python-api-jnlabsetup/",
	"title": "Jupyter Lab を使ってみよう",
	"tags": [],
	"description": "ArcGIS API for Python の実行に便利な Jupyter Notebook の基本的な起動と使用方法を簡単に紹介します。",
	"content": "JupyterLab は、コード、データ、そして Jupyter Notebook のファイル形式（*.ipynb）を扱う最新の対話型開発環境（IDE）です。Jupyter Notebook 同様、オープンソースとして公開されています。 ArcGIS API for Python（以下、Python API ）のバージョン 1.5.0 以降で対応しています。\nJupyterLab で GIS データとグラフの操作\n\rJupyterLab は、より柔軟で強力なユーザー体験を実現するために Jupyter Notebook の主要コンポーネント (ノートブック、ターミナル、テキスト エディター、ファイル ブラウザー、ipywidgets など) をベースに構築されています。JupyterLab の詳細は JupyterLab のブログや GitHub をご参照ください。\nJupyterLab をはじめる Python API を JupyterLab で使用するためには、いくつかインストールなどの設定が必要です。\nインストール   バージョン 1.5.0 以上の Python API をインストールするか、既存の環境を 1.5.0 以上にアップデートする ターゲットの仮想環境がある場合は、アクティベート（activate）してから行います。Python API のインストールまたはアップデートの方法はインストールガイドをご覧ください。\n  次の 2 つのコマンドを実行します\n jupyter labextension install @jupyter-widgets/jupyterlab-manager jupyter labextension install arcgis-map-ipywidget@バージョン番号    2 つ目のコマンドの最後にある「バージョン番号」部分は、使用する Python API のバージョンに合わせて変更してください (例：1.6.1)。\nエラー等で正常に完了できない場合は、お使いの端末または現在の環境に npm および nodejs をインストールする必要があります。インストールの詳細は npm のウェブサイト、または node.js のウェブサイトを参照してください。\n\r\\anaconda3\\share\\jupyter\\lab\r@jupyter-widgets/jupyterlab-manager v0.38.1 enabled ok\rarcgis-map-ipywidget v1.5.1 enabled ok\r``` --\r 以上の設定が完了したら、次のコマンドで JupyterLab を起動します。  jupyter lab    任意のディレクトリをルート ディレクトリとして起動したい場合は、cd コマンドでディレクトリを移動してから起動コマンドを実行します。\nファイルエクスプローラー JupyterLab は、従来の Jupyter Notebook のように、既存のノートブックを開いたり、新しいノートブックを作成したり、コンテンツを整理するためのファイルエクスプローラを備えています。 JupyterLab のファイルエクスプローラは、メインビューの左側のウィンドウです。\n\rJupyterLab も Jupyter Notebook と同様に、ノートブック形式（*.ipynb）で動作しコードや結果を保存できます。この 2 つのツールの違いは、主にユーザーインターフェースといくつかの外部エクステンションが追加された点です。\nウィンドウとタブを使用する JupyterLab には、Jupyter Notebook とは違って、「ウィンドウ」と「タブ」という概念があります。 これにより、ノートブックを重ねたり、横に並べたり、タブで整理したりすることができます。これらの操作は、以下のように「タブ」をクリックしてドラッグするだけで可能です。\n\rどのようなウィンドウでもこのようにドラッグすることが可能です。*.csv、*.json などのファイルも表示や編集することができます。\rセルの使用 上記のウィンドウとタブと同様に、JupyterLab ではノートブックのセルをドラッグアンドドロップして移動することができます。 JupyterLab は、1 つのノートブックから別のノートブックにセルをドラッグする機能もサポートしています。 移動したいセルの左側の領域をクリックして、それをドラッグします。\n\rJupyterLab では、Shift キーを押しながら複数のセルを選択することもできます。前述のようにこれらのセルを移動するか、右クリックして [Copy Cells] を選択してコピーします。また、右クリックのメニューには、[Create New View For Output] を含む多くのオプションがあります。[Create New View For Output] を使用すると、任意のセルの実行結果を別のタブで表示することができ、重ねたり、並べて表示したりすることができます。\n\rJupyterLab には他にも様々なセルの操作ができるので、いろいろと探してみてください！\rマップ ウィジェットとの連携 バージョン 1.5.0 以上の Python API では、2D 回転、3D モード、3D レンダラーのサポートなどマップ ウィジェットの機能が多数追加されています。これらの機能の詳細については、ガイドページ（米国ESRI ページ）でご紹介しています。このガイドでは、マップ ウィジェットと JupyterLab のシームレスな連携を紹介します。\n\rPython API の MapView クラスのデフォルトの表示動作は、Jupyter Notebook と同じで、ウィジェットはセルの出力にマップが表示されます。JupyterLab では、これに加えて以下のようなボタンが表示されます。\n\rこのボタンを押すと、ウィジェットが新しいウィンドウで表示されます。 このウィンドウは、他のすべてのウィンドウと同様に、タブでの表示、分割などが可能です。 ウィジェットを元に戻すには、以下のボタンを押します。\n\rここからは、実際にコードを試してみましょう。 以下のセルを実行します。\nfrom arcgis.gis import GIS # JupyterLab へ地図を表示する gis = GIS() map = gis.map() map \rWeb マップ と Web シーン Web マップ、Web シーン の両方とも、このボタンを使用することができます。\nfrom arcgis.mapping import WebMap webmap_item = gis.content.get(\u0026#34;ab42b088573d4253a22a8b38ee698ccd\u0026#34;) webmap = WebMap(webmap_item) webmap from arcgis.mapping import WebScene webscene_item = gis.content.get(\u0026#34;421433baeb8d487b903d4a89df79149b\u0026#34;) webscene = WebScene(webscene_item) webscene \rプログラムによるウィンドウの制御 ここまではこの機能をマウスで実行しましたが、Pythonを使用して制御することもできます。 MapView ウィジェットの各インスタンスには、tab_mode プロパティと toggle_window_view（） メソッドがあります。tab_mode を設定すると、地図ウィジェットの新しいウィンドウへの移動方法が変更されます。 この動作を試すには、以下のコードを実行してみてください。\n# 対象の地図を表示する map = gis.map() map # コメントをひとつずつオフにして実行し、map で表示している地図の UI ボタンを都度押してみてください。 # map.tab_mode = \u0026#34;split-bottom\u0026#34; # map.tab_mode = \u0026#34;split-right\u0026#34; # map.tab_mode = \u0026#34;auto\u0026#34; # map.tab_mode = \u0026#34;tab-after\u0026#34; \rUI ボタンによる新しいウィンドウでの地図表示は、toggle_window_view（） メソッドを使用することでも制御できます。次のコードでは、マップが表示されたらメソッドを使用して新しいウィンドウで表示させます。新しいウィンドウに戻すときも、このメソッドを使用可能です。 以下のコードを実行してみてください。\nfrom arcgis.widgets import MapView # 対象の地図を表示する map = MapView(gis=gis) map map.toggle_window_view() \rタイトル（タブに表示されるテキスト）と tab_mode をメソッドを呼び出すたびに指定することも可能です。\n# 対象の地図を表示する map = gis.map(mode=\u0026#34;3D\u0026#34;) map # このセルを実行して、新しいウィンドウに地図を表示します map.toggle_window_view(title=\u0026#34;My 3D Map\u0026#34;, tab_mode=\u0026#34;split-top\u0026#34;) # ウィンドウを元に戻す map.toggle_window_view() import time # このセルを実行して全てのタブモードの挙動を確認してみてください tab_modes = [\u0026#39;auto\u0026#39;, \u0026#39;split-top\u0026#39; \u0026#39;split-bottom\u0026#39;, \u0026#39;split-left\u0026#39;, \u0026#39;split-right\u0026#39;, \u0026#39;tab-before\u0026#39;, \u0026#39;tab-after\u0026#39;] for tab_mode in tab_modes: # 新しいウィンドウで開く map.toggle_window_view(title=tab_mode, tab_mode=tab_mode) time.sleep(4) # ウィンドウを元に戻す map.toggle_window_view() time.sleep(4) \r最後に、3 つ以上の Web シーンを表示すると仮定した表示方法をご紹介します。各マップ ID で構成したリストから、1 度だけ処理を実行し、3 つの　Web シーンを一度にすべて新しいタブに表示します。\n#このセルの内容を1度で実行する from arcgis.gis import GIS from arcgis.widgets import MapView gis = GIS() for webscene_id in [\u0026#39;31874da8a16d45bfbc1273422f772270\u0026#39;, \u0026#39;91b46c2b162c48dba264b2190e1dbcff\u0026#39;, \u0026#39;46c47340708f446ba7f112f139e8ae5e\u0026#39;]: webscene_item = gis.content.get(webscene_id) map = MapView(gis=gis, item=webscene_item, mode=\u0026#34;3D\u0026#34;) map.toggle_window_view(title=webscene_item.title, tab_mode=\u0026#39;tab-after\u0026#39;) \rより詳細な情報は、マップ ウィジェットの API リファレンスを参照してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/custom-widget/",
	"title": "ウィジェット開発",
	"tags": [],
	"description": "ウィジェットと呼ばれる、再利用可能な UX コンポーネント作成の基礎を紹介します。",
	"content": "出典：ArcGIS Maps SDK for JavaScript - Widget development\nウィジェットは再利用可能な UI コンポーネントで、リッチな UX を提供する鍵となります。ArcGIS Maps SDK for JavaScript はすぐに使えるウィジェットを提供しています。また、バージョン 4.2 からは、独自の機能を持つカスタム ウィジェットを作成する基盤を提供します。\nこのガイドは、ウィジェット開発の新しいフレームワークへ移行するときに重視すべきトピックを説明することで、ウィジェット開発の基本を説明します。カスタム ウィジェット作成の基盤は、ウィジェットに実装する機能にかかわらず一貫しています。\nこのフレームワークはすべての Dijit を直接差し替えることを意図していません。例えば、dgrid の利用には Dijit が必要です。\nトピック\n 開発要件 ウィジェット ライフサイクル ウィジェットの実装 TypeScript デコレーター サンプルコード 関連リンク  このガイドはウィジェットのフレームワークの大まかな概要を説明しています。どのようにカスタム ウィジェットを作成するかは、Hello World や Recenter widget のサンプルをご参照ください。\n開発要件 カスタム ウィジェットを作成する前に、開発に必要となる要件を確認してください。要件は、作成するウィジェットにより異なります。以下はウィジェット開発に最低限必要な要件です。\nTypeScript TypeScript は JavaScript のスーパーセットです。TypeScript で書かれたコードは、JavaScript にコンパイルされます。ウィジェット開発には TypeScript を使用することが推奨されています。インターネット上には、TypeScript とは何か、なぜ使われるのか、そしてどのように使うのかを詳細に知ることのできる多数のリソースがあります。これらの基本を理解することで、ウィジェット開発の過程をより簡単に進めることができます。\nJSX JSX は HTML と同じようにウィジェットの UI を表現することができる JavaScript の拡張シンタックスです。JSX は HTML に似ており、JavaScript に埋め込んで使用することができます。\nesri/core/Accessor の理解 Accessor は 4.x の主要な特徴のひとつであり、ウィジェットを含むすべてのクラスの基盤です。どのように動作するのか、使用パターンなどの詳細は Implementing Accessor をご参照ください。\nウィジェット ライフサイクル 開発をはじめる前に、ウィジェット ライフサイクルを理解している必要があります。ウィジェットの種類にかかわらず、ライフサイクル特有の一般的な概念は同じです。\n constructor (params) - プロパティを設定している間に、ウィジェットが最初に作成されるところです。ウィジェットは Accessor から生じるので、get、set、watch を使いプロパティへアクセスできます（get、set、watch の詳細は Working with properties をご参照ください）。 postInitialize() - このメソッドは、ウィジェット作成後、UI の描画前に呼ばれます。 render() - ウィジェット開発で唯一の必須となるメソッドです。UI を描画するために使用されます。 destroy() - ウィジェットのインスタンスを解放するためのメソッドです。  ウィジェットの実装 まず、ベースとなる Widget クラスを拡張することによりウィジェットを作成することからはじめます。\n// 拡張に使用する Widget クラスのインポート import Widget = require(\u0026#34;esri/widgets/Widget\u0026#34;); @subclass(\u0026#34;esri.widgets.HelloWorld\u0026#34;) class HelloWorld extends declared(Widget) { } 次に、ウィジェット特有のプロパティとメソッドを実装します。このコードは、プロパティ作成において、デコレーターをどのように利用するのかを示しています。\n// \u0026#39;name\u0026#39; プロパティの作成 @property() @renderable() name: string = \u0026#34;John Smith\u0026#34;; // \u0026#39;emphasized\u0026#39; プロパティの作成 @property() @renderable() emphasized: boolean = false; // プライベートな _onNameUpdate メソッドの作成 private _onNameUpdate(): string { return \u0026#39;${this.name}\u0026#39;;} デフォルトでは、要素の中で参照される関数は、実際の要素を参照する this を持ちます。必要に応じて、this の参照先を変更するために bind 属性を使用します。以下では、name プロパティを更新するときに呼ばれる _onNameUpdate コールバック関数を結び付けています。これは次の postInitialize メソッドに表示されます。\nclass HelloWorld extends declared(Widget) { constructor() { super(); this._onNameUpdate = this._onNameUpdate.bind(this); } } postInitialize メソッドは、ウィジェットのプロパティは用意されているが、描画される前に呼ばれます。以下のコードは name プロパティを監視しています。プロパティが更新されると、_onNameUpdate コールバック関数を呼びます。watchUtils.init() は WatchHandle オブジェクトを返し、this.own() に渡されます。これは、ウィジェットを削除した時点で、リソースを解放するメソッドです。\npostInitialize() { const handle = watchUtils.init(this, \u0026#34;name\u0026#34;, this._onNameUpdate); // ウィジェットが削除された時点でリソースを解放するメソッド  this.own(handle); } プロパティが実装された後、ウィジェットの UI は JSX を使用して描画されます。これはウィジェットの renderer メソッドに処理されます。\nベースとなる CSS は class 属性に設定されます。class 属性はクラスが変更されないときに使用されます。動的にクラスを変更したいときは、classes を使います。これは、切り替え可能な CSS クラスを表すプロパティを持ったオブジェクトです。CSS クラスは、プロパティの値が true のときに追加され、false のときに削除されます。\n// UI の描画 render() { const classes = { \u0026#34;hello-world-emphasized\u0026#34;: this.emphasized }; return ( \u0026lt;div class = \u0026#34;hello-world\u0026#34; classes={classes}\u0026gt;{this._onNameUpdate()}\u0026lt;/div\u0026gt; ); } classes と同様に、styles は動的にスタイルを適用することができます。styles のプロパティの値は文字列であることに注意してください。詳細は、Styling トピックをご参照ください。\nrender() { const dynamicStyles = { background-color: this.__hasBackgroundColor ? \u0026#34;chartreuse\u0026#34; : \u0026#34;\u0026#34; }; return ( \u0026lt;div styles={dynamicStyles}\u0026gt;Hello World!\u0026lt;/div\u0026gt; ); } renderer() メソッドは、ウィジェットを実装するために必要となる唯一の必須メソッドです。\n最後に、this.destroy() を呼びます。このメソッドはウィジェットを削除し、postInitialize() 内で参照されている own() メソッドに登録された、すべてのリソースを解放します。\npostInitialize() { const handle = watchUtils.init(this, \u0026#34;name\u0026#34;, this._onNameUpdate); // ウィジェットが削除された時点でリソースを解放するメソッド  this.own(handle); } TypeScript デコレーター ウィジェット開発は TypeScript のデコレーターを利用します。デコレーターは、設計時に、既にあるプロパティ、メソッド、コンストラクタの中にある共通する振る舞いを定義、変更します。以下は、ウィジェットで使用される、もっとも一般的なデコレーターです。\n@subclass（declared と共に使われます） これらは、4.x のクラスに結びつけられる基本となるデコレーターです。\n以下のコードは esri/widgets/Widget クラスをインポートし、拡張して、renderer メソッド内で UI を定義しています。JSX は UI を定義するために使われています。この例では、div 要素と div 要素内に John Smit が作られます。\nimport Widget = require(\u0026#34;esri/widgets/Widget\u0026#34;); @subclass(\u0026#34;esri.widgets.HelloWorld\u0026#34;) class HelloWorld extends declared(Widget) { render() { return ( \u0026lt;div\u0026gt;John Smith\u0026lt;/div\u0026gt; ); } } @property() このデコレーターは Accessor プロパティを定義するために使われます。このデコレーターで定義されたプロパティは、get、set、watch を使用できます。\n@property() name: string; @renderable() このデコレーターは描画をスケジューリングするために使われます。プロパティが修正されたとき、自動的に描画をスケジューリングし、更新します。\n@renderable() name: string; 通常、プロパティを実装するときは、@property() と @renderable() の両方を使います。\n@property() @renderable() name: string; @aliasOf() このデコレーターはプロパティ エイリアスを定義します。これは、既にあるプロパティが重複しないようにコードを保つために使用されます（例えば ViewModel の内側に既に実装されています）。このガイドで提供するサンプルはこのデコレーターを使っていません。もし、このファイルと関連する HelloWroldViewModel があるとき、この方法を通して直接プロパティへアクセスします。これにより、コードの重複を避けることができます。\n@aliasOf(\u0026#34;viewModel.name\u0026#34;) name: string; サンプルコード 以下は、このガイドで説明したサンプルコードをまとめたものです。クラスは TypeScript で書かれ、TSX 拡張子で保存されます。TSX 拡張子は、作成するクラスが JSX を使っていることを示しています。\n/// \u0026lt;amd-dependency path=\u0026#34;esri/core/tsSupport/declareExtendsHelper\u0026#34; name=\u0026#34;__extends\u0026#34; /\u0026gt; /// \u0026lt;amd-dependency path=\u0026#34;esri/core/tsSupport/decorateHelper\u0026#34; name=\u0026#34;__decorate\u0026#34; /\u0026gt;  // Import decorator modules import {subclass, declared} from \u0026#34;esri/core/accessorSupport/decorators\u0026#34;; // Import decorator module and jsxFactory used for rendering import {renderable, jsxFactory} from \u0026#34;esri/widgets/support/widget\u0026#34;; // Import used to extend off of base Widget class import Widget = require(\u0026#34;esri/widgets/Widget\u0026#34;); @subclass(\u0026#34;esri.widgets.HelloWorld\u0026#34;) class HelloWorld extends declared(Widget) { postInitialize() { const handle = watchUtils.init(this, \u0026#34;name\u0026#34;, this._onNameUpdate); // Helper used for cleaning up resources once the widget is destroyed  this.own(handle); } // Create \u0026#39;name\u0026#39; property  @property() @renderable() name: string = \u0026#34;John Smith\u0026#34;; // Create \u0026#39;emphasized\u0026#39; property  @property() @renderable() emphasized: boolean = false; // Create private _onNameUpdate method  private _onNameUpdate(): string { return \u0026#39;${this.name}\u0026#39;;} // Render the UI  render() { const classes = { \u0026#34;hello-world-emphasized\u0026#34;: this.emphasized }; return ( \u0026lt;div class = \u0026#34;hello-world\u0026#34; join={classes}\u0026gt;{this._onNameUpdate()}\u0026lt;/div\u0026gt; ); } } export = HelloWorld; 関連リンク  Widget development（英語） Hello World（英語） Recenter widget（英語） Accessor class（英語） Guide - Working with properties（英語） Implementing Accessor（英語） Recenter sample（英語） Styling（英語） TypeScript（英語） JSX（英語） バージョン 3.x から 4.x への移行 ArcGIS Maps SDK for JavaScript を利用したウィジェット開発ハンズオン  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/getting-started-widget/",
	"title": "ウィジェット開発のスタート",
	"tags": [],
	"description": "ウィジェット開発に使用しているライブラリから開発に必要な概要までを紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Getting started with widget development\nArcGIS Experience Builder は、React と ArcGIS Maps SDK for JavaScript を使用して構築されています。これにより、特定のワークフローに合わせて、カスタム ウィジェットを作成することができます。独自のウィジェットを作成するには、以下の基本的な理解が必要となります。\n TypeScript は、JavaScript のスーパーセットです。TypeScript は、ウィジェットの開発に使用される言語です。 React は、ユーザーインターフェースを作成するための JavaScript ライブラリです。React は DOM を抽象化したもので、アプリケーションや UI を様々な状態で考え、それらの状態をレンダリングすることで、UI の一貫性を保つことを容易にしています。 JSX は JavaScript の拡張構文で、React を通じてウィジェットの UI のあるべき姿を記述することができます。 Jimu は、Experience Builder がウィジェットを作成する際に使用する JavaScript ライブラリです。  インストール Experience Builder は、インストール用の ZIP ファイルとして提供されています。詳細については、インストールガイドを参照してください。\nウィジェット ウィジェットは、Experience Builder で設定可能で共有可能な機能群です。基本的に、ウィジェットは jimu フレームワークによってこれらの共通のプロパティが設定された React コンポーネントです。\n ウィジェットの設定 (id、label、configなど) state や isClassLoaded などを含むウィジェットのランタイム情報 ローカル言語の文字列 データソースのインスタンスとステータス情報 URL パラメータ情報  必要最小限のファイルですぐに始めるには、your-extensions\\widgets フォルダ内の simple widget を参照してください。\nウィジェット開発の詳細については、ウィジェットの実装について学習してください。\n基本的な考え方 Experience Builder 開発が初めての方で、基本的な考え方を理解したい方は、以下をチェックしてください。\n コア コンセプト コードを見て学ぶのが一番良い場合は、リポジトリからクローンして、サンプルを参照してください。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/android/create-startup-app-android10.2/",
	"title": "スタートアップ ガイド（10.2.x）",
	"tags": [],
	"description": "",
	"content": "開発環境 ArcGIS Runtime SDK for Android は Android Strdio に対応しています。開発環境は Android Studio をご用意ください。\nまたこの後使用するサンプル アプリは ArcGIS Runtime SDK のライブラリを Android Library プロジェクトとして参照する方法を用いています。 ArcGIS Runtime SDK のライブラリをローカル環境にダウンロードしてお使いになりたい方はこちらの The SDK download（英語）手順をご覧ください。\nなお、ArcGIS Runtime SDK を使用するには ArcGIS Online 開発者アカウントが必要です。作成方法は「開発者アカウントの作成」をご参照ください。\nサンプル プロジェクトのダウンロード このリポジトリ（arcgis-dev-resources）には開発を試してみたい方向けのサンプル コードが含まれています。ダウンロードする方法は 2 通りあります。\n  リポジトリをご自身のアカウントに Fork（複製）\n GitHub にログインして、arcgis-dev-resources ページを開いて [Fork] をクリックすると、ご自身のアカウントに同じリポジトリが作成されます。 Fork 後はご自身のローカル マシンにクローンを作成します。    zip ファイルでダウンロード（※GitHub アカウントをお持ちでない方向け）\n  arcgis-dev-resources ページを開いて [Download ZIP] をクリックするとプロジェクト ファイル一式が手に入ります。\n地図の表示 まずはダウンロードしたサンプル プロジェクトを実行してみましょう。\n  ダウンロードしたサンプル プロジェクト（arcgis-dev-resources/startup/android/map）を Android Studio で開きます。\n  MainActivity.java の 30 行目の \u0026lt;Web マップ ID\u0026gt; と記載されている箇所に Web マップの作成で作成した Web マップ ID を上書きします。32 行目の以下のコードでは、上で設定した Web マップ ID を含んだ WebMap の URL を MapView へ受け渡しています。\n  mapView = new MapView(this, webmapUrl, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;); まだ Web マップを作成しておらず、すぐに試してみたい方はサンプル Web マップをご利用ください。\n サンプル プロジェクトを実行すると、以下のように地図が表示されます。  Web マップを表示するには、最初に地図を表示するビュー（MapView クラス）を作成し、作成したビュー上で Web マップを開きます。\n現在位置の表示 Android の位置情報サービスと連携し、端末の現在位置を地図上に表示します。\nでは以下に倣ってソース コードを修正・追加してみてください。\n 現在位置の変化を受け取るための LocationListner を実装します。今回はすでに実装してあるコードを有効化します。 MainActivity.java の 41 行目から 70 行目までのコメント化されたコードをコメント解除してください。（コメント解除したい範囲を選択して Ctrl + / を押下）  // LocationListner を実装  private class MyLocationListener implements LocationListener { public MyLocationListener() { super(); } Point mLocation = null; SpatialReference wm = SpatialReference.create(102100); SpatialReference egs = SpatialReference.create(4326); public void onLocationChanged(Location loc) { if (loc == null) return; // 現在位置を取得する  mLocation = new Point(loc.getLongitude(), loc.getLatitude()); Point point = (Point) GeometryEngine.project(mLocation, egs, wm); // 表示縮尺を設定して現在位置へズーム  mapView.zoomToResolution(point, 20.0); } public void onProviderDisabled(String provider) { } public void onProviderEnabled(String provider) { } public void onStatusChanged(String provider, int status, Bundle extras) { } } この中で現在位置を取得しています。\n onCreate メソッド（38 行目）へ以下のコードを追加します。  // MapView 上に現在位置を表示するために LocationDisplayManager を取得  LocationDisplayManager locationDisplayManager; locationDisplayManager = mapView.getLocationDisplayManager(); // LocationDisplayManager に LocationListner を設定  locationDisplayManager.setLocationListener(new MyLocationListener()); // 現在位置を中央にして地図を表示する設定  locationDisplayManager.setAutoPanMode(LocationDisplayManager.AutoPanMode.LOCATION); // 現在位置の表示を開始  locationDisplayManager.start();  プロジェクトを実行すると、以下のように現在位置を表す青い丸のシンボルが地図上に表示されます。   エミュレータで実行する場合は以下の要領で位置情報を疑似的に有効にします。 2. Android Studio の [Tools] → [Android] → [Android Device Monitor] を選択し、Android Device Monitor を起動します。 2. 左側の Devices タブで該当のエミュレータ名をクリックして選択し、右側の Emulator Control タブをクリックします。 2. 下の方に Location Controls というセクションがあるので、その中の Manual タブを選択します。 2. Longitude（経度）とLatitude（緯度）へ任意の値を入力します。\n アプリの動作が確認できたら ArcGIS の OAuth 認証について学びましょう！\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/dotnet/create-startup-app-dotnet10.2/",
	"title": "スタートアップ ガイド（10.2.x）",
	"tags": [],
	"description": "",
	"content": "﻿## 開発環境\nArcGIS Runtime SDK for .NET を使用した開発には、Visual Studio が必要です。\nまた、この後使用するサンプル アプリは ArcGIS Runtime SDK のライブラリを Nuget パッケージとして参照する方法を用いています。 ArcGIS Runtime SDK のライブラリをローカル環境にダウンロードしてお使いになりたい方は ローカル環境にダウンロードしてお使いになりたい方は ドキュメント ダウンロードのページにあるインストール ガイドをご覧ください。\nなお、ArcGIS Runtime SDK を使用するには ArcGIS Online 開発者アカウントが必要です。作成方法は「開発者アカウントの作成」をご参照ください。\nサンプル プロジェクトのダウンロード このリポジトリ（arcgis-dev-resources）には開発を試してみたい方向けのサンプル コードが含まれています。ダウンロードする際の方法は 2 通りあります。\n リポジトリをご自身のアカウントに Fork（複製）   GitHub にログインして、arcgis-dev-resources ページを開いて [Fork] をクリックすると、ご自身のアカウントに同じリポジトリが作成されます。 Fork 後はご自身のローカル マシンにクローンを作成します。   zip ファイルでダウンロード（※GitHub アカウントをお持ちでない方向け）  arcgis-dev-resources ページを開いて [Download ZIP] をクリックするとプロジェクト ファイル一式が手に入ります。\n既知の制限 既知の問題により、ソリューションを正しくデバッグ実行するには、ソリューションのクローンもしくはダウンロード先のディレクトリパスに日本語などの 2 バイト文字を含めないでください（※ ArcGIS Runtime SDK for .NET を別途ご使用のマシンにインストールする場合は、この制限事項は適用されません）。\n地図の表示 まずはダウンロードしたサンプル プロジェクトを実行してみましょう。\n  ダウンロードしたサンプル プロジェクト（arcgis-dev-resources/startup/dotnet/map/sample.sln）を Visual Studio で開きます。\n  mainWindow.xaml.cs の 54 行目にある以下のコードの \u0026lt;Web マップ ID\u0026gt; と記載されている箇所に Web マップの作成で作成した Web マップ ID を上書きします。\n  var item = await ArcGISPortalItem.CreateAsync(portal, \u0026#34;Web マップ ID\u0026#34;); まだ Web マップを作成しておらず、すぐに試してみたい方はサンプル Web マップをご利用ください。\n サンプル プロジェクトを実行すると、以下のように地図が表示されます。  Web マップを表示するには、ポータル サイトから指定した ID を持つ Web マップを取得し、MapView のマップとして表示します。\n住所検索機能の追加 ArcGIS Online のジオコーディング サービスを利用した住所検索機能を追加します。[検索] ボタンをクリックすることで、テキスト ボックス内の文字列を使用して、住所検索を行うサンプルです。\n  MainWindow.xaml.cs に住所検索機能で使用する以下のメンバー変数を定義します。\n  WORLD_GEOCODE_SERVICE_URL\nArcGIS Online のジオコーディング サービスの URL です。ArcGIS for Developers の開発者はこのクラウド サービスを利用して住所検索を実行することができます。\n  onlineLocatorTask\n住所検索を実行するための OnlineLocatorTask クラスです。\n    //ArcGIS Online ジオコーディングサービスの URL  private const string WORLD_GEOCODE_SERVICE_URL = \u0026#34;http://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer\u0026#34;; //住所検索用のジオコーディング タスク  private OnlineLocatorTask onlineLocatorTask;  コンストラクター内でメンバー変数として定義した OnlineLocatorTask クラスを初期化します。初期化時のパラメーターとして ArcGIS Online のジオコーディング サービスの URL を指定します。OnlineLocatorTask クラスが住所検索のリクエストを発行する際にこの URL が使用されます。  /// \u0026lt;summary\u0026gt;  /// コンストラクタ  /// \u0026lt;/summary\u0026gt;  public MainWindow() { InitializeComponent(); //住所検索用のジオコーディング タスクを初期化  onlineLocatorTask = new OnlineLocatorTask(new Uri(WORLD_GEOCODE_SERVICE_URL)); }  住所検索に使用する検索文字列などを指定する住所検索パラメーターを作成します。パラメーターの作成には OnlineLocatorFindParameters クラスを使用します。  //住所検索用のパラメータを作成  OnlineLocatorFindParameters parameters = new OnlineLocatorFindParameters(addressTextBox.Text) { MaxLocations = 5, OutSpatialReference = SpatialReferences.WebMercator, OutFields = OutFields.All };  OnlineLocatorTask クラスの FindAsync 非同期メソッドを使用して住所検索を実行します。パラメーターとして事前に作成した住所検索パラメーターを指定しています。  //住所の検索  IList\u0026lt;LocatorFindResult\u0026gt; resultCandidates = await onlineLocatorTask.FindAsync(parameters, CancellationToken.None);  住所検索を実行し結果の取得に成功したら、検索結果に対して地図上に表示するなどの何らかの処理を実行します。サンプル アプリケーションでは、ジオコーディング サービスから返された検索結果候補の一番最初の検索結果候補（最も一致していると思われる検索結果）を地図上に拡大表示します。  //常に最初の候補を採用  LocatorFindResult candidate = resultCandidates.FirstOrDefault(); //最初の候補からグラフィックを作成  Graphic locatedPoint = new Graphic() { Geometry = candidate.Feature.Geometry }; //住所検索結果表示用のグラフィックスオーバーレイにグラフィックを追加  geocodeResultGraphicsLayer.Graphics.Add(locatedPoint); //追加したグラフィックの周辺に地図を拡大  await mainMapView.SetViewAsync((MapPoint)locatedPoint.Geometry, 36112);  アプリの動作が確認できたら ArcGIS の OAuth 認証について学びましょう！\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/ios/create-startup-app-ios10.2/",
	"title": "スタートアップ ガイド（10.2.x）",
	"tags": [],
	"description": "",
	"content": "SDK のインストール ArcGIS Runtime SDK for iOS のライブラリをインストールします。\n SDK のダウンロードページ にアクセスします（開発者アカウント でサインインします）。 ArcGIS Runtime SDK for iOS の箇所の [Download] をクリックして、インストーラーをダウンロードします。  ダウンロードしたインストーラー（.pkg ファイル）を実行して SDK をインストールします。  サンプル プロジェクトのダウンロード このリポジトリ（arcgis-dev-resources）には開発を試してみたい方向けのサンプル コードが含まれています。ダウンロードする際の方法は 2 通りあります。\n リポジトリをご自身のアカウントに Fork（複製）   GitHub にログインして、arcgis-dev-resources ページを開いて [Fork] をクリックすると、ご自身のアカウントに同じリポジトリが作成されます。 Fork 後はご自身のローカル マシンにクローンを作成します。   zip ファイルでダウンロード（※GitHub アカウントをお持ちでない方向け）  arcgis-dev-resources ページを開いて [Download ZIP] をクリックするとプロジェクト ファイル一式が手に入ります。\n地図の表示 まずはダウンロードしたサンプル プロジェクトを実行してみましょう。\n  ダウンロードしたサンプル プロジェクト（arcgis-dev-resources/startup/ios/map/sample.xcodeproj）を Xcode で開きます。\n  ViewController.swift の 24 行目にある以下のコードの \u0026lt;Web マップ ID\u0026gt; と記載されている箇所に Web マップの作成 で作成した Web マップ ID を上書きします。\nwebmap = AGSWebMap(itemId: \u0026#34;\u0026lt;Web マップ ID\u0026gt;\u0026#34;, credential: nil)   まだ Web マップを作成しておらず、すぐに試してみたい方はサンプル Web マップをご利用ください。\n サンプル プロジェクトを実行すると、以下のように地図が表示されます。 Web マップを表示するには、最初に地図を表示するビュー（AGSMapView クラス）を作成し、作成したビュー上で Web マップを開きます。  現在位置の表示 iOS の位置情報サービスと連携し、端末の現在位置を地図上に表示します。   地図の読み込みが完了したイベントをハンドリングするために、デリゲート プロトコル(AGSMapViewLayerDelegate) を宣言します。ViewController.swift の 13 行目を以下のコードに置き換えます。\n// デリゲート プロトコルの宣言 class ViewController: UIViewController, AGSMapViewLayerDelegate {   地図の読み込みのデリゲートを自身に設定します。viewDidLoad() 関数の最後に以下のコードを追加します。\n// AGSMapView のデリゲートを自身に設定 mapView.layerDelegate = self   地図の読み込み完了時に実行されるデリゲート メソッド内に現在位置を表示する処理を記述します。ViewController.swift に以下のコードを記述します。\n// AGSMapView のデリゲート メソッド（地図の読み込み完了時に実行）  func mapViewDidLoad(_ mapView: AGSMapView!) { // 位置情報の表示モードを設定  mapView.locationDisplay.autoPanMode = .default // 地図が現在位置にズームされる際の表示縮尺の設定  mapView.locationDisplay.zoomScale = 100000 // 現在位置の表示を開始  mapView.locationDisplay.startDataSource() }   プロジェクトを実行すると、以下のように現在位置を表す青い丸のシンボルが地図上に表示されます。 位置情報の表示モードについてはナビゲーションに便利な位置情報の表示モードをご覧ください。   シミュレータで実行する場合は、iOS シミュレータの [Debug] → [Location] メニューで設定することで、端末の位置情報を擬似表現できます。\nアプリが起動すると「マップ上での現在位置確認に位置情報サービスを使用します。」と位置情報サービスの使用を確認するメッセージが表示されます。このメッセージはサンプル プロジェクトの Info.plist ファイルの NSLocationWhenInUseUsageDescription プロパティで設定できます。\n アプリの動作が確認できたら ArcGIS の OAuth 認証について学びましょう！\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/security/",
	"title": "セキュリティと認証",
	"tags": [],
	"description": "有償のサービスやプライベート コンテンツへアクセスするアプリに必要な認証について紹介します。",
	"content": "出典：ArcGIS Developers - Security and authentication - Introduction\nセキュリティと認証 ArcGIS は、ロケーション サービスやプライベート データへの安全なアクセスをサポートしています。これにより、有効かつ認証されたユーザーやサービスのみが保護された情報にアクセスできるようになります。安全なリソースにアクセスするためには、アプリケーションがサービスに対して認証されたリクエストを行えるように、認証方法を実装する必要があります。\nはじめに 以下の手順で認証を開始できます。\n  ArcGIS 開発者アカウントをお持ちでない場合は、新規作成してください。\n  利用可能な認証方法と認証方法の選択を確認します。\n  開発者用ダッシュボードにサインインし、認証情報を作成します。\n  認証チュートリアルにアクセスして、アプリの構築を始めましょう。\n  ArcGIS Enterprise アカウントを使用して認証する場合、ArcGIS identity、アプリケーション認証情報、その他の ArcGIS identity 認証方法を使用できます。ただし、API キーは ArcGIS Enterprise ではサポートされていません。\n\r認証方法 認証方法とは、アクセストークンを取得するためのプロセスです。アプリケーションがロケーション サービスに認証済みのリクエストを行う際には、アクセストークンを提示する必要があります。アクセストークンは、アプリケーションが利用できる範囲と権限を定義します。アクセストークンの取得に使用する認証方法はいくつかあります。\nアクセストークンには以下の 3 種類あります。\n API キー：すぐに使えるサービスや、ArcGIS Developer アカウントがあればプライベート（ベータ）なコンテンツへのアクセスをアプリケーションに与える永続的なトークンです。 ArcGIS Identity (指定ユーザー ログイン)：既存の ArcGIS ユーザのアカウントに認可されたプライベート コンテンツおよびサービスへのアクセスをアプリケーションに与える一時的なトークンです。 アプリケーション認証： OAuth 2.0 で生成された一時的なトークンで、すぐに使えるサービスへのアクセスを認証することができます。  サービスに対して認証のリクエストを行うには、token パラメーターにアクセストークンを設定する必要があります。\nhttps://\u0026lt;LOCATION-SERVICE-URL\u0026gt;?token=\u0026lt;ACCESS-TOKEN\u0026gt;\n各サービスへのURLリクエストのフォーマットについては、ロケーション サービスを参照してください。\n\rAPI キー API キーは永続的なアクセストークンであり、公開アプリケーションにすぐに使用できるサービスへのアクセスを付与します。また、ArcGIS Developer アカウントを使用すると、プライベート(ベータ)なコンテンツ、アイテム、および限定されたクライアント リファラーへのアクセスが可能になります。\n次のような場合に API キーを使用します。\n すぐに使えるサービスを利用するアプリケーションを素早く作成する場合。 ユーザーが ArcGIS アカウントでサインインしなくてもサービスへのアクセスを提供する場合。 アクセストークンは有効期限のないものを使用する場合。    開発者ダッシュボードで API キーを構成します。 API キーは、ArcGIS 開発者アカウントにサインアップしたときに作成されます。\n  選択したクライアント API に従って API キーを設定し、ArcGIS との認証を行います。\n  API キーの詳細についてはこちらをご参照ください。\nArcGIS Identity (指定ユーザー ログイン) ArcGIS Identity (指定ユーザー ログインとも呼ばれる) は、一時的なアクセストークンであり、アプリケーション ユーザーの既存の ArcGIS Online または ArcGIS Enterprise アカウントで許可されたコンテンツおよびサービスへのアクセスをアプリケーションに与えるものです。この一時的なトークンは OAuth 2.0 プロトコルを使用して作成され、ユーザーのセキュアなパスワードをアプリケーションに公開することなく、ユーザーの代わりにアプリケーションを動作することを許可します。消費されたサービス クレジットは、認証されたユーザーの ArcGIS サブスクリプションに請求され、認証された期間中は、ユーザーに代わってアプリケーションがユーザーのプライベート コンテンツにアクセスすることが許可されます。\n次のような場合に ArcGIS Identity (指定ユーザーログイン) を使用します。\n ユーザーが自分の ArcGIS アカウントでサインインし、認証されていることを確認する場合。 アプリユーザーのクレジットを使用して、プライベートなデータ、コンテンツ、サービスの取引の支払いを行う場合。 ユーザーが一時的なトークンを使ってアプリにサインインできる時間を制限する場合。    開発者用ダッシュボードでアプリケーションを登録し、クライアント認証情報を取得します。\n  OAuth 2.0 認証のワークフローを実装します。\n  ユーザーがアプリケーションを認証すると、認可コードが返されます。\n  認証コードは、短命のアクセストークンと交換されます。\n  アクセストークンは、ArcGIS のコンテンツやサービスにアクセスするために使用されます。\n  ArcGIS Identity の詳細についてはこちらをご参照ください。\nアプリケーション認証 アプリケーション認証は、OAuth 2.0 によって取得される一時的なアクセストークンで、ベースマップレイヤー、検索、ルート解析など、すぐに使えるサービスへのアクセスを可能にします。\n次のような場合にアプリケーション認証を使用します。\n  すぐに使えるサービスにアクセスしたいが、一時的なトークンを使ってより安全なプロセスを実現したい場合。\n  ユーザーが ArcGIS アカウントを持っていなくても、サービスにアクセスできるようにする場合。\n    開発者用ダッシュボードで OAuth 2.0 アプリケーションを登録し、認証情報を受け取ります。\n  ユーザーが Web サーバー上のリソースをリクエストします。\n  OAuth 2.0 クライアント認証情報のワークフローを実装し、アプリケーション認証情報を生成します。\n  アプリケーション認証を用いてユーザーのリクエストに応答します。\n  アプリケーション認証を使用して、特定のクライアント API に従って ArcGIS で認証します。\n  アプリケーション認証の詳細についてはこちらをご参照ください。\n認証方法の選択 一連の状況に最適な認証を選択するには、多くの考慮事項があります。以下のことを考慮してください。\n  アクセストークンを作成するために使用するアカウントの種類：ArcGIS Developer、ArcGIS Online、または ArcGIS Enterprise。\n  APIを選択することができます。\n  要求されるセキュリティのレベル：短命なトークンか永続的なトークンか。\n  ユーザーがログインしてアクセスを許可する、または無言でログインするための要件。\n  セキュリティのアクセスが行われる場所：クライアントサイド、Web ベースのアプリ、またはサーバーサイド。\n     シナリオ 認証方法     すぐに使えるサービスへのアクセスのみを必要とするアプリケーションを構築しており、ユーザーにはログインしてほしくない場合 API キー、またはアプリケーション認証   サーバーや API バックエンドでアプリケーションを構築し、すぐに利用できるサービスにのみアクセスする必要がある場合 API キー、またはアプリケーション認証   ArcGIS Developer アカウントでホストされているプライベート データを読み込むアプリケーションを構築している場合 API キー、またはアプリケーション認証   ArcGIS Online アカウントのプライベート ホスト データを使用するアプリケーションを構築している場合 ArcGIS Identity (指定ユーザー ログイン)   オープン ソース API を使用してアプリケーションを構築している場合、または ArcGIS REST API を直接使用している場合 API キー   ArcGIS API を使用するアプリケーションを構築している場合 API キー、またはアプリケーション認証、ArcGIS Identity (指定ユーザー ログイン)    以下の対応表を参考に、検討中の機能と API を照らし合わせてください。\n機能の比較     　API キー　 　ArcGIS Identity (指定ユーザー ログイン)　 　アプリケーション認証　     永続的なトークン 〇 × ×   一時的なトークン × 〇 〇   サーバーレス認証 〇 〇 ×   サーバーベース認証 〇 × 〇   特定のサービスへの制限 〇 × ×   特定のリファラーに制限 〇 × ×   すぐに使えるサービス 〇 〇 〇   プライベート データのホスティング サービス △1 〇 ×   コンテンツ管理 △2 〇 ×    〇：対応　△：一部対応 ×：未対応\n1. ArcGIS Developer サブスクリプションのみ 2. ArcGIS Developer サブスクリプションのみ、制限付き\nAPI のサポート     API キー アプリケーション認証 ArcGIS Identity (指定ユーザー ログイン)     ArcGIS Maps SDK for JavaScript 〇 △1 〇   ArcGIS Runtime API for Android 〇 〇 〇   ArcGIS Runtime API for iOS 〇 〇 〇   ArcGIS Runtime API for Java* 〇 〇 〇   ArcGIS Runtime API for .NET 〇 〇 〇   ArcGIS Runtime API for Qt* 〇 〇 〇   ArcGIS API for Python 〇 〇 〇   Esri Leaflet* 〇 △1 △2   MapBox GL JS* 〇 △1 △2   OpenLayers* 〇 △1 △2   ArcGIS REST JS* 〇 〇 〇    〇：対応　△：一部対応 (詳細は各 API のページを参照)　*国内未サポート\n1. トークンやユーザーセッションにアクセスし管理するために、サーバーコンポーネントを使用する必要があります。 2. OAuth 2.0 から取得したトークンの利用をサポートするが、高度な ID 管理機能はない。\nArcGIS 以外の API で ArcGIS Identity (指定ユーザー ログイン) を使用することは可能ですが、アプリケーションの一部としてユーザーび資格情報を取得、管理、および保護する責任が生じます。このオプションを選択する場合は、セキュリティのベスト プラクティスでガイドラインを確認してください。\n\rチュートリアル  Create and manage an API key Authenticate with an ArcGIS identity  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/visualization/data-visualization-procedure-3d/",
	"title": "データ可視化の手順（3D）",
	"tags": [],
	"description": "",
	"content": "ArcGIS Online が提供するシーン ビューアーを使用して、3D マップにデータを可視化する方法を紹介します。\n [3D マップを作成したい](#3D マップを作成したい) シンボルを変更したい 高さを表現したい  3D マップを作成したい シーン ビューアー → [新しいシーン] → [レイヤーの追加] → [シーンの保存]\nArcGIS Online などに公開されている Web サービスを、レイヤーとしてマップに追加し、様々なレイヤーを組み合わせて 3D マップを作成することができます。3D マップの保存には、コンテンツを作成する権限が必要です（権限を持っていない場合でも 3D マップは作成できますが、保存することはできません）。\n  シーン ビューアーを開きます。シーン ビューアーを開いた時点でベースとなる背景地図(ベースマップ)は自動的に表示されます。\n  [レイヤーの追加] をクリックします。\n  [レイヤーの検索]、[レイヤー URL の入力] いずれかのレイヤーの追加方法を選択します。\n  それぞれのレイヤー追加方法は、以下の通りです。\nレイヤーの検索   [レイヤーの検索] ボックスにキーワードを入力し、[検索] をクリックします。\n  検索結果は下部のボックス内に表示され、[追加] をクリックします。\n  [完了] をクリックし、レイヤーの追加を終了します。\n  レイヤー URL の入力 URL を指定して、ArcGIS Server Web サービスのレイヤーを追加することができます。\nシンボルを変更したい シーン ビューアー → [レイヤー] → [レイヤーの構成] → [スタイル]\nシンボルの色や形を変更します。コンテンツを作成する権限を持っている場合に可能です。\nシンボルを変更できるのは、フィーチャ レイヤーまたはシーン レイヤーです。\n  シーン ビューアーの [レイヤー] が表示されていることを確認し、シンボルを変更したいレイヤーをクリックします。\n  [レイヤーの構成] が表示されます。レイヤーの種類により、設定できるシンボルが異なります。\n  フィーチャ レイヤー（ポイント）のシンボル設定  [①表示するメイン属性を選択] ドロップダウン リストから、シンボルの設定を行う属性フィールドを選択します。\n属性値でシンボル設定をしない場合は、[\u0026lt;なし\u0026gt;] を選択します。\n  [②描画スタイルを選択] で、変更したい描画方法の [選択] をクリックします。既に選択されている描画スタイルは [オプション] と表示されます。\n  2D マーカー / 3D オブジェクト すべてのフィーチャを同じシンボルで表現します。\n2D タイプ / 3D タイプ 樹木の種類、道路クラス、都道府県名など、属性のカテゴリごとにシンボルを割り当てて描画します。\n2D 数と量/ 3D 数と量 数値データをシンボルの色や大きさ、高さで表現します。データの数値が大きいほど、シンボルは大きく、高く表示されます。 ※レイヤーが持つ属性フィールドのタイプに応じて選択できる種類が異なります。例えば、文字列型のフィールドのみで構成されるレイヤーでは、[種類] ドロップダウン リストでサイズや色の指定はできません。\nフィーチャ レイヤー（ライン/ポリゴン）のシンボル設定  [シンボル] ドロップダウン リストから [シンボルの変更] を選択します。\n  シンボルのタイプ（2D または 3D）、大きさ/高さ、色を設定します。\n  シーン レイヤーのシンボル設定  [①表示するメイン属性を選択] ドロップダウン リストから、シンボルの設定を行う属性フィールドを選択します。\n属性値でシンボル設定をしない場合は、[\u0026lt;なし\u0026gt;] を選択します。\n  [②描画スタイルを選択] で、変更したい描画方法の [選択] をクリックします。既に選択されている描画スタイルは [オプション] と表示されます。\n  色 すべてのフィーチャを同じシンボルで表現します。\nタイプ 樹木の種類、道路クラス、都道府県名など、属性のカテゴリごとにシンボルを割り当てて描画します。\n数と量 数値データをシンボルの色で表現します。 ※レイヤーが持つ属性フィールドのタイプに応じて選択できる種類が異なります。例えば、文字列型のフィールドのみで構成されるレイヤーでは、[種類] ドロップダウン リストでサイズや色の指定はできません。\n[オプション] をクリックすると、シンボルの詳細な設定をすることができます。  2D マーカー / 3D オブジェクトの場合 [シンボル] - あらかじめ用意されているシンボルから形状を選択します。\n[色] - シンボルの色を選択します。\n[サイズ] - 大きさを設定します。固定値のほかに属性値をもとに大きさを指定することもできます。\n[回転] - 属性値をもとに回転の角度を設定します。\n2D タイプ / 3D タイプの場合 表からスタイルを変更したい値を選択し、[シンボル]、[色]、[サイズ] を設定します。\n属性値をもとに、すべてのシンボルのサイズと回転を指定することも可能です。\n2D 数と量/ 3D 数と量 [スライダー] - スライダーの上部、下部のバーを動かして、最大 / 最小クラスの閾値を変更できます。また、数値をクリックして、直接入力することもできます。\n[シンボル] - あらかじめ用意されているシンボルから形状を選択します。\n[色] - 色のパターンなどを変更します。\n[サイズ] - 最大 / 最小クラスに設定した値の大きさを設定します。\n[回転] - 属性値をもとに回転の角度を設定します。\n色の場合 [テクスチャ] - テクスチャのタイプを選択します。\n[色] - シンボルの色を選択します。\nタイプの場合 表からスタイルを変更したい値を選択し、[テクスチャ]、[色] を設定します。\n数と量の場合 [スライダー] - スライダーの上部、下部のバーを動かして、最大 / 最小クラスの閾値を変更できます。また、数値をクリックして、直接入力することもできます。\n[色] - 色のパターンなどを変更します。 6. 設定後、各パネルにおいて [完了] をクリックします。\n高さを表現したい シーン ビューアー → [レイヤー] → [レイヤーの構成] → [標高モード] レイヤーに含まれる Z 値や、オフセットを定義して、グラフィックの高さを表現することができます。\n  シーン ビューアーの [レイヤー] が表示されていることを確認し、高さを表現したいレイヤーをクリックします。\n  [レイヤーの構成] が表示されます。\n  [標高モード] でモードを選択し、必要に応じてオフセットを設定します。\n  標高モード 地表 グラフィックは、地表を覆うように配置されます。\nグラフィックに含まれる Z 値は無視されます。また、オフセットを設定することはできません。\n地面を基準 グラフィックは、地面を基準にした高さに配置されます。\nグラフィックに Z 値が含まれる場合、Z 値を使用して高さは表現されます。\nシーンを基準 グラフィックは、シーンを基準にした高さに配置されます。\nグラフィックに含まれる Z 値は無視されます。\n絶対高度 グラフィックは、測地系を基準にした高さに配置されます。\n絶対高度は、各グラフィックの Z 値により決まります。[地面を基準] と似ていますが、[絶対高度] は地表の高さを無視します。\n※レイヤーの種類により、選択できるモードが異なります。例えば、シーン レイヤーでは、[絶対高度] 以外のモードは指定はできません。\nオフセット オフセットは、すべてのグラフィックに高さを加えます。例えば、オフセットに 100 メートルを設定した場合、グラフィックは現在の高さから 100 メートル上に表示されます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/screen/",
	"title": "画面グループ（Screen groups）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Screen groups\n画面グループ（Screen groups） 画面グループは、複数の画面を持つレイアウトコンテナで、スクロールするページのコンテンツやウィジェットを整理するためのものです。各画面はメインステージを持ち、画面グループのテンプレートによってはスクロールパネルを持つこともできます。画面グループにスクロールすると、画面の高さ全体を占めます。画面グループにスクロールパネルがある場合、エンドユーザーがパネル内のコンテンツをスクロールしても、メインステージはその場に留まり、最後のパネルがスクロールしたときにのみ切り替わります。画面グループにパネルがない場合は、メインステージは画面の高さいっぱいにスクロールするまで固定されます。\napp config では、画面グループは screenGroups で定義され、画面は screens で定義されます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/create-app/create-startup-app-dotnet/",
	"title": ".NET",
	"tags": [],
	"description": "ArcGIS Maps SDK for .NET を用いたネイティブ地図アプリの作成方法を紹介します。",
	"content": "マップを表示する このチュートリアルでは ArcGIS Maps SDK for .NET を使用して、マップとベースマップ レイヤーを表示する方法を紹介します。\nマップには、地理データのレイヤーが含まれています。マップには、ベースマップ レイヤーと、オプションで 1 つ以上のデータ レイヤーを追加できます。マップ ビューを使用し、場所とズーム レベルを設定することで、マップの特定の領域を表示できます。\nこのチュートリアルでは、地形 (ベクトル) ベースマップ レイヤーを使用して、富士山付近を表示する地図を作成します。\n前提条件 このチュートリアルを実施するには、以下が必要です。\n API キーにアクセスするための ArcGIS 開発者アカウント。アカウントをお持ちでない場合は、サインアップ (無料) してください。アカウントの作成方法は「開発者アカウントの作成」をご覧ください。 開発環境がシステム要件を満たしていることを確認します。  必要に応じて、ArcGIS Maps SDK for .NET をインストールして、Visual Studio プロジェクト テンプレート (Windows のみ) とオフラインにコピーされた NuGet パッケージを利用することもできます。\nステップ 新しい Visual Studio プロジェクトを作成する ArcGIS Maps SDK for .NET は、Windows Presentation Framework (WPF)、Universal Windows Platform (UWP)、Windows UI Library (WinUI)、.NET MAUI 向けのアプリをサポートしています。 このチュートリアルの説明は、Visual Studio for Windows を使用して .NET Core WPF プロジェクトを作成することを目的としています。\n Visual Studio を起動し、新しいプロジェクトを作成します。  Visual Studio の開始画面で、[新しいプロジェクトの作成] をクリックします C# 用の「WPF アプリケーション」テンプレートを選択し、[次へ] をクリックします。 [新しいプロジェクトを構成します] 画面で必要な値を入力します。  プロジェクト名: DisplayAMap 場所: 任意のフォルダーを選択   [作成] をクリックしてプロジェクトを作成します。    API の参照を追加する  NuGet パッケージをインストールして、API への参照を追加します。  ソリューション エクスプローラーで、[依存関係] を右クリックし、[NuGet パッケージの管理] を選択します。 [NuGet パッケージ マネージャー] ウィンドウで、[パッケージ ソース] に「nuget.org」が選択されていることを確認します。 [参照] タブを選択して、[検索] テキスト ボックスに「ArcGISRuntime」と入力します。 検索結果から、プラットフォームに適したパッケージを選択します。このチュートリアルでは「Esri.ArcGISRuntime.WPF」NuGet パッケージを選択します。 [バージョン] にパッケージの「最新の安定版\u0026hellip;」が選択されていることを確認します。 [インストール] をクリックします。 NuGet は、パッケージの依存関係または競合を自動的に解決します。デフォルトでは、[変更のプレビュー] ダイアログが表示されます。 変更を確認し [OK] をクリックしてパッケージのインストールを続行します。 [ライセンスへの同意] ダイアログでライセンス条項を確認し、[同意する] をクリックしてパッケージをプロジェクトに追加します。 Visual Studio の [出力] ウィンドウで、パッケージが正常にインストールされたことを確認します。 [NuGet パッケージ マネージャー] ウィンドウを閉じます。    ArcGIS Maps SDK for .NET プロジェクト テンプレートからプロジェクトを作成した場合は、必要な NuGet パッケージがプロジェクトに追加されています。\nAPI キーを取得する ArcGIS Online でホストされているサービス、Web マップ、および Web シーンにアクセスするには API キーが必要です。 まだ取得していない場合は、ArcGIS Developers のダッシュボードに移動してAPIキーを取得します。\nアプリで API キーを設定する   App.xaml.cs の OnStartup メソッドをオーバーライドして、アプリケーションの起動時に API キーを設定します。\nApp.xaml.cs\npublic partial class App : Application { // 追加開始  protected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); // 注: API キーをソース コードに保存することはベスト プラクティスではありません。  // API キーは、チュートリアルの便宜上、ここで参照されています。  Esri.ArcGISRuntime.ArcGISRuntimeEnvironment.ApiKey = \u0026#34;API キー\u0026#34;; } // 追加終了 }   アプリ ロジックを保存するビュー モデルを作成する このアプリは、以降のすべてのチュートリアルで使用する基盤を構築するためのものです。堅固な設計で構築することをお勧めします。\nModel-View-ViewModel (MVVM) デザイン パターンは、ユーザー インターフェイス要素 (および関連するコード) をアプリの基礎となるロジックから分離するアーキテクチャを提供します。このパターンでは、「モデル」はアプリで消費されるデータを表し、「ビュー」はユーザー インターフェースであり、「ビューモデル」にはモデルとビューをバインド (結合) するロジックが含まれます。このようなパターンに必要な追加のフレームワークは、小規模なプロジェクトでは大変な作業に思えるかもしれませんが、プロジェクトの複雑さが増すにつれて、堅固な設計を行うことでコードの保守性と柔軟性が大幅に向上します。\nMVVM で設計された ArcGIS アプリでは、通常、マップ ビューがメインのビュー コンポーネントになります。クラスの多くは、モデルの役割を果たします (データをマップ、レイヤー、グラフィックス、フィーチャなどとして表します)。 ビュー モデル コンポーネントには、ArcGIS オブジェクトを操作するためのロジックを追加したり、ビューに表示するためのデータを提供したりするため、記述するコードの多くはここになります。\nすべての ArcGIS Maps SDK for .NET プロジェクト テンプレートは、MVVM デザインパターンを使用しています。\n  プロジェクトのビュー モデルを定義する新しいクラスを追加します。\n [プロジェクト] メニュー \u0026gt; [クラスの追加\u0026hellip;] をクリックします。 新しいクラスに名前を付けます。  名前: MapViewModel.cs   [追加] をクリックして新しいクラスを作成し、プロジェクトに追加します。 新しいクラスが VisualStudio で開きます。    必要な using ステートメントをビュー モデルに追加します。\nMapViewModel.cs\nusing System; using System.Collections.Generic; using System.Text; // 追加開始 using Esri.ArcGISRuntime.Geometry; using Esri.ArcGISRuntime.Mapping; using System.ComponentModel; using System.Runtime.CompilerServices; // 追加終了   MapViewModel クラスに INotifyPropertyChanged インターフェイスを実装します。\nこのインターフェイスは、ビュー モデルのプロパティが変更されたことをクライアント (ビュー) に通知するために使用される PropertyChanged イベントを定義します。\nMapViewModel.cs\nnamespace DisplayAMap { // 変更前  // class MapViewModel  // 変更後  class MapViewModel : INotifyPropertyChanged { } }   MapViewModel クラス内に、PropertyChanged イベントを実装するコードを追加します。 ビュー モデルのプロパティが変更されると、OnPropertyChanged の呼び出しにより、このイベントが発生します。\nMapViewModel.cs\nclass MapViewModel : INotifyPropertyChanged { // 追加開始  public event PropertyChangedEventHandler PropertyChanged; protected void OnPropertyChanged([CallerMemberName] string propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } // 追加終了 }   ビュー モデルに Esri.ArcGISRuntime.Mapping.Map オブジェクトを公開する Map という新しいプロパティを定義します。 プロパティが設定されると、OnPropertyChanged を呼び出します。\nMapViewModel.cs\npublic event PropertyChangedEventHandler PropertyChanged; protected void OnPropertyChanged([CallerMemberName] string propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } // 追加開始  private Map _map; public Map Map { get { return _map; } set { _map = value; OnPropertyChanged(); } } // 追加終了 }   MapViewModel クラスに SetupMap という関数を追加します。この関数は、新しいマップを作成して Map プロパティを設定します。 マップは、「地形 (ベクトル)」ベースマップを使用します。\nMapViewModel.cs\nprivate Map _map; public Map Map { get { return _map; } set { _map = value; OnPropertyChanged(); } } // 追加開始  private void SetupMap() { //「地形 (ベクトル)」ベースマップを使用して新しいマップを作成します。  Map = new Map(BasemapStyle.ArcGISTopographic); } // 追加終了 }   MapViewModel が新規にインスタンス化された際に、SetupMap 関数を呼び出すコンストラクターを追加します。 MapViewModel newMapVM = new MapViewModel(); のようなコードを書くと、クラス コンストラクターが実行されます。\nMapViewModel.cs\nclass MapViewModel : INotifyPropertyChanged { // 追加開始  public MapViewModel() { SetupMap(); } // 追加終了  public event PropertyChangedEventHandler PropertyChanged; protected void OnPropertyChanged([CallerMemberName] string propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); }   これで MapViewModel が完成しました。\nMVVM デザイン パターンを使用する利点は、ビュー モデルのコードを再利用できることです。API はプラットフォーム間でほぼ標準的な API サーフェスを持っているため、１つのアプリ用に作成したビュー モデルのコードは、通常、サポートされているすべての .NET プラットフォームで動作します。\n次に、プロジェクトにビューを設定して、ビュー モデルを使用します。\nマップ ビューを追加する MapView コントロールは、マップを表示するために使用します。 マップ ビューをプロジェクトの UI に追加し、MapViewModel で定義したマップを使用するように設定します。\n  必要な XML 名前空間とリソースを追加します。\n MainWindow.xaml を開き、XAML ビューに切り替えます。 既存の名前空間の宣言内に、ArcGIS コントロールの esri XML 名前空間を追加します。 MapViewModel インスタンスを静的リソースとして定義する XAML を追加します。  MainWindow.xaml\n\u0026lt;Window x:Class=\u0026#34;DisplayAMap.MainWindow\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:d=\u0026#34;http://schemas.microsoft.com/expression/blend/2008\u0026#34; xmlns:mc=\u0026#34;http://schemas.openxmlformats.org/markup-compatibility/2006\u0026#34; xmlns:local=\u0026#34;clr-namespace:DisplayAMap\u0026#34; \u0026lt;!--追加開始--\u0026gt; xmlns:esri=\u0026#34;http://schemas.esri.com/arcgis/runtime/2013\u0026#34; \u0026lt;!--追加終了--\u0026gt; mc:Ignorable=\u0026#34;d\u0026#34; Title=\u0026#34;MainWindow\u0026#34; Height=\u0026#34;450\u0026#34; Width=\u0026#34;800\u0026#34;\u0026gt; \u0026lt;!--追加開始--\u0026gt; \u0026lt;Window.Resources\u0026gt; \u0026lt;local:MapViewModel x:Key=\u0026#34;MapViewModel\u0026#34; /\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;!--追加終了--\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;/Grid\u0026gt;   MapView コントロールを MainWindow.xaml に追加し、MapViewModel にバインドします。\n 「MainMapView」という名前の MapView コントロールを定義する XAML を追加します。 データ バインディングを使用して、MapViewModel リソースを使用し MapView コントロールの Map プロパティを設定します。  MainWindow.xaml\n\u0026lt;Window.Resources\u0026gt; \u0026lt;local:MapViewModel x:Key=\u0026#34;MapViewModel\u0026#34; /\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;!--追加開始--\u0026gt; \u0026lt;esri:MapView x:Name=\u0026#34;MainMapView\u0026#34; Map=\u0026#34;{Binding Map, Source={StaticResource MapViewModel}}\u0026#34; /\u0026gt; \u0026lt;!--追加終了--\u0026gt; \u0026lt;/Grid\u0026gt;   マップ ビューの視点を設定する ウィンドウの読み込み時にマップ ビューの視点 (ビュー ポイント) を設定します。富士山を中心にマップを表示するための、位置と縮尺を定義します。\n  MainWindow.xaml.cs を開きます。\n  必要な using ステートメントを追加します。\nMainWindow.xaml.cs\nusing System.Windows.Navigation; using System.Windows.Shapes; // 追加開始 using Esri.ArcGISRuntime.Geometry; using Esri.ArcGISRuntime.Mapping; // 追加終了  namespace DisplayAMap {   MainWindow のコンストラクターで、新しい Viewpoint を定義するコードを追加し、マップ ビューに適用します。\nMainWindow.xaml.cs\npublic MainWindow() { InitializeComponent(); // 追加開始  // マップの中心位置として設定する MapPoint を作成  MapPoint mapCenterPoint = new MapPoint(138.727363, 35.360626, SpatialReferences.Wgs84); // マップの視点を決める Viewpoint を設定  MainMapView.SetViewpoint(new Viewpoint(mapCenterPoint, 200000.0)); // 追加終了 }   アプリを実行する [デバッグ] メニュー \u0026gt; [デバッグの開始] をクリックして (またはキーボードの [F5] キーを押して) アプリを実行します。\n注:「The 'Esri.ArcGISRuntime.WPF' nuget package cannot be used to target 'net6.0-windows'. Target 'net6.0-windows10.0.19041.0' or later instead.」のエラーが出ている場合は、Visual Studio の [プロジェクト] \u0026gt; [DisplayAMap のプロパティ] \u0026gt; [アプリケーション] \u0026gt; [全般] \u0026gt; [ターゲット OS バージョン] を 10.0.19041.0 に設定します。\r 富士山を中心に、「地形 (ベクトル)」ベースマップ レイヤーが追加されたマップが表示されます。マップ ビュー上でマウス ホイールをダブルクリック、ドラッグ、およびスクロールして、マップを操作します。\n完成版のプロジェクトはこちらからダウンロードできます (マップの表示場所は本チュートリアルで設定した場所とは異なります)。\nWeb マップを表示する 「Web マップの作成」のガイドで Web マップを作成している場合は、作成した Web マップも基本的に同じステップで表示できます。\n  Visual Studio で、マップを表示するのステップで作成したプロジェクトの MapViewModel.cs を開きます。\n  必要な using ステートメントを追加します。\nMapViewModel.cs\nusing Esri.ArcGISRuntime.Portal; using System.Threading.Tasks;   MapViewModel.cs 内の SetupMap 関数を下記のように書き換えます。\nMapViewModel.cs\nprivate async Task SetupMap() { // ArcGIS ポータルを作成します。URI を指定しない場合は \u0026#34;www.arcgis.com\u0026#34; を使用します。  ArcGISPortal portal = await ArcGISPortal.CreateAsync(); // アイテム ID を使用して、Web マップをポータル アイテムとして取得します。  PortalItem mapItem = await PortalItem.CreateAsync(portal, \u0026#34;41281c51f9de45edaf1c8ed44bb10e30\u0026#34;); // ポータル アイテムからマップを作成します。  Map map = new Map(mapItem); // マップを表示するには、マップ ビューにバインドされている MapViewModel.Map プロパティを設定します。  this.Map = map; }    アプリの動作が確認できたら ArcGIS の セキュリティと認証について学びましょう！\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/arcade/",
	"title": "Arcade",
	"tags": [],
	"description": "ArcGIS プラットフォーム標準で利用できる条件式のためのスクリプト言語 Arcade について紹介します。",
	"content": "出典：ArcGIS Maps SDK for JavaScript - Arcade\nArcade とは ArcGIS プラットフォームで使用するために作られた軽量でセキュアな条件式のためのスクリプト言語です。 他の一般的な式言語のように、数学的な計算や評価ロジックの命令語を利用できます。 ArcGIS プラットフォームにおける独自のデータ可視化とラベル表現の作成のためにデザインされており、独自の命令語を ArcGIS Pro や ArcGIS Online、ArcGIS Runtime SDK、ArcGIS Maps SDK for JavaScript で編集・共有・実行することができます。\nArcade が他のスクリプト言語に比べてユニークなのは、ジオメトリ関数を含んでいるところです。 ジオメトリ関数は、面積や長さの計算、トポロジ リレーションシップのテスト、そしてシンプルなオーバーレイの実行を可能にします。 現在のリリースでは、ジオメトリの作成と参照が可能です。 しかし、Arcade バージョン 1.3 で導入されたジオメトリの操作は、4.x 系の ArcGIS Maps SDK for JavaScript ではサポートされていません。\nArcade バージョン 1.3 で導入されたジオメトリ関数は、4.x 系の ArcGIS Maps SDK for JavaScript ではサポートされていません。3.x 系の API では、バージョン 3.23 以上で使用できます。将来的には、4.x でのサポートを予定しています。\nシンタックス Arcade のシンタックスは JavaScript ライクに変数の宣言やロジックの実行、関数の記述などができます。 しかし、二つの言語間にはいくつか異なる部分があります。 記述方法の詳細については、Arcade ドキュメント（英語）をご参照ください。 また、ArcGIS Arcade Playground では独自のスクリプトをテスト実行するための環境を提供していますので、アクセスしてみてください。\nArcade には外部データにアクセスするためのグローバル変数が用意されています。 $feature というグローバル変数は、フィーチャ レイヤー内のフィーチャが持つフィールド値にアクセスするために使用します。 以下のシンタックスを使用することでフィールド値を参照できます。\n$feature.fieldName このように、ランタイムでフィールド値を使用したシンプルな計算を容易に実行できます。\n// 民主党候補者に投票した人の割合（%）を計算 ($feature.DEM_VOTES / $feature.TURNOUT ) * 100 Arcade はコンテクスト内、または Arcade が理解されるプロファイル内でのみ実行可能です。JavaScript アプリでは、式は常に文字列の値として参照されます。Arcade は、シンプルな一行の式、または、より複雑な複数行からなる式として書かれます。\n一行の式を書くとき、シンプルにダブルまたはシングル クォーテーションで囲みます。\nrenderer.valueExpression = \u0026#34;Round( ($feature.AGE_18UP / $feature.TOTAL_POP) * 100 )\u0026#34;; 複数行に渡る式を書くとき、JavaScript の外に \u0026lt;script\u0026gt; タグを分け、タイプを text/plain に設定し、JavaScript から参照できるようユニークな ID を付与して配置することが推奨されます。\n\u0026lt;script type=\u0026#34;text/plain\u0026#34; id=\u0026#34;adult-population\u0026#34;\u0026gt; // 複数行の式を記述 \u0026lt;/script\u0026gt; そして、JavaScript は、document.getElementById() メソッドを呼ぶことで、文字列として参照します。\nrenderer.valueExpression = document.getElementById(\u0026#34;adult-population\u0026#34;).text; 下記のスニペットや Create a custom visualization using an Arcade expression サンプルを参照ください。\nプロファイル Arcade はいくつかのプロファイルにおける使用のためにデザインされました。プロファイルとは、理解し使用される命令語のコンテクストです。ArcGIS API 4.5 for JavaScript では、ビジュアライゼーション、ポップアップ、ラベリング（3D のみサポート）の３つのプロファイルをサポートしています。3D では、Arcade を使用することにより、フィーチャの標高を計算することも可能です。\nビジュアライゼーション ビジュアライゼーション プロファイルにおいて、Arcade を使ってランタイムで FeatureLayer (フィーチャ レイヤー) あるいは SceneLayer (シーン レイヤー) 内の各フィーチャが持つ値を計算することができます。 また、データドリブンな可視化のための基盤として、それらの値を使用することができます。 これは、レイヤー内の単一フィールド値をもとにしたデータ ビジュアライゼーションを作成するための別のアプローチになります。 これによって、Arcade 命令語は field/normarizationField あるいは JavaScript 関数の代わりに ClassBreaksRenderer (数値分類) や UniqueValueRenderer (個別値分類)、その他の可視化変数 (color, size, opacity, rotation) の valueExpression プロパティに渡されます。\nArcade は FeatureLayer と SceneLayer におけるビジュアライゼーションの作成のみサポートします。 ClassBreaks と UniqueValueRenderer を利用できる他のレイヤー (例えば、MapImageLayer) は Arcade をサポートしていません。\nClassBreaksRenderer あるいはその他の可視化変数を使用する際、命令語は必ず数値を評価してください。 UniqueValueRenderer は文字列と数値のいずれも評価して構いません。\n以下の例では、Arcade 命令語が UniqueValueRenderer の valueExpression プロパティを使用しています。 アメリカの州を表すフィーチャ レイヤーのためにビジュアライゼーションを作成します。 このサービスは各州における共和党、民主党、無所属に対する得票数という 3 つのフィールドを持ちます。 そこで、得票数で勝った党を各州で可視化したいとします。 サービスには優勢な党を示すフィールドが含まれていません。 したがって、Arcade を使ってその党を明らかにしましょう。\n// まず、各フィールドの属性値の参照と変数宣言を記述しています。 // Max() 関数を使って最大数を算出し、 // 最大数を持つ党を判定するために Decode() 関数を使います。  var arcade = \u0026#34;var republican = $feature.MP06025a_B;\u0026#34; + \u0026#34;var democrat = $feature.MP06024a_B;\u0026#34; + \u0026#34;var independent = $feature.MP06026a_B;\u0026#34; + \u0026#34;var parties = [republican, democrat, independent];\u0026#34; // Decode() と Max() は Arcade 組み込みの関数です。  + \u0026#34;Decode( Max(parties),\u0026#34; + \u0026#34; republican, \u0026#39;republican\u0026#39;,\u0026#34; + \u0026#34; democrat, \u0026#39;democrat\u0026#39;,\u0026#34; + \u0026#34; independent, \u0026#39;independent\u0026#39;,\u0026#34; + \u0026#34; \u0026#39;n/a\u0026#39;);\u0026#34;; // `valueExpression` プロパティに Arcade で記述した式を割り当て、 // Decode() で処理された値をもとに個別値の情報を設定します。  var renderer = new UniqueValueRenderer({ valueExpression: arcade, valueExpressionTitle: \u0026#34;Counties by dominant party among registered voters\u0026#34;, uniqueValueInfos: [{ value: \u0026#34;democrat\u0026#34;, symbol: createSymbol(\u0026#34;#00c3ff\u0026#34;), label: \u0026#34;Democrat\u0026#34; }, { value: \u0026#34;republican\u0026#34;, symbol: createSymbol(\u0026#34;#ff002e\u0026#34;), label: \u0026#34;Republican\u0026#34; }, { value: \u0026#34;independent\u0026#34;, symbol: createSymbol(\u0026#34;#faff00\u0026#34;), label: \u0026#34;Independent/non-affiliated\u0026#34; }] }); また、各州における優勢な党の相対的な力を示すために renderer に対して opacity の可視化変数を追加します。 より多くの人々が特定の党に投票している州を高い透過率でし、各党に対する得票数が拮抗している州は低い透過率で描画してみましょう。\n// まず、各フィールドの属性値の参照と変数宣言を記述しています。 // Max() 関数を使って最大数を、 // Sum() 関数ですべての党の得票数の合計値を算出します。 // 合計値に対するもっとも多くの投票を得た党の得票数の割合をパーセントで返します。  var opacityArcade = \u0026#34;var republican = $feature.MP06025a_B;\u0026#34; + \u0026#34;var democrat = $feature.MP06024a_B;\u0026#34; + \u0026#34;var independent = $feature.MP06026a_B;\u0026#34; + \u0026#34;var parties = [republican, democrat, independent];\u0026#34; + \u0026#34;var total = Sum(parties);\u0026#34; + \u0026#34;var max = Max(parties);\u0026#34; + \u0026#34;return (max / total) * 100;\u0026#34;; // `valueExpression` プロパティに Arcade で記述した式を割り当て、 // 返り値であるパーセントに応じて透過率を設定します。  var opacityVV = { type: \u0026#34;opacity\u0026#34;, valueExpression: opacityArcade, stops: [ { value: 33, opacity: 0.1 }, { value: 50, opacity: 1.0 } ] }; // 先に作成したレンダラーに透過率による可視化変数を追加します。  renderer.visualVariables = [ opacityVV ]; 実際にビジュアライゼーションを行った結果はサンプル アプリ (Create a custom visualization using Arcade) で確認してみてください。\nポップアップ Arcadeを PopupTmplate のコンテンツ  内で参照することもできます。ビジュアライゼーション プロファイルと同様に、 FeatureLayer  インスタンスに属性値として存在しないデータを表示する場合に便利です。 例えば、サンプルアプリ （ Reference Arcade expressions in PopupTemplate ）では、各米国郡の労働統計を含むレイヤーを表示します。いくつかの属性には、失業率、人口、および労働人口が含まれます。労働参加率の属性は含まれていません。 Arcade を使用して、実行時に算出することができます。\n// 労働参加率を計算 Round(($feature.CIVLBFR_CY / $feature.POP_16UP)*100,2) この式から返された値を使用して、レイヤーを視覚化したり、レイヤーの PopupTmplate に表示したりすることができます。ポップアップで値を表示するには、PopupTmplate の expressioninfo プロパティで値を参照し、 name と title を割り当てる必要があります。\nlayer.popupTemplate = {　expressionInfos: [{　name: \u0026#34;participation-rate\u0026#34;,　title: \u0026#34;% of population 16+ participating in the labor force\u0026#34;,　expression: \u0026#34;Round(($feature.CIVLBFR_CY / $feature.POP_16UP)*100,2)\u0026#34;　}],　content: \u0026#34;In {NAME} county, {expression/participation-rate}% of the population\u0026#34;　+ \u0026#34; participates in the labor force.\u0026#34;　};　式が expressionInfos プロパティに存在すると、 PopupTemplate のコンテンツ内の{expession/expression-name} プレースホルダー テンプレートを使用して式から返された値を参照できます。 ポップアップのコンテンツは、ユーザーが Greenlee , AZ を表現しているフィーチャーをクリックした後に次のように表示されます。\nまた、PopupTmplate　のコンテンツ の fieldinfos　プロパティの中で Arcade から返された値を参照できるため、表形式で表示することもできます。オブジェクトの fieldName プロパティで式の名前を参照するだけです。なお、 expression/expression-name シンタックスを使用してください。\nlayer.popupTemplate = { expressionInfos: [{ name: \u0026#34;participation-rate\u0026#34;, title: \u0026#34;% of population 16+ participating in the labor force\u0026#34;, expression: \u0026#34;Round(($feature.CIVLBFR_CY / $feature.POP_16UP)*100,2)\u0026#34; }], content: [{ type: \u0026#34;fields\u0026#34;, fieldInfos: [{ fieldName: \u0026#34;expression/participation-rate\u0026#34; }] }] }; ポップアップには以下のように表示されます。\nPopupTmplate の fieldinfos プロパティの書式設定オプションを利用して、式から返された数値を書式設定することもできます。 このワークフローはサンプルアプリ（PopupTemplate Reference Arcade）でご覧ください。\nラベリング ラベリングは、現在、3D SceneView のみサポートしています。2D MapView でのラベリングは将来のリリースで追加される予定です。\nArcade は、FeatureLayer または SceneLayer に含まれるフィーチャのラベルの式を作成するためにも使用されます。バージョン 4.5 からは、フィーチャをラベリングするためにサポートされた唯一の方法です。\n少なくともひとつの LabelClass をレイヤーの LabelingInfo プロパティへ追加し、labelsVisible プロパティを true へ設定する必要があります。式は、LabelClass の labelExpressionInfo オブジェクトの expression プロパティへ文字列として渡します。\n// レイヤーのフィールド値を返す // フィールド値は各フィーチャのラベルに使用される var arcade = \u0026#34;$feature.STATION_NAME\u0026#34;; // new LabelClass() の autocast オブジェクト var labelClass = { // 式を labelExpressionInfo の `expression` プロパティに設定する  labelExpressionInfo: { expression: arcade }, labelPlacement: \u0026#34;below-right\u0026#34;, minScale: 2500000, symbol: { type: \u0026#34;label-3d\u0026#34;, symbolLayers: [{ type: \u0026#34;text\u0026#34;, material: { color: \u0026#34;white\u0026#34; }, halo: { color: \u0026#34;black\u0026#34;, size: 1 }, size: 8 }] } }; // LabelClass を FeatureLayer へ設定 featureLayer.labelingInfo = [ labelClass ]; featureLayer.labelsVisible = true; Arcade で書かれたラベル式は、数学的で論理的な操作を実行する複数行に渡るもっと複雑な式になるかもしれません。例えば、Label features using Arcade expressions サンプルは、より複雑な複数行に渡るラベル式を示しています。この式は２つの数値フィールドの値を変数に入れ、評価し、文字列を返します。Arcade の When() は、風向き（0 - 360 度）を評価し、N、NE、E、SE、S、SW、W または NW のいずれかの関連する方角を返します。風力が 0 のとき、方角は返されません。式の最後で、ラベル（WIND 変数の値）を返します。\n\u0026lt;script type=\u0026#34;text/plain\u0026#34; id=\u0026#34;wind-direction\u0026#34;\u0026gt; var DEG = $feature.WIND_DIRECT; var SPEED = $feature.WIND_SPEED; var DIR = When( SPEED == 0, \u0026#39;\u0026#39;, (DEG \u0026lt; 22.5 \u0026amp;\u0026amp; DEG \u0026gt;= 0) || DEG \u0026gt; 337.5, \u0026#39;N\u0026#39;, DEG \u0026gt;= 22.5 \u0026amp;\u0026amp; DEG \u0026lt; 67.5, \u0026#39;NE\u0026#39;, DEG \u0026gt;= 67.5 \u0026amp;\u0026amp; DEG \u0026lt; 112.5, \u0026#39;E\u0026#39;, DEG \u0026gt;= 112.5 \u0026amp;\u0026amp; DEG \u0026lt; 157.5, \u0026#39;SE\u0026#39;, DEG \u0026gt;= 157.5 \u0026amp;\u0026amp; DEG \u0026lt; 202.5, \u0026#39;S\u0026#39;, DEG \u0026gt;= 202.5 \u0026amp;\u0026amp; DEG \u0026lt; 247.5, \u0026#39;SW\u0026#39;, DEG \u0026gt;= 247.5 \u0026amp;\u0026amp; DEG \u0026lt; 292.5, \u0026#39;W\u0026#39;, DEG \u0026gt;= 292.5 \u0026amp;\u0026amp; DEG \u0026lt; 337.5, \u0026#39;NW\u0026#39;, \u0026#39;\u0026#39; ); var WIND = SPEED + \u0026#39; mph \u0026#39; + DIR; return WIND; \u0026lt;/script\u0026gt; そのほかにも、テキスト整形のロジックを提供するテキスト関数を含む、ラベリングに役立つ多くの関数が用意されています。詳細は Arcade をご参照ください。\nその他のケース 標高 3D SceneView では、Arcade を使用してフィーチャごとに独自の標高を設定できます。フィーチャは Z 値を持つことができますが、属性値や Z 値を使用した計算式をもとに高さを演算したい場合に有効です。さらに、Z 値を含まないが、属性フィールドに Z 値に関連する情報を持つデータの場合、featureExpressionInfo.expression プロパティに式を設定できます。例として、Elevation options サンプルは Arcade を使用してポイント シンボルの高さがどのように変化するのかを示しています。\nlayer.elevationInfo = { mode: \u0026#34;absolute-height\u0026#34;, featureExpressionInfo: { expression: \u0026#34;Geometry($feature).z + $feature.HEIGHT\u0026#34; }, unit: \u0026#34;meters\u0026#34; }; 上記の例では、独自の HEIGHT 属性がジオメトリの Z 値として、グラフィックの標高に設定されます。ラインまたはポリゴン フィーチャにおいて、すべてのフィーチャの頂点は expression の戻り値の標高を持ちます。\nプレイグラウンドでは、入力フィーチャ サービスからインポートしたフィールド値をもとに、ブラウザーから式をビルド、デバッグ、テストできます。Console() 機能を使い、複雑なスクリプトをデバッグすることも可能です。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/",
	"title": "ArcGIS API for Python",
	"tags": [],
	"description": "ArcGIS API for Python の開発に役立つガイド集です。",
	"content": "ArcGIS API for Python の開発に役立つガイド集です。\n ArcGIS API for Python のコンセプト\nArcGIS API for Python のプロダクト コンセプトと動作要件について紹介します。\n\r ArcGIS API for Python のための基礎環境：conda入門\nconda の基本について簡単に紹介します。\n\r インストール ガイド\nArcGIS API for Python の環境構築方法を紹介します。\n\r Jupyter Notebook を使ってみよう\nArcGIS API for Python の実行に便利な JupyterLab の初期設定方法と使用方法を簡単に紹介します。\n\r Jupyter Lab を使ってみよう\nArcGIS API for Python の実行に便利な Jupyter Notebook の基本的な起動と使用方法を簡単に紹介します。\n\r スクリプト実行の自動化\nタスクスケジューラや cron を使用した Python スクリプトの実行の自動化について紹介します。\n\r matplotlib での日本語利用について\nArcGIS API for Python で利用されているグラフ描画ライブラリの matplotlib で日本語を使う方法を説明します。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/widget-manifest/",
	"title": "ウィジェット manifest",
	"tags": [],
	"description": "ウィジェットの名前やバージョンなどのウィジェットの属性などを設定する manifest.json ファイルについて紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Widget manifest\n各 ArcGIS Experience Builder ウィジェットには、ウィジェットの属性とプロパティを記述した manifest.json ファイルがあります。ウィジェットの manifest には、name、type、version、exbVersion、および translatedLocales プロパティを含める必要があります。ウィジェットの manifest を作成する簡単な方法は、demo widget から manifest.json ファイルをコピーすることです。以下は manifest.json ファイルの例です。ウィジェット内で ArcGIS Maps SDK for JavaScript を使用するには、dependency プロパティに jimu-arcgis を設定します。\n{ \u0026#34;name\u0026#34;: \u0026#34;count-features\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Count Features\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;widget\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.5.0\u0026#34;, \u0026#34;dependency\u0026#34;: \u0026#34;jimu-arcgis\u0026#34;, \u0026#34;exbVersion\u0026#34;: \u0026#34;1.5.0\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Esri R\u0026amp;D Center Beijing\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is widget is designed to display the numeric attributes of features.\u0026#34;, \u0026#34;copyright\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;http://www.apache.org/licenses/LICENSE-2.0\u0026#34;, \u0026#34;publishMessages\u0026#34;: [ \u0026#34;EXTENT_CHANGE\u0026#34;, \u0026#34;DATA_RECORDS_SELECTION_CHANGE\u0026#34; ], \u0026#34;messageActions\u0026#34;: [], \u0026#34;defaultSize\u0026#34;: { \u0026#34;width\u0026#34;: 360, \u0026#34;height\u0026#34;: 80 }, \u0026#34;properties\u0026#34;: {}, \u0026#34;translatedLocales\u0026#34;: [ \u0026#34;en\u0026#34;, \u0026#34;es\u0026#34;, \u0026#34;zh-cn\u0026#34; ] } widget\u0026rsquo;s manifest で利用可能なプロパティの詳細を参照してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/automate-tasks/",
	"title": "スクリプト実行の自動化",
	"tags": [],
	"description": "タスクスケジューラや cron を使用した Python スクリプトの実行の自動化について紹介します。",
	"content": "ArcGIS API for Python や ArcPy は、タスク スケジューラなどと組み合わせることで、様々な GIS タスクの実行を自動化することが可能です。\nここでは、例として以下のようなディレクトリ構成で実行する Python スクリプトを作成したと想定し、そのスクリプトを Windows 及び Linux で 30 分ごとに無期限で定期実行する方法を紹介します。\npy-script/\n├ config.ini\n└ task.py\ntask.py は実行する Python スクリプト、config.ini は task.py の実行に必要なパラメータを記載した設定ファイルとします。\nWindows のタスク スケジューラを使用する場合 Windows ではタスク スケジューラを使用することでプログラムやスクリプトを決められた時間や一定の間隔で実行することができます。\nタスク スケジューラは以下の手順で設定します。\n タスク スケジューラを開く  スタート メニューからタスク スケジューラを検索して開く    \r 右側の [操作] ペインから [タスクの作成] をクリック  新規タスクを作成するウィザードが開きます    \r [全般] タブ内のパラメーターを設定する  名前：タスクの名前 説明：タスクの説明を記載 セキュリティ オプション：  タスク実行時に使う Windows のユーザーアカウントを指定 [ユーザーがログオンしているかどうかにかかわらず実行する] をクリック [最上位の特権で実行する] にチェックを入れる   [構成] は使用している Windows のバージョンに合わせる (今回は Windows 10)    \r [トリガー] タブ内のパラメーターを設定する  [新規] をクリックし、新しいトリガーを作成 [タスクの開始] は [スケジュールに従う] をドロップダウンから選択 任意の開始時間を指定 [繰り返し間隔] にチェックを入れ、30分間を指定 [継続時間] は [無期限] を指定    \r [操作] タブのパラメーターを設定する  [操作] のドロップダウンから [プログラムの開始] を選択 [プログラム/スクリプト] で実行する Python の エグゼキュータブル ファイルのパスを指定  上の画像では ArcGIS Pro の Python パッケージ マネージャー で作成した環境の Python を指定しています。 パスが不明な場合、実行したい環境で ArcGIS Pro を起動し、Python ウィンドウを表示させて以下のコードを実行することで確認することができます。  import sys sys.executable     [引数の追加 (オプション)] で実行する Python スクリプトのファイル名を指定 [開始 (オプション)] で Python スクリプトが格納されているディレクトリを指定    \r指定するパス等にスペースが含まれている場合はダブル クォーテーションで囲んでください。\nまた半角括弧 () が含まれるパスを指定すると正常に動作しないため、ディレクトリ名などを変更してください\n\r OK ボタンをクリックし、要求された場合はユーザーアカウント情報を入力  Linux の cron を使用する場合 Linux で特定のタスクを定期実行する場合は cron が用いられます。\ncron は任意のタスクを任意の時間にバックグラウンドで実行するデーモンです。実行する内容は crontab と呼ばれるテキスト ファイルに記述します。\n設定方法は以下のとおりです。\ncrontab を開く  以下のコマンドを Bash ターミナルから実行   crontab -e\r 次のような使用するテキスト エディタを選択する画像が表示された場合、任意の番号のテキストエディタを選択します (今回は 1 番を選択)。  \rcrontab を編集する  crontab の編集画面が開くので次のとおり実行する内容を記述  */30 * * * * cd /home/\u0026lt;ユーザー名\u0026gt;/py-script \u0026amp;\u0026amp; /home/\u0026lt;ユーザー名\u0026gt;/anaconda3/envs/arcgis171/bin/python task.py\r\r 記述した内容の概要は以下のとおりです  */30 * * * *  30分に一回の実行間隔を指定   cd /home/\u0026lt;ユーザー名\u0026gt;/py-script  cd コマンドでカレントのディレクトリを実行するスクリプトと設定ファイルが格納されているディレクトリに移動 ※ ここではログインしているユーザーのホーム ディレクトリ直下に配置していると想定   \u0026amp;\u0026amp;  連続してコマンドを実行する場合に用いるオペレーター   /home/\u0026lt;ユーザー名\u0026gt;/anaconda3/envs/arcgis171/bin/python  実行する Python のパスを指定   task.py  実行する Python スクリプトを指定      上記の内容は Anaconda3 をインストールして構築した ArcGIS API for Python の実行環境を想定しています。詳細はインストールガイドを参照ください。\nより詳細な cron の使い方はubuntu の Community Help Wiki の Cron How to をご覧下さい。\n\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/guide/deployment/",
	"title": "デプロイ",
	"tags": [],
	"description": "開発したアプリをデプロイするために必要なライセンスや利用規約などについて紹介します。",
	"content": "出典：ArcGIS Developers - Deployment - Introduction\nArcGIS Platform のロケーションサービスでは、Web アプリケーション、ネイティブ アプリケーション、サービスサイドアプリケーションなど、さまざまな種類のアプリケーションを構築およびデプロイできます。どのような種類のアプリケーションを構築する場合でも、デプロイの前に確認する必要があるガイドラインと利用規約があります。\nこのセクションでは、ArcGIS Platform で構築したアプリケーションをデプロイする前に知っておくべき情報を提供します。\nデプロイのガイドライン   アカウント：ArcGIS アカウントがサービスの使用とデプロイにどのように影響するかを確認します。\n  サービス：アクセストークンを使って、有効な認証方法でロケーションサービスにアクセスします。\n  データの使用：アプリケーションが使用するすべてのコンテンツとデータの使用条件に従ってください。\n  ベースマップの帰属：ArcGIS のベースマップ レイヤーを使用する場合は、クレジットと帰属のガイドラインに従ってください。\n  配布：アプリケーションをデプロイ、または配布する場合は、ライセンス、または配布の要件を遵守してください。\n  利用規約：Esri の利用規約および関連する法的文書を確認してください。\n  詳しくは、以下のトピックスをご覧ください。\nトピックス アカウント  アカウントの種類によって、アプリケーションの構築やデプロイメントにどのような影響があるのかをご説明します。  コンテンツとデータ  アプリケーションで使用するデータの利用規約についてご説明します。  ベースマップの帰属  アプリケーションで正しいベースマップの帰属を提供する方法について説明します。  配布方法  異なる API で構築されたアプリケーションを配布、デプロイするための要件について説明します。  利用条件  利用規約などの法的文書についてご紹介します。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/visualization/",
	"title": "データ ビジュアライゼーション",
	"tags": [],
	"description": "地図にデータを可視化する際の Tips を紹介します。",
	"content": "地図にデータを可視化する際の Tips を紹介します。\n データ可視化のワークフロー\nマップ ビューアーを使用した地図上でのデータ可視化のプロセスを紹介します。\n\r データ可視化の手順\nArcGIS Online 上のデータを可視化するための方法を紹介します。\n\r 地図上に賢くデータを可視化するための 6 つの方法\nマップ ビューアーを使って地図データを賢く可視化するために おさえておくべき６つの方法を紹介します。\n\r\r"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/layout/",
	"title": "レイアウト（Layout）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Layout\nレイアウト（Layout） レイアウトは、レイアウトコンテナにコンテンツを配置する方法を定義します。コンテンツには、ウィジェット、セクション、または画面グループが含まれ、レイアウト コンテナには、ページ、ビュー、またはダイアログなどがあります。ArcGIS Experience Builder には、いくつかのレイアウト規則があります。たとえば、新しいページを作成するときに、Fixed レイアウトまたは Flow レイアウトを選択したり、Layout ウィジェットを使用して異なるレイアウトを作成したりすることができます。\nアプリ コンフィグでは、レイアウトは layouts プロパティで定義され、レイアウト コンテナは layout id でレイアウトを参照します。レイアウトコンテナには、異なるサイズモードでのレイアウトを定義する layouts オブジェクトプロパティがあります。Experience Builder では、Large、Medium、Small の各サイズモードをサポートしています。レイアウトが定義されていないサイズモードでは、アプリの設定で定義された mainSizeMode レイアウトが使用されます。\nフレームワークのレイアウト・コンテナの他に、ウィジェットもレイアウト・コンテナになることができます。ウィジェットがレイアウト・コンテナになると，ユーザーは他のウィジェットをドラッグ・アンド・ドロップすることができます．例えば、Map や Card はレイアウト・コンテナ・ウィジェットです。レイアウト・コンテナ・ウィジェットは、manifest.json で layouts プロパティを宣言し、LayoutEntry コンポーネントを使用する必要があります。パフォーマンス上の理由から、以下のロジックを使用する必要があります。\nimport {LayoutEntry} from \u0026#39;jimu-layouts/layout-runtime\u0026#39; let LayoutEntryComponent if (window.jimuConfig.isInBuilder) { LayoutEntryComponent = this.props.builderSupportModules.LayoutEntry } else { LayoutEntryComponent = LayoutEntry } "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/prosdk/",
	"title": "ArcGIS Pro SDK",
	"tags": [],
	"description": "ArcGIS Pro SDK の開発に役立つガイド集です。",
	"content": "ArcGIS Pro SDK の開発に役立つガイド集です。\n  ArcGIS Pro を使用した開発\n 概要  SDK の概要・コンポーネント、開発要件、リリースノート等を紹介します。   ArcGIS Pro Extensions Nuget  ArcGIS Pro Extensions Nuget の使用方法や導入の利点を紹介します。   ArcMap から ArcGIS Pro への移行  ArcMap のカスタマイズを ArcGIS Pro に移行する際のアプローチ、ベストプラクティス、および実装上の考慮事項の概要を説明します。   ArcGIS Pro 3.0 への移行  ArcGIS Pro 3.0 の変更点と 2.x から 3.0 への移行手順について説明します。   フレームワーク  開発フレームワークの詳細を説明します。   非同期プログラミング  アドイン開発で使用する非同期プログラミング手法について説明します。      アドイン開発\n インストールとアップグレード  SDK のインストール、アップグレード、およびアンインストール方法を説明します。   はじめてのアドイン作成  ArcGIS Pro アドインの開発方法をステップで説明します。   アドインの種類  開発できる UI コントロールの種類を説明します。   ジオデータベース  ジオデータベースの操作について説明します。   よくある問題  アドイン開発でよく遭遇する問題とその解決策を紹介します。      構成管理\n コンセプト  ArcGIS Pro のカスタマイズ方法のひとつである構成管理のコンセプトを説明します。   カスタマイズ方法  構成管理のカスタマイズ方法をステップで説明します。      "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/python/matplotlib-japanese/",
	"title": "matplotlib での日本語利用について",
	"tags": [],
	"description": "ArcGIS API for Python で利用されているグラフ描画ライブラリの matplotlib で日本語を使う方法を説明します。",
	"content": "ArcGIS API for Python では様々な オープンソース ライブラリを活用していますが、グラフを描画する際は主に matplotlib が使用されています。\nmatplotlib をデフォルトのまま使用すると日本語のテキストは文字化けしてしまいますが、フォント設定を変更することで表示させることが可能です。\n対応環境 ここでは、次の環境を用いた場合の設定方法を説明します。\n ArcGIS Pro 2.5 ArcGIS API for Python 1.7.0 matplotlib 3.1.1  日本語フォントの多くは ttc ファイルで提供されていますが、以前の matplotlib は ttc ファイルに対応していませんでした。matplotlib 3.1.0 から ttc ファイルに対応するようになったため、フォントを追加でインストールすることなく日本語を表示させることができるようになっています。それ以前のバージョンをご利用されている場合は以下をご検討ください。\n ArcGIS Pro のアップグレード  ArcGIS Pro 2.5 では、デフォルトで作成されている arcgispro-py3 という名前の環境に、ArcGIS API for Python 1.7.0 及び matplotlib 3.1.1 がインストールされています。   ArcGIS API for Python をアップグレード  Anaconda を利用して環境構築している場合、ArcGIS API for Python を最新バージョンにアップグレードすることで、依存パッケージである matplotlib も併せてアップグレードされます。    matplotlib での日本語フォントの設定方法 設定方法は主に以下の 2 通りがあります。\n スクリプトで matplotlib の設定を都度変更する matplotlib の設定ファイル (matplotlibrc) を編集する  前者の方法では一時的な設定変更、後者では恒久的な設定変更が可能です。 どちらが適しているかはご自身の状況に合わせて選択してください。\nスクリプトで matplotlib の設定を都度変更する 次のコードをスクリプトの最初に実行することでフォント設定を変更することが可能です。\nimport matplotlib.pyplot as plt from matplotlib import rcParams rcParams[\u0026#34;font.family\u0026#34;] = \u0026#34;sans-serif\u0026#34; rcParams[\u0026#34;font.sans-serif\u0026#34;] = [\u0026#34;Meiryo\u0026#34;] rcParams は matplotlib のデフォルト設定が入っているオブジェクトです。\n上記では Windows で利用可能な Meriyo に変更していますが、ご自身の OS 等に応じて適宜フォントファミリー、フォントを変更してください。\n設定したらサンプル コードを実行してみましょう。\nmatplotlib の設定ファイル (matplotlibrc) を編集する 上記の設定方法では毎回スクリプトの最初にコードを実行する必要がありますが、以下の方法でデフォルトのフォントを恒久的に変更することが可能です。\nmatplotlibrc のパスを確認 次のコードを実行して matplotlib の設定ファイルである matplotlibrc のパスを確認します。\nimport matplotlib as mpl mpl.matplotlib_fname() matplotlibrc を C:\\Users\\\u0026lt;ユーザー名\u0026gt;\\.matplotlib にコピー \u0026amp; ペーストで配置 matplotlibrc が格納されているパスへ移動しファイルをコピーしたら、以下のディレクトリにペーストします。\n C:\\Users\\\u0026lt;ユーザー名\u0026gt;\\.matplotlib  conda を使用して複数の環境を作成・利用している場合、それぞれの環境が matplotlibrc を保持しています。\n上記のパスに配置された matplotlibrc は各環境の matplotlibrc よりも優先されるため、当該ファイルを修正するだけで全ての環境で日本語のフォントを設定することができます。\n\rmatplotlibrc の内容を修正 ペーストした matplotlibrc のフォント設定部分を書き換えます。\nmatplotlibrc は非常に長いファイルですが、160 行目あたりからフォント設定のセクションが始まります。\n\r198 行目にフォント ファミリー、210 行目に sans-serif のフォント設定の箇所があります。\nフォント ファミリーはデフォルトが sans-serif なので、ここではデフォルト設定のままにしておきます。\n210 行目のフォント設定の行で、# を削除し、: の後に日本語のフォントを追加しましょう。\nここでは Meiryo に設定します。設定後の画面は以下のようになります。\n\rキャッシュの再構築 以上で設定は終了ですが、うまく反映されない場合があるので、念のため以下のコードを実行してキャッシュを再構築します。\nimport matplotlib.font_manager matplotlib.font_manager._rebuild() 設定が完了したらしたら以下のサンプルコードを実行してみましょう。\nサンプル コード フォント設定が完了したら以下のサンプル コードを実行してみましょう。\nimport matplotlib.pyplot as plt import numpy as np def test_function(x): return 3*x**3 + 2*x**2 + 4*x - 10 x = np.linspace(-3, 3, 200) plt.plot(x, test_function(x), color = \u0026#34;cornflowerblue\u0026#34;, label = \u0026#34;日本語のラベル\u0026#34;) plt.legend(loc = \u0026#34;upper left\u0026#34;) plt.ylim(-120, 120) plt.title(\u0026#34;日本語のタイトル\u0026#34;) plt.xlabel(\u0026#34;日本語のX軸\u0026#34;) plt.ylabel(\u0026#34;日本語のY軸\u0026#34;) plt.grid(True) plt.show() 次のようなグラフが描ければ成功です。\n\r参考  matplotlibで日本語 - Qiita matplotlib 公式ドキュメント  Configuring the font family The matplotlibrc file    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/extend-base-widget/",
	"title": "ウィジェットの実装",
	"tags": [],
	"description": "ウィジェットの実装方法について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Widget implementation\nExperience Builder ウィジェットは、次のファイルで構成されています。\n src: ウィジェットのソースコード  runtime: フォルダ  widget.tsx: メインのファイル assets: widget.tsx で使用される assets フォルダ translations: ウィジェットで使われる strings フォルダ   setting: フォルダ  setting.tsx: ウィジェットで使用する設定ファイル assets: 設定で使用する assets フォルダ translations: 設定で使用する strings フォルダ     dist: コンパイル済みのウィジェットのソースコードを配置。ウィジェットのソースコードのフォルダと同じ構成 icon.svg: ウィジェットパネルのウィジェットのアイコン config.json: ウィジェットのデフォルト設定 manifest.json: プロパティのリストは jim-core/lib/types/manifest で設定した内容を表示  Client サーバー Experience Builder (開発者向けエディション)で必要なモジュールをインストールしたら、/client ディレクトリで npm start を実行して webpack サーバーを起動します。webpack サーバーを起動した状態にすることでソースコードの編集におけるファイル変更を監視し、自動的にコンパイルを行います。通常は、ソースコードを編集する際に webpack サーバーを再起動する必要はありませんが、以下の場合では、サーバーを再起動する必要があります。\n 新しいモジュールのインストール ウィジェットの追加、削除、名前の変更 ウィジェットの manifest.json の編集 ファイルやフォルダの追加、削除、名前の変更  ctrl + c で webpack サーバーを停止させることができます。\n\rウィジェットの作成 ウィジェットに必要なファイルを作成する簡単な方法は、samples repo にある demo widget をコピーして、client/your-extensions/widget ディレクトリに配置します。demo widget フォルダの名前を変更し、maniest.json で名前とラベルを変更し、ウィジェットの translations フォルダにある default.ts ファイルの _widgetLabel のプロパティを変更します。widget/React コンポーネントを作成するには、クラスと関数の 2 つの方法があります。以下に、2 つの違いについて紹介します。\n  クラスコンポーネント\n ES6 クラスを利用し、React のコンポーネントクラスを拡張します。 独自のデータを state で維持します。 props(properties) をクラスコンポーネントに渡し、this.props でアクセスします。 render() メソッドを使います。    関数コンポーネント\n アロー関数を使った JavaScript の基本的な関数ですが、通常の関数キーワードを使用することができます。 props を受け入れて使用します。 React Hooks を使用して state やその他の機能を使用します。 render() メソッドはありません。    開発者向けドキュメントで使用されているサンプルは、1 つを除いてすべてクラスコンポーネントに基づいています。今後のリリースでは、関数コンポーネントのサンプルを追加する予定です。\nクラスコンポーネントを使ったウィジェットの作成 以下の例では、React.PureComponent クラスを拡張して、シンプルな hello world クラスの widget/component を作成する方法を示しています。ウィジェットは、export default class Widget extends React.Component\u0026lt;AllWidgetProps\u0026gt;, any\u0026gt; { で AllWidgetProps 型で宣言されており、ウィジェットの props を使用しています。 render() メソッドは、translations ファイル内の _widgetLabel のプロパティで設定した テキスト名：hello world とウィジェット名を返すために呼び出されます。\n//a custom pragma to transform your jsx into plain JavaScript /** @jsx jsx */ import { React, AllWidgetProps, jsx } from \u0026#34;jimu-core\u0026#34;; export default class Widget extends React.PureComponent\u0026lt;AllWidgetProps\u0026lt;{}\u0026gt;, any\u0026gt; { render() { return ( \u0026lt;div className=\u0026#34;widget-starter jimu-widget\u0026#34; style={{ overflow: \u0026#34;auto\u0026#34; }}\u0026gt; \u0026lt;p\u0026gt;Hello world!\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Widget Name: {this.props.label}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } } 関数コンポーネントを使ったウィジェットの作成 以下の例では、シンプルな hello world 関数の widget/component を作成するために必要なモジュールをロードしています。ウィジェットは、export default function Widget (props: AllWidgetProps) { で AllWidgetProps 型の関数として宣言されており、ウィジェットの props を使用しています。translations ファイルの _widgetLabel のプロパティで設定した テキスト名: hello world とウィジェット名を返します。\n/** @jsx jsx */ import { AllWidgetProps, jsx} from \u0026#34;jimu-core\u0026#34;; export default function Widget (props:AllWidgetProps) { return \u0026lt;div className=\u0026#34;widget-starter jimu-widget\u0026#34; style={{ overflow: \u0026#34;auto\u0026#34; }}\u0026gt; \u0026lt;p\u0026gt;Hello world!\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Widget Name: {props.label}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; } ウィジェットの UI 設定 ウィジェットの UI 設定は、ウィジェットの作成と似ていますが、setting フォルダの setting.tsx を使用することができます。ウィジェットの UI 設定を作成するには、クラスと関数の 2 つの方法があります。クラス コンポーネントを使うと、jimu-for-builder パッケージの一部である BaseWidgetSetting クラスを拡張することができます。この例では、データソースを追加して設定パネルの config.json ファイルを操作する方法を示しています。また、以下の例であるようにインポートに注意する必要があります。\n import React.Component はクラスを拡張するために使用します。 import DataSourceTypes はデータソースの種類に使用します。 import SettingSection と SettingRow は設定に便利な UI コンポーネントです。 import DataSourceSelector もデータソースの選択に使われるコンポーネントです。 import IMConfig は config.json ファイルに使用されます。  import {React, Immutable, FormattedMessage} from \u0026#39;jimu-core\u0026#39;; import {AllWidgetSettingProps} from \u0026#39;jimu-for-builder\u0026#39;; import {DataSourceTypes} from \u0026#39;jimu-arcgis\u0026#39;; import {SettingSection, SettingRow} from \u0026#39;jimu-ui/advanced/setting-components\u0026#39;; import {DataSourceSelector} from \u0026#39;jimu-ui/advanced/data-source-selector\u0026#39;; import {IMConfig} from \u0026#39;../config\u0026#39;; import defaultI18nMessages from \u0026#39;./translations/default\u0026#39; BaseWidgetSetting クラスは AllWidgetSettingProps と IMConfig という型で宣言されています。supportedTypes プロパティは、クラス全体でデータソースタイプの Web マップに使用されます。onDataSourceSelected は、データソースの選択を処理する関数を持つクラス プロパティです。設定 UI の変更を通知する関数 this.props.OnSettingChange() を使用しています。クラスプロパティの onP1Change とonP2Change は、React のイベント処理を利用して、config.json ファイルの値の設定を支援しています。\nexport default class Setting extends React.PureComponent{ supportedTypes = Immutable([DataSourceTypes.WebMap]); onDataSourceSelected = (useDataSources: UseDataSource[]) =\u0026gt; { this.props.onSettingChange({ id: this.props.id, useDataSources: useDataSources }); } onP1Change = (evt: React.FormEvent\u0026lt;HTMLInputElement\u0026gt;) =\u0026gt; { this.props.onSettingChange({ id: this.props.id, config: this.props.config.set(\u0026#39;p1\u0026#39;, evt.currentTarget.value) }); } onP2Change = (evt: React.FormEvent\u0026lt;HTMLInputElement\u0026gt;) =\u0026gt; { this.props.onSettingChange({ id: this.props.id, config: this.props.config.set(\u0026#39;p2\u0026#39;, evt.currentTarget.value) }); } jimu ライブラリには、ウィジェットで使用できるコンポーネントがあります。例えば、Web マップを選択のための UI を支援するために、DataSourceSelector コンポーネントが、選択されたデータソースのタイプ、ID、およびコールバックを処理するために使用されます。さらに、SettingSection コンポーネントと SettingRow コンポーネントは、翻訳や config ファイルからの文字列のコンテナの整形を処理するために使用されます。\nrender(){ return \u0026lt;div className=\u0026#34;sample-map-view-setting p-2\u0026#34;\u0026gt; \u0026lt;DataSourceSelector types={this.supportedTypes} mustUseDataSource useDataSources={this.props.useDataSources} onChange={this.onDataSourceSelected} widgetId={this.props.id} /\u0026gt; \u0026lt;SettingSection\u0026gt; \u0026lt;SettingRow label={\u0026lt;FormattedMessage id=\u0026#34;p1\u0026#34; defaultMessage={defaultI18nMessages.p1}/\u0026gt;}\u0026gt; \u0026lt;input defaultValue={this.props.config.p1} onChange={this.onP1Change}/\u0026gt;\u0026lt;/SettingRow\u0026gt; \u0026lt;SettingRow label={\u0026lt;FormattedMessage id=\u0026#34;p2\u0026#34; defaultMessage={defaultI18nMessages.p2}/\u0026gt;}\u0026gt; \u0026lt;input defaultValue={this.props.config.p2} onChange={this.onP2Change}/\u0026gt;\u0026lt;/SettingRow\u0026gt; \u0026lt;/SettingSection\u0026gt; \u0026lt;/div\u0026gt; } } Props ウィジェットでは props があります。クラス コンポーネントの this.props や関数コンポーネントの props パラメータ {props} を通してアクセスすることができます。例えば、クラス コンポーネントを使用してウィジェットの config.json にある props にアクセスするには、this.props.config を使用します。関数コンポーネントでアクセスするには、props.config を使用します。利用可能なプロパティの詳細については、Experience Builder の client/jimu-core/lib/types/props.ts を参照してください。\nstatic mapExtraStateProps = (state: IMState) =\u0026gt; { return { appMode: state \u0026amp;\u0026amp; state.appRuntimeInfo \u0026amp;\u0026amp; state.appRuntimeInfo.appMode }; }; i18n サポート Experience Builder は react-intl ライブラリを使用して i18n をサポートしています。ウィジェットで言語のサポートを有効にするには、ウィジェットの manifest.json で translatedLocales プロパティのロケールを宣言します。慣例によりデフォルトのロケールを最初に指定しなければなりません。例えば、以下のスニペットでは、translatedLocales プロパティのデフォルトロケールは、英語(米国)、スペイン語、中国語(北京語) の順になっています。\n\u0026#34;translatedLocales\u0026#34;: [ \u0026#34;en\u0026#34;, \u0026#34;es\u0026#34;, \u0026#34;zh-cn\u0026#34; ] 翻訳文字列は default.ts というファイルが必要で、runtime/translations と settings/translations フォルダにあります。default.ts はデフォルトの文字列を定義し、ウィジェットにインポートしてデフォルトのメッセージに使うことができます。例えば、widget.tsx では、以下のような翻訳された文字列にアクセスする方法があります。\n// Class component this.props.intl.formatMessage({id: \u0026#39;_widgetLabel\u0026#39;, defaultMessage: defaultMessages._widgetLabel}) // Function component props.intl.formatMessage({id: \u0026#39;_widgetLabel\u0026#39;, defaultMessage: defaultMessage._widgetLabel}) // JSX \u0026lt;FormattedMessage id=\u0026#34;widgetProperties\u0026#34; defaultMessage={defaultMessages.widgetProperties}/\u0026gt; マップ ビュー/シーン ビュー ほとんどの Experience Builder では、ウィジェットはマップ ビュー/シーン ビューで動作し、同様にビュー内のレイヤーにアクセスする必要があります。一貫した拡張性モデルを持つことを保証するために、Experience Builder フレームワーク内での使用をより簡単にするために、他のクラスやメソッドに加えて、MapViewManager クラスが jimu-arcgis で利用可能です。基本的に全てのウィジェットは createJimuMapView メソッドを呼び出して MapViewManager にマップ ビュー/シーン ビューを追加し、他のウィジェットで使用できるようにすることができます。\nMapViewManager.getInstance().createJimuMapView({ mapWidgetId: this.props.id, view: new MapView(options), datasourceId: webmapDs.id, isActive: true }) マップ ビュー/シーン ビューを使用する必要がある他のウィジェットでは、UI 設定で JimuMapViewSelector を使用して選択することができます。選択したマップ/シーンは WidgetJson.useMapWidgetsIds に保存されます。\n\u0026lt;JimuMapViewSelector onSelect={this.onMapWidgetSelected} useMapWidgetIds={this.props.useMapWidgetIds[0]} /\u0026gt; ArcGIS Maps SDK for JavaScript のモジュール 既定では、Experience Builder はアプリのロード時に ArcGIS Maps SDK for JavaScript (JS API) をロードしません。JS API モジュールを利用するには、2 つのオプションがあります。\n JS API に依存するウィジェット (例：JS API がないと何もできません。)  ウィジェットの manifest.json で jimu-arcgis 依存関係を宣言します。 widget.tsx で必要なモジュールをインポート import Query = require('esri/tasks/support/Query') します。    const query = new Query({ where: `${typeIdField}= ${graphic.attributes[objectIdField]}`, outFields: [\u0026#39;FirstName\u0026#39;], returnGeometry: true })  条件付きで JS API に依存するウィジェット (例：JS API が無くても何かを実行することはできます。)  import {loadArcGISJSAPIModules}とloadArcGISJSAPIModules([]) を使用してモジュールを動的にロードします。    loadArcGISJSAPIModules([\u0026#39;esri/widgets/Directions\u0026#39;]).then(modules =\u0026gt; { [this.Directions] = modules; this.setState({ apiLoaded: true }); }) インライン編集をサポート 構成可能なすべてのウィジェットは、ウィジェットの構成を可能にする設定ページを提供する必要があります。ただし、構成によっては、設定パネルよりもウィジェットの設定を変更する方が簡単な場合があります。このワークフローでは、ウィジェットはインライン編集機能を提供することで、この機能をサポートすることができます。\nインライン編集を実装する方法はいくつかあります。\n ウィジェットの manifest.json の properties オブジェクトに supportInlineEditing を宣言します。このインスタンスでは、ウィジェットが Builder で起動されたときにウィジェットに編集ツールバーが表示されます。Text ウィジェットはこのように実装されています。 ウィジェットの manifest.json の properties オブジェクトに hasEmbeddedLayout を宣言します。この場合、ユーザーが他のウィジェットをウィジェットの中でドラッグ＆ドロップできるようにするために、レイアウト コンポーネントを使用することをお勧めします。jimu-layouts/layout-builder と jimu-layouts/layout-runtime からエクスポートされた 2 つのレイアウト コンポーネントがあります。ウィジェットでは、jimu-layouts/layout-runtime からエクスポートされたレイアウトコンポーネントを使用する必要があります。jimu-layouts/layout-builder からエクスポートされたコンポーネントにアクセスするには、this.props.builderSupportModules.LayoutClass を使用します。List ウィジェットはこの手法を使っています。 ウィジェットの manifest.json で CONTEXT_TOOL 拡張機能を宣言します。宣言した拡張機能は選択ツールバーで利用できるようになります。Image ウィジェットは、このように選択ツールバーに shape ツールや crop ツールを追加して使用します。  インライン編集をサポートするために、ウィジェットは Builder でウィジェットを起動した時にのみ必要なモジュールが含まれている場合があります。このシナリオでは、これらのモジュールを builder-support.tsx に配置します。このファイルは widget.tsx と同じフォルダにあるはずです。このファイル内のモジュールは、ウィジェットが Builder で起動されると、this.props.builderSupportModules.widgetModules 内で利用できるようになります。\nベストプラクティス  ウィジェットのクラス名として widget-\u0026lt;widget name\u0026gt; を、ウィジェット設定のクラス名として widget-setting-\u0026lt;widget name\u0026gt; を使用して、ウィジェットのルート CSS クラス名を指定します。 サードパーティの内蔵ライブラリをロードするには import {} from 'jimu-core' を使います。例えば、import {React} from 'jimu-core から {React} をインポートします; import {} from '3rd_lib' を使うと、lib がウィジェットに組み込まれるので、ウィジェットのサイズは大きくなります。 widget の src フォルダに Typesafe 設定ファイルを作成し、widget.tsx と setting.tsx の両方で使用します。 可能な限りアウトオブボックスの UI コンポーネントを活用して、ウィジェット UI を作成する方法の詳細をご覧ください。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/javascript/custom-font/",
	"title": "カスタム フォント",
	"tags": [],
	"description": "独自のフォントを使用する手順を紹介します。",
	"content": "ArcGIS Maps SDK for JavaScript のバージョン 4.10 以降、MapView 上のフィーチャ レイヤーのラベルやテキスト シンボルで使用するフォントは、pbf (Protocolbuffer Binary Format) で配信する必要があります。 デフォルトでは、pbf フォントは Esri が https://static.arcgis.com/fonts でホストしているフォントを使用できます。 利用可能なフォントの一覧は、Esri のガイドで確認できます（\u0026ldquo;Read more\u0026rdquo; をクリックしてページを展開してください）。\nデフォルトで提供されていないフォントを使用したい場合は、自身で pbf フォントを作成し Web サーバーで配信することで、API から使用することができます。このガイドでは ArcGIS Maps SDK for JavaScript バージョン 4.x で独自のフォントを使用する手順を紹介します。\n※ 本ガイドでご紹介する手順に関しては ESRIジャパンの技術サポート サービスの対象外となります。予めご了承ください。また、フォントの変換・配置を行う場合は、利用されるフォントの利用規約を予めご確認ください。\nフォントの入手 今回は、Google フォント からダウンロードして PBF に変換します。\npbf フォントの作成 pbf ファイルは符号付き距離フィールドのセットとして以下の URL で配信する必要があります。これは MapBox GL JS のスタイル仕様と同じです。\nhttps://fonts/\u0026lt;フォントスタック\u0026gt;/\u0026lt;ユニコード文字範囲\u0026gt;.pbf\npbf ファイルは node-fontnik を使用して、ttf や otf 等のフォントファイルから変換して作成できます。\n node-fontnik をクローンします。  git clone https://github.com/mapbox/node-fontnik.git\r node-fontnik フォルダに移動して、モジュールをインストールします。  npm install\r fonts フォルダを作成し、作成したフォルダにダウンロードした Google フォントを配置します。 glyphs フォルダと変換後のファイルを出力するサブフォルダ（例: glyphs/KosugiMaru-Regular）を作成します。 build-glyphs を実行して pbf ファイルを作成します。  node-fontnik/bin/build-glyphs fonts/KosugiMaru-Regular.ttf glyphs/KosugiMaru-Regular\r glyphs/KosugiMaru-Regular フォルダにユニコード文字範囲の pdf ファイル群が作成されていることを確認します。  PBF フォントの配置 以下のディレクトリ構成にして Web サーバーへ配置します。 IIS を使用する場合は、MIME に .pbf (binary/octet-stream) を登録します。\n「fonts」 フォルダ\n|\u0026ndash;「\u0026lt;フォントファミリー\u0026gt;-\u0026lt;ウェイト\u0026gt;-\u0026lt;スタイル\u0026gt;」フォルダ（例：arial-bold-italic） ※\n|\u0026ndash; pbf ファイル群\n※ \u0026lt;スタイル\u0026gt; は省略可能です。今回は「KosugiMaru-Regular」フォルダを作成します。 詳細は「API の設定」の項目を参照してください。\nAPI の設定   ArcGIS Maps SDK for JavaScript で参照するフォント リソースの URL を変更します。 フォントの URL の設定は、esri/config クラスの fontsUrl プロパティを使用します。\n  マップに表示するフォントを作成します。 フォントの作成は Font クラスを使用します。 family、weight、style の各プロパティに設定した値をもとに設定したフォント URL へリクエストが実行されます。 例えば、family に \u0026ldquo;arial\u0026rdquo;、weight に \u0026ldquo;bold\u0026rdquo;、style に \u0026ldquo;italic\u0026rdquo; を設定した場合は、https://\u0026lt;サーバー名\u0026gt;/fonts/arial-bold-italic フォルダにある pbf ファイルを取得します。 フォントに複数スタイルが存在しない場合は style プロパティは省略可能です。 また、weight プロパティも省略可能ですが、API で指定しない場合は regular が自動で設定され、https://\u0026lt;サーバー名\u0026gt;/fonts/arial-regular がリクエストされます。\n  以下は作成した pbf フォントをテキスト シンボルで表示した画面とサンプルコードです。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;initial-scale=1,maximum-scale=1,user-scalable=no\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;font_mapView\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://js.arcgis.com/4.11/esri/themes/light/main.css\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; html, body, #viewDiv { padding: 0; margin: 0; height: 100%; width: 100%; background-color: black; } \u0026lt;/style\u0026gt; \u0026lt;script src=\u0026#34;https://js.arcgis.com/4.11/\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; require([ \u0026#34;esri/Map\u0026#34;, \u0026#34;esri/views/MapView\u0026#34;, \u0026#34;esri/Graphic\u0026#34;, \u0026#34;esri/config\u0026#34; ], function(Map, MapView, Graphic, esriConfig) { // .pbfファイルを独自に配信するURL  esriConfig.fontsUrl = \u0026#34;http://\u0026lt;サーバー名\u0026gt;/fonts\u0026#34;; // テキストシンボルの作成  var textSymbol = { type: \u0026#34;text\u0026#34;, color: \u0026#34;white\u0026#34;, text: \u0026#34;KosugiMaru フォントです\u0026#34;, // 表示する文字列  font: { size: 15, family: \u0026#39;KosugiMaru\u0026#39; // フォントファミリー  } }; var point = { type: \u0026#34;point\u0026#34;, longitude: 139.751068, latitude: 35.684482 }; var pointGraphic = new Graphic({ geometry: point, symbol: textSymbol }); var map = new Map({ basemap: \u0026#34;dark-gray-vector\u0026#34; }); const view = new MapView({ container: \u0026#34;viewDiv\u0026#34;, map: map, center: [139.751068, 35.684482], zoom: 12 }); view.graphics.add(pointGraphic); }); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;viewDiv\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/samples/",
	"title": "サンプル集",
	"tags": [],
	"description": "開発にすぐに使えるサンプル データ/コードを紹介します。",
	"content": "開発にすぐに使えるサンプル データ/コードを紹介します。\nサンプル データ 開発でサンプルとして利用可能なデータです。以下は抜粋ですので、他のサンプル データを探したい場合は、マップ ビューアーでレイヤー検索してみてください。\n マップ  Web マップ（ArcGIS for Developers 開発ガイドのサンプル Web マップ）   フィーチャ レイヤー  tokyo_23（東京都における東京23区、市部、町村部（郡部）（町村部（島部）以外））   タイル レイヤー  南海トラフ巨大地震の被害想定（震度/最大クラス） 南海トラフ巨大地震の被害想定（液状化/最大クラス）    サンプル コード GitHub にて開発サンプルとなるソースコードを公開しています。\n JavaScript  arcgis-samples-js: ArcGIS API for JavaScript のサンプル集 data-visualization-js: JavaScript で始めるデータ ビジュアライゼーションのサンプル webmap-startup-template-js: Web マップを使用した開発手法を伝えるためのアプリケーション テンプレートのサンプル   .NET  arcgis-samples-dotnet: ArcGIS Runtime SDK for .NET のサンプル集 startup-sample-dotnet: .NET SDK のスタートアップ サンプル アプリケーション webmap-startup-template-dotnet: Web マップを使用した開発手法を伝えるためのアプリケーションのサンプル   Android  arcgis-samples-android: ArcGIS Runtime SDK for Android のサンプル集   iOS  arcgis-samples-ios: ArcGIS Runtime SDK for iOS (Objective-C/Swift) のサンプル集 startup-swift-ios: iOS SDK のスタートアップ サンプル アプリケーション   Python  arcgis-samples-python-api    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/theme/",
	"title": "テーマ（Theme）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Theme\nテーマ（Theme） テーマは、エクスペリエンスの外観と使用感を定義します。エクスペリエンスは、すぐに使える (OOB) テーマがあり、カスタムテーマの作成も可能です。テーマ開発については、theme development をご覧ください。\napp config では、アプリが使用するテーマは theme で定義されます。テーマをカスタマイズした場合、そのカスタマイズ内容は customTheme に保存されます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/appstudio/",
	"title": "ArcGIS AppStudio",
	"tags": [],
	"description": "ArcGIS AppStudio を使用したアプリ作成に役立つガイド集です。",
	"content": "ArcGIS AppStudio を使用したアプリ作成に役立つガイド集です。\nArcGIS AppStudio は2025年1月末日でサポートが終了します。ArcGIS AppStudio のサポートおよび移行に関する情報についてはこちらをご参照ください。\n\r  ガイド\n AppStudio の概要からアプリの作成・デプロイ、AppStudio Player を使用したモバイル デバイスでのテスト、カスタマイズ方法等を紹介したガイドです。    AppStudio Framework API リファレンス（英語）\n AppStudio Framework API は、ファイルパスの管理、ネットワーク インターフェース、画像操作などの、プラットフォーム共通の基本機能を提供しています。    ユースケース\n ギャラリー（英語）  全世界のユーザーによって作成されたアプリと利活用方法が紹介されています。   国内事例  日本国内での事例を紹介しています。      システム要件\n システム要件（米国Esri社）  AppStudio のデスクトップ用のアプリ、AppStudio Player のサポート OS 等のシステム要件が記載されています。   システム要件（Esriジャパン）  日本国内での固有のシステム要件を記載しています。      ライセンス\n AppStudio の 2 つのライセンス オプション（「ArcGIS AppStudio」と「ArcGIS AppStudio Developer Edition」）について紹介しています。    ダウンロード\n AppStudio のデスクトップ用のアプリ、AppStudio Player はこちらからダウンロード（無償）できます。    インストール\n AppStudio のデスクトップ用のアプリ、AppStudio Player のインストール方法を紹介しています。    チュートリアル\n アプリの作成からデプロイまでの手順を示したチュートリアルです。はじめての方はこちらのチュートリアルをお試しください。 コーディングによるカスタマイズのチュートリアルは、ハイカー向けアプリの構成 をお試しください。AppStudio の Nearby（近傍）テンプレートを使用したアプリ作成のチュートリアルで、最後にコーディングによるカスタマイズを行います。    その他\n  FAQ（米国Esri社）\n よくあるご質問とその回答が記載されています。    Esri Community（英語）\n 全世界のユーザーが投稿した製品に関する質問等の投稿を確認できます。    その他の Tips\n アプリ作成に関する技術的な情報を紹介しています。      "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/widget-ui/",
	"title": "ウィジェット UI の作成",
	"tags": [],
	"description": "ウィジェット UI の作成方法について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Create UI for widget\nExperience Builder のベースとなる Widget クラスは、React のコンポーネントサブクラスから拡張されています。PureComponent から拡張されており、render() と呼ばれる関数を提供しています。UI の作業のほとんどは、この関数の内部で行われることが予想されます。\nJSX の記述 UI テンプレートの作成に使用される React の構文は JSX と呼ばれています。これは HTML を書くのと非常に似ていますが、JavaScript の機能を完全に組み込んでいます。\nJSX の詳細を参照してください。\nここでは、ウィジェットの UI にいくつかの基本的な HTML 要素を追加する簡単な例を示します。\n// in widget.tsx: import { React, AllWidgetProps } from \u0026#39;jimu-core\u0026#39;; export default class Widget extends React.PureComponent\u0026lt;AllWidgetProps\u0026lt;{}\u0026gt;, any\u0026gt;{ render() { return \u0026lt;div className=\u0026#34;myWidget\u0026#34;\u0026gt; \u0026lt;p\u0026gt;This is a sample widget\u0026lt;/p\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; style={{background: \u0026#39;orange\u0026#39;}}\u0026gt;I\u0026#39;m a button\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;; } } Output 例: Jimu UI ライブラリの使用 Jimu フレームワークは、開発者がウィジェット開発で使用するコンポーネントの UI ライブラリを提供しています。\n 基本的な UI コンポーネント: button, dropdown, form controls, icon, navigation, modal, grid layout container など 高度な UI コンポーネント: date picker, resource selector, expression builder など  内部的には、Jimu の UI コンポーネントは Reactstrap と呼ばれる React Bootstrap フレームワークから拡張・カスタマイズされています。このライブラリは、他の類似した React UI ライブラリと同様に、コンポーネントの使用方法についても同様のパターンを踏襲しています。\n一般的に使用されているコンポーネントやアイコンのほとんどは、Storybookのサイト (https://localhost:3001/storybook/index.html) にアクセスしてプレビューすることができます。\nExperience Builder の Storybook の詳細を参照してください。\nJimu UI は Experience Builder の公式 UI ライブラリであり、このライブラリのコンポーネントを考慮して UI 開発を利用することを強くお勧めします。その理由は以下の通りです。\n UI/UX の一貫性: ウィジェットの全体的な外観と操作感、それを使って作成されたアプリは、一貫したパターンに従います。 テーマ性：コンポーネントのスタイルは設定可能でテーマ性があるため、さまざまなテーマに対応したウィジェットを簡単に作ることができます。 Experience Builder および ArcGIS とのより良い統合が実現できます。  UI コンポーネント コンポーネントのインポート 基本的な UI コンポーネントは「jimu-ui」から直接インポートでき、高度な UI コンポーネントはパスを使用して個別にインポートする必要があります。\nimport { Button, Icon, TextInput } from \u0026#39;jimu-ui\u0026#39;; // basic import { DatePicker } from \u0026#39;jimu-ui/date-picker\u0026#39;; // advanced クイック サンプル ここでは、\u0026ldquo;primary\u0026rdquo; スタイルの Button コンポーネントとスターアイコンをウィジェットに追加しています。\n// in widget.tsx: import { React, AllWidgetProps } from \u0026#39;jimu-core\u0026#39;; import { Button, Icon } from \u0026#39;jimu-ui\u0026#39;; // import components  // Create an svg icon using Icon component: const iconNode = \u0026lt;Icon icon={require(\u0026#39;jimu-ui/lib/icons/star.svg\u0026#39;)} /\u0026gt;; export default class Widget extends React.PureComponent\u0026lt;AllWidgetProps, any\u0026gt;{ render(){ // Add Button component containing an icon to the widget:  return \u0026lt;Button type=\u0026#34;primary\u0026#34;\u0026gt;{iconNode} primary button\u0026lt;/Button\u0026gt;; } } Output 例: CSS ユーティリティクラス Jimu UI は、Bootstrap と同じ CSS ユーティリティクラスを提供しており、UI 要素に素早くスタイルを適用することができます。\nクイック サンプル ここでは w-100、p-3、bg-primary、text-white を追加して要素を作成しています。\n 親要素の幅を 100% に設定 1 rem の padding（パディング）を設定 背景色を テーマの primary color として設定 テキストカラーを テーマの white color として設定  // in the render() function:  return \u0026lt;div className=\u0026#34;w-100 p-3 bg-primary text-white\u0026#34;\u0026gt; \u0026lt;p\u0026gt;This is a sample widget\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;; Output 例: ウィジェット スタイル設定 Experience Builder では、ウィジェットのスタイルを設定するには 3 つのオプションがあります。\nインライン CSS React のコンテキストでは、インラインの CSS スタイルは JavaScript オブジェクトとして記述され、DOM 要素の style 属性に適用されます。\n// in the render() function: const containerStyle = { background: \u0026#39;darkblue\u0026#39;, color: \u0026#39;white\u0026#39;, width: 200, height: 150, padding: \u0026#39;1rem\u0026#39;, borderRadius: 5 }; return \u0026lt;div style={containerStyle} // CSS styles applied \u0026gt; content \u0026lt;/div\u0026gt;; Output 例: 外部 CSS スタイルシート 別の方法としては、外部スタイルシートのファイルで CSS スタイルを定義し、ウィジェット内で個別にインポートする方法があります。使用できるスタイルシートのファイルの拡張子は .css、.sass、および .scss です。\n先ほどのコードサンプルを例に、CSS スタイルを別のスタイルシート (例: style.css) に移動します。\n/* style.css */ .my-widget { background: \u0026#39;darkblue\u0026#39;; color: \u0026#39;white\u0026#39;; width: 200px; height: 150px; padding: \u0026#39;1rem\u0026#39;; border-radius: 5px; } としてウィジェットにファイルをインポートします。\n// widget.tsx: import \u0026#39;path/to/style.css\u0026#39;; そして、style.css で定義されている DOM 要素にクラス名を追加することを忘れないでください。\n// widget.tsx: // in the render() function: return \u0026lt;div className=\u0026#34;my-widget\u0026#34;\u0026gt; content \u0026lt;/div\u0026gt;; Output 例: CSS-in-JS (推奨) CSS-in-JS とは、ベンダープレフィックス、スコープ付き CSS、JS ロジック、テーマ機能など、CSS では解決できない問題に対処するために JavaScript で CSS を書く方法のことを指します。\nStyled Components や Emotion など、よく知られている CSS-in-JS のライブラリがたくさんあります。Experience Builder では、スタイリングとテーマ設定を目的としたフレームワークとして Emotion を使用しています。\nEmotion には 2 つのスタイリング パターンがあります。\n1. css prop Emotion の css prop を使うと、React のスタイルプロップに比べて、より自然で親しみやすい方法で CSS スタイルを書くことができます。CSS スタイルは template literals で書くことができるので、CSS の中に JS ロジックを書くことができます。\n例えば、以下のサンプルの Counter ウィジェットは、カウント値が 2 以上になるとテキストの色が赤から緑に変わります。\n/// widget.tsx: /** @jsx jsx */ // \u0026lt;-- make sure to include the jsx pragma import { React, AllWidgetProps } from \u0026#39;jimu-core\u0026#39;; import { css, jsx } from \u0026#39;jimu-core\u0026#39;; import { Button, ButtonGroup } from \u0026#39;jimu-ui\u0026#39;; interface State { count: number; } export default class Widget extends React.PureComponent\u0026lt;AllWidgetProps\u0026lt;{}\u0026gt;, State\u0026gt;{ constructor(props) { super(props); this.state = { count: 0, }; } render() { const numberStyle = css` font-size: 2.5rem; color: ${this.state.count \u0026gt; 2 ? \u0026#39;green\u0026#39; : \u0026#39;red\u0026#39;}; `; return \u0026lt;div className=\u0026#34;text-center\u0026#34;\u0026gt; \u0026lt;p css={numberStyle}\u0026gt;{this.state.count}\u0026lt;/p\u0026gt; \u0026lt;ButtonGroup\u0026gt; \u0026lt;Button type=\u0026#34;secondary\u0026#34; onClick={e =\u0026gt; {this.setState({ count: this.state.count - 1 })}}\u0026gt; - \u0026lt;/Button\u0026gt; \u0026lt;Button type=\u0026#34;secondary\u0026#34; onClick={e =\u0026gt; {this.setState({ count: this.state.count + 1 })}}\u0026gt; + \u0026lt;/Button\u0026gt; \u0026lt;/ButtonGroup\u0026gt; \u0026lt;/div\u0026gt;; } } Output 例: 2. Styled Components このパターンは Styled-Components ライブラリにインスピレーションされたもので、使い方は非常に似ています。\u0026ldquo;styled\u0026rdquo; アプローチは、ウィジェット内で再利用可能なコンポーネントを作成するのに最適です。\n/** @jsx jsx */ // \u0026lt;-- make sure to include the jsx pragma import { React, AllWidgetProps } from \u0026#39;jimu-core\u0026#39;; import { styled, jsx } from \u0026#39;jimu-core\u0026#39;; // A styled button component: const StyledButton = styled.button` color: white; background-color: blue; transition: 0.15s ease-in all; \u0026amp;:hover { background-color: darkblue; } `; export default class Widget extends React.PureComponent\u0026lt;AllWidgetProps\u0026lt;{}\u0026gt;\u0026gt;{ render() { return \u0026lt;StyledButton\u0026gt; A styled HTML Button \u0026lt;/StyledButton\u0026gt;; } } Output 例: 3. テーマを使った作業 これは、ウィジェットをアプリケーションの他の部分と一貫して見えるようにしたい場合や、テーマが変更されたときに自動的にルック＆フィールを更新したい場合に必要です。\nExperience Builder フレームワークは、テーマ変数を JSON オブジェクトとして提供し、それをプロパティとしてウィジェットに挿入します。色、フォント、サイズ、コンポーネントなど、すべてのテーマ変数にアクセスできます。\nウィジェット内のテーマ変数にアクセスし、CSS 宣言でそれらを参照するには this.props.theme を使用します。例えば、以下のようになります。\n/** @jsx jsx */ // \u0026lt;-- make sure to include the jsx pragma import { React, AllWidgetProps } from \u0026#39;jimu-core\u0026#39;; import { css, jsx } from \u0026#39;jimu-core\u0026#39;; export default class Widget extends React.PureComponent\u0026lt;AllWidgetProps\u0026lt;{}\u0026gt;\u0026gt;{ render() { const theme = this.props.theme; const style = css` background: ${theme.colors.palette.primary[100]}; color: ${theme.colors.black}; padding: ${theme.sizes[3]}; `; return \u0026lt;div css={style}\u0026gt; \u0026lt;p\u0026gt;This is a sample widget\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;; } } Output 例: default theme vs. dark theme\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/widget/",
	"title": "ウィジェット（Widget）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Widget\nウィジェット（Widget） ウィジェットは設定可能な機能単位で、エクスペリエンスなページを作成するために使用されるビルディングブロックです。Experience Builder は、マップ、ボタン、リストなどのすぐに使える（OOB）ウィジェットが用意されており、カスタムウィジェットを作成することも可能です。ウィジェットは通常、ユーザーがビルダー環境で機能を設定できるように設定UIを提供します。ウィジェットに設定可能なオプションがありますが、設定 UI が含まれていない場合は、JSON エディタを使用して設定することが可能です。\nウィジェットの実装についてはこちらをご覧ください。\napp config では、widgets でウィジェットを定義します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/other/hackathon/",
	"title": "ミートアップ",
	"tags": [],
	"description": "ミートアップ参加者を支援するリソースをまとめています。",
	"content": "ミートアップ参加者を支援するリソースをまとめています。\nオープンデータを入手する ArcGIS Open Data では ArcGIS のクラウドで公開されている全世界のオープンデータを検索・参照・ダウンロードが可能です。 自由に使える地理データを取得する方法を紹介します。\n オープンデータの入手 (ArcGIS Open Data コミュニティサイト)  地図にデータを可視化する 座標情報を持った地理データや住所情報を持ったテキストデータなどを可視化して、アプリに組み込むための地図を作成する方法や Tips を紹介します。 なお、データ可視化の作業はコーディングが不要なので、プランナーやデザイナーの方でも取り組んでいただくことができます。\n データ可視化のワークフロー データ可視化の手順 データ可視化の手順（3D） 地図上に賢くデータを可視化するための 6 つの方法  アプリに地図を組み込む アプリに ArcGIS の地図を組み込む際に便利な開発キットやライブラリです。アプリ作成ツールを活用することで、ノンコーディングでアプリを作成することも可能です。\nコードを書く JavaScript  ArcGIS Web API: リファレンス (英語) | 日本語ガイド Leaflet.js (Esri Leaflet): リファレンス (英語) | 日本語ガイド(ブログ記事)  Android  ArcGIS Runtime SDK: リファレンス (英語) | 日本語ガイド  iOS  ArcGIS Runtime SDK: リファレンス (英語) | 日本語ガイド  .NET  ArcGIS Runtime SDK: リファレンス (英語) | 日本語ガイド  コードを書かない アプリケーション ビルダー  Web AppBuilder for ArcGIS: リファレンス | 日本語ガイド  ストーリーマップ  ストーリーマップ: リファレンス  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/calcite-design-system/",
	"title": "Calcite Design System",
	"tags": [],
	"description": "Calcite Design System の開発に役立つガイド集です。",
	"content": "Calcite Design System の開発に役立つガイド集です。\nCalcite Design System は、最小限の労力で、アプリ間で美しく、使いやすく、まとまりのある体験を生み出すためのデザインおよび開発リソースを集めたものです。UI キット、アイコン、カラー スキーム、そしてボタン、パネル、アコーディオン、アラートなどの UI 要素を含む Web コンポーネントライブラリが含まれています。\nどこから始めるか Calcite Design System で、一貫性のある考慮された体験を構築します。\n はじめに\n次の手順に従って、すぐに Calcite Components を使い始めることができます。\n\r コア コンセプト\nWeb コンポーネントを活用するための基本的な概念とパターンを学びます。\n\r チュートリアル\nCalcite の開発パターンを学び、ワークフローやアプリケーションを構築します。\n\r\rDesign System Calcite Design System の基礎、包括的なコンポーネント ライブラリ、およびガイド リソースをご覧いただけます。\n  基礎編（英語）  アクセシブルなアプリケーションを構築し、テーマやアイコンを使って製品をカスタマイズすることができます。\n  コンポーネント（英語）  一貫したユーザビリティを実現するためのインタラクティブな Web コンポーネント群です。\n  リソース（英語）  UI キット、フレームワークの統合、ローカライゼーションのガイダンス、コミュニティとサポートにアクセスできます。\n  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/jimu/",
	"title": "Jimu",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Jimu\nJimu Jimu は、設定可能なエクスペリエンスを作成するために使用されるJavaScript ライブラリで、以下のようなパッケージで構成される拡張フレームワークです。\n jimu-core パッケージは、アプリの設定をロードして解析し、アプリの設定に基づいてレイアウト、テーマ、ウィジェットをロードします。これをサポートするために、本パッケージは WidgetManager、ConfigManager、ThemeManager などのいくつかのクラスを定義しています。また、jimu-core はウィジェットのインターフェイス、いくつかの共通型、およびいくつかの拡張ポイントを定義していますが、これらは他のパッケージやウィジェットにより拡張される可能性があります。 jimu-layouts パッケージは、レイアウト ウィジェットのための、一般的な実装が含まれています。 jimu-ui パッケージは、エクスペリエンスが利用するすべての UI コンポーネントが含まれています。より詳しくは、reactstrap と emotion-js を使用しています。さらに reactstrap に含まれていない、より多くのコンポーネントが追加されています。読み込みサイズを小さくするために、コンポーネントはindex、setting-components、sql-expression-builder などのいくつかのエントリに分割されています。詳細はAPIを参照してください。 jimu-arcgis パッケージは、ArcGIS Maps SDK for JavaScript 4.x を実行するために必要なすべてのコンポーネントが含まれています。 jimu-for-builder パッケージは、ウィジェットの設定ページの開発をサポートしています。  これらのパッケージは同じ構造パターンを使用しているため、同じベストプラクティスに沿って使用することができます。各パッケージは import するためのいくつかのエントリを定義し、これらのエントリはパッケージのルートフォルダの下に置かれます。lib フォルダ内のコンテンツは，パッケージの内部コンテンツとみなされますので，ウィジェットには import しないでください。例えば、jimu-ui の Button コンポーネントを使用する必要がある場合は、import {Button} from 'jimu-ui' ではなく、import {Button} from 'jimu-ui/lib/components/button' のようにインポートする必要があります。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/use-data-source-in-widget/",
	"title": "ウィジェットでデータソースを使用",
	"tags": [],
	"description": "ウィジェットでデータソースを使用する方法について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Use data source in widget\nデータソースは、ウィジェットがデータにアクセスする方法を定義します。データソースを使用して行いたいことは様々ですが、それぞれについて紹介します。\n ウィジェットの設定でデータソースを選択 ウィジェット ランタイムのデータを読み込んで表示 ユーザー入力に基づくデータのフィルタリングやクエリ データ上の選択を処理 ArcGIS Maps SDK for JavaScript のフィーチャ オブジェクトとデータソースの同期 ウィジェットで出力データソースの生成 ウィジェットでメッセージの公開  本ドキュメントで使用している appConfig という変数は、アプリの config JSON オブジェクトを指します。ArcGIS Online または Enterprise 版では、アプリの config JSON はアイテム データとして保存され、Developer Edition では server/public/apps/[appId]/config.json (公開版) または server/public/apps/[appId]/resources/config.json (ドラフト版) の下に保存されます。\n\rウィジェットの設定でデータソースを選択 ウィジェットの設定でデータソースを選択するには、DataSourceSelector コンポーネントを使用する必要があります。Experience Builder は、複数の種類のデータソースをサポートしています。これらのデータソースは jimu-core と jimu-arcgis の 2 つのパッケージに入っています。jimu-core の DataSourceTypes と jimu-arcgis の DataSourceTypes をご覧ください。jimu-arcgis のデータソースは ArcGIS Maps SDK for JavaScript に依存しており、jimu-core のデータソースは依存していません。\nDataSourceSelector コンポーネントを使用するには、types プロパティを通じてウィジェットがサポートするデータソースの種類を設定する必要があります。データソースを選択した後、onChange コールバックにより選択されたデータソースを取得することができます。onChange コールバックでは、props.onSettingChange() を呼び出して、選択したデータソースを appConfig に保存する必要があります (appConfig.widgets[widgetId].useDataSources)。ユーザーが新しいデータソースを追加した場合、新しく追加されたデータソースは appConfig.dataSources に保存されます。こちらのサンプルウィジェットを参照してください。\n\u0026lt;DataSourceSelector types={Immutable([AllDataSourceTypes.FeatureLayer])} useDataSources={props.useDataSources} useDataSourcesEnabled={props.useDataSourcesEnabled} onToggleUseDataEnabled={onToggleUseDataEnabled} onChange={onDataSourceChange} widgetId={props.id} /\u0026gt; データソースを選択した後、ユーザーがデータからフィールドを選択できるようにしたい場合があります。そのためには、FieldSelector コンポーネントを使用します。データソースと同様に、appConfig.widgets[widgetId].useDataSources にも選択したフィールドを保存する必要があります。\n{ props.useDataSources \u0026amp;\u0026amp; props.useDataSources.length \u0026gt; 0 \u0026amp;\u0026amp; \u0026lt;FieldSelector useDataSources={props.useDataSources} onChange={onFieldChange} selectedFields={props.useDataSources[0].fields || Immutable([])} /\u0026gt; } ウィジェット ランタイムのデータを読み込んで表示 ウィジェット設定でデータソースを選択すると、ウィジェットランタイムは props.useDataSources で選択したデータソースを取得することができます。データを読み込むには、DataSource インスタンスを使用します。DataSource インスタンスを取得するには、DataSourceManager またはDataSourceComponent を使用します。DataSourceComponent を使用する場合は、useDataSource プロパティを渡します。DataSource インスタンスを取得するには、onDataSourceCreated コールバックを使用します。\nデータを読み込むには、render 関数を使用してデータを表示します。こちらのサンプルウィジェットを参照してください。別の方法として、onDataSourceInfoChange コールバックを使用し、データソースの現在のデータに応じてこのコールバック関数でウィジェットの UI を更新することができます。ウィジェットがデータをロードする必要がある場合、query と widgetId プロパティを渡します。フレームワークは、複数のウィジェットが同じデータソースに適用するクエリパラメータを管理するのにこのプロパティを使用するため、widgetId は必須です。\nデータをロードしたいが、データソースのデータを変更したくない場合は、localId プロパティを渡します。これにより、ローカルデータソースが作成され、使用することができます。推奨される localId のパターンは、例えば、widget_1_my_local のように widgetId + ??? とします。\nDataSourceComponent をレンダリングすると、データソースのインスタンスが作成されますが、データは初期状態ではロードされません。なぜなら、query プロパティを渡すことを期待しているので、別のネットワーク要求が発生するためです。読み込まれたデータを取得するには、dataSource.getRecords() を使用します。データはページングされ、デフォルトのページングサイズは 100 です。ユーザーはビルダーデータ設定パネルでページングサイズを変更することができます。ロードされたデータはクライアント上にキャッシュされ、クエリ条件が変更されるとキャッシュはクリアされます。\nデータを表示する際、表示されるページサイズはクエリのページサイズと同じである必要はありません。例えば、クエリのページサイズが 100 の場合、dataSource.getRecordsByPage(1, 10) を使用して、最初の 10 レコードを取得して表示することが可能です。\nレコードの総数を取得するには、queryCount プロパティを渡し、dataSource.count で件数を取得します。\nデータソース情報が変更されるたびに、データレンダリング関数とonDataSourceInfoChange コールバックが呼び出されます。情報の内容は以下の通りです。\n instanceStatus: データソースのインスタンスが正常に作成されたかどうか status: データがロード中か、ロードされたか countStatus: データのカウントがロード中か、ロードされたか selectedIds: 選択されたデータ ID widgetQueries: データソースに適用されるクエリ(フィルタ)ウィジェット version: バージョン番号は、クライアント側でデータの変更を管理するために使用されます。そのため、データソース利用者はデータが変更されたことを認識することができます。 gdbVersion: ブランチ バージョニングをサポートするフィーチャ サービスのためのもの。ブランチ バージョン マネージメント ウィジェットでブランチ バージョンが切り替わると、そのバージョンがここに保存されます。  多くの場合、ウィジェットは現在のデータソース情報と以前の情報とを比較して、何を更新する必要があるかを判断する必要があります。\nウィジェットがデータソースの情報変更を聞く必要があるが、データソースのデータレコードを使う必要がない場合、query パラメータを省略し、onQueryRequired コールバックでクエリを実行することが可能です。\nデータソースのフィールドを取得するには、dataSource.getSchema().fields を使用します。\nユーザー入力に基づくデータのフィルタリングやクエリ ウィジェットがデータをフィルタリングすると、データソース インスタンスのデータが変更され、すべてのウィジェットがその変更を観察します。ウィジェットがデータソースを介してデータをクエリする場合、データソースインスタンスのデータは影響を受けません。\n複数のウィジェットが同じデータソースにフィルタを適用する場合、属性フィルタは and 演算子で結びつけられます。ジオメトリ フィルタの場合、最後にジオメトリ フィルタを適用したウィジェット (アプリ設定でのウィジェット追加順) からのフィルタが使用されます。\n  データソースにフィルタをかけるには、データソースの設定により、基本的に2つの方法があります。\n ウィジェットでデータを読み込む場合は、以下のようにDataSourceComponent を使うのがおすすめです。  \u0026lt;DataSourceComponent useDataSource={} widgetId={} query={}\u0026gt; { Your render method } \u0026lt;/DataSourceComponent\u0026gt; DataSourceComponent の使用例は、Message subscriber のサンプルと Server-side output data source のサンプルに記載されています。\ndataSource.load() を使用して、データの読み込みとフィルタリングも可能です。\n\r ウィジェットがデータを読み込まない場合は、Data Source の updateQueryParams() 関数を使用することができます。例として、Filter feature layer のサンプルをご覧ください。    データソースからデータをクエリするには、dataSource.query() を使用します。データをクエリする際には、このデータソースに適用されているフィルタも使用されます。\n  データ上の選択を処理 Experience Builder アプリで設計された選択の動作は、すべてのウィジェットが同じ選択を更新し、観察することです。例えば、ユーザーがリスト ウィジェット内のレコードを選択すると、選択ビューを使用しているテキスト ウィジェットにはその選択内容が表示されます。すべてのデータソースには、選択範囲を管理する選択範囲データ ビューがあります。選択データビューの他に、選択されたレコードの ID が Redux アプリストアに保存されるので、データソースを使用するウィジェットは、選択内容が変更されたときに通知を受けることができます。\nデータソース内のデータレコードを選択するには、dataSource.selectRecordById() または dataSource.selectRecordsByIds() を使用することができます。レコードがデータソースに読み込まれている場合は、2 番目のパラメータを渡す必要はありません。そうでない場合は、選択項目を使用する他のウィジェットがレコードを読み込めるようにするために、2 番目のパラメータを渡す必要があります。\n選択範囲を読み取るには、dataSource.getSelectedRecords() を使用します。\nWebMap/WebScene の使用 ArcGIS Maps SDK for JavaScript の WebMap と WebScene は、データソースとして jimu-arcgis パッケージでラッピングされています。WebMap にアクセスする場合は WebMapDataSource を、WebScene にアクセスする場合は WebSceneDataSource を使用します。これらのデータソースの使用方法については、MapView のサンプルをご覧ください。WebMap と WebScene オブジェクトに加えて、これらのオブジェクト内のすべてのレイヤーはデータソースとしてラッピングされているため、getChildDataSources() を呼び出してすべてのレイヤーデータソースを取得できます。サポートされるレイヤーとサービスは、SupportedLayerServiceTypes と SupportedServiceTypes で定義されています。\nFeatureLayer の使用 ワークフローによっては、フィーチャ レイヤーで直接動作する軽量なエクスペリエンスを作成する必要があります。このシナリオでは、FeatureLayerDataSource クラスを使用します。一般的に、スタンドアロン レイヤーを使用するウィジェットは、layer プロパティを持たない FeatureLayerDataSource オブジェクトを取得しますが、Web マップまたは Web シーンからのフィーチャ レイヤーを使用すると、layer プロパティを持つ FeatureLayerDataSource オブジェクトを返します。Layer オブジェクトは ArcGIS Maps SDK for JavaScript から提供されています。\nconst getLayerObject = (ds: FeatureLayerDataSource) =\u0026gt; { return ds.layer; // this can be null  } ウィジェット間のデータ共有 ウィジェットは、多くの場合、同じデータを共有します。この良い例が、エクスペリエンスでマップ ウィジェットとリスト ウィジェットを使用する場合です。リスト ウィジェットでフィーチャを選択すると、対応するフィーチャがマップ上で選択されます。これを実現する最も簡単な方法は、両方のウィジェットに同じデータソースを使用することです。たとえば、リスト ウィジェットでアイテムが選択されると、ウィジェットは datasource.selectRecord() を呼び出して、app store のデータソースの状態を更新します。これにより、マップ ウィジェットでは、現在選択されているアイテムを適宜レンダリングすることができます。また、現在選択されているアイテムの ID が URL に配置されるため、現在のアプリの状態を他の人と共有することが可能になります。\nArcGIS Maps SDK for JavaScript のフィーチャ オブジェクトとデータソースの同期 Experience Builder ウィジェットでは、ArcGIS Maps SDK for JavaScript を使用してフィーチャを取得することができます。その後、他のウィジェットがこれらのフィーチャを使用できるようにしたい場合があります。たとえば、マップ上でこれらのフィーチャをハイライト表示したり、リスト ウィジェットでこれらのフィーチャを表示したりする必要があるかもしれません。これには、以下の 3 つのオプションがあります。\n データソースでこれらのフィーチャ レコードを選択する  使用できるデータソース インスタンスがあれば、dataSource.selectRecordsByIds() を呼んでこれらのレコードを選択することができます。Graphic インスタンスを取得する場合は、まずFeatureRecord インスタンスを作成する必要があります。   ウィジェットから出力データソースを生成する  Widget output data source サンプルを参照してください。   メッセージを公開する  ウィジェットが何らかのフィーチャを生成する場合、DataRecordSetChangeMessage メッセージを公開することで、他のウィジェットがサブスクライブできるようになります。    MapView/SceneView または LayerView での作業 ウィジェットがデータソースと連動する場合、MapView/SceneView とも連動する必要がある場合が多くあります。ウィジェットが JimuMapViewComponent によってJimuMapView インスタンスを取得した後、jimuMapView.dataSourceId によって MapView/SceneView の対応するデータソースを取得し、jimuMapView.jimuLayerViews によって関連レイヤーを取得することができます。jimuLayerView インスタンスを介して、jimuMapView.dataSource によって、レイヤービューの対応するデータソースを取得することもできます。一般に、レイヤーからデータソースと同期する機能を取得するには、以下のオプションがあります。\n フィーチャの objectId を使用して、データソースから関連するデータレコードを検索 FeatureDataRecord インスタンスを作成し、そのフィーチャに対応するデータレコードを作成 FeatureDataRecord のインスタンスから、featureDataRecord.getFeature() でフィーチャを取得  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/widget-communication/",
	"title": "ウィジェット間の通信",
	"tags": [],
	"description": "ウィジェット同士がどのように相互に通信する方法について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Widget communication\nExperience Builder のウィジェットは、1 つの機能単位です。しかし、多くの場合、1 つのタスクを完了するために複数のウィジェットが一緒に動作する必要があるので、フレームワーク レベルでウィジェット同士がどのように相互に通信するかをサポートする必要があります。 以下の方法をサポートしています。\n  Message action (メッセージアクション): このメカニズムは、ウィジェット間の通信のための設定可能なソリューションです。詳細は Message action を参照してください。\n  Share state (状態の共有): このメカニズムは、ウィジェット間の通信のためのプログラミングを行います。ウィジェット間で state (状態) を共有するには、ウィジェットの state (状態) を使用する方法と、独自の Redux store/action/reducer を提供する方法の2つの方法があります。\n  ウィジェットの状態を使用してウィジェット間で状態を共有 React コンポーネントとしての Widget は内部 state (状態) を持つことができますが、他の Widget はこの state (状態) にアクセスすることができません。Jimu は state (状態) 管理 として Redux を使用しています。多くの情報を Redux store に保存します。情報の一つは widgetsState と呼ばれるもので、型の定義は jimu-core/lib/types/state にあります。widgetState に保存された情報は、他のすべてのウィジェットからアクセス可能です。widgetsState に情報を保存するには、以下のコードを参照してください。\nimport {appActions} from \u0026#39;jimu-core\u0026#39;; /* * Call this when you need to save state. * * widgetId: your widget id * propKey: can be a string with this format \u0026#34;a.b.c\u0026#34; * value: the info you want to store */ this.props.dispatch(appActions.widgetStatePropChange(widgetId, propKey, value)) 例えば、this.props.dispatch(appActions.widgetStatePropChange(\u0026quot;w1\u0026quot;, \u0026quot;a.b1\u0026quot;, \u0026quot;value1\u0026quot;)) と this.props.dispatch(appActions.widgetStatePropChange(\u0026quot;w1\u0026quot;, \u0026quot;a.b2\u0026quot;, \u0026quot;value2\u0026quot;)) を呼び出すと、Redux store でこの store の state (状態) が取得されます。\nwidgetsState: { w1: { a: { b1: \u0026#39;value1\u0026#39;, b2: \u0026#39;value2\u0026#39; } } } ウィジェット2 の w1 が格納した情報にアクセスするには、mapExtraStateProps を使用するか、useSelect hooks を使用して store から値を選択することができます。\nただし、widgetState にはプレーンな JavaScript オブジェクトのみを格納することができます。複雑な JavaScript オブジェクトを格納するには、this.props.dispatch(appActions.widgetMutableStatePropChange(widgetId, propKey, value)) を使用して値を格納し、MutableStoreManager.getInstance().getStateValue() を使用してアクセスすることができます。\nウィジェット間で状態を共有するための独自の redux store/action/reducer を提供します。 これにより、state (状態) 管理をより柔軟にカスタマイズすることができます。これは通常の Redux で行う方法とほぼ同じです。ご存知のように、Redux には 1 つの store と 1 つの root reducer があり、これは jimu によって使用されます。ウィジェット開発者が通常の Redux の方法で state (状態)を管理できるようにするために、jimu は ReduxStore 拡張ポイントを定義しています。Redux を使用する必要があるウィジェットはこの拡張ポイント用の拡張を提供できます。\n ReduxStoreExtension インターフェースを実装する拡張クラスを作成します。  import {extensionSpec} from \u0026#39;jimu-core\u0026#39;; export default class MyReduxStoreExtension implements extensionSpec.ReduxStoreExtension{ getActions(){ // return your redux actions.  } getInitLocalState(){ // return your redux init local state.  } getReducer(){ // return your redux reducer.  } getStoreKey(){ // return your redux local key.  } }  ウィジェットの manifest.json で拡張機能を宣言します。  \u0026#34;extensions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;My Store\u0026#34;, \u0026#34;point\u0026#34;: \u0026#34;REDUX_STORE\u0026#34;, \u0026#34;uri\u0026#34;: \u0026#34;my-store\u0026#34; } ] "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/widget-list/",
	"title": "ウィジェット一覧表",
	"tags": [],
	"description": "ArcGIS Web AppBuilder で提供されているウィジェットの一覧表です。",
	"content": "ArcGIS Web AppBuilder ウィジェット一覧表 ArcGIS Web AppBuilder（ArcGIS Online 版、ArcGIS Enterprise 版、Developer Edition 版 ※1）で提供されているウィジェットの一覧表です。\n表の「〇」をクリックすると、ウィジェットの詳細ページ（Web ガイド）にリンクします。\n 2D ウィジェット 3D ウィジェット 補足事項  2D ウィジェット    ウィジェット 機能概要 ArcGIS Online (2022 年 11 月アップデート) ArcGIS Enterprise バージョン 11.0 Developer Edition バージョン 2.26 ※1     情報ウィジェット 情報ウィジェットは、ウィジェットに表示するコンテンツを作成します。 〇 〇 〇   データ追加 データ追加ウィジェットを使用すると、ArcGIS Online または ArcGIS Enterprise のコンテンツからレイヤーを検索するか、URL を入力するか、ローカル ファイルをアップロードすることで、データをマップに追加できます。 〇 〇 〇   解析 解析ウィジェットを使用すると、アプリケーション内で ArcGIS Online または ArcGIS Enterprise の空間解析ツールを簡単に利用できます。 〇 〇 〇   属性テーブル 属性テーブル ウィジェットは、操作レイヤーの属性を表形式で表示します。 〇 〇 〇   属性一括編集 属性の一括編集ウィジェットではフィーチャ (関連フィーチャ、別のレイヤーに基づくフィーチャ、または図形内でスケッチしたフィーチャ) を選択し、共通属性を一括更新できます。 〇 〇 〇   ベースマップ ギャラリー ベースマップ ギャラリー ウィジェットには、ベースマップがギャラリー形式で表示され、ギャラリーの中から 1 つのベースマップを選択してアプリのベースマップにすることができます。 〇 〇 〇   ブックマーク ブックマーク ウィジェットには、アプリに表示されるマップ表示範囲 (空間ブックマーク) のコレクションが格納されます。 〇 〇 〇   Business Analyst Business Analyst ウィジェットを使用すると、マップ上のポイントまたはポリゴン フィーチャのレポートとインフォグラフィックスを実行することで、その詳細情報を表示することができます。 〇 〇 〇   チャート チャート ウィジェットには、操作レイヤーから取得された定量属性がデータのグラフィカルな表現として表示されます。 〇 〇 〇   コントローラー コントローラー ウィジェットはパネル内ウィジェット用のコンテナーです。ヘッダー構成とサイドバー構成という 2 種類のコントローラーが事前に組み込まれています。 〇 〇 〇   座標 座標ウィジェットは、マップ上に X と Y の座標値を表示します。 〇 〇 〇   座標変換 座標変換ウィジェットでは、1 つの座標系を使用する座標を入力し、複数の表記形式を使用する別の座標系に出力することができます。 〇 〇 〇   コスト解析 コスト解析ウィジェットを使用すると、作成する各フィーチャにコスト係数を割り当てることができます。 〇 〇 〇   データ集約 データ集約ウィジェットを使用すると、CSV (カンマ区切り値) ファイルに格納されている住所または座標情報から地理フィーチャを作成し、CSV ファイルとターゲット レイヤーのフィールド情報を関連付ける方法を定義できます。 〇 〇 〇   ルート案内 ルート案内ウィジェットは、2 つ以上の地点間のターンに基づくルート案内をすばやく効果的に算出する機能を提供します。 〇 〇 〇   地域検索 地域検索ウィジェットを使用すると、選択したポリゴンに関連するポイント フィーチャを検索したり、各フィーチャの詳細を表示したり、選択したポイント フィーチャへのルート案内を取得したりすることができます。 〇 〇 〇   距離と方向 距離と方向ウィジェットは、線、円、楕円、および範囲リングを描画し、重要な情報を視覚化できます。 〇 〇 〇   描画 描画ウィジェットでは、マップ上に任意のグラフィック (図形) を描画できます。 〇 〇 〇   編集 このウィジェットには、フィーチャ サービスのうち編集可能なレイヤーを編集する機能が含まれています。 〇 〇 〇   緊急時応急措置指針 ERG (緊急時応急措置指針) ウィジェットでは、危険物の流出の種類とユーザーが選択したマップ上の場所に基づいて、潜在的な危険を特定できます。 〇 〇 〇   範囲移動 範囲移動ウィジェットを使用すると、マップの前または次の範囲に移動することができます。 〇 〇 〇   フィルター フィルター ウィジェットを使用すると、レイヤー内のフィーチャの表示設定を制限できます。 〇 〇 〇   全画面 全画面ウィジェットでは、全画面モードを使用できます。 〇 〇 〇   ジオコーダー ジオコーダー ウィジェットは、検索ウィジェットに置き換えられました。検索ウィジェットの項目を参照してください。 〇 〇 〇   地理検索 地理検索ウィジェットは、マップ上のポリゴン フィーチャ レイヤーを使用して、CSV ファイル内の位置リストに情報を付加します。 〇 〇 〇   ジオプロセシング ジオプロセシング ウィジェットには、ジオプロセシング タスクを実行するダイナミック ユーザー インターフェイスが組み込まれています。 〇 〇 〇   グリッド オーバーレイ グリッド オーバーレイ ウィジェットでは、Web アプリでクライアント側のリソースを使用して、U.S. MGRS (Military Grid Reference System) グリッドをすばやくレンダリングできます。 〇 〇 〇   インデックス格子線 インデックス格子線 (GRG) を使用すると、アナリストは対象地理領域を分割する際に使用するグリッドを作成できます。 〇 〇 〇   グループ フィルター グループ フィルター ウィジェットでは、マップ内の 1 つ以上のレイヤーに基づき、マップにフィルターを適用できます。 〇 〇 〇   ホーム ボタン ホーム ボタン ウィジェットは、マップを初期表示範囲にズームします。 〇 〇 〇   画像計測 画像計測ウィジェットでは、計測機能を使用してイメージ サービスで測定を実行できます。 〇 〇 〇   インシデント解析 インシデント解析ウィジェットを使用すると、マップ上でインシデントを特定し、インシデントから指定した距離内にあるさまざまなフィーチャ レイヤーの情報を解析できます。 〇 〇 〇   インフォグラフィック インフォグラフィック ウィジェットが提供する 8 種類のグラフィックス テンプレートを使用すると、マップ内とその他のデータ ソースからの属性と統計情報データを視覚化してモニタリングできます。 〇 〇 〇   情報サマリー 情報サマリー ウィジェットを使用して、指定したレイヤーごとに、現在のマップ範囲内のフィーチャの数を表示できます。 〇 〇 〇   レイヤー リスト レイヤー リスト ウィジェットでは、操作レイヤーとそのシンボルがリスト形式で表示され、レイヤーを個別に表示または非表示にすることができます。 〇 〇 〇   凡例 凡例ウィジェットには、マップ内のレイヤーのラベルとシンボルが表示されます。 〇 〇 〇   計測 計測ウィジェットでは、ポリゴンの面積やラインの長さを計測したり、ポイントの座標を検索したりすることができます。 〇 〇 〇   現在地 現在地ウィジェットでは、ネットワークを使用してユーザーの物理的な位置を特定し、マップ上でその位置にズームできます。 〇 〇 〇   近隣検索 近隣検索ウィジェットを使用して、定義した住所または位置のバッファー内のフィーチャを検索したり、それらのフィーチャに関する詳細な情報を表示したり、選択したフィーチャまでのルート案内を取得したりすることができます。 〇 〇 〇   ネットワーク トレース※2 ネットワーク トレース ウィジェットは、任意のジオプロセシング サービスを呼び出して操作するように設計されています。 〇 〇 〇   傾斜ビューアー 傾斜ビューアー ウィジェットは、ArcGIS の [画像座標系 (ICS)] を使用して、ネイティブの座標系で画像を表示し、カメラ位置から自然なビューを提供します。 〇 〇 〇   概観図 概観図ウィジェットは、より大きなエリア内でマップの現在の範囲を表示し、マップ範囲が変更されるたびに更新します。 〇 〇 〇   パーセル ドラフター パーセル ドラフターは、マッピング技術者が土地境界の説明を入力し、クロージャ エラーをチェックするために使用できる Web AppBuilder for ArcGIS の構成です。 〇 〇 〇   印刷 印刷ウィジェットでは、Web アプリを印刷サービスに接続して、現在のマップを印刷できるようにします。 〇 〇 〇   パブリック通知 パブリック通知は、Web AppBuilder for ArcGIS の構成の 1 つで、地方自治体の職員が、所有者および占有者の財産を特定し、宛名ラベルや構造化テキスト ファイルを作成できるようにします。 〇 〇 〇   クエリ クエリ ウィジェットを使用すると、事前に定義されたクエリを実行して、ソース データから情報を取得することができます。 〇 〇 〇   関連テーブル チャート 関連テーブル チャート ウィジェットを使用して、フィーチャ レイヤーの関連テーブルの値のチャート (バー チャート、パイ チャート、または極座標チャート) を作成できます。 〇 〇 〇   フィーチャ レポート フィーチャ レポート ウィジェットでは、ユーザーからのデータ品質のフィードバックを収集および管理できます。 〇 〇 〇   レビューアー ダッシュボード レビューアー ダッシュボード ウィジェットには、ユーザーの GIS データで特定されたデータ品質の問題を集計し、インフォグラフィックスとしてデータ品質結果の統計情報が円グラフおよび棒グラフで表示されます。 〇 〇 〇   縮尺記号 縮尺記号ウィジェットは、マップに縮尺記号を表示します。 〇 〇 〇   スクリーニング スクリーニング ウィジェットを使用すると、対象地域を定義し、指定されたレイヤーを解析して、潜在的な影響がないか確認できます。 〇 〇 〇   検索 検索ウィジェットを使用すると、エンド ユーザーはマップ上で場所を見つけたり、フィーチャを検索したりできます。 〇 〇 〇   選択 選択ウィジェットを使用すると、マップ上のフィーチャを対話的に選択し、選択したフィーチャに対してアクションを行えます。 〇 〇 〇   共有 共有ウィジェットでは、アプリをソーシャル メディア アカウントにポストしたり、リンクを電子メールで送信したり、Web サイトやブログに埋め込んだりして共有することができます。 〇 〇 〇   状況認識 状況認識ウィジェットでは、マップ上の位置を指定し、指定の領域内にあるフィーチャ レイヤーの情報を解析することができます。 〇 〇 〇   スマート エディター スマート エディター ウィジェットを使用すると、フィーチャおよびその関連レコードを容易に編集できます。 〇 〇 〇   スプラッシュ スプラッシュ ウィジェットは、アプリのスプラッシュ画面上の表示コンテンツを定義します。 〇 〇 〇   ストリーム ストリーム ウィジェットを使用すると、ストリーミング フィーチャ レイヤーからのリアルタイムのデータ フィードを可視化および制御できます。 〇 〇 〇   適合性モデラー 適合性モデラー ウィジェットを使用すると、活動に最適な場所の検索、危険性の予測、事象が発生する可能性が高い場所の識別が可能になります。 〇 〇 〇   サマリー サマリー ウィジェットを使用すると、現在のマップ内のフィーチャ レイヤーから、表示されているマップ範囲内にある数値属性を集計できます。 〇 〇 〇   スワイプ スワイプ ウィジェットを使用して、マップ内のさまざまなレイヤーのコンテンツを簡単に比較できます。 〇 〇 〇   脅威分析 公共安全の担当者と初動対応者は、イベントの計画時に安全な距離と区域を特定します。 〇 〇 〇   タイム スライダー タイム スライダー ウィジェットを使用して時系列レイヤーをマップに表示し、アニメーションを再生して、データが時間とともにどのように変化するかを確認できます。 〇 〇 〇   可視解析 可視解析ウィジェットは、指定された距離、観測点の高さ、および視野に基づいて、観測点から見えるものを特定します。 〇 〇 〇   ズーム スライダー ズーム スライダー ウィジェットは、マップ表示に対話型のズーム コントロールを提供します。 〇 〇 〇    3D ウィジェット    ウィジェット 機能概要 ArcGIS Online (2022 年 11 月アップデート) ArcGIS Enterprise バージョン 11.0.1 Developer Edition バージョン 2.26 ※1     3DFx 3DFx ウィジェットが提供する一連の 3D アニメーション アプローチを使用して、地理情報を直感的で対話的な 3D 環境で視覚化および解析することができます。 〇 〇 〇   情報 情報ウィジェットは、ウィジェットに表示するコンテンツを作成します。 〇 〇 〇   ベースマップ ギャラリー ベースマップ ギャラリー ウィジェットには、組織から提供されるベースマップを表す画像のコレクション、またはユーザー定義の一連のマップ/イメージ サービスが表示されます。 〇 〇 〇   コンパス コンパス ウィジェットをクリックすると、シーンが北向きで再描画されます。 〇 〇 〇   座標 座標ウィジェットは、X,Y 座標、標高、およびカメラの高度の値を 3D アプリに表示します。 〇 〇 〇   日光 日光ウィジェットでは、時刻と月を変化させて日差しと影がシーンに与える影響を変更できます。 〇 〇 〇   全画面 全画面ウィジェットを使用して、全画面モードを開始できます。 〇 〇 〇   ホーム ボタン ホーム ボタン ウィジェットをクリックすると、最初のカメラ位置に戻ります。 〇 〇 〇   レイヤー リスト レイヤー リスト ウィジェットは、シーン内の 2D レイヤーまたは 3D レイヤーをリスト表示します。 〇 〇 〇   凡例 凡例ウィジェットには、シーン内のレイヤーのラベルとシンボルが表示されます。 〇 〇 〇   計測 3D アプリの計測ウィジェットでは、2 つのポイント間の水平、垂直、および直線距離、ポリゴンの面積および周囲長を計測できます。 〇 〇 〇   現在地 現在地ウィジェットでは、ネットワークを使用してユーザーの物理的な位置を特定し、マップ上でその位置にズームできます。 〇 〇 〇   ナビゲート ナビゲート ウィジェットを使用して、シーンを回転したり画面移動したりします。 〇 〇 〇   検索 検索ウィジェットを使用して、シーン内で場所を見つけることができます。 〇 〇 〇   共有 共有ウィジェットでは、3D アプリをソーシャル メディア アカウントにポストしたり、リンクを電子メールで送信したり、Web サイトやブログに埋め込んだりして共有することができます。 〇 〇 〇   スライド スライド ウィジェットは、シーンのさまざまなビューを表示します。 〇 〇 〇   スプラッシュ スプラッシュ ウィジェットは、アプリのスプラッシュ画面上の表示コンテンツを定義します。 〇 〇 〇   ズーム スライダー ズーム スライダー ウィジェットは、マップ表示に対話型のズーム コントロールを提供します。 〇 〇 〇    補足事項  ※1: Developer Edition 版のガイドは英語です。ウィジェットの説明を日本語でご覧になりたい場合は、ArcGIS Online まはた ArcGIS Enterprise のヘルプを参照してください（ウィジェットの説明に関しては、基本的にどのガイドも共通です）。 ※2: 日本国内サポート対象外のウィジェットです。  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/debugging-widget-development/",
	"title": "ウィジェット開発のデバック",
	"tags": [],
	"description": "ウィジェット開発におけるデバック方法について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Debugging widget development\nウィジェット開発環境の設定 カスタム ウィジェットの開発には、使い慣れた IDE やテキストエディタを使うことができます。Visual Studio Code は、デフォルトで TypeScript を認識する機能が組み込まれているため、よいオプションのひとつです。\n作成したカスタム ウィジェットは、Experience Builder ファイル構造の client フォルダのディレクトリ内に配置されます。Visual Studio Code 内で、プロジェクトとして client フォルダを開きます。\n ファイル メニューをクリックします。 フォルダを開く をクリックします。 Experience Builder　を初めて起動したときに解凍した Experience Builder ファイル内の client フォルダを参照します。  これにより、client フォルダ内のすべてのファイル (カスタム ウィジェットのファイルを含む) が、左側の VS Code Explorer タブで利用できるようになります。また、Visual Studio Code は、Experience Builder ライブラリの TypeScript の定義について client フォルダの内容全体をスキャンし、カスタム ウィジェットを書いている間に TypeScript の検証と autocomplete (オートコンプリート:自動補完) を可能にします。\nVisual Studio コード テキストエディタとして Visual Studio Code を使用している場合、テキストエディタに機能を追加するために使用できる拡張機能のマーケットプレイスがあります。インストールしておきたい React 拡張機能に加えて、Experience Builder のカスタム ウィジェット開発にはこれらの拡張機能が推奨されています (必須ではありません)。\n  IntelliSense for CSS class names in HTML - ワークスペースで見つけた定義に基づいてHTML クラス属性 の CSS クラス名を補完します (ワークスペースの中の CSS を読み込んで HTML 上でクラス指定するときに入力候補を表示します)。\n  vcode-styled-components - styled-components のシンタックスハイライトを付けます。\n  デバッグツール Web ブラウザ内には、カスタム ウィジェットを効率的に構築するために使用できるさまざまなデバッグツールがあります。\nブラウザ開発ツール Experience Builder のオーサリング インターフェイスまたはプレビュー モードでは、ブラウザの開発者ツールを開いてデバッグ ツールにアクセスすることができます。開発者ツールを開くには\n Chrome で、メイン メニューをクリックし、「その他のツール」→「開発者ツール」を選択します。(詳細) Firefoxで、[メインメニュー] \u0026gt; [Web開発者] \u0026gt; [ツールの切り替え] ((詳細)をクリックします。  DOM 要素 ブラウザの開発者ツールで、Sources (Chrome) または Debugger (Firefox) タブをクリックします。ここでは、カスタムウィジェットの DOM を調べて現在の状態を確認できます。\nJavaScript のソースとブレークポイント ブラウザの開発者ツールで、Elements (Chrome) または Inspector (Firefox) タブをクリックします。ここでは、ページの JavaScript コードを閲覧することができます。ウィジェットが開かれていることを確認して(該当する場合)、左側のファイルブラウザで webpack を選択してウィジェットの widget.tsx ファイルを見つけてダブルクリックしてください。別の方法としては、ctrl + p と入力してファイル コマンドパレットを開き、widget.tsx と入力してください。目的の widget.tsx ファイルはファイル名の最後に ?zzzz (zzzz は数字と文字の組み合わせ) が付いているものになります。\nウィジェット ファイルを開くと、その TypeScript コードを見ることができます。行番号をクリックしてブレークポイントを設定することができます (詳細: Chrome、Firefox)\nGlobal Experience Builder の変数 コードがブレークポイントで停止している場合、右側のパネルで Scope ペインを開き、現在スコープ内にある変数を見ることができます。Global まで下にスクロールしてください。ここには、Experience Builder がいくつかの便利な変数を配置しています。これらの変数を調べて、Experience Builder 内のさまざまな現在のステータスを確認できます。\nこれらの変数には、以下のものがあります。\n _appState - Experience Builder の現在の状態に関するさまざまなプロパティ。 _dataSourceManager - ウィジェット内の現在のデータソース。 _widgetManager - ウィジェットがロードされているかどうかなど、ウィジェットに関する様々なプロパティ。 _sessionManager - ログイン情報の確認と管理に使用できます。 他にも、あまり使われていないグローバル変数もあります。すべてのリストを見るには、ファイル clientjimu-core\\jimu-coreliblib\\typeswindow.d.ts を参照してください。  ビルダーページでのデバッグ ビルダーページでデバッグすると、Experience は iframe で読み込まれます。このため、Javascript の実行コンテキストには top と _appWindow の 2 つに分かれています。top コンテキストがビルダーコンテキストで、_appWindow コンテキストが Experience コンテキストです。コンソールでグローバル変数を検査する場合は、ブラウザの開発者ツールのドロップダウン リストで正しいコンテキストが選択されていることを確認してください。ブレークポイントを使用してデバッグしているときは、window.jimuConfig.isBuilder を見て実行コンテキストを判断してください。true はコードが ビルダーコンテキスト内にあることを意味します。\nネットワーク ブラウザの開発者ツールで、Network タブをクリックします。ここでは、Experience によって送受信されるネットワークのリクエストを確認できます。\nキャッシュのクリア コードをデバッグしている間は、コードを変更したり、ページを頻繁にリロードしたりすることがあります。ブラウザが予期せずにキャッシュし、開発中に混乱を招くこともあります。このため、ブラウザを更新するたびにキャッシュをクリアするか、開発中にネットワーク開発者ツールの Disable cache にするチェックボックスを有効にすることが重要です。\nReact 開発ツール Experience Builder の Experiences は、React JavaScript ライブラリを使用しています。上記の DOM Elements ブラウザに加えて、React がどのように動作するかを知り、React コンポーネントについてさらに詳しい情報を表示してくれるブラウザ拡張機能をインストールすることができます。ブラウザの拡張機能ストア (Chrome, Firefox) から拡張機能をインストールし、ツールを有効にします。これで、ブラウザの開発者ツールに 2 つのタブが追加されました。Components と Profiler です。\nComponents タブをクリックします。Search または \u0026ldquo;Select Element\u0026rdquo; ボタンを使用して、コンポーネントツリーでカスタム ウィジェットを選択します。選択されると、右側の情報パネルにコンポーネントの props と state が表示されます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/data-source/",
	"title": "データ ソース（Data source）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Data sources\nデータ ソース（Data source） データソースは、ウィジェットがどのようにデータにアクセスするかを定義します。例えば、データがリモートサーバーからのものである場合、ウィジェットはクライアント側にクエリするために、データソース クラスを使用します。ウィジェットでデータが生成された場合、それ自身をデータソース クラスに入れることで、別のウィジェットで使用することができます。\n高レベルでは、データ ソースはスキーマといくつかのレコードを持ち、子/親データ ソースを持つ場合があります。さらに、すべてのデータソースは、それを識別するのに役立つ型、ID、ステータスがあります。 DataSource インターフェースは jimu-core パッケージで定義されており、これは以下のメソッドとプロパティのいくつかを定義しています。\n id: データソースID。 type: どのタイプのデータソースを使っているかチェックするため、ウィジェットで使っているプロパティ。 fetchSchema: すべてのデータソースは、スキーマを返すためにこのメソッドを実装しなければなりません。これは、リモート データ サービスで定義されたスキーマです。例えば、ユーザーがExperience Builder でデータ ソースを追加した場合、データ ソースのスキーマはアプリ構成に保存されません。代わりに、最新のデータ ソース スキーマを取得するために fetchSchema メソッドが呼び出されます。 getSchema: ウィジェットがデータソースのスキーマとフィールドにアクセスするために使用するメソッドです。 getRecords: ウィジェットがデータソースのデータレコードにアクセスするために使用するメソッドです。 getStatus: ウィジェットはこのプロパティを使用してデータソースのステータスを取得します。これらのステータスの中には、Loading、Loaded、Errorなどがあります。  1つのデータソースには、サブデータソースを含めることができます。その結果、使いやすくするために複数のデータソースを含めることができます。このようなデータソースを DataSourceSet と呼びます。WebMapDataSource は DataSourceSet です。DataSourceSet も、isDataSourceSet プロパティをtrue に設定していれば、データソースの一種です。データソースは DataSourceManager で管理し、データソースの作成や取得を行います。\n複数のウィジェットが 1 つのデータ ソースに接続する場合、ウィジェットはデータ ソースのローカル ビューを表示したい場合があります。このシナリオでは、データ ビューを使用します。データ ビューとデータ ソースの関係は、リレーショナル データベースのビューとテーブルの関係に非常に似ています。Experience Builder のデータ ソースは、クライアント側の実際のリモート データ ソースのビューですが、データ ソースはテーブル、データ ビューはビューと考えることができます。アプリ作成者は、データソースからデータ ビューを作成し、ビルダーでデータ ビューにウィジェットを接続することができます。API レベルでは、データ ビューは DataSource クラスを使用して管理されるため、データ ビューは、属性の違いだけでデータ ソースと同じインターフェースとふるまいを持ちます。\nデータ ソースの使用を簡単にするために、DataSourceComponent コンポーネントが定義されています。これは useDataSource プロパティを受け取り、コールバックを通じてデータ ソース オブジェクトとそのステータス情報を返します。また、子として関数を受け入れ、データ ソース オブジェクトとデータ ソース内のデータをレンダリングするための情報を取得するために使用することができます。DataSourceComponent コンポーネントは、オプションの query プロパティを受け入れることもでき、クエリが変更されたときにデータをリロードします。\nフィーチャーサービスのような最も一般的に使用されるデータ形式をサポートするために、APIにはQueriableDataSourceインターフェイスと抽象クラス AbstractQueriableDataSource があります。このインターフェイスには、url、load、query などのプロパティがあります。ロードとクエリの違いは、ロードはレコードのプロパティとデータソースのステータスを更新し、クエリはレコードのみをクエリして返すことです。\n具体的には、Experience Builder で FeatureLayerDataSource データソースを定義して、フィーチャレイヤーにアクセスします。データ ソースがスタンドアロンのフィーチャ レイヤから作成された場合、オブジェクトには layer プロパティはありません。Webmap/Webscene に含まれるフィーチャ レイヤから作成された場合、オブジェクトには layer プロパティがあり、これは ArcGIS Maps SDK for JavaScript の FeatureLayer オブジェクトです。FeatureLayerDataSource の実際のデータは、リモート データベースからのものと、クライアント側のフィーチャのコレクションからのものがあり、どちらもクエリをサポートしています。クライアント側のデータについては、データソースがスタンドアロン フィーチャ レイヤーから作成された場合でも、クエリをサポートするためにレイヤー オブジェクトが作成されます。\n一般的にデータソースは2つの場所に保存され、データソースオブジェクトは DataSourceManager に保存・管理され、データソース情報はredux アプリ ストアに保存されます。ataSourceComponent を使う場合、コンポーネントは DataSourceManager を呼び出してオンデマンドでデータソースを作成し、コールバック プロップを使ってデータ ソース オブジェクトとdataSourceInfo を返します。dataSourceInfo では、データソースの instanceStatus, status, selectedIds などを返すことができます。\nArcGIS server サービスの多くは、MapServiceDataSource、FeatureServiceDataSource など、アクセスしやすいようにデータソースにマッピングされています。 ArcGIS Maps SDK for JavaScript の WebMap と WebScene は、jimu-arcgis パッケージ内で WebMapDataSource と WebSceneDataSource としてラップされています。\nデータ ソース セット（Data Source Set） データソースは、子データソースを持つことができます。そのため、使いやすいように複数のデータソースを含めることがあります。このようなデータソースを DataSourceSet と呼びます。WebMapDataSource は DataSourceSet です。isDataSourceSet プロパティが true に設定されていれば、DataSourceSet もデータソースの一種です。getChildDataSources を使って親データソースから子データソースを取得したり、parentDataSource を使って子データソースから親データソースを取得することができます。\nデータ ビュー（Data View） 複数のウィジェットが 1 つのデータソースに接続している場合、ウィジェットはデータソースのローカルビューを見たいと思うかもしれません。このような場合には、データ ビューを使用します。データ ビューとデータソースの関係は、リレーショナルデータベースのビューとテーブルの関係によく似ています。Experience Builder のデータソースは、クライアント側の実際のリモートデータソースのビューですが、データソースはテーブル、データ ビューはビューと考えることができます。アプリ作成者は、データソースからデータ ビューを作成し、ビルダー内のデータビューにウィジェットを接続することができます。APIレベルでは、データ ビューは DataSource クラスを使用して管理されているため、データビューは、いくつかのプロパティの違いがあるだけで、データソースと同じインターフェイスと動作を持っています。データ ビューのベースとなるデータソースはメインデータソースと呼ばれ、getMainDataSource を使ってデータビューからデータソースを取得したり、getDataViews を使ってメインデータソースのすべてのビューを取得することができます。\n選択は、メインデータソースとそのすべてのデータビューの間で共有されます。選択されたレコードはデータソースの選択ビューに保存され、選択されたレコード ID は redux app store のデータソース ID の下に保存されます。選択ビューは、メインデータソースの特別なデータビューで、${mainDataSourceId}-sclection で識別されます。\nローカルデータソースとデータビュー（Local data source and data view） 複数のウィジェットが異なるデータを取得するために異なるデータビューを使用することができますが、異なるウィジェットが同じデータソースまたは同じデータビューに接続する必要があっても、ウィジェット内のドロップダウンリストなど、ウィジェット内の異なるデータを取得する必要があるシナリオがあります。この場合、ウィジェットはローカルデータソースまたはデータビューを作成することができ、ローカルデータソースまたはデータビューに適用されたフィルタは、関連するデータソースまたはデータビューに影響を与えません。DataSourceComponent を使用して localId を渡すか、DataSourceManager().getinstance().createLocalDataSource を使用してローカルデータソースまたはデータビューを使用することができます。\nデータソース内のソースレコード（Source records in data source） ほとんどの場合、データはリモート・データベースにあるので、データ・ソース・インスタンスはリモートからデータを取得してデータ・ソース・インスタンスに保存するだけです。しかし、一部のデータソースでは、ウィジェットの出力データソースや選択ビューのデータソースのように、データがクライアント側で生成される場合があります。これらのシナリオでは、データソースのデータは、データソース・インスタンスの DsourceRecords に格納されます。getSourceRecords と setSourceRecords を使用して、それを取得および更新することができます。\nウィジェット出力データソース（Widget output data source） ウィジェットは、データソースを使用することができ、また、データソースを生成することもできます。一般的に、ウィジェットはその設定ページで this.props.onSettingChange を呼び出して出力データソースを宣言し、他のウィジェットがその出力データソースを使用できるようにする必要があります。出力データソースは app config の dataSources に保存されます。他のウィジェットでは、出力データソースを使用しても、ユーザーが追加したデータソースを使用しても、違いはありません。\n内部的には、ウィジェットが出力データソースを使用し、ウィジェットがレンダリングされると、出力データソースと出力データビューが作成されます。出力データビューは、${outputDataSourceId}-output で識別されます。出力データソースを使用するウィジェットは、出力ビューを使用します。出力データソースを生成したウィジェットは、出力データソースのsetSourceRecords または updateQueryParams を呼び出すことで、データソースを更新します。\n出力データソースの JSON 内の originDataSources は、オリジンデータソースと出力データソースの関係を維持するために使用されます。例えば、ウィジェットの出力データ・ソースにスキーマが定義されていない場合、オリジン・データ・ソースのスキーマが使用されます。ウィジェットは、このプロパティと、id、type などの一般的なプロパティを更新する必要があります。クエリとチャートのウィジェットは、どちらも出力データソースを生成します。これらの出力データソースの JSON を参考にして、出力データソースの JSON に必要なプロパティを確認することができます。\nデータアクション（Data action） データアクションの参照\nリピート データ ソース（Repeated Data source） RepeatedDataSourceProvider が提供するデータソースをリピートデータソースと呼びます。データソースを提供するウィジェットのすべての子ウィジェットは、リピートデータソースを受け取ります。これは React\u0026rsquo;s Context と似ています。ウィジェットは this.props.repetedDataSource でリピートデータソースにアクセスできます。リピートデータソースは、データソースの id、record、recordIndx を取得します。 どのウィジェットでも、RepeatedDataSourceProvider を使用してリピートデータソースを提供することができます。Experience Builder の List ウィジェットは、リピートデータソースを提供する良い例です。リピートデータソースを使用するには、ウィジェットのマニフェストファイルに supportRepeat プロパティを追加します。\nウィジェットでのデータソースの使用（Use data source in widget） データソースは、ウィジェットがデータにアクセスする方法を定義します。公開されたエクスペリエンスのすべてのデータソースは、アプリの config.json の dataSources プロパティに保存されます。config.json は server/public/apps/ フォルダにあります。以下のスニペットでは、この dataSources プロパティに WEB_MAP タイプのデータソースが 1 つあります。\n\u0026#34;dataSources\u0026#34;: { \u0026#34;dataSource_1\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;WEB_MAP\u0026#34;, \u0026#34;itemId\u0026#34;: \u0026#34;cb5329a59a354904a035de57f85112d3\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;dataSource_1\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;US Breweries\u0026#34;, \u0026#34;portalUrl\u0026#34;: \u0026#34;https://www.arcgis.com\u0026#34; } }, ウィジェットでのデータソースの使用は、app config で useDataSources というプロパティで宣言されます。\n\u0026#34;useDataSources\u0026#34;: [ { \u0026#34;dataSourceId\u0026#34;: \u0026#34;dataSource_1\u0026#34; } ], ウィジェットでは、データソースを選択できる設定UIを提供することをお勧めします。これを実現するには、DataSourceSelector コンポーネントを使用して、設定 UI でデータソースを選択します。詳細については、設定 UI の作成をご確認ください。実行時には、DataSourceComponent を使用して、データソースオブジェクトとデータソース情報を取得します。情報には以下のものが含まれます。\n instanceStatus: データソースのインスタンスが正常に作成されたかどうか status: データがロードされているかどうか countStatus: データのカウントがロードされているかどうか selectedIds: 選択されたデータの ID widgetQueries: データソースに適用されたクエリ(フィルタ)ウィジェット version: バージョン番号は、クライアント側でデータの変更を管理するためのもので、すべてのデータソース・コンシューマーはデータがいつ変更されたかを知ることができます。 gdbVersion： ブランチバージョンをサポートしている機能サービスの場合。ブランチ・バージョン管理ウィジェットがブランチ・バージョンを切り替えると、そのバージョンがここに保存されます。  選択されたデータソースの id/index は、datasource.selectRecord または datasource.selectRecordById を使って、クエリパラメータとして URL に入れることができます。\nWebMap/WebScene の使用（Use WebMap/WebScene） jimu-arcgis パッケージでは、データソースとして WebMap/WebScene をラッピングしています。WebMap にアクセスするには WebMapDataSource を、WebScene には WebSceneDataSource を使用します。これらのデータソースの使用方法については、MapView サンプルをご確認ください。WebMap/WebScene オブジェクトに加えて、これらのオブジェクトに含まれるすべてのレイヤーもデータソースとしてラップされているため、getChildDataSources を呼び出してすべてのレイヤーのデータソースを取得することができます。サポートされているレイヤーとサービスは、SupportedLayerServiceTypes と SupportedServiceTypes で定義されています。\nFeatureLayer の使用（Use FeatureLayer） ワークフローの中には、FeatureLayer を直接操作するような軽量のエクスペリエンスを作成する必要があるものもあります。このような場合、FeatureLayerDataSource クラスを使用します。独立したフィーチャーマップを使用するウィジェットは、layer プロパティを持たない FeatureLayerDataSource オブジェクトを取得しますが、ウェブマップやウェブシーンからフィーチャーマップを使用すると、layer プロパティを持つ FeatureLayerDataSource オブジェクトが返されます。Layer オブジェクトは、ArcGIS Maps SDK for JavaScript のものです。\nconst getLayerObject = (ds: FeatureLayerDataSource) =\u0026gt; { return ds.layer; // this can be null  } ウィジェット間のデータ共有（Sharing data between widgets） ウィジェットが同じデータを共有することは、一般的なワークフローです。例えば、Map と List の2つのウィジェットを使った体験談です。リストウィジェットでフィーチャーが選択されると、マップでも対応するフィーチャーが選択されます。これを実現する最も簡単な方法は、両方のウィジェットに同じデータソースを使用することです。例えば、リストウィジェットでアイテムが選択されると、ウィジェットは datasource.selectRecord() を呼び出し、アプリストアのデータソースのステータスを更新します。これにより、Map ウィジェットは現在選択されているアイテムを適宜レンダリングすることができます。また、現在選択されているアイテムが URL に配置されるため、現在のアプリの状態を他の人と共有することが可能になります。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/third-party-libraries/",
	"title": "サードパーティ製のライブラリ使用",
	"tags": [],
	"description": "サードパーティ製のライブラリの使用方法について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Using third-party libraries\nExperience Builder に付属の jimu ライブラリを使用して、ウィジェットに様々な機能を組み込むことができます。この機能に加えて、サードパーティのライブラリを追加して、Experience Builder のカスタム ウィジェット内で使用することができます。\nサードパーティのライブラリをインクルードして、ウィジェット内で使用できるようにするには、3 つの方法があります。\nNPM インストール ライブラリを 1 つのウィジェットのみで使用する場合は、使用するライブラリを npm に含めることをお勧めします。\n利用方法 ターミナルでカスタム ウィジェットのルートディレクトリを参照し、npm init を実行し、対話形式で質問に答えます。これにより、カスタム ウィジェットのルートディレクトリに package.json ファイルが作成されます。\n次に、npm のパッケージディレクトリからサードパーティのライブラリの名前を探します。これは npmjs.com にアクセスして検索するか、通常はライブラリのドキュメントページにパッケージ名が記載されています。パッケージ名を使って npm インストールコマンドを実行します。\nnpm install \u0026lt;package-name\u0026gt;\rこのコマンドを実行すると、2 つのことができます。まず、ライブラリファイルをダウンロードし、node_modules ディレクトリに配置します。第二に、上記の npm init コマンドで作成した package.json ファイルにライブラリへの参照を追加します。\nパッケージ名は、カスタムウィジェットの import コマンドで使用できるようになりました。例えば、\u0026quot;import * as ReactDataGrid from \u0026quot;react-data-grid\u0026quot; としてインポートします。\npackage.json にライブラリへの参照が追加されたので、他のコンピュータにすべてのウィジェットの依存関係を素早くインストールするには、ウィジェットのルートディレクトリでターミナルを開き、npm install を実行して、ウィジェットのすべての依存関係をインストールします。\nこのパターンの動作の説明は react-data-grid のサンプルを参照してください。\nmanifest.json を使用して CDN 経由で使用 ライブラリを複数のウィジェットで使用する場合は、ライブラリの CDN url を manifest.json ファイルの dependency プロパティに 配置することで、ライブラリを含めることができます。\n利用方法 ライブラリの CDN url を見つける必要があります。通常、これはライブラリのドキュメントに記載されているか、jsDelivr や unpkg で見つけることができます。たとえば、jQuery サンプルでは、CDN URL は https://unpkg.com/jquery@3.5.1/dist/jquery.js です。\nウィジェットの manifest.json ファイルに dependency と呼ばれる配列プロパティを追加し、その配列に url を追加します。例えば、以下のようになります。\n\u0026#34;dependency\u0026#34;: [ \u0026#34;https://unpkg.com/jquery@3.5.1/dist/jquery.js\u0026#34; ], Experience Builder は Experience がロードされると自動的にライブラリをロードし、ウィジェットはライブラリのドキュメントに従ってライブラリを使用することができます。\nこのパターンの動作の説明は jquery のサンプルを参照してください。\nダウンロードして直接読み込む ライブラリが複数のウィジェットで使用されている場合、手動でファイルをダウンロードしてウィジェットのコード構造内に格納することでライブラリを含めることができます。\n利用方法 ライブラリのダウンロード可能なビルド済み assets を探します。通常、これはライブラリのドキュメントにリンクされているか、ライブラリの GitHub リポジトリの Releases エリアにあるダウンロード可能な assets の dist フォルダにあります。\nダウンロード後、ファイルを展開し、ウィジェットのルートディレクトリにコピーしてください。相対パスで指定し、インポートを介してインクルードされるので、ウィジェット内の任意の場所にファイルを配置することができますが、慣習的には、lib というフォルダ内に配置することをお勧めします。\nファイルを配置した後、相対パスを使用してライブラリをインポートすることができます。例えば、以下のようになります。\nimport * as d3 from \u0026#34;./lib/d3/d3.min.js\u0026#34;; このパターンの動作例は、D3 のサンプルを参照してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/data-action/",
	"title": "データアクション（Data action）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Data action\nデータアクション（Data action） データアクションは、データレコードのコレクションを拡張可能な方法で処理する方法を提供します。データアクションは、データソースのインスタンスとデータレコードの配列を受け取ります。データをサポートしているかどうかや、ユーザーが実行したときに何が実行されるかを定義することができます。フレームワークは、CSV へのエクスポートや JSON へのエクスポートなどのデータアクションを提供します。ウィジェットでもデータアクションを提供することができます。例えば、Map ウィジェットは pan to とzoom to のデータアクションを提供しています。データアクションは、manifest.json でデータアクションを宣言し、AbstractDataAction を継承したクラスを作成することで、ウィジェットに実装することができます。\nデータ・アクションを提供するだけでなく、ウィジェットはデータ・アクションを使用することもできます。ウィジェットでデータアクションを使用するには、ウィジェットのmanifest.json プロパティで canConsumeDataAction: true を宣言し、import {DataActionDropDown} from 'jimu-ui' をインポートして、ウィジェットの UI で DataActionDropDown をレンダリングする必要があります。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/deploy-pattern/",
	"title": "デプロイ パターン",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) で作成したアプリやウィジェットのデプロイ パターンを紹介します。",
	"content": "トピック  概要 Web アプリケーションをデプロイ ウィジェットをデプロイ  概要 ArcGIS Experience Builder (Developer Edition) (以下 Developer Edition) では ArcGIS Experience Builder を拡張して、独自の Web アプリケーションやウィジェットを作成することが可能です。エンド ユーザーの利用形態や要件により最適なデプロイは異なりますが、このページでは以下の 2 つの主要なデプロイ パターンと、それぞれのデプロイ方法についてご紹介します。\n Web アプリケーションをデプロイ 全体像  Web アプリケーションを作成し、独自のサーバーでホストすることができます。特定の業務で継続的に利用されるアプリ等、ユーザーによる設定変更が不要な場合や、ユーザーに設定変更をさせたくない場合等に活用できます。   必要なコンポーネント  開発時  Node.js Developer Edition   運用時  ArcGIS Enterprise または ArcGIS Online Web サーバー (ArcGIS Enterprise の Web サーバーと併用も可)    手順概要 以下は Web アプリケーション作成から、デプロイ、実際の運用までの流れの概要です。\n カスタム ウィジェットを含む Web アプリケーションを作成  Developer Edition を用いたウィジェットの開発や Web アプリケーションの作成には Node.js が必要です。 詳しくはインストールガイドをご覧下さい。 カスタム ウィジェットを開発する際は、カスタム ウィジェット開発ガイドをご覧ください。   作成した Web アプリケーションを自身で用意した Web サーバーに配置  ArcGIS Enterprise で使用している Web サーバーと併用することも可能です。 ※ ArcGIS Online を使用してホストすることはできません。 詳しくは、アプリケーションのデプロイをご覧ください。   ユーザーが作成された Web アプリケーションを利用  ユーザーが Web アプリケーションにアクセスして利用します。 ArcGIS Enterprise や ArcGIS Online のポータルにアイテムとして表示させたい場合はアプリの URL をアイテムに登録する必要があります。  詳細は「アプリの追加」及びその後の「アプリの登録」をご覧ください。   内部的には、アプリは ArcGIS Online もしくは ArcGIS Enterprise の Web マップを参照してアプリ上に地図を表示します。     ウィジェットをデプロイ  ArcGIS Enterprise 11 以降では、Experience Builder で使用できるウィジェットのみを開発し、独自のサーバーでホストすることも可能です。ユーザーが ArcGIS Online や ArcGIS Enterprise を使用して独自に Web アプリケーションを作成することを想定しているものの、デフォルトの Experience Builder のウィジェットには無い機能を拡張したい場合に活用できます。   必要なコンポーネント  開発時  Node.js Developer Edition   運用時  ArcGIS Enterprise Web サーバー (ArcGIS Enterprise の Web サーバーと併用も可)    手順概要 以下はカスタムウィジェットの作成から、デプロイ、実際の運用までの流れの概要です。\n カスタムウィジェットを作成  Developer Edition を用いたウィジェットの作成には Node.jsが必要です。 詳しくはインストールガイドをご覧下さい。 カスタムウィジェット開発の詳細については、カスタム ウィジェット開発ガイドをご覧下さい。   作成したカスタムウィジェットを自身で用意した Web サーバーに配置  ArcGIS Enterprise で使用している Web サーバーと併用することも可能です。 ※ ウィジェットを配置するサーバーが自己署名証明書を使用している場合、Portal for ArcGIS に証明書をインポートする必要があります。詳しい方法はポータルへの証明書のインポートをご覧ください。 Web サーバーに配置後、ArcGIS Enterprise に組み込まれている Experience Builder にカスタムウィジェットを追加します。  詳しくは、カスタム ウィジェットの追加をご覧ください。 ※ ArcGIS Online に追加することはできません。     ウィジェットを使った Web アプリケーションの作成・利用  ユーザーが ArcGIS Enterprise に組み込まれている Experience Builder を利用してカスタムウィジェットを使用した Web アプリケーションを作成・利用します。 内部的には、アプリは Web サーバーでホストされているカスタムウィジェットを参照して動作します。     --\r2 つのデプロイ パターンの総括表    パターン 開発時に必要なコンポーネント 運用時に必要なコンポーネント ArcGIS Online での利用可否 ArcGIS Enterprise での利用可否     Web アプリケーションをデプロイ Node.js、Developer Edition Web サーバー、ArcGIS Online もしくは ArcGIS Enterprise 〇 〇   ウィジェットをデプロイ Node.js、Developer Edition Web サーバー、 ArcGIS Enterprise × 〇    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/message-action/",
	"title": "メッセージ と アクション（Message and action）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Message and action\nメッセージ と アクション（Message and action） メッセージ/アクションは、ウィジェットからウィジェット、ウィジェットからフレームワーク、フレームワークからウィジェットへの通信をサポートする方法です。 ウィジェット/フレームワークはメッセージを公開したり、メッセージを聞いたりすることができます。メッセージは jimu フレームワークによって定義される MessageType によって識別されます。jimu には ExtentChange や DataRecordsSelectionChange のようないくつかのメッセージタイプが定義されています。\nメッセージの発行（Publishing a message） ウィジェットは，MessageManager.getInstance().publishMessage(message) を呼び出してメッセージを発行します．例えば、List ウィジェットでは，リストアイテムがクリックされたときに DataRecordsSelectionChange メッセージを発行したり，Map ウィジェットでは，ビューが変更されたときに ExtentChange メッセージを発行して，List ウィジェットのコンテンツを更新したりします。以下の MessageTypes がサポートされています。\n StringSelectionChange ExtentChange DataRecordsSelectionChange DataRecordSetChange  各メッセージには、それを定義するクラスがあります。例えば、ExtentChange メッセージは ExtentChangeMessage クラスで定義され、このクラスはメッセージのペイロードである extent プロパティを定義します。\nメッセージを公開するために、ウィジェットは manifest.json ファイルで公開メッセージを宣言する必要があります。\n\u0026#34;publishMessages\u0026#34;: [ \u0026#34;DATA_RECORDS_SELECTION_CHANGE\u0026#34; ] メッセージアクションの作成（Creating a message action） メッセージアクションを作成するには、AbstractMessageAction クラスを継承する必要があります。メッセージアクションの開発に役立つメソッドや関数がいくつかあります。\nfilterMessageType メソッドは、利用可能なアクションのフィルタリングに使用されます。\nexport default class QueryAction extends AbstractMessageAction{ filterMessageType(messageType: MessageType, messageWidgetId?: string): boolean{ return [MessageType.StringSelectionChange, MessageType.DataRecordsSelectionChange].indexOf(messageType) \u0026gt; -1; } } filterMessage メソッドは、メッセージマネージャでメッセージをフィルタリングするために使用されます。\nfilterMessage(message: Message): boolean{ return true; } getSettingComponentUri コンポーネントを使って、メッセージに基づいてアクションを設定することができます。\ngetSettingComponentUri(messageType: MessageType, messageWidgetId?: string): string { return \u0026#39;actions/query-action-setting\u0026#39;; } onExecute メソッドは、メッセージタイプに応じて発生させたいロジックを処理します。以下のスニペットでは、基本的にメッセージタイプに基づいてアクションを選択し、dispatch プロパティを使用してアプリケーションから getAppStore() 関数を使用してストアに送信しています。これにより、redux アクションがディスパッチされ、ステートが更新されるようになります。Redux アクションと Redux でのストアの使用について詳しくはこちらをご覧ください。\nonExecute(message: Message, actionConfig?: any): Promise\u0026lt;boolean\u0026gt; | boolean{ let q = `${(actionConfig as ConfigForStringChangeMessage).fieldName}= \u0026#39;${message}\u0026#39;` switch(message.type){ case MessageType.StringSelectionChange: q = `${(actionConfig as ConfigForStringChangeMessage).fieldName}= \u0026#39;${(message as StringSelectionChangeMessage).str}\u0026#39;` break; case MessageType.DataRecordsSelectionChange: q = `${actionConfig.fieldName}= ` + `\u0026#39;${(message as DataRecordsSelectionChangeMessage).records[0].getFieldValue(actionConfig.fieldName)}\u0026#39;` break; } getAppStore().dispatch(appActions.widgetStatePropChange(this.widgetId, \u0026#39;queryString\u0026#39;, q)); return true; } manifest.json には messageActions プロパティがあり、メッセージ アクション エクステンションの場所と情報を提供します。\n\u0026#34;messageActions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;query\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Query\u0026#34;, \u0026#34;uri\u0026#34;: \u0026#34;actions/query-action\u0026#34;, \u0026#34;settingUri\u0026#34;: \u0026#34;actions/query-action-setting\u0026#34; } ] 国際化対応（i18n support） メッセージアクションの言語サポートは、ウィジェットと同じパターンですが、1つ重要な違いがあります。メッセージアクションには、ユーザーがアクションを選択するための Select an action パネルがあります。そのため、アクションのプロパティ名を記載した default.ts というファイルを runtime/translations フォルダに用意する必要があります。フレームワークは、このパネルのアクションラベルの翻訳を処理します。そのため、ラベルのプロパティは、_action_\u0026lt;actionName\u0026gt;_label という命名規則を持つ必要があります。\nexport default { _widgetLabel: \u0026#39;Message subscriber\u0026#39;, _action_query_label: \u0026#39;Query\u0026#39; } "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/unit-testing/",
	"title": "単体テスト",
	"tags": [],
	"description": "単体テストの方法について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Unit Testing\n単体テストの一般原則 良い単体テストを行うためには、テスト可能なコードを書くことが重要です。シンプルな設計原則を適用することが助けになります\n 適切な命名規則を使用し、コードにはコメントを付けましょう（「どのように」ではなく「なぜ」）。コメントは、名前やデザインの悪さの代用にはならないことを覚えておいてください。 DRY：Don\u0026rsquo;t Repeat Yourself（同じことを繰り返さない） - コードの重複を避ける。 単一責任：各オブジェクト/機能は、単一のタスクに集中しなければならない。 同じコンポーネント内では、1つの抽象度にとどめる。例えば、同じメソッドの中で、ビジネスロジックと低レベルの技術的詳細を混在させないようにします。 コンポーネント間の依存関係の最小化：コンポーネント間の情報のカプセル化と交換を少なくする。 ハードコーディングではなく、コンフィギュラビリティをサポートする。そうすることで、テスト時に全く同じ環境を再現する必要がなくなります。  ArcGIS Experience Builder での単体テスト 単体テストのファイルは .test.ts(x) または .spec.ts(x) で終わり、tests フォルダに置く必要があります。 単体テストは、行動駆動型開発（BDD）スタイルで記述する必要があります。たとえば、以下のようになります。\ndescribe(\u0026#39;calculator\u0026#39;, function() { // Describes a module with nested \u0026#34;describe\u0026#34; functions  describe(\u0026#39;add\u0026#39;, function() { // Specify the expected behavior  it(\u0026#39;should add 2 numbers\u0026#39;, function() { // Use assertion functions to test the expected behavior  expect(foo).toBeTruthy(); expect(foo).toBe(\u0026#39;bar\u0026#39;); }) }) })  Experience Builder は、テストフレームワークとして Jest を使用しています。 Experience Builder では、React コンポーネントのテストに @testing-library/react を使用しています。  Experience Builderで単位テストを書く 一般的には、以下の3種類のコードに対して単位テストを書く必要があります。\n TypeScript のネイティブコード：この種のコードでは、Jest のみを使用することができるかもしれません。ほとんどの場合、単体テストを書きやすくするために、いくつかのコンポーネントをモックする必要があります。 ネイティブな React コンポーネント：この種のコードでは、Jest と @testing-library/react を使用する必要があります。テストフレームワークとしてJestを使用し、テスティングライブラリを使用してReactコンポーネントをレンダリングし、そのレンダリング結果を確認します。 Experience Builder ウィジェット：エクスペリエンス・ビルダー・ウィジェットには、jimu-for-test からエクスポートされた wrapWidget と wrapWidgetSetting を使用する必要があります。  上記のような種類のコードに対して、jimu-for-test はテストを簡単に書くためのいくつかのヘルパーユーティリティー関数を提供します。例えば、以下のようなものです。\n 状態の初期化：getInitState() と getDefaultAppConfig() を使って、このようにストアを初期化することができます。  getAppStore().dispatch(appActions.updateStoreState(getInitState().merge({ appConfig: getDefaultAppConfig().merge({ widgets: { w1: { label: \u0026#39;W 1\u0026#39; } } }) })))  フィーチャーサービスをモックするには、次のようにモックデータを使って mockFeatureLayer を呼び出します。  mockFeatureLayer(mockData) フィーチャ レイヤーをモックアップした後は、単体テストのリクエストがネットワークリクエストを行わないため、テストがより安定して高速になります。\n React コンポーネントをレンダリングするには、次のようにしてレンダリングします。  const {queryByText} = render(\u0026lt;Component/\u0026gt;) const {queryByText} = withStoreRender(\u0026lt;Component/\u0026gt;)  そして、レンダリング結果を次のようにチェックします。  expect(queryByText(\u0026#39;the text\u0026#39;)).toBeInTheDocument();  ウィジェットをレンダリングするには、次のようにします。  // Get the widget render, you can pass in store/theme/locale optionally const render = widgetRender(); // Wrap the widget to inject some props into widget component const Widget = wrapWidget(_Widget, {config: {}}); // Then, you can render the widget like a native react component const {queryByText} = render(\u0026lt;Widget/\u0026gt;) ArcGIS Maps SDK for JavaScript を使用するモジュールのテスト コンポーネントで使用したモジュールをモックする必要があります。loadArcGISJSAPIModule でモジュールをロードした場合は、以下のようにモックを作成します。\njest.mock(\u0026#39;jimu-core\u0026#39;, () =\u0026gt; { return { ...jest.requireActual(\u0026#39;jimu-core\u0026#39;), loadArcGISJSAPIModule: jest.fn().mockImplementation(moduleId =\u0026gt; { let module if(moduleId === \u0026#39;esri/layers/FeatureLayer\u0026#39;){ module = jest.fn().mockImplementation(() =\u0026gt; { return { queryFeatureCount: () =\u0026gt; Promise.resolve(5) } }) } return Promise.resolve(module) }) } }) モジュールをインポートすると、jade.mock() が使えるようになります。\n単体テストの実行 client フォルダで npm test を実行します。\n単体テストの例は show-unit-tests サンプルをご覧ください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/use-assets/",
	"title": "assets の使用",
	"tags": [],
	"description": "assets の使用について紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Use assets\nassets の使用に関する一般的なガイドライン ウィジェットでは、画像や動画などのアセットを使用する必要があります。以下では、ArcGIS Experience Builder ウィジェットで assets を使用する方法について説明します。\n一般的に、assets を使用する方法は 2 つあります。\n assets のインライン化 assets を動的にロードする  インライン assets 画像などの小さな assets の場合、ネットワークパフォーマンスへの悪影響が限定的であるため、この方法は妥当な方法です。assets をインライン化するには、次のように assets をrequire() します。\nconst smallImage = require(\u0026#39;./small-image.png\u0026#39;) \u0026lt;img style={{width: \u0026#39;200px\u0026#39;, height: \u0026#39;200px\u0026#39;}} src={smallImage}/\u0026gt; .svg ファイルの場合、インラインで SVG DOM としてレンダリングしたい場合は、assets/icons フォルダにファイルを置き、次のように require() します。\nconst svg = require(\u0026#39;./assets/icons/mysvg.svg\u0026#39;) \u0026lt;Icon icon={svg} color=\u0026#34;red\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;200px\u0026#34;/\u0026gt; ダイナミックに読み込む 動画や大きな画像の場合、ネットワークのパフォーマンスに悪影響を与える可能性があるため、インラインではなくダイナミックにアセットをロードするのが妥当な方法です。\nアセットを動的にロードするには、2つの方法があります。アセットがランタイムで使用される場合は、ファイルを runtime/assets フォルダに配置します。それ以外の場合は、assets をsetting/assets フォルダに配置します。そうすれば、次のようにアセットを使用することができます。\n\u0026lt;img style={{width: \u0026#39;200px\u0026#39;, height: \u0026#39;200px\u0026#39;}} src={`${props.context.folderUrl}dist/runtime/assets/large-image.jpg`}/\u0026gt; or \u0026lt;Icon icon={`${props.context.folderUrl}dist/runtime/assets/mysvg.svg`} color=\u0026#34;red\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;200px\u0026#34;/\u0026gt; 後者（上図）は、.svg ファイルを SVG DOM としてレンダリングします。\nアセットの使用方法やその他の詳細については，use-assets サンプル ウィジェットを参照してください。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/deployment-topics/",
	"title": "デプロイ",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) で作成したアプリケーションをダウンロードし、独自のサーバーにホストする手順を紹介します。",
	"content": "ArcGIS Experience Builder で作成した Experience は、ダウンロードして Web サーバーにホストすることができます。プライベート コンテンツを使用している Experience は、ArcGIS Online または ArcGIS Enterprise にアプリを登録する必要があります。エンド ユーザーに最適なユーザー エクスペリエンスを提供するために、Experience を展開する前にシステム要件を参照してください。\nExperience のダウンロード Experience ギャラリーのホームページで Experience をダウンロードするには、以下のように ● (3 つのドット) をクリックして ダウンロード をクリックします。ZIP ファイルが作成され、ローカルドライブにダウンロードされます。ZIP ファイルは、お使いのブラウザ用に定義されたダウンロード ディレクトリにあります。\nExperience のデプロイ Experience を Web サーバーにデプロイするには、次の手順を実行します。\n ダウンロードした Experience を解凍し、フォルダを Web サーバーにコピーします。 アプリにプライベート コンテンツがある場合は、手順 3 ～ 6 を完了し、そうでない場合は Experience が展開されます。 アプリを追加して登録します。詳細については、アプリの追加とアプリの登録を参照してください。 AppID をコピーし、Experience アプリのルート ディレクトリ (例：app/config.json) にある config.json ファイルを開きます。 attributes オブジェクトの下に clientId プロパティを作成します。 config.json ファイルの clientId プロパティに AppID を貼り付けます。再度にファイルを保存します。  \u0026#34;attributes\u0026#34;: { \u0026#34;portalUrl\u0026#34;: \u0026#34;https://exb.maps.arcgis.com\u0026#34;, \u0026#34;clientId\u0026#34;: \u0026#34;EXBAPPsag0XSRtpj\u0026#34; }, server/app name/index.html にアクセスすることでアプリを利用することができます。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/map-scene-view/",
	"title": "マップ/シーン ビュー（Map/Scene View）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Map/Scene View\nマップ/シーン ビュー（Map/Scene View） ビューの概念はArcGIS Maps SDK for JavaScript と同じですが、Experience Builder では、ウィジェットやメッセージ/アクションなどを作成する際に一貫した拡張性モデルを確保するために、ビューは JimuMapView としてラップされます。JimuMapView オブジェクトを作成するには、ウィジェットは JimuMapViewManager.createJimuMapView() メソッドを使用します。JimuMapView オブジェクトは、主に以下のプロパティを持っています。\n view: マップ/シーン ビュー オブジェクト datasourceId: ビューを作成するデータソース (webmap/webscene) mapWidgetId: オブジェクトを作成するビュー jimuLayerViews: レイヤー ビュー オブジェクトのラッパー  マップ/シーン ビューを使用する必要があるウィジェットは、設定ページの JimuMapViewSelector コンポーネントを使用してマップ/シーンビューを選択することができます。これも JimuMapViewComponent を使用してJimuMapViewオブジェクトにアクセスします。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/tutorials/",
	"title": "チュートリアル",
	"tags": [],
	"description": "ArcGIS Experience Builder (Developer Edition) のチュートリアルでは、カスタム ウィジェットの作成方法について説明しています。",
	"content": "ArcGIS Experience Builder のチュートリアルでは、カスタム ウィジェットの作成方法について説明しています。各チュートリアルの完了には、約 15 分かかります。カスタム ウィジェットの作成方法と API の使用方法について理解することができます。\n スターター ウィジェットの作成 (Esri Community ブログ) マップの座標を取得 (Esri Community ブログ) Add layers to a map (英語)  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/core-concepts/extension-points/",
	"title": "拡張ポイント（Extension points）",
	"tags": [],
	"description": "",
	"content": "出典：ArcGIS Experience Builder - Guide - Extension points\n拡張ポイント（Extension points） Jimu ライブラリを使用すると、ArcGIS Experience Builder を拡張することができます。多くの場合、カスタム ウィジェットやテーマを作成することで Experience Builder を拡張します。また、Jimu エクステンションにより、より深いカスタマイズを行うことができます。\nJimu ライブラリでは、特定の拡張ポイントが定義されています。エクステンションポイントとは、エクステンションが準拠すべきインターフェースを定義したものです。エクステンションとは、エクステンションポイントのインターフェースを実装したクラスのことです。このインターフェースは、jimu-core からエクスポートされた extensionSpec です。ウィジェットでエクステンションを提供するには、ウィジェットの manifest.json ファイルでエクステンションを宣言する必要があります。\n\u0026#34;extensions\u0026#34;: [ { \u0026#34;point\u0026#34;: \u0026#34;\u0026lt;Extension point name\u0026gt;\u0026#34;, \u0026#34;uri\u0026#34;: \u0026#34;\u0026lt;Extension uri, relative to src folder\u0026gt;\u0026#34; } ] Jimu では、API ドキュメントで定義されている様々な拡張ポイントが定義されています。よく使われる拡張ポイントは以下の 2 つです。\nAppConfigProcessor - この拡張ポイントのエクステンションは、AppConfig を受け取り、処理された app config を解決するプロミスを返す必要があります。これは、文字列の翻訳（Translation サンプルを参照）のように、app config を実行時に修正するために使用できます。この処理は、app config がロードされた直後に起動されます。 DependencyDefine - この拡張機能を使用すると、初期化が必要なサードパーティのライブラリを使用できます。 ReduxStore - この拡張機能を使用すると、ウィジェットの Redux 状態の actions と reducers を定義できます。\nサンプル 拡張機能の作成例として、Translation サンプルをご紹介します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/experience-builder/widget-development/code-linting/",
	"title": "コードリンティング",
	"tags": [],
	"description": "コードリンティングについて紹介します。",
	"content": "出典：ArcGIS Experience Builder - Guide - Code linting\nバージョン 1.7 から、Experience Builder Developer Edition は、コードエディタがコードのフォーマットと lint (エラーチェック) に使用できる ESLint ルール (.eslintrc.js ファイル形式) を含むようになりました。\nこれらは、standard-with-typescript に基づいて、Experience Builder チームが使用しているルールです。ご自身のコードにどの ESLint ルールを使うかについては、好みがあるかもしれません。もしこれらのルールを使いたくない場合は、以下のルールを無効にする方法を参照してください。ルールを変更したい場合は、.eslintrc.js ファイルを修正することができます。\n これらの ESLint のルールでコードをチェックしたい場合は、client フォルダで、コマンドラインから、npm run lint. を実行します。また、ESLint 拡張機能をコードエディタにインストールすることもできます。 この ESLint のルールを無視したい場合は、以下のどちらかをお試しください。  コードエディタの ESLint 拡張を無効にする client/.eslintrc.js ファイルを削除する    "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tips/webappbuilder/create-startup-app-wab/",
	"title": "スタートアップ ガイド",
	"tags": [],
	"description": "",
	"content": "ArcGIS Web AppBuilder とは？ ArcGIS Web AppBuilder（以下、Web AppBuilder）は、コーディング不要、インタラクティブな操作で Web アプリを作成可能なアプリケーション ビルダーです。\nWeb AppBuilder は、Web マップと呼ばれる、さまざまなデータを地図上に重ね合わせ、表示スタイルやポップアップを定義したマップをもとにアプリを作成します。\nアプリの外観を決めるテーマと、機能を提供するウィジェットを選択していくことで、独自のアプリを作成していきます。\nWeb アプリの作成   Web マップの作成\nハッカソン向け資料 - 地図にデータを可視化する を参考に、アプリで使用する Web マップを作成します。\n  Web AppBuilder の起動\n作成した Web マップを保存したら、[共有] をクリックします。[Web アプリの作成] から [Web AppBuilder] を選択、[開始] をクリックして Web AppBuilder を起動します。   テーマの選択\nアプリの外観は、テーマと呼ばれるテンプレートによって決められます。テーマには、色を設定するスタイルや、ウィジェットの配置を定義するレイアウトなどが含まれます。\n  ウィジェットの追加\nアプリの機能は、ウィジェットを選択することで追加していきます。追加したい機能を持つウィジェットを選択して、アプリ固有の設定は構成パネルで決めます。ウィジェットを組み合わせることで、さまざまな目的に適したアプリを作成することができます。   アプリの保存、起動\nアプリを作成できたら保存して起動してみましょう。   ArcGIS Web AppBuilder (Developer Edition) ポータルサイトに組み込まれた Web AppBuilder を利用してアプリを作成するほかに、開発者向けに Developer Edition が提供されています。\nDeveloper Edition は、テーマやウィジェットを開発可能で、Web AppBuilder に独自の機能を追加することができます。 Web AppBuilder が提供するテーマやウィジェットを活用したアプリを作成できるので、コストを抑えたアプリ開発を実現します。\n"
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/",
	"title": "ArcGIS Developers 開発リソース集",
	"tags": [],
	"description": "",
	"content": "\r\rArcGIS Developers 開発リソース集 本サイトは、ArcGIS の API / SDK を利用して開発する方向けに、開発をよりスムーズにスタートしていただけるよう、ArcGIS Platform を利用した開発、開発環境の構築から簡単なアプリケーション作成までのガイド、開発に役立つ 技術 Tips 集を紹介しています。\nArcGIS Platform は、ロケーションサービスを提供する PaaS（Platform as a Service）です。サービスの詳細は ESRIジャパン製品ページをご覧ください。\nArcGIS Developers が提供するサービスの詳細は ESRIジャパン製品ページをご覧ください。\n目次\r  スタートアップガイド\n 開発を始める方のために必要なアカウントの作成、API キーの取得、ロケーションサービスの利用、各 API / SDK を使った開発の基本的な流れからセキュリティ、デプロイまでと ArcGIS Platform を利用した開発手順にそって学べる情報をまとめています。    もっと学ぶ\n スタートアップガイドをひととおり学び終えた方は、次のステップとして、何を見て学習すれば良いのか、より深く学べるように情報をまとめています。米国 Esri 社が無償で提供している学習素材や、ESRIジャパンのスタッフが作成したサンプル プログラム、過去に実施したセミナーやハンズオンの資料、ブログ記事など、多くの情報をまとめています。    技術 Tips 集\n 各 API / SDK を使用した開発をサポートするドキュメント（インストール ガイド、アプリケーションの配布など）や、データの可視化に関する技術 Tips をまとめています。    \r\rプライバシーポリシー  ESRIジャパン Web サイトポリシー  "
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://esrijapan.github.io/arcgis-dev-resources/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]